<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试文章</title>
      <link href="/2024/04/05/test/"/>
      <url>/2024/04/05/test/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><blockquote><p>本文参考自12.29日尚硅谷雷神的 <a href="https://gitee.com/leifengyang/java-design-pattern">巧妙使用设计模式重构项目</a></p></blockquote><h2 id="一、设计模式总览"><a href="#一、设计模式总览" class="headerlink" title="一、设计模式总览"></a>一、设计模式总览</h2><ul><li>总体分类</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/9e402b0c6ec2bc81a317c6b8774d2c7f.png" alt="20230113210444492"></p><ul><li>不同时期选择不同的设计模式~</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/5ed1ffc8fb36192278f04e22eb606402.png" alt="image-20230114113220058"></p><ul><li>设计模式本质上玩的就是：<code>封装</code>，<code>继承</code>，<code>多态</code></li><li>设计模式遵循的六大原则</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/df85588b81d2d6631d201855a66ea948.png" alt="image-20230114113416409"></p><h2 id="二、模板方法模式案例"><a href="#二、模板方法模式案例" class="headerlink" title="二、模板方法模式案例"></a>二、模板方法模式案例</h2><p><strong>描述：</strong>父类（接口、抽象类）提供了一种<code>定义算法的骨架</code>，&#x3D;&#x3D;允许子类为一个或多个步骤提供实现&#x3D;&#x3D;，在不改变算法结构的情况下，重新定义算法的某些步骤。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/65b0a3725926c195902515b16a6411d4.png"></p><p><strong>案例：订单处理</strong></p><p><font color=orange>1、定义订单处理模板</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 定义订单处理模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-12-29 20:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OrderProcessTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理订单： 定义好算法骨架</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1、选择商品</span></span><br><span class="line">        doSelect();</span><br><span class="line">        <span class="comment">//2、进行支付</span></span><br><span class="line">        doPayment();</span><br><span class="line">        <span class="comment">//3、开具发票</span></span><br><span class="line">        doReceipt();</span><br><span class="line">        <span class="comment">//4、派送商品</span></span><br><span class="line">        doDelivery();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doSelect</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doPayment</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doReceipt</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doDelivery</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=orange>2、定义实现类：<code>NetOrder</code> 和 <code>StoreOrder</code></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 网络订单：算法细节实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-12-29 20:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetOrder</span> <span class="keyword">extends</span> <span class="title class_">OrderProcessTemplate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSelect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;把 xiaomi11 加入购物车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPayment</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在线微信支付 1999&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doReceipt</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发票已经发送给用户邮箱： aaaa@qq.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doDelivery</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;顺丰次日达：投送商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 门店订单：子类实现具体算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-12-29 20:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StoreOrder</span> <span class="keyword">extends</span> <span class="title class_">OrderProcessTemplate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSelect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户选择了：3号货架-xiaomi11 商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPayment</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;刷卡机：刷卡支付 1999&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doReceipt</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印发票，和物品一起包装&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doDelivery</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;把商品交给用户，用漂亮的袋子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设计模式：  多定义接口、抽象类</span></span><br><span class="line"><span class="comment"> * 1）、依赖倒置； 依赖抽象</span></span><br><span class="line"><span class="comment"> * 2）、多态；    随便替换实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 模板方法模式测试 ； 核心： 父类定义算法骨架，子类实现算法细节</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-12-28 20:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateMethodPatternTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//行为型模式玩的就是一个多态</span></span><br><span class="line">        <span class="comment">//1、外界调用模板类【遵循依赖反转原则】【依赖抽象而不是细节】</span></span><br><span class="line">        <span class="type">OrderProcessTemplate</span> <span class="variable">processTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NetOrder</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;网络订单：&quot;</span>);</span><br><span class="line">        <span class="comment">//处理订单</span></span><br><span class="line">        processTemplate.processOrder(); <span class="comment">//定义了算法的模板</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        processTemplate = <span class="keyword">new</span> <span class="title class_">StoreOrder</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;门店订单：&quot;</span>);</span><br><span class="line">        <span class="comment">// 根据需要，选择不同的实现类，从而达到我们需要的效果：网络订单 或 门店订单</span></span><br><span class="line">        processTemplate.processOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/039d094065690f2e4da8f73e94526786.png" alt="image-20230113220611870"></p><h2 id="三、策略模式案例"><a href="#三、策略模式案例" class="headerlink" title="三、策略模式案例"></a>三、策略模式案例</h2><p><strong>描述：</strong>定义<code>算法家族，分别封装</code>起来，让它们之间可以<code>相互替换</code>，此模式让算法的变化独立于使用算法的客户。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/003b3cc3b5b54eee7bb255bde2e82ec5.png"></p><p><strong>案例：排序算法</strong></p><p><font color=orange>1、定义算法接口</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 算法接口：排序策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-12-29 20:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] arr)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=orange>2、定义策略类，实现算法接口</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 策略1：冒泡排序策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-12-29 20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSortStrategy</span> <span class="keyword">implements</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] arr)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始冒泡排序....&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt; arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length- <span class="number">1</span> - i  ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序结果：&quot;</span>+ Arrays.asList(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-12-29 20:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSortStrategy</span> <span class="keyword">implements</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] arr)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;快速排序开始&quot;</span>);</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序结果：&quot;</span>+Arrays.asList(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=orange>3、定义上下文对象(入口类)：持有策略对象</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 上下文：入口类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-12-29 20:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拿到一个排序算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SortStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了强制要求用户必须传入一个排序算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SortService</span><span class="params">(SortStrategy strategy)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy  =strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随时动态更新排序算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(SortStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 才是别人调用的排序方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] arr)</span>&#123;</span><br><span class="line">        strategy.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=orange>4、使用策略对象执行算法</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>  模板模式定义大框架、策略默认定义小细节</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-12-28 21:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyPatternTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">// 传入不同的策略，就使用对应的策略</span></span><br><span class="line">        <span class="type">SortService</span> <span class="variable">sortService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortService</span>(<span class="keyword">new</span> <span class="title class_">BubbleSortStrategy</span>());</span><br><span class="line">        sortService.sort(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新策略</span></span><br><span class="line">        sortService.setStrategy(<span class="keyword">new</span> <span class="title class_">QuickSortStrategy</span>());</span><br><span class="line">        sortService.sort(arr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/879dd90a18e7a5bc986a4bca6627a4e7.png" alt="image-20230113220248469"></p><h2 id="四、支付改造"><a href="#四、支付改造" class="headerlink" title="四、支付改造"></a>四、支付改造</h2><h3 id="4-1-思路分析"><a href="#4-1-思路分析" class="headerlink" title="4.1 思路分析"></a>4.1 思路分析</h3><p>使用<code>模板方法模式</code>：定义&#x3D;&#x3D;支付的完整流程&#x3D;&#x3D;；</p><p>使用<code>策略模式</code>：定义&#x3D;&#x3D;支付的不同实现&#x3D;&#x3D;；</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2e0d3c18725c719c98d22d7b5aa1bc5a.png"></p><h3 id="4-2-实现图解："><a href="#4-2-实现图解：" class="headerlink" title="4.2 实现图解："></a>4.2 实现图解：</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/6628cf4dc83c070f9bbd822c3a45878f.png"></p><blockquote><p><strong>分析</strong>：PayStrategy使用的是策略模式~  PayService中的processNotify里面包含了 一系列抽象方法的调用,不同的支付方式会有不同的实现,这里使用了模板方法模式~</p></blockquote><h3 id="4-3-代码实现："><a href="#4-3-代码实现：" class="headerlink" title="4.3 代码实现："></a>4.3 代码实现：</h3><p><font color=orange>1、支付策略接口：<code>PayStrategy</code></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 支付策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-12-28 22:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PayStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持哪种支付</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(String type)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为某个订单展示收银台页面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">cashierPage</span><span class="params">(OrderInfo orderInfo)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  原生请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body     请求体数据【请求体只能读取一次，所以controller拿到以后都往下传递即可】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">checkSign</span><span class="params">(HttpServletRequest request,String body)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验签错误处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">signError</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验签通过返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">signOk</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验签成功后处理通知数据： 把通知的所有数据封装指定对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;String,Object&gt; <span class="title function_">process</span><span class="params">(HttpServletRequest request,String body)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=orange>2、接口实现：<code>AlipayStrategy</code> 、<code>WeixinPayStrategy</code></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 支付宝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-12-28 22:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayStrategy</span> <span class="keyword">implements</span> <span class="title class_">PayStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AlipayProperties alipayProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AlipayClient alipayClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">cashierPage</span><span class="params">(OrderInfo orderInfo)</span> &#123;</span><br><span class="line">        <span class="comment">//1、创建一个 AlipayClient</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、创建一个支付请求</span></span><br><span class="line">        <span class="type">AlipayTradePagePayRequest</span> <span class="variable">alipayRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradePagePayRequest</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、设置参数</span></span><br><span class="line">        alipayRequest.setReturnUrl(alipayProperties.getReturn_url()); <span class="comment">//同步回调：支付成功以后，浏览器要跳转到的页面地址</span></span><br><span class="line">        alipayRequest.setNotifyUrl(alipayProperties.getNotify_url()); <span class="comment">//通知回调：支付成功以后，支付消息会通知给这个地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//商户订单号（对外交易号）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">outTradeNo</span> <span class="operator">=</span> orderInfo.getId().toString();</span><br><span class="line">        <span class="comment">//付款金额</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">totalAmount</span> <span class="operator">=</span> orderInfo.getPrice();</span><br><span class="line">        <span class="comment">//订单名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">orderName</span> <span class="operator">=</span> <span class="string">&quot;尚品汇-订单-&quot;</span>+outTradeNo;</span><br><span class="line">        <span class="comment">//商品描述</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">tradeBody</span> <span class="operator">=</span> orderInfo.getDesc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//详细：https://opendocs.alipay.com/open/028r8t?scene=22</span></span><br><span class="line">        <span class="comment">//业务参数</span></span><br><span class="line">        Map&lt;String,Object&gt; bizContent = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        bizContent.put(<span class="string">&quot;out_trade_no&quot;</span>,outTradeNo);</span><br><span class="line">        bizContent.put(<span class="string">&quot;total_amount&quot;</span>,totalAmount);</span><br><span class="line">        bizContent.put(<span class="string">&quot;subject&quot;</span>,orderName);</span><br><span class="line">        bizContent.put(<span class="string">&quot;body&quot;</span>,tradeBody);</span><br><span class="line">        bizContent.put(<span class="string">&quot;product_code&quot;</span>,<span class="string">&quot;FAST_INSTANT_TRADE_PAY&quot;</span>);</span><br><span class="line">        <span class="comment">//自动关单</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(orderInfo.getExpireTime());</span><br><span class="line">        bizContent.put(<span class="string">&quot;time_expire&quot;</span>,date);</span><br><span class="line">        alipayRequest.setBizContent(JSON.toJSONString(bizContent));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成支付页面</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">page</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            page = alipayClient.pageExecute(alipayRequest).getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AlipayApiException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkSign</span><span class="params">(HttpServletRequest request,String body)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; params = HttpUtils.getParameterMap(request);</span><br><span class="line">        log.info(<span class="string">&quot;支付宝通知验证签名...&quot;</span>);</span><br><span class="line">        <span class="comment">//验证签名</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用SDK验证签名</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">signVerified</span> <span class="operator">=</span> AlipaySignature.rsaCheckV1(params,</span><br><span class="line">                    alipayProperties.getAlipay_public_key(), alipayProperties.getCharset(),</span><br><span class="line">                    alipayProperties.getSign_type());</span><br><span class="line">            <span class="keyword">return</span> signVerified;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AlipayApiException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">signError</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">process</span><span class="params">(HttpServletRequest request,String body)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = HttpUtils.getParameterMap(request);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(map);</span><br><span class="line">        Map&lt;String, Object&gt; data = JSON.parseObject(json, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">signOk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//支付宝要求成功返回 success 字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">//对新增开放，对修改关闭</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;alipay&quot;</span>.equalsIgnoreCase(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 微信支付</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-12-28 22:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeixinPayStrategy</span> <span class="keyword">implements</span> <span class="title class_">PayStrategy</span> &#123;</span><br><span class="line">    <span class="comment">// 具体实现省略，可以到代码仓库查看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=orange>3、支付Service代码编写</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-12-28 22:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PayService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成支付收银台页</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">payPage</span><span class="params">(String type, Long orderId)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理支付通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">processNotify</span><span class="params">(HttpServletRequest request,String body)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=orange>4、支付Service实现</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 支付上下文引用支付策略； 这个上下文也是模板类；定义好算法步骤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-12-28 22:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span> <span class="comment">//模板类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PayService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    List&lt;PayStrategy&gt; payStrategies; <span class="comment">//注入支付策略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成收银台页面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">payPage</span><span class="params">(String type, Long orderId)</span> &#123;</span><br><span class="line">        <span class="comment">//1、查询数据库订单</span></span><br><span class="line">        <span class="type">OrderInfo</span> <span class="variable">orderInfo</span> <span class="operator">=</span> getOrderInfo(orderId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、生成支付页</span></span><br><span class="line">        <span class="keyword">for</span> (PayStrategy strategy : payStrategies) &#123;</span><br><span class="line">            <span class="keyword">if</span>(strategy.supports(type))&#123;</span><br><span class="line">                <span class="comment">//获取收银台页面</span></span><br><span class="line">                <span class="keyword">return</span> strategy.cashierPage(orderInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、如果以上都不支持，打印错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;不支持这种支付方式&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义通知处理模板；</span></span><br><span class="line"><span class="comment">     * 微信通知</span></span><br><span class="line"><span class="comment">     * 支付宝通知</span></span><br><span class="line"><span class="comment">     * 1）、验证签名</span></span><br><span class="line"><span class="comment">     * 2）、验证通过改订单为已支付</span></span><br><span class="line"><span class="comment">     * 3）、验证通过给支付宝(success)微信(200状态码json)返回数据</span></span><br><span class="line"><span class="comment">     * 4）、xxx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">processNotify</span><span class="params">(HttpServletRequest request,String body)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;不支持此方式&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、判断是那种通知</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> getNotifyType(request);</span><br><span class="line">        Map&lt;String, Object&gt; data = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、验证签名</span></span><br><span class="line">        <span class="keyword">for</span> (PayStrategy strategy : payStrategies) &#123;</span><br><span class="line">            <span class="keyword">if</span>(strategy.supports(type))&#123;</span><br><span class="line">                <span class="comment">//签名校验</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">checkSign</span> <span class="operator">=</span> strategy.checkSign(request,body);</span><br><span class="line">                <span class="keyword">if</span>(!checkSign)&#123;</span><br><span class="line">                    log.error(<span class="string">&quot;签名验证失败，疑似攻击请求&quot;</span>);</span><br><span class="line">                    <span class="comment">//验签失败返回</span></span><br><span class="line">                   <span class="keyword">return</span> strategy.signError();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;签名验证成功，提取通知数据&quot;</span>);</span><br><span class="line">                    <span class="comment">//验签成功处理数据</span></span><br><span class="line">                    data = strategy.process(request,body);</span><br><span class="line">                    <span class="comment">//验签成功返回</span></span><br><span class="line">                    result = strategy.signOk();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、通用的后续处理算法；处理订单数据</span></span><br><span class="line">        processOrder(data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理订单数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Map&lt;String, Object&gt; data)</span> &#123;</span><br><span class="line">        <span class="comment">//TODO 把支付成功信息等保存数据库，并修改订单状态，通知库存系统等...</span></span><br><span class="line">        log.info(<span class="string">&quot;订单支付成功，状态修改完成，已通知库存系统，详细数据：&#123;&#125;&quot;</span>,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断通知类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getNotifyType</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;wechatpay-serial&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(header))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;weixin&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">app_id</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;app_id&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(app_id))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;alipay&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> OrderInfo <span class="title function_">getOrderInfo</span><span class="params">(Long orderId)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;查询数据库订单：&#123;&#125;&quot;</span>,orderId);</span><br><span class="line">        <span class="type">OrderInfo</span> <span class="variable">orderInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderInfo</span>();</span><br><span class="line">        orderInfo.setId(orderId);</span><br><span class="line">        orderInfo.setTitle(<span class="string">&quot;尚品汇-商城-订单&quot;</span>);</span><br><span class="line">        orderInfo.setComment(<span class="string">&quot;快点发货&quot;</span>);</span><br><span class="line">        orderInfo.setDesc(<span class="string">&quot;买了一堆商品&quot;</span>);</span><br><span class="line">        orderInfo.setPrice(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;9098.00&quot;</span>));</span><br><span class="line">        orderInfo.setExpireTime(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()+<span class="number">30</span>*<span class="number">60</span>*<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> orderInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/543a45872d4d17617504e7dea6c7119f.png" alt="image-20230113223331649"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/3267819573fb85bf35740bd55b7048b1.png" alt="image-20230114125758333"></p><h3 id="4-4-效果演示"><a href="#4-4-效果演示" class="headerlink" title="4.4 效果演示"></a>4.4 效果演示</h3><p><font color=orange>1、用户进入支付页面后：</font></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b1235253e3ce038125552750ac0c3b65.png" alt="image-20230114112440663"></p><p><font color=orange>2、当选择微信支付时，进入微信二维码页面</font></p><p><img src="https://img-blog.csdnimg.cn/img_convert/2c644c164d36791ac1dc70cda7202dc1.png" alt="image-20230114112525508"></p><p><font color=orange>3、当选择支付宝支付，进入支付宝页面</font></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9f2041ef2259893210790a38c3d2b14f.png" alt="image-20230114112626541"></p><p><font color=orange>4、支付成功之后会跳转到对应的成功页面（微信成功页面、支付宝成功页面…）</font></p><h3 id="4-5-如何扩展"><a href="#4-5-如何扩展" class="headerlink" title="4.5 如何扩展"></a>4.5 如何扩展</h3><p>最后我们需要思考一个问题，经过我们使用策略+模板改造的支付 和传统的写法有啥好处呢？</p><p>1、&#x3D;&#x3D;易于扩展&#x3D;&#x3D;，如果我们想要增加新的支付方式：银联支付、白条支付…我们只需要定义对应的支付策略类即可~ 当不需要时，直接删除对应的实现类。然后在调用的时候，会自适应使用对应的策略~ 符合<code>对修改关闭，对扩展开放</code>的特点！</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3bf9cdcfd38eae9df74d77e1b4610252.png" alt="image-20230114124615619"></p><p>2、Service中的模板方法也让我们的&#x3D;&#x3D;代码冗余度更低&#x3D;&#x3D;，逻辑更加清晰~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十三、垃圾回收器</title>
      <link href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC13%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC13%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="13-垃圾回收器"><a href="#13-垃圾回收器" class="headerlink" title="13. 垃圾回收器"></a>13. 垃圾回收器</h1><h2 id="13-1-GC-分类与性能指标"><a href="#13-1-GC-分类与性能指标" class="headerlink" title="13.1. GC 分类与性能指标"></a>13.1. GC 分类与性能指标</h2><h3 id="13-1-1-垃圾回收器概述"><a href="#13-1-1-垃圾回收器概述" class="headerlink" title="13.1.1. 垃圾回收器概述"></a>13.1.1. 垃圾回收器概述</h3><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的 JVM 来实现。</p><p>由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。</p><p>从不同角度分析垃圾收集器，可以将 GC 分为不同的类型。</p><h3 id="13-1-2-垃圾收集器分类"><a href="#13-1-2-垃圾收集器分类" class="headerlink" title="13.1.2. 垃圾收集器分类"></a>13.1.2. 垃圾收集器分类</h3><p>按<mark>线程数</mark>分，可以分为<mark>串行垃圾回收器</mark>和<mark>并行垃圾回收器</mark>。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608908.png" alt="image-20210512144253383"></p><p>串行回收指的是在同一时间段内只允许有一个 CPU 用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p><ul><li>在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<mark>串行回收默认被应用在客户端的 Client 模式下的 JVM 中</mark></li><li>在并发能力比较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器。</li></ul><p>和串行回收相反，并行收集可以运用多个 CPU 同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</p><p>按照<mark>工作模式</mark>分，可以分为<mark>并发式垃圾回收器</mark>和<mark>独占式垃圾回收器</mark>。</p><ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608891.png" alt="image-20200713083443486"></p><p>按<mark>碎片处理方式</mark>分，可分为<mark>压缩式垃圾回收器</mark>和<mark>非压缩式垃圾回收器</mark>。</p><ul><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li><li>非压缩式的垃圾回收器不进行这步操作。</li></ul><p>按<mark>工作的内存区间</mark>分，又可分为<mark>年轻代垃圾回收器</mark>和<mark>老年代垃圾回收器</mark>。</p><h3 id="13-1-3-评估-GC-的性能指标"><a href="#13-1-3-评估-GC-的性能指标" class="headerlink" title="13.1.3. 评估 GC 的性能指标"></a>13.1.3. 评估 GC 的性能指标</h3><ul><li><mark>吞吐量</mark>：运行用户代码的时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</li><li><mark>垃圾收集开销</mark>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li><mark>暂停时间</mark>：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li><mark>收集频率</mark>：相对于应用程序的执行，收集操作发生的频率。</li><li><mark>内存占用</mark>：Java 堆区所占的内存大小。</li><li><mark>快速</mark>：一个对象从诞生到被回收所经历的时间。</li></ul><p>吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p><p>简单来说，主要抓住两点：吞吐量、暂停时间</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608759.jpg" alt="第17章_吞吐量与暂停时间"></p><p><strong>吞吐量</strong></p><p>吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 &#x3D; 运行用户代码时间 &#x2F;（运行用户代码时间+垃圾收集时间）。比如：虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。</p><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p><p>吞吐量优先，意味着在单位时间内，STW 的时间最短：0.2 + 0.2 &#x3D; 0.4</p><p><strong>暂停时间</strong></p><p>“暂停时间”是指一个时间段内应用程序线程暂停，让 GC 线程执行的状态。</p><p>例如，GC 期间 100 毫秒的暂停时间意味着在这 100 毫秒期间内没有应用程序线程是活动的。</p><p>暂停时间优先，意味着尽可能让单次 STW 的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 &#x3D; 0.5</p><p><strong>吞吐量 vs 暂停时间</strong></p><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p><p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是 GC 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，<mark>有时候甚至短暂的 200 毫秒暂停都可能打断终端用户体验</mark>。因此，具有低的较大暂停时间是非常重要的，特别是对于一个<mark>交互式应用程序</mark>。</p><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p><ul><li>因为如果选择以吞吐量优先，那么<mark>必然需要降低内存回收的执行频率</mark>，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。</li><li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也<mark>只能频繁地执行内存回收</mark>，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li></ul><p>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p><p>现在标准：<mark>在最大吞吐量优先的情况下，降低停顿时间</mark></p><h2 id="13-2-不同的垃圾回收器概述"><a href="#13-2-不同的垃圾回收器概述" class="headerlink" title="13.2. 不同的垃圾回收器概述"></a>13.2. 不同的垃圾回收器概述</h2><p>垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p><h3 id="13-2-1-垃圾回收器发展史"><a href="#13-2-1-垃圾回收器发展史" class="headerlink" title="13.2.1. 垃圾回收器发展史"></a>13.2.1. 垃圾回收器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是 Garbage Collection，对应的产品我们称为 Garbage Collector。</p><ul><li>1999 年随 JDK1.3.1 一起来的是串行方式的 serialGc，它是第一款 GC。ParNew 垃圾收集器是 Serial 收集器的多线程版本</li><li>2002 年 2 月 26 日，Parallel GC 和 Concurrent Mark Sweep GC 跟随 JDK1.4.2 一起发布·</li><li>Parallel GC 在 JDK6 之后成为 HotSpot 默认 GC。</li><li>2012 年，在 JDK1.7u4 版本中，G1 可用。</li><li>2017 年，JDK9 中 G1 变成默认的垃圾收集器，以替代 CMS。</li><li>2018 年 3 月，JDK10 中 G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li>2018 年 9 月，JDK11 发布。引入 Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入 ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li><li>2019 年 3 月，JDK12 发布。增强 G1，自动返回未用堆内存给操作系统。同时，引入 Shenandoah GC：低停顿时间的 GC（Experimental）。·</li><li>2019 年 9 月，JDK13 发布。增强 ZGC，自动返回未用堆内存给操作系统。</li><li>2020 年 3 月，JDK14 发布。删除 CMS 垃圾回收器。扩展 ZGC 在 macos 和 Windows 上的应用</li></ul><h3 id="13-2-2-7-种经典的垃圾收集器"><a href="#13-2-2-7-种经典的垃圾收集器" class="headerlink" title="13.2.2. 7 种经典的垃圾收集器"></a>13.2.2. 7 种经典的垃圾收集器</h3><ul><li>串行回收器：Serial、Serial Old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li>并发回收器：CMS、G1</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608936.png" alt="image-20200713093551365"></p><p>官方手册：<a href="https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf">https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</a></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608748.png" alt="image-20230304171940201"></p><h3 id="13-2-3-7-款经典收集器与垃圾分代之间的关系"><a href="#13-2-3-7-款经典收集器与垃圾分代之间的关系" class="headerlink" title="13.2.3. 7 款经典收集器与垃圾分代之间的关系"></a>13.2.3. 7 款经典收集器与垃圾分代之间的关系</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608755.jpg" alt="第17章_经典的7种GC"></p><ul><li><p>新生代收集器：Serial、ParNew、Parallel Scavenge；</p></li><li><p>老年代收集器：Serial Old、Parallel Old、CMS；</p></li><li><p>整堆收集器：G1；</p></li></ul><h3 id="13-2-4-垃圾收集器的组合关系"><a href="#13-2-4-垃圾收集器的组合关系" class="headerlink" title="13.2.4. 垃圾收集器的组合关系"></a>13.2.4. 垃圾收集器的组合关系</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608371.jpg" alt="第17章_垃圾收集器组合"></p><ol><li>两个收集器间有连线，表明它们可以搭配使用：Serial&#x2F;Serial Old、Serial&#x2F;CMS、ParNew&#x2F;Serial Old、ParNew&#x2F;CMS、Parallel Scavenge&#x2F;Serial Old、Parallel Scavenge&#x2F;Parallel Old、G1；</li><li>其中 Serial Old 作为 CMS 出现”<code>Concurrent Mode Failure</code>“失败的后备预案。</li><li>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial+CMS、ParNew+Serial Old 这两个组合声明为废弃（JEP173），并在 JDK9 中完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK14 中：弃用 Parallel Scavenge 和 Serialold GC 组合（JEP366）</li><li>（绿色虚框）JDK14 中：删除 CMS 垃圾回收器（JEP363）</li></ol><h3 id="13-2-5-不同的垃圾收集器概述"><a href="#13-2-5-不同的垃圾收集器概述" class="headerlink" title="13.2.5. 不同的垃圾收集器概述"></a>13.2.5. 不同的垃圾收集器概述</h3><p>为什么要有很多收集器，一个不够吗？因为 Java 的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p><p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以<mark>我们选择的只是对具体应用最合适的收集器</mark>。</p><h3 id="13-2-6-如何查看默认垃圾收集器"><a href="#13-2-6-如何查看默认垃圾收集器" class="headerlink" title="13.2.6. 如何查看默认垃圾收集器"></a>13.2.6. 如何查看默认垃圾收集器</h3><p><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p><p>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 进程ID</code></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608417.png" alt="image-20230228150151322"></p><h2 id="13-3-Serial-回收器：串行回收"><a href="#13-3-Serial-回收器：串行回收" class="headerlink" title="13.3. Serial 回收器：串行回收"></a>13.3. Serial 回收器：串行回收</h2><p>Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3 之前回收新生代唯一的选择。</p><p>Serial 收集器作为 HotSpot 中 client 模式下的默认新生代垃圾收集器。</p><p><mark>Serial 收集器采用复制算法、串行回收和”stop-the-World”机制的方式执行内存回收。</mark></p><p>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。<mark>Serial Old 收集器同样也采用了串行回收和”Stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</mark></p><ul><li>Serial old 是运行在 Client 模式下默认的老年代的垃圾回收器</li><li>Serial 0ld 在 Server 模式下主要有两个用途：① 与新生代的 Parallel scavenge 配合使用 ② 作为老年代 CMS 收集器的后备垃圾收集方案</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608583.png" alt="image-20200713100703799"></p><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会<mark>使用一个 CPU 或一条收集线程去完成垃圾收集工作</mark>，更重要的是在它进行垃圾收集时，<mark>必须暂停其他所有的工作线程</mark>，直到它收集结束（Stop The World）</p><p>优势：<mark>简单而高效</mark>（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在 Client 模式下的虚拟机是个不错的选择。</p><p>在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB），可以在较短时间内完成垃圾收集（几十 ms 至一百多 ms），只要不频繁发生，使用串行回收器是可以接受的。</p><p>在 HotSpot 虚拟机中，使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器。等价于新生代用 Serial GC，且老年代用 Serial Old GC</p><p><strong>总结</strong></p><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核 cpu 才可以用。现在都不是单核的了。</p><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在 Java web 应用程序中是不会采用串行垃圾收集器的。</p><h2 id="13-4-ParNew-回收器：并行回收"><a href="#13-4-ParNew-回收器：并行回收" class="headerlink" title="13.4. ParNew 回收器：并行回收"></a>13.4. ParNew 回收器：并行回收</h2><p>如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。Par 是 Parallel 的缩写，New：只能处理的是新生代</p><p>ParNew 收集器除了采用<mark>并行回收</mark>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是采用<mark>复制算法、”Stop-the-World”机制</mark>。</p><p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608652.png" alt="image-20200713102030127"></p><ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU 并行需要切换线程，串行可以省去切换线程的资源）</li></ul><p>由于 ParNew 收集器是基于并行回收，那么是否可以断定 ParNew 收集器的回收效率在任何场景下都会比 serial 收集器更高效？</p><ul><li>ParNew 收集器运行在多 CPU 的环境下，由于可以充分利用多 CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li><li>但是<mark>在单个 CPU 的环境下，ParNew 收集器不比 Serial 收集器更高效</mark>。虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li></ul><p>因为除 Serial 外，目前只有 ParNew GC 能与 CMS 收集器配合工作</p><p>在程序中，开发人员可以通过选项”<code>-XX:+UseParNewGC</code>“手动指定使用 ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p><p><code>-XX:ParallelGCThreads</code>限制线程数量，默认开启和 CPU 数据相同的线程数。</p><h2 id="13-5-Parallel-回收器：吞吐量优先"><a href="#13-5-Parallel-回收器：吞吐量优先" class="headerlink" title="13.5. Parallel 回收器：吞吐量优先"></a>13.5. Parallel 回收器：吞吐量优先</h2><p>HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器同样也采用了<mark>复制算法、并行回收和”Stop the World”机制</mark>。</p><p>那么 Parallel 收集器的出现是否多此一举？</p><ul><li>和 ParNew 收集器不同，ParallelScavenge 收集器的目标则是达到一个<mark>可控制的吞吐量</mark>（Throughput），它也被称为吞吐量优先的垃圾收集器。</li><li>自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别。</li></ul><p>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要<mark>适合在后台运算而不需要太多交互的任务</mark>。因此，常见在服务器环境中使用。<mark>例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序</mark>。</p><p>Parallel 收集器在 JDK1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。</p><p>Parallel Old 收集器采用了<mark>标记-压缩算法</mark>，但同样也是基于<mark>并行回收和”Stop-the-World”机制</mark>。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608716.png" alt="image-20200713110359441"></p><p>在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。在 Java8 中，默认是此垃圾收集器。</p><p><strong>参数配置</strong></p><ul><li><p><code>-XX:+UseParallelGC</code> 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务。</p></li><li><p><code>-XX:+UseParallelOldGC</code> 手动指定老年代都是使用并行回收收集器。</p><ul><li>分别适用于新生代和老年代。默认 jdk8 是开启的。</li><li>上面两个参数，默认开启一个，另一个也会被开启。（&#x3D;&#x3D;互相激活&#x3D;&#x3D;）</li></ul></li><li><p><code>-XX:ParallelGCThreads</code> 设置年轻代并行收集器的线程数。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能。</p><p>$$ ParallelGCThreads &#x3D; \begin{cases} CPU_Count &amp; \text (CPU_Count &lt;&#x3D; 8) \ 3 + (5 * CPU＿Count &#x2F; 8) &amp; \text (CPU_Count &gt; 8) \end{cases} $$</p></li><li><p><code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（即 STw 的时间）。单位是毫秒。</p><ul><li>为了尽可能地把停顿时间控制在 MaxGCPauseMills 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallel，进行控制。</li><li><mark>该参数使用需谨慎</mark>。[如果该参数设置的很小，就会导致堆被调整的很小，从而GC的频率就会很高，吞吐量会降低]</li></ul></li><li><p><code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间的比例（&#x3D;1&#x2F;（N+1））。用于衡量吞吐量的大小。</p><ul><li>取值范围（0, 100）。默认值 99，也就是垃圾回收时间不超过 1%。</li><li>与前一个<code>-XX:MaxGCPauseMillis </code>参数有一定矛盾性。暂停时间越长，Radio 参数就容易超过设定的比例。</li></ul></li><li><p><code>-XX:+UseAdaptivesizePolicy</code> 设置 Parallel Scavenge 收集器具有<mark>自适应调节策略</mark></p><ul><li>在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li><li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（<code>GCTimeRatio</code>）和停顿时间（<code>MaxGCPauseMills</code>），让虚拟机自己完成调优工作。</li></ul><blockquote><p>无需记住所有的参数，只需要记住该垃圾回收器可以调整哪些参数就可以了，使用时从文档中查</p></blockquote></li></ul><h2 id="13-6-CMS-回收器：低延迟"><a href="#13-6-CMS-回收器：低延迟" class="headerlink" title="13.6. CMS 回收器：低延迟"></a>13.6. CMS 回收器：低延迟</h2><h3 id="13-6-1-CSM概述"><a href="#13-6-1-CSM概述" class="headerlink" title="13.6.1 CSM概述"></a>13.6.1 CSM概述</h3><p>在 JDK1.5 时期，Hotspot 推出了一款在<mark>强交互应用</mark>中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<mark>这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</mark>。</p><p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><ul><li><mark>目前很大一部分的 Java 应用集中在互联网站或者 B&#x2F;S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短</mark>，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。</li></ul><p>CMS 的垃圾收集算法采用<mark>标记-清除算法</mark>，并且也会”Stop-the-World”</p><p>不幸的是，CMS 作为老年代的收集器，却无法与 JDK1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</p><p>在 G1 出现之前，CMS 使用还是非常广泛的。一直到今天，仍然有很多系统使用 CMS GC。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608893.png" alt="image-20200713205154007"></p><p>CMS 整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</p><ul><li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务<mark>仅仅只是标记出 GCRoots 能直接关联到的对象</mark>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<mark>速度非常快</mark>。</li><li><strong>并发标记</strong>（Concurrent-Mark）阶段：从 GC Roots 的<mark>直接关联对象开始遍历整个对象图的过程</mark>，这个过程耗时较长但是<mark>不需要停顿用户线程</mark>，可以与垃圾收集线程一起并发运行。</li><li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<mark>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</mark>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段<mark>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</mark>。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ul><p>尽管 CMS 收集器采用的是并发回收（非独占式），但是<mark>在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制</mark>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p><p><mark>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</mark></p><p>另外，由于在垃圾收集阶段用户线程没有中断，<mark>所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用</mark>。因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是<mark>当堆内存使用率达到某一阈值时，便开始进行回收</mark>，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次“<code>Concurrent Mode Failure</code>” 失败，这时虚拟机将启动后备预案：临时&#x3D;&#x3D;启用 Serial Old 收集器&#x3D;&#x3D;来重新进行老年代的垃圾收集，这样停顿时间[STW]就很长了。</p><p>CMS 收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会<mark>产生一些内存碎片</mark>。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608144.png" alt="image-20200713212230352"></p><p><strong>有人会觉得既然 Mark Sweep 会造成内存碎片，那么为什么不把算法换成 Mark Compact？</strong></p><p>答案其实很简单，因为当并发清除的时候，用 Compact 整理内存的话，原来的用户线程使用的内存还怎么用呢？&#x3D;&#x3D;要保证用户线程能继续执行，前提的它运行的资源不受影响&#x3D;&#x3D;嘛。Mark Compact 更适合“Stop the World” 这种场景下使用</p><h3 id="13-6-2-CMS-的优缺点"><a href="#13-6-2-CMS-的优缺点" class="headerlink" title="13.6.2. CMS 的优缺点"></a>13.6.2. CMS 的优缺点</h3><p><strong>优点：</strong></p><ul><li>并发收集</li><li>低延迟</li></ul><p><strong>缺点：</strong></p><ul><li><mark>会产生内存碎片</mark>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发 FullGC。</li><li><mark>CMS 收集器对 CPU 资源非常敏感</mark>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li><mark>CMS 收集器无法处理浮动垃圾</mark>。可能出现“<code>Concurrent Mode Failure</code>“失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么<mark>在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</mark>，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。</li></ul><h3 id="13-6-3-设置的参数"><a href="#13-6-3-设置的参数" class="headerlink" title="13.6.3. 设置的参数"></a>13.6.3. 设置的参数</h3><ul><li><p><code>-XX:+UseConcMarkSweepGC </code>手动指定使用 CMS 收集器执行内存回收任务。</p><p>开启该参数后会自动将<code>-xx:+UseParNewGC</code>打开。即：ParNew（Young 区用）+CMS（Old 区用）+ Serial Old 的组合。</p></li><li><p><code>-XX:CMSInitiatingOccupanyFraction</code> 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p><ul><li>JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68%时，会执行一次 CMS 回收。<mark>JDK6 及以上版本默认值为 92%</mark></li><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 FullGC 的执行次数。</li></ul></li><li><p><code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p></li><li><p><code>-XX:CMSFullGCsBeforeCompaction</code> 设置在执行多少次 Full GC 后对内存空间进行压缩整理。【与上个参数配合使用】</p></li><li><p><code>-XX:ParallelcMSThreads</code> 设置 CMS 的线程数量。</p><ul><li>CMS 默认启动的线程数是（ParallelGCThreads+3）&#x2F;4，ParallelGCThreads 是年轻代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul></li></ul><h3 id="13-6-4-小结"><a href="#13-6-4-小结" class="headerlink" title="13.6.4. 小结"></a>13.6.4. 小结</h3><p>HotSpot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 Gc 有什么不同呢？</p><p>请记住以下口令：</p><ul><li>如果你想要最小化地使用内存和并行开销，请选 Serial GC；老年代对应的Serial Old GC</li><li>如果你想要最大化应用程序的吞吐量，请选 Parallel GC；老年代对应着Parallel Old GC</li><li>如果你想要最小化 GC 的中断或停顿时间，请选 CMS GC；老年代对应着ParNew GC</li></ul><h3 id="13-6-5-JDK-后续版本中-CMS-的变化"><a href="#13-6-5-JDK-后续版本中-CMS-的变化" class="headerlink" title="13.6.5. JDK 后续版本中 CMS 的变化"></a>13.6.5. JDK 后续版本中 CMS 的变化</h3><p>JDK9 新特性：CMS 被标记为 <code>Deprecate </code>了（JEP291）</p><ul><li>如果对 JDK9 及以上版本的 HotSpot 虚拟机使用参数<code>-XX: +UseConcMarkSweepGC</code>来开启 CMS 收集器的话，用户会收到一个警告信息，提示 CMS 未来将会被废弃。</li></ul><p>JDK14 新特性：<code>删除 </code>CMS 垃圾回收器（JEP363）</p><ul><li>移除了 CMS 垃圾收集器，如果在 JDK14 中使用 <code>-XX:+UseConcMarkSweepGC</code>的话，JVM 不会报错，只是给出一个 warning 信息，但是不会 exit。JVM 会自动回退以默认 GC 方式启动 JVM</li></ul><h2 id="13-7-G1-回收器：区域化分代式"><a href="#13-7-G1-回收器：区域化分代式" class="headerlink" title="13.7. G1 回收器：区域化分代式"></a>13.7. G1 回收器：区域化分代式</h2><p><strong>既然我们已经有了前面几个强大的 GC，为什么还要发布 Garbage First（G1）？</strong></p><p>原因就在于应用程序所应对的<mark>业务越来越庞大、复杂，用户越来越多</mark>，没有 GC 就不能保证应用程序正常进行，而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。G1（Garbage-First）垃圾回收器是在 Java7 update4 之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p><p>与此同时，为了适应现在<mark>不断扩大的内存和不断增加的处理器数量</mark>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p><p><mark>官方给 G1 设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</mark></p><p><strong>为什么名字叫 Garbage First(G1)呢？</strong></p><p>因为 G1 是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的 Region 来表示 Eden、幸存者 0 区，幸存者 1 区，老年代等。</p><p>G1 GC 有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<mark>每次根据允许的收集时间，优先回收价值最大的 Region</mark>。</p><p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给 G1 一个名字：垃圾优先（Garbage First）。</p><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<mark>主要针对配备多核 CPU 及大容量内存的机器</mark>，以极高概率满足 GC 停顿时间的同时，还兼具高吞吐量的性能特征。</p><p>在 JDK1.7 版本正式启用，移除了 Experimenta1 的标识，是<mark>JDK9 以后的默认垃圾回收器</mark>，取代了 CMS 回收器以及 Parallel+Parallel Old 组合。被 Oracle 官方称为“<mark>全功能的垃圾收集器</mark>”。</p><p>与此同时，CMS 已经在 JDK9 中被标记为废弃（deprecated）。在 jdk8 中还不是默认的垃圾回收器，需要使用<code>-XX:+UseG1GC</code>来启用。</p><h3 id="13-7-1-G1-回收器的特点（优势）"><a href="#13-7-1-G1-回收器的特点（优势）" class="headerlink" title="13.7.1. G1 回收器的特点（优势）"></a>13.7.1. G1 回收器的特点（优势）</h3><p>与其他 GC 收集器相比，G1 使用了全新的分区算法，其特点如下所示：</p><p><strong>并行与并发</strong></p><ul><li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程 STW</li><li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul><p><strong>分代收集</strong></p><ul><li>从分代上看，<mark>G1 依然属于分代型垃圾回收器</mark>，它会区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它不要求整个 Eden 区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将<mark>堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代</mark>。</li><li>和之前的各类回收器不同，它同时<mark>兼顾年轻代和老年代</mark>。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608161.png" alt="image-20200713215105293"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608132.png" alt="image-20200713215133839"></p><p><strong>空间整合</strong></p><ul><li>CMS：“标记-清除”算法、内存碎片、若干次 Gc 后进行一次碎片整理</li><li>G1 将内存划分为一个个的 region。内存的回收是以 region 作为基本单位的。<mark>Region 之间是复制算法</mark>，但整体上实际可看作是<mark>标记-压缩（Mark-Compact）算法</mark>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</li></ul><p><strong>可预测的停顿时间模型（即：软实时 soft real-time）</strong></p><p>这是 G1 相对于 CMS 的另一大优势，G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p><ul><li>由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<mark>每次根据允许的收集时间，优先回收价值最大的 Region</mark>。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li><li>相比于 CMSGC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</li></ul><h3 id="13-7-2-G1-垃圾收集器的缺点"><a href="#13-7-2-G1-垃圾收集器的缺点" class="headerlink" title="13.7.2. G1 垃圾收集器的缺点"></a>13.7.2. G1 垃圾收集器的缺点</h3><p>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 要高。</p><p>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势。平衡点在 6-8GB 之间。</p><h3 id="13-7-3-G1-回收器的参数设置"><a href="#13-7-3-G1-回收器的参数设置" class="headerlink" title="13.7.3. G1 回收器的参数设置"></a>13.7.3. G1 回收器的参数设置</h3><ul><li><code>-XX:+UseG1GC</code>：手动指定使用 G1 垃圾收集器执行内存回收任务</li><li><code>-XX:G1HeapRegionSize</code> 设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内存的 1&#x2F;2000。</li><li><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。默认值是 200ms（人的平均反应速度）</li><li><code>-XX:+ParallelGCThread</code> 设置 STW 时GC线程数的值。最多设置为 8（上面说过 Parallel 回收器的线程计算公式，当 CPU_Count &gt; 8 时，ParallelGCThreads 也会大于 8）</li><li><code>-XX:ConcGCThreads</code> 设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1&#x2F;4 左右。</li><li><code>-XX:InitiatingHeapOccupancyPercent</code> 设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发 GC。默认值是 45。</li></ul><h3 id="13-7-4-G1-收集器的常见操作步骤"><a href="#13-7-4-G1-收集器的常见操作步骤" class="headerlink" title="13.7.4. G1 收集器的常见操作步骤"></a>13.7.4. G1 收集器的常见操作步骤</h3><p>G1 的设计原则就是简化 JVM 性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步：开启 G1 垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ul><p>G1 中提供了三种垃圾回收模式：Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。</p><h3 id="13-7-5-G1-收集器的适用场景"><a href="#13-7-5-G1-收集器的适用场景" class="headerlink" title="13.7.5. G1 收集器的适用场景"></a>13.7.5. G1 收集器的适用场景</h3><p>1、面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p><p>2、最主要的应用是需要&#x3D;&#x3D;低 GC 延迟，并具有大堆&#x3D;&#x3D;的应用程序提供解决方案；如：在堆大小约 6GB 或更大时，可预测的暂停时间可以低于 0.5 秒；（G1 通过每次只清理一部分而不是全部的 Region 的增量式清理来保证每次 GC 停顿时间不会过长）。</p><p>3、用来替换掉 JDK1.5 中的 CMS 收集器；在下面的情况时，使用 G1 可能比 CMS 好：</p><ul><li>超过 50%的 Java 堆被活动数据占用；</li><li>对象分配频率或年代提升频率变化很大；</li><li>GC 停顿时间过长（长于 0.5 至 1 秒）</li></ul><p>4、HotSpot 垃圾收集器里，除了 G1 以外，其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作【优先级比较低】，而 G1 GC 可以采用<code>应用线程</code>承担后台运行的 GC 工作，即当 JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p><h3 id="13-7-6-分区-Region：化整为零"><a href="#13-7-6-分区-Region：化整为零" class="headerlink" title="13.7.6. 分区 Region：化整为零"></a>13.7.6. 分区 Region：化整为零</h3><p>使用 G1 收集器时，它将整个 Java 堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32MB 之间，且为 2 的 N 次幂，即 1MB，2MB，4MB，8MB，16MB，32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定。<mark>所有的 Region 大小相同，且在 JVM 生命周期内不会被改变。</mark></p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 <code>Region</code>（不需要连续）的集合。通过 Region 的动态分配方式实现逻辑上的连续。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608349.png" alt="image-20200713223244886"></p><p>一个 region 有可能属于 Eden，Survivor 或者 Old&#x2F;Tenured 内存区域。但是一个 region 只可能属于一个角色。图中的 E 表示该 region 属于 Eden 内存区域，S 表示属于 survivor 内存区域，O 表示属于 Old 内存区域。图中空白的表示未使用的内存空间。</p><p>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，<code>如果超过 1.5 个 region，就放到 H</code>。</p><p>设置 H 的原因：对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放大对象。<mark>如果一个 H 区装不下一个大对象，那么 G1 会寻找连续的 H 区来存储。</mark>为了能找到连续的 H 区，有时候不得不启动 Full GC。G1 的大多数行为都把 H 区作为老年代的一部分来看待。</p><p><font color=red>每个 Region 都是通过指针碰撞来分配空间</font></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608420.png" alt="image-20200713223509993"></p><h3 id="13-7-7-G1-垃圾回收器的回收过程【了解】"><a href="#13-7-7-G1-垃圾回收器的回收过程【了解】" class="headerlink" title="13.7.7. G1 垃圾回收器的回收过程【了解】"></a>13.7.7. G1 垃圾回收器的回收过程【了解】</h3><p>G1GC 的垃圾回收过程主要包括如下三个环节：</p><ul><li>年轻代 GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li></ul><blockquote><p>如果需要，单线程、独占式、高强度的 Full GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。类似于Serial Old GC对CMS的一种保底方案一样</p></blockquote><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608401.jpg" alt="第17章_G1-GC垃圾回收过程"></p><p>顺时针，Young gc -&gt; Young gc + Concurrent mark-&gt;Mixed GC 顺序，进行垃圾回收。</p><p>应用程序分配内存，<mark>当年轻代的 Eden 区用尽时开始年轻代回收过程</mark>；G1 的年轻代收集阶段是一个<mark>并行的独占式</mark>【STW】收集器。在年轻代回收期，G1GC 暂停所有应用程序线程，启动多线程执行年轻代回收。然后<mark>从年轻代区间移动存活对象到 Survivor 区间或者老年区间，也有可能是两个区间都会涉及</mark>。</p><p>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程。</p><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC 从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的 G1 回收器和其他 GC 不同，<mark>G1 的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的 Region 就可以了</mark>。同时，这个老年代 Region 是和年轻代一起被回收的。</p><p>举个例子：一个 Web 服务器，Java 进程最大堆内存为 4G，每分钟响应 1500 个请求，每 45 秒钟会新分配大约 2G 的内存。G1 会每 45 秒钟进行一次年轻代回收，每 31 个小时整个堆的使用率会达到 45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><h3 id="13-7-8-Remembered-Set"><a href="#13-7-8-Remembered-Set" class="headerlink" title="13.7.8. Remembered Set"></a>13.7.8. Remembered Set</h3><ul><li>一个对象被不同区域引用的问题</li><li>一个 Region 不可能是孤立的，一个 Region 中的对象可能被其他任意 Region 中对象引用，判断对象存活时，是否需要扫描整个 Java 堆才能保证准确？</li><li>在其他的分代收集器，也存在这样的问题（而 G1 更突出）</li><li>回收新生代也不得不同时扫描老年代？【因为老年代可能引用了新生代的某些对象】</li><li>这样的话会降低 MinorGC 的效率；</li></ul><p><strong>解决方法：</strong></p><p>无论 G1 还是其他分代收集器，JVM 都是使用 Remembered Set 来避免全局扫描：</p><p><mark>每个 Region 都有一个对应的 Remembered Set；</mark></p><p>每次 Reference 类型数据写操作时，都会产生一个 Write Barrier 暂时中断操作；</p><p>然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p><p>如果不同，通过 CardTable 把相关引用信息记录到引用指向对象的所在 Region 对应的 Remembered Set 中；</p><p>当进行垃圾收集时，在 GC 根节点的枚举范围加入 Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608721.png" alt="image-20200713224716715"></p><h3 id="13-7-9-G1-回收过程一：年轻代-GC"><a href="#13-7-9-G1-回收过程一：年轻代-GC" class="headerlink" title="13.7.9. G1 回收过程一：年轻代 GC"></a>13.7.9. G1 回收过程一：年轻代 GC</h3><p>JVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，&#x3D;&#x3D;当 Eden 空间耗尽时，G1 会启动一次年轻代垃圾回收过程&#x3D;&#x3D;。</p><p>年轻代垃圾回收只会回收 Eden 区和 Survivor 区。</p><p>首先 G1 停止应用程序的执行（Stop-The-World），G1 创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代 Eden 区和 Survivor 区所有的内存分段。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608890.png" alt="image-20200713225100632"></p><p>然后开始如下回收过程：</p><ol><li><p><mark>第一阶段，扫描根</mark>。根是指 static 变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象的入口。</p><blockquote><p>注意：年轻代是一定要有Rset的，年轻代的回收太频繁了。不适用Rset，每次都要判断老年代是否有引用指向新生代效率就太低了。反之，老年代回收不需要，因为老年代回收的时候，新生代也会进行回收</p></blockquote></li><li><p><mark>第二阶段，更新 RSet</mark>。处理 dirty card queue（见备注）中的 card，更新 RSet。此阶段完成后，<mark>RSet 可以准确的反映老年代对所在的内存分段中对象的引用</mark>。</p></li><li><p><mark>第三阶段，处理 RSet</mark>。识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。</p></li><li><p><mark>第四阶段，复制对象</mark>。此阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段，Survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加 1，达到阀值会被会被复制到 Old 区中空的内存分段。如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间。</p></li><li><p><mark>第五阶段，处理引用</mark>。处理 Soft，Weak，Phantom，Final，JNI Weak 等引用。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p></li></ol><h3 id="13-7-10-G1-回收过程二：并发标记过程"><a href="#13-7-10-G1-回收过程二：并发标记过程" class="headerlink" title="13.7.10. G1 回收过程二：并发标记过程"></a>13.7.10. G1 回收过程二：并发标记过程</h3><ol><li><mark>初始标记阶段</mark>：标记从根节点直接可达的对象。这个阶段是 STW 的，并且会触发一次年轻代 GC。</li><li><mark>根区域扫描（Root Region Scanning）</mark>：G1 GC 扫描 Survivor 区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 YoungGC 之前完成。</li><li><mark>并发标记（Concurrent Marking）</mark>：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 YoungGC 中断。在并发标记阶段，<mark>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</mark>。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li><mark>再次标记（Remark）</mark>：由于应用程序持续进行，需要修正上一次的标记结果。是 STW 的。G1 中采用了比 CMS 更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li><mark>独占清理（cleanup，STW）</mark>：计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是 STW 的。这个阶段并不会实际上去做垃圾的收集</li><li><mark>并发清理阶段</mark>：识别并清理完全空闲的区域。</li></ol><h3 id="13-7-11-G1-回收过程三：混合回收"><a href="#13-7-11-G1-回收过程三：混合回收" class="headerlink" title="13.7.11. G1 回收过程三：混合回收"></a>13.7.11. G1 回收过程三：混合回收</h3><p>当越来越多的对象晋升到老年代 o1d region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，该算法并不是一个 Old GC，除了回收整个 Young Region，还会回收一部分的 Old Region。这里需要注意：<mark>是一部分老年代，而不是全部老年代</mark>。可以选择哪些 Old Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC 并不是 Full GC。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608000.png" alt="image-20200713225810871"></p><p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分 8 次（可以通过<code>-XX:G1MixedGCCountTarget</code>设置）被回收</p><p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段，Survivor 区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p><p>由于老年代中的内存分段默认分 8 次回收，G1 会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为 65%，意思是垃圾占内存分段比例要达到 65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p><p>混合回收并不一定要进行 8 次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为 10%，意思是允许整个堆内存中有 10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于 10%，则不再进行混合回收。因为 GC 会花费很多的时间但是回收到的内存却很少。</p><h3 id="13-7-12-G1-回收可选的过程四：Full-GC"><a href="#13-7-12-G1-回收可选的过程四：Full-GC" class="headerlink" title="13.7.12. G1 回收可选的过程四：Full GC"></a>13.7.12. G1 回收可选的过程四：Full GC</h3><p>G1 的初衷就是要避免 Full GC 的出现。但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免 Full GC 的发生，一旦发生需要进行调整。什么时候会发生 Full GC 呢？比如<mark>堆内存太小</mark>，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回退到 Full GC，这种情况可以通过增大内存解决。</p><p>导致 G1 Full GC 的原因可能有两个：</p><ul><li>Evacuation 的时候没有足够的 to-space 来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ul><blockquote><p><strong>补充：</strong></p><p>从 Oracle 官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到 G1 只是回一部分 Region，停顿时间是用户可控制的，所以并不迫切去实现，而<mark>选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即 ZGC）中</mark>。另外，还考虑到 G1 不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p></blockquote><h3 id="13-7-13-G1-回收器优化建议"><a href="#13-7-13-G1-回收器优化建议" class="headerlink" title="13.7.13. G1 回收器优化建议"></a>13.7.13. G1 回收器优化建议</h3><p>年轻代大小</p><ul><li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li><li>固定年轻代的大小会覆盖暂停时间目标</li></ul><p>暂停时间目标不要太过严苛</p><ul><li>G1 GC 的吞吐量目标是 90%的应用程序时间和 10%的垃圾回收时间</li><li>评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul><h2 id="13-8-垃圾回收器总结"><a href="#13-8-垃圾回收器总结" class="headerlink" title="13.8. 垃圾回收器总结"></a>13.8. 垃圾回收器总结</h2><h3 id="13-8-1-7-种经典垃圾回收器总结"><a href="#13-8-1-7-种经典垃圾回收器总结" class="headerlink" title="13.8.1. 7 种经典垃圾回收器总结"></a>13.8.1. 7 种经典垃圾回收器总结</h3><p>截止 JDK1.8，一共有 7 款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><table><thead><tr><th align="left">垃圾收集器</th><th align="left">分类</th><th align="left">作用位置</th><th align="left">使用算法</th><th align="left">特点</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">Serial</td><td align="left">串行运行</td><td align="left">作用于新生代</td><td align="left">复制算法</td><td align="left">响应速度优先</td><td align="left">适用于单 CPU 环境下的 client 模式</td></tr><tr><td align="left">ParNew</td><td align="left">并行运行</td><td align="left">作用于新生代</td><td align="left">复制算法</td><td align="left">响应速度优先</td><td align="left">多 CPU 环境 Server 模式下与 CMS 配合使用</td></tr><tr><td align="left">Parallel</td><td align="left">并行运行</td><td align="left">作用于新生代</td><td align="left">复制算法</td><td align="left">吞吐量优先</td><td align="left">适用于后台运算而不需要太多交互的场景</td></tr><tr><td align="left">Serial Old</td><td align="left">串行运行</td><td align="left">作用于老年代</td><td align="left">标记-压缩算法</td><td align="left">响应速度优先</td><td align="left">适用于单 CPU 环境下的 Client 模式</td></tr><tr><td align="left">Parallel Old</td><td align="left">并行运行</td><td align="left">作用于老年代</td><td align="left">标记-压缩算法</td><td align="left">吞吐量优先</td><td align="left">适用于后台运算而不需要太多交互的场景</td></tr><tr><td align="left">CMS</td><td align="left">并发运行</td><td align="left">作用于老年代</td><td align="left">标记-清除算法</td><td align="left">响应速度优先</td><td align="left">适用于互联网或 B／S 业务</td></tr><tr><td align="left">G1</td><td align="left">并发、并行运行</td><td align="left">作用于新生代、老年代</td><td align="left">标记-压缩算法[整体]、复制算法[Regin]</td><td align="left">响应速度优先</td><td align="left">面向服务端应用</td></tr></tbody></table><p>GC 发展阶段：Serial &#x3D;&gt; Parallel（并行）&#x3D;&gt; CMS（并发）&#x3D;&gt; G1 &#x3D;&gt; ZGC</p><h3 id="13-8-2-垃圾回收器组合"><a href="#13-8-2-垃圾回收器组合" class="headerlink" title="13.8.2. 垃圾回收器组合"></a>13.8.2. 垃圾回收器组合</h3><p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot 虚拟机在 JDK7&#x2F;8 后所有收集器及组合如下图：（更新到了JDK14）</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608955.jpg" alt="第17章_垃圾收集器组合"></p><ol><li><p>两个收集器间有连线，表明它们可以搭配使用：Serial&#x2F;Serial Old、Serial&#x2F;CMS、ParNew&#x2F;Serial Old、ParNew&#x2F;CMS、Parallel Scavenge&#x2F;Serial Old、Parallel Scavenge&#x2F;Parallel Old、G1;</p></li><li><p>其中 Serial Old 作为 CMS 出现＂<code>Concurrent Mode Failure</code>＂失败的后备预案。</p></li><li><p>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial ＋ CMS、ParNew ＋ Serial old 这两个组合声明为 Deprecated（JEP 173），并在 JDK 9 中</p></li></ol><p>完全取消了这些组合的支持（JEP214），即：移除。</p><ol start="4"><li><p>（绿色虚线）JDK 14 中：弃用 ParallelScavenge 和 SeriaOold GC 组合(JEP 366)</p></li><li><p>（绿色虚框）JDK 14 中：删除 CMS 垃圾回收器（JEP 363）</p></li></ol><h3 id="13-8-3-怎么选择垃圾回收器"><a href="#13-8-3-怎么选择垃圾回收器" class="headerlink" title="13.8.3. 怎么选择垃圾回收器"></a>13.8.3. 怎么选择垃圾回收器</h3><p>Java 垃圾收集器的配置对于 JVM 优化来说是一个很重要的选择，选择合适的垃圾收集器可以让 JVM 的性能有一个很大的提升。</p><p>怎么选择垃圾收集器？</p><ol><li><p>优先调整堆的大小让 JVM 自适应完成。</p></li><li><p>如果内存小于 100M，使用串行收集器</p></li><li><p>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</p></li><li><p>如果是多 CPU、需要高吞吐量、允许停顿时间超过 1 秒，选择并行或者 JVM 自己选择</p></li><li><p>如果是多 CPU、追求低停顿时间，需快速响应（比如延迟不能超过 1 秒，如互联网应用），使用并发收集器</p><p>官方推荐 G1，性能高。<mark>现在互联网的项目，基本都是使用 G1</mark>。</p></li></ol><p>最后需要明确一个观点：</p><ol><li>没有最好的收集器，更没有万能的收集</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ol><p><strong>面试</strong></p><p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。 这里较通用、基础性的部分如下：</p><ul><li><p>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</p></li><li><p>垃圾收集器工作的基本流程。</p></li></ul><p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</p><h2 id="13-9-GC-日志分析"><a href="#13-9-GC-日志分析" class="headerlink" title="13.9. GC 日志分析"></a>13.9. GC 日志分析</h2><h3 id="13-9-1-参数设置"><a href="#13-9-1-参数设置" class="headerlink" title="13.9.1 参数设置"></a>13.9.1 参数设置</h3><p>通过阅读 GC 日志，我们可以了解 Java 虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表</p><ul><li><code>-XX:+PrintGC</code> 输出 GC 日志。类似：<code>-verbose:gc</code></li><li><code>-XX:+PrintGCDetails</code> 输出 GC 的详细日志</li><li><code>-XX:+PrintGCTimestamps</code> 输出 GC 的时间戳（以基准时间的形式）</li><li><code>-XX:+PrintGCDatestamps</code> 输出 GcC 的时间戳（以日期的形式，如 2013-05-04T21：53：59.234+0800）</li><li><code>-XX:+PrintHeapAtGC</code> 在进行 GC 的前后打印出堆的信息</li><li><code>-Xloggc:../logs/gc.log</code> 日志文件的输出路径</li></ul><p><strong><font color=orange>① -verbose:gc</font></strong></p><p>这个只会显示总的 GC 堆的变化，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) 80832K-&gt;19298K(228840K),<span class="number">0.0084018</span> secs]</span><br><span class="line">[GC (Metadata GC Threshold) 109499K-&gt;21465K(228352K),<span class="number">0.0184066</span> secs]</span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span> 21465K-&gt;16716K(201728K),<span class="number">0.0619261</span> secs]</span><br></pre></td></tr></table></figure><p>参数解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GC、Full GC：GC的类型。GC只在新生代上进行，Full GC包括永生代，新生代，老年代。</span><br><span class="line">Allocation Failure：GC发生的原因。</span><br><span class="line">80832K-&gt;19298K：堆在GC前的大小和GC后的大小。</span><br><span class="line">228840k：现在的堆大小。</span><br><span class="line"><span class="number">0.0084018</span> secs：GC持续的时间。</span><br></pre></td></tr></table></figure><p><strong><font color=orange>② -verbose:gc -XX:+PrintGCDetails</font></strong></p><p>输入信息如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen:70640K-&gt;10116K(141312K)] 80541K-&gt;20017K(227328K),<span class="number">0.0172573</span> secs] [Times:user=<span class="number">0.03</span> sys=<span class="number">0.00</span>,real=<span class="number">0.02</span> secs]</span><br><span class="line">[GC (Metadata GC Threshold) [PSYoungGen:98859K-&gt;8154K(142336K)] 108760K-&gt;21261K(228352K),<span class="number">0.0151573</span> secs] [Times:user=<span class="number">0.00</span> sys=<span class="number">0.01</span>,real=<span class="number">0.02</span> secs]</span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span>[PSYoungGen:8154K-&gt;0K(142336K)]</span><br><span class="line">[ParOldGen:13107K-&gt;16809K(62464K)] 21261K-&gt;16809K(204800K),[Metaspace:20599K-&gt;20599K(1067008K)],<span class="number">0.0639732</span> secs]</span><br><span class="line">[Times:user=<span class="number">0.14</span> sys=<span class="number">0.00</span>,real=<span class="number">0.06</span> secs]</span><br></pre></td></tr></table></figure><p>参数解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GC，Full FC：同样是GC的类型</span><br><span class="line">Allocation Failure：GC原因</span><br><span class="line">PSYoungGen：使用了Parallel Scavenge并行垃圾收集器的新生代GC前后大小的变化</span><br><span class="line">ParOldGen：使用了Parallel Old并行垃圾收集器的老年代GC前后大小的变化</span><br><span class="line">Metaspace： 元数据区GC前后大小的变化，JDK1<span class="number">.8</span>中引入了元数据区以替代永久代</span><br><span class="line">xxx secs：指GC花费的时间</span><br><span class="line">Times：user：指的是垃圾收集器花费的所有CPU时间，sys：花费在等待系统调用或系统事件的时间，real：GC从开始到结束的时间，包括其他进程占用时间片的实际时间。</span><br></pre></td></tr></table></figure><p><strong><font color=orange>③ -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimestamps -XX:+PrintGCDatestamps</font></strong></p><p>输入信息如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-09-24T22:<span class="number">15</span>:<span class="number">24.518</span>+0800: <span class="number">3.287</span>: [GC (Allocation Failure) [PSYoungGen:136162K-&gt;5113K(136192K)] 141425K-&gt;17632K(222208K),<span class="number">0.0248249</span> secs] [Times:user=<span class="number">0.05</span> sys=<span class="number">0.00</span>,real=<span class="number">0.03</span> secs]</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span>-09-24T22:<span class="number">15</span>:<span class="number">25.559</span>+0800: <span class="number">4.329</span>: [GC (Metadata GC Threshold) [PSYoungGen:97578K-&gt;10068K(274944K)] 110096K-&gt;22658K(360960K),<span class="number">0.0094071</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>,real=<span class="number">0.01</span> secs]</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span>-09-24T22:<span class="number">15</span>:<span class="number">25.569</span>+0800: <span class="number">4.338</span>: [Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span> [PSYoungGen:10068K-&gt;0K(274944K)][ParoldGen:12590K-&gt;13564K(56320K)] 22658K-&gt;13564K(331264K),[Metaspace:20590K-&gt;20590K(1067008K)],<span class="number">0.0494875</span> secs] [Times: user=<span class="number">0.17</span> sys=<span class="number">0.02</span>,real=<span class="number">0.05</span> secs]</span><br></pre></td></tr></table></figure><p>说明：带上了日期和实践</p><blockquote><p>如果想把 GC 日志存到文件的话，是下面的参数：<code>-Xloggc:/path/to/gc.log</code></p></blockquote><p><strong>日志补充说明</strong></p><ul><li><p>“<code>[GC</code>“和”<code>[Full GC</code>“说明了这次垃圾收集的停顿类型，如果有”Full”则说明 GC 发生了”Stop The World”</p></li><li><p>使用 Serial 收集器在新生代的名字是 Default New Generation，因此显示的是”<code>[DefNew</code>“</p></li><li><p>使用 ParNew 收集器在新生代的名字会变成”<code>[ParNew</code>“，意思是”Parallel New Generation”</p></li><li><p>使用 Parallel scavenge 收集器在新生代的名字是”<code>[PSYoungGen</code>“</p></li><li><p>老年代的收集和新生代道理一样，名字也是收集器决定的</p></li><li><p>使用 G1 收集器的话，会显示为”garbage-first heap”</p></li><li><p><mark>Allocation Failure</mark> 表明本次引起 GC 的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p></li><li><p><mark>[PSYoungGen：5986K-&gt;696K(8704K) ] 5986K-&gt;704K(9216K)</mark></p><p>中括号内：GC 回收前年轻代大小，回收后大小，（年轻代总大小）</p><p>括号外：GC 回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p></li><li><p><mark>user 代表用户态回收耗时，sys 内核态回收耗时，rea 实际耗时</mark>。由于多核的原因，时间总和可能会超过 real 时间</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Heap（堆）</span><br><span class="line">PSYoungGen（Parallel Scavenge收集器新生代）total 9216K，used 6234K [<span class="number">0x00000000ff600000</span>,<span class="number">0x0000000100000000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">eden space（堆中的Eden区默认占比是<span class="number">8</span>）8192K，<span class="number">768</span> used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffc16b08</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">from space（堆中的Survivor，这里是From Survivor区默认占比是<span class="number">1</span>）1024K， <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">to space（堆中的Survivor，这里是to Survivor区默认占比是<span class="number">1</span>，需要先了解一下堆的分配策略）1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line"></span><br><span class="line">ParOldGen（老年代总大小和使用大小）total 10240K， used 7001K ［<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line">object space（显示个使用百分比）10240K，<span class="number">688</span> used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff2d6630</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"></span><br><span class="line">PSPermGen（永久代总大小和使用大小）total 21504K， used 4949K [<span class="number">0x00000000f9a00000</span>,<span class="number">0x00000000faf00000</span>,<span class="number">0x00000000fec00000</span>)</span><br><span class="line">object space（显示个使用百分比，自己能算出来）21504K， <span class="number">238</span> used [<span class="number">0x00000000f9a00000</span>,<span class="number">0x00000000f9ed55e0</span>,<span class="number">0x00000000faf00000</span>)</span><br></pre></td></tr></table></figure><h3 id="13-9-2-Minor-GC-日志图解"><a href="#13-9-2-Minor-GC-日志图解" class="headerlink" title="13.9.2 Minor GC 日志图解"></a>13.9.2 Minor GC 日志图解</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608098.png" alt="image-20200714082555688"></p><h3 id="13-9-3-Full-GC-日志图解"><a href="#13-9-3-Full-GC-日志图解" class="headerlink" title="13.9.3 Full GC 日志图解"></a>13.9.3 Full GC 日志图解</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608198.png" alt="image-20210512194815354"></p><h3 id="13-9-4-日志分析工具的使用"><a href="#13-9-4-日志分析工具的使用" class="headerlink" title="13.9.4 日志分析工具的使用"></a>13.9.4 日志分析工具的使用</h3><p>在生产开发中，我们也可以用一些工具去分析这些 GC 日志</p><p>常用的日志分析工具有：<a href="https://sourceforge.net/projects/gcviewer/">GCViewer</a>、<a href="https://gceasy.io/">GCEasy</a>、GCHisto、GCLogViewer、Hpjmeter、garbagecat 等</p><p>只需要在JVM参数中加入<code>  -Xloggc:./logs/gc.log</code>，控制台的一些日志就会输出到日志中</p><ul><li>GCViewer界面</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608509.png" alt="image-20230304160528881"></p><ul><li>GCEasy：**<font color=red>☆☆☆☆☆</font>**</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608553.png" alt="image-20230304162020051"><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608592.png" alt="image-20230304162121922"></p><h2 id="13-X-垃圾回收器的新发展"><a href="#13-X-垃圾回收器的新发展" class="headerlink" title="13.X. 垃圾回收器的新发展"></a>13.X. 垃圾回收器的新发展</h2><p>GC 仍然处于飞速发展之中，目前的默认选项<mark>G1 GC 在不断的进行改进</mark>，很多我们原来认为的缺点，例如串行的 Fu11GC、Card Table 扫描的低效等，都已经被大幅改进，例如，JDK10 以后，Fu11GC 已经是并行运行，在很多场景下，其表现还略优于 ParallelGC 的并行 Ful1GC 实现。</p><p>即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<mark>在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台</mark>。</p><p>比较不幸的是 CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在 JDK9 中已经被标记为废弃，并在 JDK14 版本中移除</p><h3 id="13-X-1-JDK11-新特性"><a href="#13-X-1-JDK11-新特性" class="headerlink" title="13.X.1. JDK11 新特性"></a>13.X.1. JDK11 新特性</h3><p>Epsilon:A No-Op GarbageCollector（Epsilon 垃圾回收器，”No-Op（无操作）”回收器）<a href="http://openidk.iava.net/jeps/318">http://openidk.iava.net/jeps/318</a></p><p>ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）<a href="http://openidk.iava.net/jeps/318">http://openidk.iava.net/jeps/333</a></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608962.png" alt="image-20210512195426194"></p><p>现在 G1 回收器已成为默认回收器好几年了。</p><p>我们还看到了引入了两个新的收集器：ZGC（JDK11 出现）和 Shenandoah（Open JDK12）。主打特点：低停顿时间</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608898.png" alt="image-20210512195528695"></p><h3 id="13-X-2-Open-JDK12-的-Shenandoash-GC"><a href="#13-X-2-Open-JDK12-的-Shenandoash-GC" class="headerlink" title="13.X.2. Open JDK12 的 Shenandoash GC"></a>13.X.2. Open JDK12 的 Shenandoash GC</h3><p><mark>Open JDK12 的 Shenandoash GC：低停顿时间的 GC（实验性）</mark></p><p><mark>Shenandoah，无疑是众多 GC 中最孤独的一个。</mark>是第一款不由 oracle 公司团队领导开发的 Hotspot 垃圾收集器。不可避免的<mark>受到官方的排挤</mark>。比如号称 OpenJDK 和 OracleJDK 没有区别的 Oracle 公司仍拒绝在 OracleJDK12 中支持 Shenandoah。</p><p>Shenandoah 垃圾回收器最初由 RedHat 进行的一项垃圾收集器研究项目 Pauseless GC 的实现，<mark>旨在针对 JVM 上的内存回收实现低停顿的需求</mark>.。在 2014 年贡献给 OpenJDK。</p><p>Red Hat 研发 Shenandoah 团队对外宣称，<mark>Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。</mark>不过实际使用性能将取决于实际工作堆的大小和工作负载。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608261.png" alt="image-20200714090608807"></p><p>这是 RedHat 在 2016 年发表的论文数据，测试内容是使用 Es 对 200GB 的维基百科数据进行索引。从结果看：</p><ul><li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li><li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li></ul><p>总结</p><ul><li>Shenandoah GC 的弱项：高运行负担下的吞吐量下降。</li><li>Shenandoah GC 的强项：低延迟时间。</li><li>Shenandoah GC 的工作过程大致分为九个阶段，这里就不再赘述。在之前 Java12 新特性视频里有过介绍。</li></ul><p>【Java12 新特性地址】</p><p><a href="http://www.atguigu.com/download_detail.shtml?v=222">http://www.atguigu.com/download_detail.shtml?v&#x3D;222</a></p><p>或</p><p><a href="https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&seid=12339069673726242866">https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&seid=12339069673726242866</a></p><h3 id="13-X-3-令人震惊、革命性的-ZGC"><a href="#13-X-3-令人震惊、革命性的-ZGC" class="headerlink" title="13.X.3. 令人震惊、革命性的 ZGC"></a>13.X.3. 令人震惊、革命性的 ZGC</h3><p>官方地址：<a href="https://docs.oracle.com/en/java/javase/12/gctuning/">https://docs.oracle.com/en/java/javase/12/gctuning/</a></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608314.png" alt="image-20210512200236647"></p><p>ZGC 与 Shenandoah 目标高度相似，<mark>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</mark></p><p>《深入理解 Java 虚拟机》一书中这样定义 ZGC：ZGC 收集器是一款基于 Region 内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现<mark>可并发的标记-压缩算法</mark>的，以<mark>低延迟为首要目标</mark>的一款垃圾收集器。</p><p>ZGC 的工作过程可以分为 4 个阶段：<mark>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</mark> 等。</p><p>ZGC 几乎在所有地方并发执行的，除了初始标记的是 STw 的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p><p>测试数据：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608346.png" alt="image-20200714091201073"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608374.png" alt="image-20200714091401511"></p><p>在 ZGC 的强项停顿时间测试上，它毫不留情的将 Parallel、G1 拉开了两个数量级的差距。无论平均停顿、95％停顿、99％停顿、99.9％停顿，还是最大停顿时间，ZGC 都能毫不费劲控制在 10 毫秒以内。</p><p>虽然 ZGC 还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。 <mark>未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</mark></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608800.png" alt="image-20200714093243028"></p><p><mark>JEP 364：ZGC 应用在 macos 上</mark></p><p><mark>JEP 365：ZGC 应用在 Windows 上</mark></p><p>JDK14 之前，ZGC 仅 Linux 才支持。</p><p>尽管许多使用 zGc 的用户都使用类 Linux 的环境，但在 Windows 和 macos 上，人们也需要 ZGC 进行开发部署和测试。许多桌面应用也可以从 ZGC 中受益。因此，ZGC 特性被移植到了 Windows 和 macos 上。</p><p>现在 mac 或 Windows 上也能使用 zGC 了，示例如下：<code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</code></p><h3 id="13-X-4-其他垃圾回收器：AliGC"><a href="#13-X-4-其他垃圾回收器：AliGC" class="headerlink" title="13.X.4. 其他垃圾回收器：AliGC"></a>13.X.4. 其他垃圾回收器：AliGC</h3><p>AliGC 是阿里巴巴 JVM 团队基于 G1 算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202303061608892.png" alt="image-20200714093604012"></p><p>当然，其它厂商也提供了各种别具一格的 GC 实现，例如比较有名的低延迟 GC：Zing，有兴趣可以参考提供的链接 <a href="https://www.infoq.com/articles/azul_gc_in_detail">https://www.infoq.com/articles/azul_gc_in_detail</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十二、垃圾回收相关概念</title>
      <link href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC12%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC12%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="12-垃圾回收相关概念"><a href="#12-垃圾回收相关概念" class="headerlink" title="12. 垃圾回收相关概念"></a>12. 垃圾回收相关概念</h1><h2 id="12-1-System-gc-的理解"><a href="#12-1-System-gc-的理解" class="headerlink" title="12.1. System.gc()的理解"></a>12.1. System.gc()的理解</h2><p>在默认情况下，通过 system.gc()或者 Runtime.getRuntime().gc() 的调用，<mark>会显式触发 Full GC</mark>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p>然而 System.gc() 调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)</p><p>JVM 实现者可以通过 System.gc() 调用来决定 JVM 的 GC 行为。而一般情况下，垃圾回收应该是自动进行的，<mark>无须手动触发，否则就太过于麻烦了</mark>。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用 System.gc()</p><p><strong>案例一：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemGCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemGCTest</span>();</span><br><span class="line">        System.gc();<span class="comment">// 提醒JVM的垃圾回收器执行gc，但是不确定是否马上执行gc</span></span><br><span class="line">        <span class="comment">// 与Runtime.getRuntime().gc();的作用一样</span></span><br><span class="line"></span><br><span class="line">        System.runFinalization();<span class="comment">//强制执行失去引用的对象的finalize()方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;SystemGCTest 重写了finalize()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例二：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  14:57</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> *理解不可达对象的回收行为</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：为啥FullGC之前执行一次YoungGC呢？</span></span><br><span class="line"><span class="comment"> *      是为了减少FullGC时要扫描的对象，提升效率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVarGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//没有被回收，而是经过GC和Full GC，从新生代-&gt;老年代</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        buffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();<span class="comment">// 回收时，buffer对象已经没有引用指向了，所以可以被回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC3</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//局部变量表的位置是2,0：this，1:buffer，所以不会被回收。</span></span><br><span class="line">        <span class="comment">// 虽然已经出了buffer的作用范围，变量表1如果这个时候有其他变量递定义肯定会被复用，但是由于没有新的变量定义</span></span><br><span class="line">        <span class="comment">// 1位置实际上存的还是buffer这个引用的地址~</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC4</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 局部变量表的大小是2,0:this，1:value，buffer对象已经没有引用指向了，所以可以被回收。</span></span><br><span class="line">        <span class="comment">// 中间涉及到Slot的复用。1:buffer 被覆盖橙 1:value 所以GC3和GC4的局部变量表一样大~</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC5</span><span class="params">()</span> &#123;</span><br><span class="line">        localvarGC1();</span><br><span class="line">        System.gc();<span class="comment">//方法1对应的栈帧弹出栈了，变量销毁了，堆里的对象没有引用，就可以被回收了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVarGC</span> <span class="variable">local</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVarGC</span>();</span><br><span class="line">        local.localvarGC5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-2-内存溢出与内存泄露"><a href="#12-2-内存溢出与内存泄露" class="headerlink" title="12.2. 内存溢出与内存泄露"></a>12.2. 内存溢出与内存泄露</h2><h3 id="内存溢出（OOM）"><a href="#内存溢出（OOM）" class="headerlink" title="内存溢出（OOM）"></a>内存溢出（OOM）</h3><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p><p>由于 GC 一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现 OOM 的情况。</p><p>大多数情况下，GC 会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的 Full GC 操作，这时候会回收大量的内存，供应用程序继续使用。</p><p>javadoc 中对 OutOfMemoryError 的解释是，<mark>没有空闲内存，并且垃圾收集器[经过GC]也无法提供更多内存</mark>。</p><p>首先说没有空闲内存的情况：说明 Java 虚拟机的堆内存不够。原因有二：</p><ol><li><p><mark>Java 虚拟机的堆内存设置不够。</mark></p><p>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定 JVM 堆大小或者指定数值偏小。我们可以通过参数<code>-Xms</code> 、<code>-Xmx</code>来调整。</p></li><li><p><mark>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</mark></p><p>对于老版本的 Oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：“<code>java.lang.OutOfMemoryError: PermGen space</code>“。</p><p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 OOM 有所改观，出现 OOM，异常信息则变成了：“<code>java.lang.OutofMemoryError:Metaspace</code>“。直接内存不足，也会导致 OOM。</p></li></ol><p>这里面隐含着一层意思是，在抛出 OutOfMemoryError 之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p><ul><li>例如：在引用机制分析中，涉及到 JVM 会去尝试回收软引用指向的对象等。</li><li>在<code>java.nio.BIts.reserveMemory()</code>方法中，我们能清楚的看到，<code>System.gc()</code>会被调用，以清理空间。</li></ul><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p><ul><li>比如，我们去分配一个超大对象，类似一个<code>超大数组超过堆的最大值</code>，JVM 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 OutOfMemoryError。</li></ul><h3 id="内存泄漏（Memory-Leak）"><a href="#内存泄漏（Memory-Leak）" class="headerlink" title="内存泄漏（Memory Leak）"></a>内存泄漏（Memory Leak）</h3><p>也称作“存储渗漏”。严格来说，<mark>只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏</mark>。</p><p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致 OOM，也可以叫做<mark>宽泛意义上的“内存泄漏”</mark>。</p><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 OutOfMemory 异常，导致程序崩溃。</p><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/68967cdd14772a749efdb7485950aaa6.png" alt="image-20200712195158470"></p><p><strong>举例</strong></p><ol><li><p>单例模式</p><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p></li><li><p>一些提供 close 的资源未关闭导致内存泄漏</p><p>数据库连接（dataSourse.getConnection() ），网络连接（socket）和 io 连接必须手动 close，否则是不能被回收的。</p></li></ol><h2 id="12-3-Stop-The-World"><a href="#12-3-Stop-The-World" class="headerlink" title="12.3. Stop The World"></a>12.3. Stop The World</h2><p>Stop-the-World，简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。<mark>停顿产生时整个应用程序线程都会被暂停，没有任何响应</mark>，有点像卡死的感觉，这个停顿称为 STW。</p><p>可达性分析算法中枚举根节点（GC Roots）会导致所有 Java 执行线程停顿。</p><ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li><mark>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</mark></li></ul><p>被 STW 中断的应用程序线程会在完成 GC 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少 STW 的发生。</p><p><font color=red>STW 事件和采用哪款 GC 无关，所有的 GC 都有这个事件</font>。</p><p>哪怕是 G1 也不能完全避免 Stop-the-World 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p><p>STW 是 JVM 在<mark>后台自动发起和自动完成</mark>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p><p><font color=red>开发中不要用 System.gc() 会导致 Stop-the-World 的发生。</font></p><h2 id="12-4-垃圾回收的并行与并发"><a href="#12-4-垃圾回收的并行与并发" class="headerlink" title="12.4. 垃圾回收的并行与并发"></a>12.4. 垃圾回收的并行与并发</h2><h3 id="程序中的并行与并发"><a href="#程序中的并行与并发" class="headerlink" title="程序中的并行与并发"></a>程序中的并行与并发</h3><h4 id="并发（Concurrent）"><a href="#并发（Concurrent）" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h4><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p><p>并发不是真正意义上的“同时进行”，只是 CPU 把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于 CPU 处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5e4a10263a26cb7aa87f1a6615b5b833.png" alt="image-20200712202522051"></p><h4 id="并行（Parallel）"><a href="#并行（Parallel）" class="headerlink" title="并行（Parallel）"></a>并行（Parallel）</h4><p>当系统有一个以上 CPU 时，当一个 CPU 执行一个进程时，另一个 CPU 可以执行另一个进程，两个进程互不抢占 CPU 资源，可以同时进行，我们称之为并行（Parallel）。</p><p>其实决定并行的因素不是 CPU 的数量，而是 CPU 的核心数量，比如一个 CPU 多个核也可以并行。</p><p>适合科学计算，后台处理等弱交互场景</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7ea1ebdd0fd0bc3a27c0d745c9bcdff7.png" alt="image-20200712202822129"></p><h4 id="并发-vs-并行"><a href="#并发-vs-并行" class="headerlink" title="并发 vs 并行"></a>并发 vs 并行</h4><ul><li><p>并发，指的是多个事情，在<mark>同一时间段内</mark>同时发生了。</p></li><li><p>并行，指的是多个事情，在<mark>同一时间点上</mark>同时发生了。</p></li><li><p>并发的多个任务之间是互相抢占资源的。</p></li><li><p>并行的多个任务之间是不互相抢占资源的。</p></li><li><p>只有在多 CPU 或者一个 CPU 多核的情况中，才会发生并行。</p></li><li><p>否则，看似同时发生的事情，其实都是并发执行的。</p></li></ul><h3 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h3><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><h4 id="并行（Parallel）-1"><a href="#并行（Parallel）-1" class="headerlink" title="并行（Parallel）"></a>并行（Parallel）</h4><p>指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如 ParNew、Parallel Scavenge、Parallel Old；</p><h4 id="串行（Serial）"><a href="#串行（Serial）" class="headerlink" title="串行（Serial）"></a>串行（Serial）</h4><p>相较于并行的概念，单线程执行。如果内存不够，则程序暂停，启动 JM 垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fd2b4f4ece3976fbd73c1039666cf7d7.png" alt="image-20210512112822896"></p><h4 id="并发（Concurrent）-1"><a href="#并发（Concurrent）-1" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h4><p>指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。用户程序在继续运行，而垃圾收集程序线程运行于另一个 CPU 上；如：CMS、G1</p><p><img src="https://img-blog.csdnimg.cn/img_convert/48a4190f4d2ff4b7c8963a75ba2e6182.png" alt="image-20200712203815517"></p><h2 id="12-5-安全点与安全区域"><a href="#12-5-安全点与安全区域" class="headerlink" title="12.5. 安全点与安全区域"></a>12.5. 安全点与安全区域</h2><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>程序执行时并非在所有地方都能停顿下来开始 GC，只有在特定的位置才能停顿下来开始 GC，这些位置称为“安全点（Safepoint）”。</p><p>Safe Point 的选择很重要，<mark>如果太少可能导致 GC 等待的时间太长[从而可能出现OOM]，如果太频繁可能导致运行时的性能问题</mark>。大部分指令的执行时间都非常短暂，通常会根据“<mark>是否具有让程序长时间执行的特征</mark>”为标准。比如：选择一些执行时间较长的指令作为 Safe Point，如<mark>方法调用、循环跳转和异常跳转等</mark>。</p><p>如何在 GC 发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p><p><strong>抢先式中断：（目前没有虚拟机采用了）</strong></p><ul><li>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li></ul><p><strong>主动式中断</strong></p><ul><li>设置一个中断标志，各个线程运行到 Safe Point 的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</li></ul><h3 id="安全区域（Safe-Resion）"><a href="#安全区域（Safe-Resion）" class="headerlink" title="安全区域（Safe Resion）"></a>安全区域（Safe Resion）</h3><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint。但是，程序“不执行”的时候呢？例如线程处于 Sleep 状态或 Blocked 状态，这时候线程无法响应 JVM 的中断请求，“走”到安全点去中断挂起，JVM 也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p><p><mark>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 GC 都是安全的。</mark>我们也可以把 Safe Region 看做是被扩展了的 Safepoint。</p><p><strong>实际执行时：</strong></p><ol><li>当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Relgion，如果这段时间内发生 GC，JVM 会忽略标识为 Safe Region 状态的线程</li><li>当线程即将离开 Safe Region 时，会检查 JVM 是否已经完成 GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开 Safe Region 的信号为止；</li></ol><h2 id="12-6-引用概述"><a href="#12-6-引用概述" class="headerlink" title="12.6. 引用概述"></a>12.6. 引用概述</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p><p>【既<mark>偏门</mark>又非常<mark>高频</mark>的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</p><p>在 JDK1.2 版之后，Java 对引用的概念进行了扩充，将引用分为：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）这 4 种引用强度依次逐渐减弱。</p><p>除强引用外，其他 3 种引用均可以在 java.lang.ref 包中找到它们的身影。如下图，显示了这 3 种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p><p>.<img src="https://img-blog.csdnimg.cn/img_convert/1ef8adfbf9082acacc9db47ae48f5b47.png" alt="image-20200712205813321"></p><p>Reference 子类中只有终结器引用是包内可见的，其他 3 种引用类型均为 public，可以在应用程序中直接使用</p><ul><li><mark>强引用（StrongReference）</mark>：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>Object obj = new Object()</code>”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。【死也不回收】</li><li><mark>软引用（SoftReference）</mark>：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。【内存不足就回收】</li><li><mark>弱引用（WeakReference）</mark>：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。【发现即回收】</li><li><mark>虚引用（PhantomReference）</mark>：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。<font color=red>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</font></li></ul><h2 id="12-7-再谈引用：强引用"><a href="#12-7-再谈引用：强引用" class="headerlink" title="12.7 再谈引用：强引用"></a>12.7 再谈引用：强引用</h2><p>在 Java 程序中，最常见的引用类型是强引用（<mark>普通系统 99%以上都是强引用</mark>），也就是我们最常见的普通对象引用，<mark>也是默认的引用类型</mark>。</p><p>当在 Java 语言中使用 new 操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p><p><mark>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</mark></p><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 nu11，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p><p>相对的，&#x3D;&#x3D;软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的&#x3D;&#x3D;，在一定条件下，都是可以被回收的。所以，<mark>强引用是造成 Java 内存泄漏的主要原因之一</mark>。</p><p><strong>强引用例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello mogublog&quot;</span>);</span><br></pre></td></tr></table></figure><p>局部变量 str 指向 StringBuffer 实例所在堆空间，通过 str 可以操作该实例，那么 str 就是 StringBuffer 实例的强引用</p><p><strong>对应内存结构</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/34ad0a72d2fce1fd6c06b5965c354712.png" alt="image-20200712211501377"></p><p>此时，如果再运行一个赋值语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str1</span> <span class="operator">=</span> str;</span><br></pre></td></tr></table></figure><p><strong>对应的内存结构</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/baf5d789fc28868dfb983adc7265461c.png" alt="image-20200712211732976"></p><p>本例中的两个引用，都是强引用，强引用具备以下特点：</p><ul><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象。</li><li>强引用可能导致内存泄漏。</li></ul><h2 id="12-8-再谈引用：软引用"><a href="#12-8-再谈引用：软引用" class="headerlink" title="12.8. 再谈引用：软引用"></a>12.8. 再谈引用：软引用</h2><blockquote><p>软引用（Soft Reference）——内存不足即回收</p></blockquote><p>软引用是用来描述一些还有用，但非必需的对象。<mark>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收</mark>，【第一次回收是不可达对象的回收，强引用的回收】如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><p>软引用通常用来实现内存敏感的缓存。比如：<mark>高速缓存</mark>就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。【Mybatis中的内部类就使用了软引用】</p><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p><p>类似弱引用，只不过 Java 虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p><p>在 JDK1.2 版之后提供了 java.lang.ref.SoftReference 类来实现软引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure><p>测试案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 软引用的测试：内存不足即回收</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  16:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象，建立软引用</span></span><br><span class="line"><span class="comment">//        SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(new User(1, &quot;songhk&quot;));</span></span><br><span class="line">        <span class="comment">//上面的一行代码，等价于如下的三行代码</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;songhk&quot;</span>);</span><br><span class="line">        SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;User&gt;(u1);</span><br><span class="line">        u1 = <span class="literal">null</span>;<span class="comment">//取消强引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从软引用中重新获得强引用对象</span></span><br><span class="line">        System.out.println(userSoftRef.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;After GC:&quot;</span>);</span><br><span class="line"><span class="comment">//        //垃圾回收之后获得软引用中的对象</span></span><br><span class="line">        System.out.println(userSoftRef.get());<span class="comment">//由于堆空间内存足够，所有不会回收软引用的可达对象。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//让系统认为内存资源紧张[内存可以容得下数组，但是再加上软引用就不够了]、不够</span></span><br><span class="line"><span class="comment">//            byte[] b = new byte[1024 * 1024 * 7];</span></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">7168</span> - <span class="number">635</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//再次从软引用中获取数据</span></span><br><span class="line">            System.out.println(userSoftRef.get());<span class="comment">//在报OOM之前，垃圾回收器会回收软引用的可达对象。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-9-再谈引用：弱引用"><a href="#12-9-再谈引用：弱引用" class="headerlink" title="12.9. 再谈引用：弱引用"></a>12.9. 再谈引用：弱引用</h2><blockquote><p>弱引用（Weak Reference）——发现即回收</p></blockquote><p>弱引用也是用来描述那些非必需对象，<mark>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止</mark>。在系统 GC 时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，<mark>弱引用对象可以存在较长的时间</mark>。</p><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p><p><mark>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</mark>。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p><p>在 JDK1.2 版之后提供了 WeakReference 类来实现弱引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 声明强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure><p><mark>弱引用对象与软引用对象的最大不同</mark>就在于，当 GC 在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC 总是进行回收。<mark>弱引用对象更容易、更快被 GC 回收</mark>。</p><p><strong>面试题：你开发中使用过 WeakHashMap 吗？</strong></p><p>WeakHashMap 用来存储图片信息，可以在内存不足的时候，及时回收，避免了 OOM</p><p>测试案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 弱引用的测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  16:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构造了弱引用</span></span><br><span class="line">        WeakReference&lt;User&gt; userWeakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;User&gt;(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;songhk&quot;</span>));</span><br><span class="line">        <span class="comment">//从弱引用中重新获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 不管当前内存空间足够与否，都会回收它的内存</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After GC:&quot;</span>);</span><br><span class="line">        <span class="comment">//重新尝试从弱引用中获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span>id=<span class="number">1</span><span class="punctuation">,</span> name=songhk<span class="punctuation">]</span> </span><br><span class="line">After GC<span class="punctuation">:</span></span><br><span class="line"><span class="literal"><span class="keyword">null</span></span></span><br></pre></td></tr></table></figure><h2 id="12-X-再谈引用：虚引用"><a href="#12-X-再谈引用：虚引用" class="headerlink" title="12.X. 再谈引用：虚引用"></a>12.X. 再谈引用：虚引用</h2><blockquote><p>虚引用（Phantom Reference）——对象回收跟踪</p></blockquote><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中<code>最弱</code>的一个。</p><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的 get()方法取得对象时，总是 null</p><p><mark>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</mark></p><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p><p><mark>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</mark></p><p>在 JDK1.2 版之后提供了 PhantomReference 类来实现虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 声明强引用</span></span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">phantomQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>测试案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚引用的测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  16:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj;<span class="comment">//当前类对象的声明</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="literal">null</span>;<span class="comment">//引用队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="literal">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; <span class="comment">//finalize()方法只能被调用一次！</span></span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类的finalize()方法&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckRefQueue</span>();</span><br><span class="line">        <span class="comment">// t.setDaemon(true);//设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;PhantomReferenceTest&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">PhantomReferenceTest</span>();<span class="comment">//obj和对象是虚引用</span></span><br><span class="line">        <span class="comment">//构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;PhantomReferenceTest&gt;(obj, phantomQueue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//不可获取虚引用中的对象</span></span><br><span class="line">            System.out.println(phantomRef.get());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将强引用去除</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//第一次进行GC,由于对象可复活，GC无法回收该对象</span></span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第 2 次 gc&quot;</span>);</span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc(); <span class="comment">//一旦将obj对象回收，就会将此虚引用存放到引用队列中。【此时相当于堆中的对象已经GC了，放入队列的是引用哦】</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal"><span class="keyword">null</span></span></span><br><span class="line">调用当前类的finalize()方法</span><br><span class="line">obj 可用</span><br><span class="line">第 <span class="number">2</span> 次 gc</span><br><span class="line">追踪垃圾回收过程：PhantomReferenceTest实例被GC了</span><br><span class="line">obj 是 <span class="literal"><span class="keyword">null</span></span></span><br></pre></td></tr></table></figure><h2 id="12-11-终结器引用"><a href="#12-11-终结器引用" class="headerlink" title="12.11. 终结器引用"></a>12.11. 终结器引用</h2><p>它用于实现对象的 finalize() 方法，也可以称为终结器引用。无需手动编码，其内部配合引用队列使用。</p><p>在 GC 时，终结器引用入队。由 Finalizer 线程通过终结器引用找到被引用对象调用它的 finalize()方法，第二次 GC 时才回收被引用的对象</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十一、垃圾回收相关算法</title>
      <link href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC11%E7%AB%A0_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
      <url>/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC11%E7%AB%A0_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="12-垃圾回收相关算法"><a href="#12-垃圾回收相关算法" class="headerlink" title="12. 垃圾回收相关算法"></a>12. 垃圾回收相关算法</h1><p><strong>对象存活判断</strong></p><p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先<mark>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</mark>。只有被标记为己经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<mark>垃圾标记阶段</mark>。</p><p>那么在 JVM 中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><p>判断对象存活一般有两种方式：<mark>引用计数算法</mark>和<mark>可达性分析算法</mark>。</p><h3 id="12-1-标记阶段：引用计数算法"><a href="#12-1-标记阶段：引用计数算法" class="headerlink" title="12.1. 标记阶段：引用计数算法"></a>12.1. 标记阶段：引用计数算法</h3><h4 id="12-1-1-什么是引用计数算法"><a href="#12-1-1-什么是引用计数算法" class="headerlink" title="12.1.1 什么是引用计数算法"></a>12.1.1 什么是引用计数算法</h4><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的<mark>引用计数器属性。用于记录对象被引用的情况。</mark></p><p>对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，即表示对象 A 不可能再被使用，可进行回收。</p><p>优点：<mark>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</mark></p><p>缺点：</p><ul><li>它需要单独的字段存储计数器，这样的做法增加了<mark>存储空间的开销</mark>。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<mark>时间开销</mark>。</li><li>引用计数器有一个严重的问题，即<mark>无法处理循环引用</mark>的情况。这是一条致命缺陷，导致在 Java 的垃圾回收器中没有使用这类算法。</li></ul><h4 id="12-1-2-循环引用"><a href="#12-1-2-循环引用" class="headerlink" title="12.1.2 循环引用"></a>12.1.2 循环引用</h4><p>当 p 的指针断开的时候，内部的引用形成一个循环，这就是循环引用</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1367a58058e6653d53afdea83b937af3.png" alt="image-20200712102205795"></p><p><strong>举例</strong> ：测试 Java 中是否采用的是引用计数算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * 证明：java使用的不是引用计数算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 2:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefCountGC</span> &#123;</span><br><span class="line">    <span class="comment">//这个成员属性唯一的作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//5MB</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line"></span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line"></span><br><span class="line">        obj1 = <span class="literal">null</span>;</span><br><span class="line">        obj2 = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//显式的执行垃圾回收行为</span></span><br><span class="line">        <span class="comment">//这里发生GC，obj1和obj2能否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302161641381.png"></p><p>上述进行了 GC 收集的行为，所以可以证明 JVM 中采用的不是引用计数器的算法</p><p><img src="https://img-blog.csdnimg.cn/img_convert/010896600bb4483f35d004dce60cc58b.png" alt="image-20200712103230349"></p><h4 id="12-1-3-小结"><a href="#12-1-3-小结" class="headerlink" title="12.1.3 小结"></a>12.1.3 小结</h4><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的 Python，它更是同时支持引用计数和垃圾收集机制。</p><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p><p>Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p><p>Python 如何解决循环引用？</p><ul><li>手动解除：很好理解，就是在合适的时机，解除引用关系。 </li><li>使用弱引用 weakref，weakref 是 Python 提供的标准库，旨在解决循环引用。</li></ul><h3 id="12-2-标记阶段：可达性分析算法"><a href="#12-2-标记阶段：可达性分析算法" class="headerlink" title="12.2. 标记阶段：可达性分析算法"></a>12.2. 标记阶段：可达性分析算法</h3><h4 id="12-2-1-可达性分析算法（根搜索算法、追踪性垃圾收集）"><a href="#12-2-1-可达性分析算法（根搜索算法、追踪性垃圾收集）" class="headerlink" title="12.2.1 可达性分析算法（根搜索算法、追踪性垃圾收集）"></a>12.2.1 可达性分析算法（根搜索算法、追踪性垃圾收集）</h4><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<mark>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</mark>。</p><p>相较于引用计数算法，这里的可达性分析就是 Java、C#选择的。这种类型的垃圾收集通常也叫作<mark>追踪性垃圾收集（Tracing Garbage Collection）</mark></p><p>所谓”GCRoots”根集合就是一组必须活跃的引用。</p><h4 id="12-2-2-基本思路"><a href="#12-2-2-基本思路" class="headerlink" title="12.2.2 基本思路"></a>12.2.2 基本思路</h4><ul><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式<mark>搜索被根对象集合所连接的目标对象是否可达</mark>。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<mark>引用链（Reference Chain）</mark></li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul><p><font color=red>只要被GC Roots里面的引用 直接 或间接指向的对象，就是存活对象，否则就是要被回收的对象</font></p><p><img src="https://img-blog.csdnimg.cn/img_convert/071039dcf30672f55dfe8e5dab5e8081.png" alt="image-20210511195540451"></p><p><strong>在 Java 语言中，GC Roots 包括以下几类元素：</strong></p><ul><li>虚拟机栈中引用的对象<ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内 JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象<ul><li>比如：Java 类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池（String Table）里的引用</li></ul></li><li>所有被同步锁 synchronized 持有的对象</li><li>Java 虚拟机内部的引用。<ul><li>基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li></ul></li><li>反映 java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/d1ce4b570439851d57973a00684c6410.png" alt="image-20200712104622677"></p><p>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，<strong>还可以有其他对象“临时性”地加入</strong>，共同构成完整 GC Roots 集合。比如：<code>分代收集和局部回收</code>（PartialGC）。</p><p>如果只针对 Java 堆中的某一块区域进行垃圾回收（比如：典型的只针对<code>新生代</code>），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象（比如老年代）也加入 GCRoots 集合中去考虑，才能保证可达性分析的准确性。</p><p>小技巧：由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root。</p><p><strong>注意</strong></p><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能<code>保障一致性</code>的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p><p>这点也是导致 GC 进行时必须“stop The World”的一个重要原因。</p><ul><li>即使是号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。</li></ul><h3 id="12-3-对象的-finalization-机制"><a href="#12-3-对象的-finalization-机制" class="headerlink" title="12.3. 对象的 finalization 机制"></a>12.3. 对象的 finalization 机制</h3><p>Java 语言提供了对象终止（finalization）机制来允许开发人员提供<mark>对象被销毁之前的自定义处理逻辑</mark>。</p><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize()方法。</p><p>finalize() 方法允许在子类中被重写，<mark>用于在对象被回收时进行资源释放</mark>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p><p>永远不要主动调用某个对象的 finalize()方法 ， 应该交给垃圾回收机制调用。理由包括下面三点：</p><ul><li>在 finalize()时可能会导致对象复活。</li><li>finalize()方法的执行时间是没有保障的，它完全由 GC 线程【一个优先级非常低的finalizer线程】决定，极端情况下，若不发生 GC，则 finalize()方法将没有执行机会。</li><li>一个糟糕的 finalize()会严重影响 GC的性能。</li></ul><p>从功能上来说，finalize()方法与 C++中的析构函数比较相似，但是 Java 采用的是基于垃圾回收器的自动内存管理机制，所以 finalize()方法在本质上不同于 C++中的析构函数。</p><p>由于 finalize()方法的存在，<mark>虚拟机中的对象一般处于三种可能的状态</mark>。</p><h4 id="12-3-1-生存还是死亡？"><a href="#12-3-1-生存还是死亡？" class="headerlink" title="12.3.1 生存还是死亡？"></a>12.3.1 生存还是死亡？</h4><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<mark>一个无法触及的对象有可能在某一个条件下“复活”自己</mark>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p><ul><li><mark>可触及的</mark>：从根节点开始，可以到达这个对象。</li><li><mark>可复活的</mark>：对象的所有引用都被释放【不可达】，但是对象有可能在 finalize()中复活。</li><li><mark>不可触及的</mark>：对象的 finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<mark>finalize()只会被调用一次</mark>。</li></ul><p>以上 3 种状态中，是由于 inalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p><h4 id="12-3-2-具体过程"><a href="#12-3-2-具体过程" class="headerlink" title="12.3.2 具体过程"></a>12.3.2 具体过程</h4><p>判定一个对象 objA 是否可回收，至少要经历两次标记过程：</p><ol><li>如果对象 &#x3D;&#x3D;objA 到 GC Roots 没有引用链，则进行第一次标记&#x3D;&#x3D;。</li><li>进行筛选，判断此对象是否有必要执行 finalize()方法</li><li>如果对象 objA 没有重写 finalize()方法，或者 finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA 被判定为不可触及的。</li><li>如果对象 objA 重写了 finalize()方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize()方法执行。</li><li><mark>finalize()方法是对象逃脱死亡的最后机会</mark>，稍后 GC 会对 F-Queue 队列中的对象进行第二次标记。如果 objA 在 finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA 会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 finalize 方法只会被调用一次。</li></ol><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Object类中finalize()方法，即对象的finalization机制。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 2:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanReliveObj</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj obj;<span class="comment">//类变量，属于 GC Root</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法只能被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;<span class="comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = <span class="keyword">new</span> <span class="title class_">CanReliveObj</span>();</span><br><span class="line">            <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();<span class="comment">//调用垃圾回收器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第1次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第2次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">调用当前类重写的finalize()方法</span><br><span class="line">第1次 gc</span><br><span class="line">obj is still alive</span><br><span class="line">第2次 gc</span><br><span class="line">obj is dead</span><br></pre></td></tr></table></figure><p>在第一次 GC 时，执行了 finalize 方法，对象复活。但 finalize()方法只会被调用一次，所以第二次该对象被 GC 标记并清除了。</p><h3 id="12-4-MAT-与-JProfiler-的-GC-Roots-溯源"><a href="#12-4-MAT-与-JProfiler-的-GC-Roots-溯源" class="headerlink" title="12.4. MAT 与 JProfiler 的 GC Roots 溯源"></a>12.4. MAT 与 JProfiler 的 GC Roots 溯源</h3><h4 id="12-4-1-MAT-是什么？"><a href="#12-4-1-MAT-是什么？" class="headerlink" title="12.4.1 MAT 是什么？"></a>12.4.1 MAT 是什么？</h4><p>MAT 是 Memory Analyzer 的简称，它是一款功能强大的 Java 堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p><p>MAT 是基于 Eclipse 开发的，是一款免费的性能分析工具。</p><p>大家可以在 <a href="http://www.eclipse.org/mat/">http://www.eclipse.org/mat/</a> 下载并使用 MAT</p><p>接下来，演示如何查看GC Roots都会以下面的代码案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  16:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCRootsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            numList.add(String.valueOf(i));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">        numList = <span class="literal">null</span>;</span><br><span class="line">        birth = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-4-2-获取-dump-文件"><a href="#12-4-2-获取-dump-文件" class="headerlink" title="12.4.2 获取 dump 文件"></a>12.4.2 获取 dump 文件</h4><h5 id="方式一：命令行使用-jmap"><a href="#方式一：命令行使用-jmap" class="headerlink" title="方式一：命令行使用 jmap"></a>方式一：命令行使用 jmap</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/f8cc8bd3ef9526b497bcc4335e84e639.png" alt="image-20210512105418987"></p><h5 id="方式二：使用-JVisualVM-导出"><a href="#方式二：使用-JVisualVM-导出" class="headerlink" title="方式二：使用 JVisualVM 导出"></a>方式二：使用 JVisualVM 导出</h5><p>捕获的 heap dump 文件是一个临时文件，关闭 JVisualVM 后自动删除，若要保留，需要将其另存为文件。</p><p>可通过以下方法捕获 heap dump：</p><ul><li>在左侧“Application”（应用程序）子窗口中右击相应的应用程序，选择 Heap Dump（堆 Dump）。</li><li>在 Monitor（监视）子标签页中点击 Heap Dump（堆 Dump）按钮。</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302191709323.png" alt="image-20230218160401774"></p><p>本地应用程序的 Heap dumps 作为应用程序标签页的一个子标签页打开。同时，heap dump 在左侧的 Application（应用程序）栏中对应一个含有时间戳的节点。</p><p>右击这个节点选择 save as（另存为）即可将 heap dump 保存到本地。</p><p>这里，我们分别在 <code>数据添加完毕</code> 和 <code>numList、birth置空</code> 后dump一次~</p><h4 id="12-4-3-使用-MAT-打开-Dump-文件"><a href="#12-4-3-使用-MAT-打开-Dump-文件" class="headerlink" title="12.4.3 使用 MAT 打开 Dump 文件"></a>12.4.3 使用 MAT 打开 Dump 文件</h4><p>打开方式：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302191709311.png" alt="image-20230218160940083"></p><p>效果展示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302191709300.png"></p><p>进行分析：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302191709319.png"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302191709315.png"></p><h4 id="12-4-4-JProfiler-的-GC-Roots-溯源"><a href="#12-4-4-JProfiler-的-GC-Roots-溯源" class="headerlink" title="12.4.4 JProfiler 的 GC Roots 溯源"></a>12.4.4 JProfiler 的 GC Roots 溯源</h4><p>我们在实际的开发中，一般不会查找全部的 GC Roots，可能只是查找某个对象的整个链路，或者称为 GC Roots 溯源，这个时候，我们就可以使用 JProfiler</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302191709333.png" alt="image-20230218164712601"></p><h4 id="12-4-5-JProfiler查看OOM的原因"><a href="#12-4-5-JProfiler查看OOM的原因" class="headerlink" title="12.4.5 JProfiler查看OOM的原因"></a>12.4.5 JProfiler查看OOM的原因</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  15:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//1MB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">HeapOOM</span>());</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302191709082.png" alt="image-20230218170421236"></p><p>分析Dump文件</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302191709106.png" alt="image-20230218170929128"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302191709140.png" alt="image-20230218171218158"></p><blockquote><p>关于JProfile更多的使用，后面调优篇章详细介绍~</p></blockquote><h3 id="12-5-清除阶段：标记-清除算法"><a href="#12-5-清除阶段：标记-清除算法" class="headerlink" title="12.5. 清除阶段：标记-清除算法"></a>12.5. 清除阶段：标记-清除算法</h3><p>当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p><p>目前在 JVM 中比较常见的三种垃圾收集算法是<mark>标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact）</mark></p><h4 id="12-5-1-标记-清除算法（Mark-Sweep）"><a href="#12-5-1-标记-清除算法（Mark-Sweep）" class="headerlink" title="12.5.1 标记-清除算法（Mark-Sweep）"></a>12.5.1 标记-清除算法（Mark-Sweep）</h4><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被 J.McCarthy 等人在 1960 年提出并并应用于 Lisp 语言。</p><h4 id="12-5-2-执行过程"><a href="#12-5-2-执行过程" class="headerlink" title="12.5.2 执行过程"></a>12.5.2 执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为 stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p><ul><li><p><mark>标记</mark>：Collector 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的 Header 中记录为可达对象【非垃圾对象】。</p></li><li><p><mark>清除</mark>：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收</p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302191709171.jpg" alt="第14章_标记-清除算法"></p><h4 id="12-5-3-缺点"><a href="#12-5-3-缺点" class="headerlink" title="12.5.3 缺点"></a>12.5.3 缺点</h4><ul><li>标记清除算法的效率不算高【需要两次遍历】</li><li>在进行 GC 的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ul><h4 id="12-5-4-何为清除？"><a href="#12-5-4-何为清除？" class="headerlink" title="12.5.4 何为清除？"></a>12.5.4 何为清除？</h4><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p><h3 id="12-6-清除阶段：复制算法"><a href="#12-6-清除阶段：复制算法" class="headerlink" title="12.6. 清除阶段：复制算法"></a>12.6. 清除阶段：复制算法</h3><h4 id="12-6-4-复制算法"><a href="#12-6-4-复制算法" class="headerlink" title="12.6.4 复制算法"></a>12.6.4 复制算法</h4><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky 于 1963 年发表了著名的论文，“使用双存储区的 Lisp 语言垃圾收集器 CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky 在该论文中描述的算法被人们称为复制（Copying）算法，它也被 M.L.Minsky 本人成功地引入到了 Lisp 语言的一个实现版本中。</p><h4 id="12-6-2-核心思想"><a href="#12-6-2-核心思想" class="headerlink" title="12.6.2 核心思想"></a>12.6.2 核心思想</h4><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302191709203.jpg" alt="第14章_复制算法"></p><h4 id="12-6-3-优缺点"><a href="#12-6-3-优缺点" class="headerlink" title="12.6.3 优缺点"></a>12.6.3 优缺点</h4><p>优点：</p><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul><p>缺点：</p><ul><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小【其实就是，当堆区对象从A区复制到B后，局部变量表里面的引用也需要变化】</li></ul><blockquote><p>注意：如果系统中的垃圾对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量并不会太大，或者说非常低才行</p></blockquote><h4 id="12-6-4-应用场景"><a href="#12-6-4-应用场景" class="headerlink" title="12.6.4 应用场景"></a>12.6.4 应用场景</h4><p>在新生代【对象朝生夕死】，对常规应用的垃圾回收，一次通常可以回收 70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302191709991.png" alt="image-20200712152847218"></p><p>为什么老年代不用复制算法？</p><p>1.老年代的存活对象较多，复制成本较高。</p><p>2.老年代本身的空间就很大，但是使用复制算法会直接砍掉一半，内存浪费严重~</p><h3 id="12-7-清除阶段：标记-压缩（整理）算法"><a href="#12-7-清除阶段：标记-压缩（整理）算法" class="headerlink" title="12.7. 清除阶段：标记-压缩（整理）算法"></a>12.7. 清除阶段：标记-压缩（整理）算法</h3><h4 id="12-7-1-标记-压缩（或标记-整理、Mark-Compact）算法"><a href="#12-7-1-标记-压缩（或标记-整理、Mark-Compact）算法" class="headerlink" title="12.7.1 标记-压缩（或标记-整理、Mark-Compact）算法"></a>12.7.1 标记-压缩（或标记-整理、Mark-Compact）算法</h4><p>复制算法的高效性是建立在&#x3D;&#x3D;存活对象少、垃圾对象多&#x3D;&#x3D;的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p><p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p><p>1970 年前后，G.L.Steele、C.J.Chene 和 D.s.Wise 等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p><h4 id="12-7-2-执行过程"><a href="#12-7-2-执行过程" class="headerlink" title="12.7.2 执行过程"></a>12.7.2 执行过程</h4><ol><li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li><li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</li><li>之后，清理边界外所有的空间。</li></ol><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302191709236.jpg" alt="第14章_标记-压缩算法"></p><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<mark>标记-清除-压缩（Mark-Sweep-Compact）算法</mark>。</p><p>二者的本质差异在于标记-清除算法是一种<mark>非移动式的回收算法</mark>，标记-压缩是&#x3D;&#x3D;移动式的&#x3D;&#x3D;。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p><blockquote><p>指针碰撞（Bump the Pointer）</p><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump tHe Pointer）。</p></blockquote><h4 id="12-7-3-优缺点"><a href="#12-7-3-优缺点" class="headerlink" title="12.7.3 优缺点"></a>12.7.3 优缺点</h4><p>优点：</p><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><p>缺点：</p><ul><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ul><h3 id="12-8-小结"><a href="#12-8-小结" class="headerlink" title="12.8. 小结"></a>12.8. 小结</h3><table><thead><tr><th align="left"></th><th align="left">Mark-Sweep</th><th align="left">Mark-Compact</th><th align="left">Copying</th></tr></thead><tbody><tr><td align="left"><strong>速率</strong></td><td align="left">中等</td><td align="left">最慢</td><td align="left">最快</td></tr><tr><td align="left"><strong>空间开销</strong></td><td align="left">少（但会堆积碎片）</td><td align="left">少（不堆积碎片）</td><td align="left">通常需要活对象的 2 倍空间（不堆积碎片）</td></tr><tr><td align="left"><strong>移动对象</strong></td><td align="left">否</td><td align="left">是</td><td align="left">是</td></tr></tbody></table><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段</p><p><strong><font color=red>难道就没有一种最优算法吗？</font></strong></p><p>回答：无，没有最好的算法，只有最合适的算法。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302191709937.png" alt="image-20230219161142998"></p><h3 id="12-9-分代收集算法"><a href="#12-9-分代收集算法" class="headerlink" title="12.9. 分代收集算法"></a>12.9. 分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<mark>不同生命周期的对象可以采取不同的收集方式</mark>，以便提高回收效率。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在 Java 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如<mark>Http 请求中的 Session 对象、线程、Socket 连接</mark>，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：<mark>String 对象</mark>，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p><mark>目前几乎所有的 GC 都采用分代手机算法执行垃圾回收的。</mark></p><p>在 HotSpot 中，基于分代的概念，GC 所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><h4 id="12-9-1-年轻代（Young-Gen）"><a href="#12-9-1-年轻代（Young-Gen）" class="headerlink" title="12.9.1 年轻代（Young Gen）"></a>12.9.1 年轻代（Young Gen）</h4><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p><p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过 hotspot 中的两个 survivor 的设计得到缓解。</p><h4 id="12-9-2-老年代（Tenured-Gen）"><a href="#12-9-2-老年代（Tenured-Gen）" class="headerlink" title="12.9.2 老年代（Tenured Gen）"></a>12.9.2 老年代（Tenured Gen）</h4><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><ul><li>Mark 阶段的开销与存活对象的数量成正比。</li><li>Sweep 阶段的开销与所管理区域的大小成正相关。</li><li>Compact 阶段的开销与存活对象的数据成正比。</li></ul><p>以 HotSpot 中的 CMS 回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收效率很高。而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿措施：当内存回收不佳（碎片导致的 Concurrent Mode Failure 时），将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理。</p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p><h3 id="12-X-增量收集算法、分区算法"><a href="#12-X-增量收集算法、分区算法" class="headerlink" title="12.X. 增量收集算法、分区算法"></a>12.X. 增量收集算法、分区算法</h3><h4 id="12-X-1-增量收集算法"><a href="#12-X-1-增量收集算法" class="headerlink" title="12.X.1 增量收集算法"></a>12.X.1 增量收集算法</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种 Stop the World 的状态。在 Stop the World 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将<mark>严重影响用户体验或者系统的稳定性</mark>。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><p><strong>基本思想</strong></p><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让<code>垃圾收集线程和应用程序线程交替执行</code>。每次，<mark>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</mark>。</p><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过<mark>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</mark></p><p><strong>缺点</strong></p><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<mark>造成系统吞吐量的下降</mark>。</p><h4 id="12-X-2-分区算法"><a href="#12-X-2-分区算法" class="headerlink" title="12.X.2 分区算法"></a>12.X.2 分区算法</h4><p>一般来说，在相同条件下，堆空间越大，一次 Gc 时所需要的时间就越长，有关 GC 产生的停顿也越长。为了更好地控制 GC 产生的停顿时间&#x3D;&#x3D;，将一块大的内存区域分割成多个小块&#x3D;&#x3D;，根据目标的停顿时间，每&#x3D;&#x3D;次合理地回收若干个小区间，而不是整个堆空间&#x3D;&#x3D;，从而&#x3D;&#x3D;减少一次 GC 所产生的停顿&#x3D;&#x3D;。</p><p>分代算法将按照对象的生命周期长短划分成两个部分【年轻代、老年代】，分区算法将整个堆空间划分成连续的不同小区间。</p><p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302191709728.png" alt="image-20200712165318590"></p><h4 id="12-X-3-写到最后"><a href="#12-X-3-写到最后" class="headerlink" title="12.X.3 写到最后"></a>12.X.3 写到最后</h4><p>注意，这些只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十、StringTable</title>
      <link href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC10%E7%AB%A0_StringTable/"/>
      <url>/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC10%E7%AB%A0_StringTable/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="10-StringTable"><a href="#10-StringTable" class="headerlink" title="10. StringTable"></a>10. StringTable</h1><h2 id="10-1-String-的基本特性"><a href="#10-1-String-的基本特性" class="headerlink" title="10.1. String 的基本特性"></a>10.1. String 的基本特性</h2><ul><li>String：字符串，使用一对””引起来表示</li><li>String 声明为 final 的，不可被继承</li><li>String 实现了 Serializable 接口：表示字符串是支持序列化的。</li><li>String 实现了 Comparable 接口：表示 string 可以比较大小</li><li>String 在 jdk8 及以前内部定义了 <code>final char[] value</code> 用于存储字符串数据。JDK9 时改为 <code>byte[]</code></li></ul><h3 id="10-1-1-String-在-jdk9-中存储结构变更"><a href="#10-1-1-String-在-jdk9-中存储结构变更" class="headerlink" title="10.1.1. String 在 jdk9 中存储结构变更"></a>10.1.1. String 在 jdk9 中存储结构变更</h3><p>官网地址：<a href="http://openjdk.java.net/jeps/254">JEP 254: Compact Strings (java.net)</a></p><blockquote><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>The current implementation of the <code>String</code> class stores characters in a <code>char</code> array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most <code>String</code> objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal <code>char</code> arrays of such <code>String</code> objects is going unused.</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>We propose to change the internal representation of the <code>String</code> class from a UTF-16 <code>char</code> array to a <code>byte</code> array plus an encoding-flag field. The new <code>String</code> class will store characters encoded either as ISO-8859-1&#x2F;Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.</p><p>String-related classes such as <code>AbstractStringBuilder</code>, <code>StringBuilder</code>, and <code>StringBuffer</code> will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations.</p><p>This is purely an implementation change, with no changes to existing public interfaces. There are no plans to add any new public APIs or other interfaces.</p><p>The prototyping work done to date confirms the expected reduction in memory footprint, substantial reductions of GC activity, and minor performance regressions in some corner cases.</p></blockquote><p><strong>动机</strong></p><p>目前 String 类的实现将字符存储在一个 char 数组中，每个字符使用两个字节（16 位）。从许多不同的应用中收集到的数据表明，字符串是堆使用的主要组成部分，此外，&#x3D;&#x3D;大多数字符串对象只包含 Latin-1 字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部字符数组中有一半的空间没有被使用&#x3D;&#x3D;。</p><p><strong>说明</strong></p><p>我们建议将 String 类的内部表示方法从 UTF-16 字符数组改为&#x3D;&#x3D;字节数组加编码标志域&#x3D;&#x3D;。新的 String 类将根据字符串的内容，以 ISO-8859-1&#x2F;Latin-1（每个字符一个字节）或 UTF-16（每个字符两个字节）的方式存储字符编码。编码标志将表明使用的是哪种编码。</p><hr><p>与字符串相关的类，如<mark>AbstractStringBuilder、StringBuilder 和 StringBuffer 将被更新以使用相同的表示方法，HotSpot VM 的内在字符串操作也是如此</mark>。</p><p>这纯粹是一个实现上的变化，对现有的公共接口没有变化。目前没有计划增加任何新的公共 API 或其他接口。</p><p>迄今为止所做的原型设计工作证实了内存占用的预期减少，GC 活动的大幅减少，以及在某些角落情况下的轻微性能倒退。</p><p><strong>结论：</strong>String 再也不用 char[] 来存储了，改成了 byte [] 加上编码标记，节约了一些空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-1-2-String-的基本特性"><a href="#10-1-2-String-的基本特性" class="headerlink" title="10.1.2. String 的基本特性"></a>10.1.2. String 的基本特性</h3><p>String：代表不可变的字符序列。简称：<code>不可变性</code>。</p><ul><li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的 value 进行赋值。</li><li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</li><li>当调用 string 的 replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</li></ul><p>&#x3D;&#x3D;通过字面量的方式（区别于 new）给一个字符串赋值，此时的字符串值声明在字符串常量池中&#x3D;&#x3D;。</p><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的基本使用:体现String的不可变性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  23:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest1</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量定义的方式，&quot;abc&quot;存储在字符串常量池中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//判断地址：true  --&gt; false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s1);<span class="comment">//</span></span><br><span class="line">        System.out.println(s2);<span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        s2 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        System.out.println(s2);<span class="comment">//abcdef</span></span><br><span class="line">        System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">        System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">        System.out.println(s2);<span class="comment">//mbc</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red>字符串常量池是不会存储相同内容的字符串的</font></strong></p><p>String 的 String Pool 是一个固定大小的 <strong>Hashtable</strong>，默认值大小长度是 1009。如果放进 String Pool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用 String.intern 时性能会大幅下降。</p><p>使用<code>-XX:StringTablesize</code>可设置 StringTable 的长度</p><ul><li>在 jdk6 中 StringTable 是固定的，就是 1009 的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize 设置没有要求</li><li>在 jdk7 中，StringTable 的长度默认值是 60013，StringTable size 设置没有要求</li><li>在 JDK8 中，设置 StringTable 长度的话，1009 是可以设置的最小值</li></ul><p><strong>注意：</strong>为啥链表长了当调用 String.intern 时性能会大幅下降？</p><p>String Pool底层是一个HashTable，调用String.intern()就是向字符串常量池中加入字符串。加入之前会先去判断池中是否存在该串，这个过程如果链表过长就会导致遍历串速度很低，降低其性能。</p><p>为啥JDK6 –&gt; JDK7，StringTable默认大小 提高呢？</p><p>StringTable越大，对应着HashTable底层的数组长度就越大，在添加元素时出现Hash冲突的概率就会更小，链表的长度会越短，遍历查找元素的时间就越短，效率越高！（长度1009时添加10W个字符串，耗时143ms。当长度为60013，耗时47ms）</p><p><strong>测试代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产生10万个长度不超过10的字符串，包含a-z,A-Z</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  23:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenerateString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;words.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//1 - 10</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * (<span class="number">10</span> - <span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">            fw.write(getString(length) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">//65 - 90, 97-122</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * (<span class="number">90</span> - <span class="number">65</span> + <span class="number">1</span>) + <span class="number">65</span>) + (<span class="type">int</span>)(Math.random() * <span class="number">2</span>) * <span class="number">32</span>;</span><br><span class="line">            str += (<span class="type">char</span>)num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试在StringTableSize=1009 和 StringTableSize=60013下，添加10W个字符串耗时情况</span></span><br><span class="line"><span class="comment"> * 结论：1009:143ms  100009:47ms</span></span><br><span class="line"><span class="comment"> *  配置：-XX:StringTableSize=1009</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  23:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试StringTableSize参数</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;我来打个酱油&quot;);</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            Thread.sleep(1000000);</span></span><br><span class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;words.txt&quot;</span>));</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            String data;</span><br><span class="line">            <span class="keyword">while</span>((data = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                data.intern(); <span class="comment">//如果字符串常量池中没有对应data的字符串的话，则在常量池中生成</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 数组越长，Hash碰撞越少，效率越高~</span></span><br><span class="line">            System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1009:143ms  100009:47ms</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(br != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-2-String-的内存分配"><a href="#10-2-String-的内存分配" class="headerlink" title="10.2. String 的内存分配"></a>10.2. String 的内存分配</h2><p>在 Java 语言中有 8 种基本数据类型和一种比较特殊的类型 String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p><p>常量池就类似一个 Java 系统级别提供的缓存。8 种基本数据类型的常量池都是系统协调的，<mark>String 类型的常量池比较特殊。它的主要使用方法有两种。</mark></p><ul><li><p>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</p></li><li><p>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern()方法。这个后面重点谈</p></li></ul><p>Java 6 及以前，字符串常量池存放在永久代</p><p>Java 7 中 Oracle 的工程师对字符串池的逻辑做了很大的改变，即将<mark>字符串常量池的位置调整到 Java 堆内</mark></p><ul><li><p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</p></li><li><p>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在 Java 7 中使用<code>String.intern()</code>。</p></li></ul><p>Java8 元空间，字符串常量在堆</p><p><img src="https://img-blog.csdnimg.cn/img_convert/27b7bf706fc1724baf503eac9b49c7fc.png" alt="image-20200711093546398"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c59830deeebca85d5b2e446211e4e28d.png" alt="image-20200711093558709"></p><p>关于更详尽的描述，请参考：<a href="https://blog.csdn.net/qq_43842093/article/details/122991756">https://blog.csdn.net/qq_43842093/article/details/122991756</a></p><p><strong>StringTable 为什么要调整？</strong></p><p>官网地址：<a href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">Java SE 7 Features and Enhancements (oracle.com)</a></p><blockquote><p><strong>Synopsis:</strong> In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap (known as the young and old generations), along with the other objects created by the application. This change will result in more data residing in the main Java heap, and less data in the permanent generation, and thus may require heap sizes to be adjusted. Most applications will see only relatively small differences in heap usage due to this change, but larger applications that load many classes or make heavy use of the <code>String.intern()</code> method will see more significant differences.</p></blockquote><p>简介：在 JDK 7 中，内部字符串不再分配在 Java 堆的永久代中，而是分配在 Java 堆的主要部分（称为年轻代和老年代），与应用程序创建的其他对象一起。这种变化将导致更多的数据驻留在主 Java 堆中，而更少的数据在永久代中，因此可能需要调整堆的大小。大多数应用程序将看到由于这一变化而导致的堆使用的相对较小的差异，但<mark>加载许多类或大量使用 String.intern()方法的大型应用程序将看到更明显的差异</mark>。</p><p><strong>调整原因：</strong>①permSize默认比较小 ② 永久代垃圾回收频率低  ，从而更可能出现OOM</p><h2 id="10-3-String-的基本操作"><a href="#10-3-String-的基本操作" class="headerlink" title="10.3. String 的基本操作"></a>10.3. String 的基本操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Debug查看字符串常量池中有多少字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  0:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.print1n(<span class="string">&quot;1&quot;</span>); <span class="comment">//2321</span></span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;10&quot;</span>); <span class="comment">//2330</span></span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>); <span class="comment">//2330 因为池中已经存在该字符串了，所以不会再创建</span></span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>); <span class="comment">//2330</span></span><br><span class="line">    System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    System.out.print1n(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">    System.out.print1n(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;10&quot;</span>);<span class="comment">//2330</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 语言规范里要求完全相同的字符串字面量，应该包含同样的 Unicode 字符序列（包含同一份码点序列的常量），并且必须是指向同一个 String 类实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="comment">//line 1</span></span><br><span class="line">        <span class="type">int</span> i= <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//line 3</span></span><br><span class="line">        <span class="type">Memory</span> <span class="variable">mem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Memory</span>();<span class="comment">//Line 4</span></span><br><span class="line">        mem.foo(obj);<span class="comment">//Line 5</span></span><br><span class="line">    &#125;<span class="comment">//Line 9</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object param)</span> &#123;<span class="comment">//line 6</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> param.toString();<span class="comment">//line 7</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;<span class="comment">//Line 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302152324436.png" alt="image-20210511111607132"></p><p><strong>注意：</strong>只有intern()的String和字面量才会添加到字符串，&#x3D;&#x3D;Object#toString返回的是多个字符拼接的结果，不属于前者&#x3D;&#x3D;。</p><p>另外关于<code>new String()</code>的形式，后面再进行讲解</p><h2 id="10-4-字符串拼接操作"><a href="#10-4-字符串拼接操作" class="headerlink" title="10.4. 字符串拼接操作"></a>10.4. 字符串拼接操作</h2><ul><li>常量与常量的拼接结果在常量池，原理是编译期优化</li><li>常量池中不会存在相同内容的变量</li><li>只要其中有一个是变量，结果就在堆中【这里的堆指 非字符串常量池的其他堆区域】。变量拼接的原理是 StringBuilder</li><li>如果拼接的结果调用 intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li></ul><p><strong>举例 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//编译期优化：等同于&quot;abc&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">         * String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">         * String s2 = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">    System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例 2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">//编译期优化</span></span><br><span class="line">    <span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line">    <span class="comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span></span><br><span class="line">    <span class="comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();</span><br><span class="line">    System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例 3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span></span><br><span class="line"><span class="comment">        ① StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">        ② s.append(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">        ③ s.append(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">        ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;<span class="comment">//</span></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>举例 4</strong></p><ul><li>不使用 final 修饰，即为变量。如 s3 行的 s1 和 s2，会通过 new StringBuilder 进行拼接</li><li>使用 final 修饰，即为常量。会在编译器进行代码优化。<mark>在实际开发中，能够使用 final 的，尽量使用</mark></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 字符串拼接操作不一定使用的是StringBuilder!</span></span><br><span class="line"><span class="comment">       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span></span><br><span class="line"><span class="comment">    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span></span><br><span class="line"><span class="comment">       final修饰的，在编译时就初始化好了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字节码角度分析</strong></p><p>我们拿例 3 的字节码进行查看，可以发现<code>s1 + s2</code>实际上是 new 了一个 StringBuilder 对象，并使用了 append 方法将 s1 和 s2 添加进来，最后调用了 toString 方法赋给 s4</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 0 ldc #14 &lt;a&gt; #加载常量a</span><br><span class="line"> 2 astore_1       #将a放到局部变量表的下标为1的位置</span><br><span class="line"> 3 ldc #15 &lt;b&gt;</span><br><span class="line"> 5 astore_2       #将b放到局部变量表的下标为2的位置</span><br><span class="line"> 6 ldc #16 &lt;ab&gt;</span><br><span class="line"> 8 astore_3</span><br><span class="line"> 9 new #9 &lt;java/lang/StringBuilder&gt; #创建StringBuilder对象</span><br><span class="line">12 dup</span><br><span class="line">13 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;</span><br><span class="line">16 aload_1</span><br><span class="line">17 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt; #append</span><br><span class="line">20 aload_2</span><br><span class="line">21 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt; #append</span><br><span class="line">24 invokevirtual #12 &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt; #toString</span><br><span class="line">27 astore 4</span><br><span class="line">29 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span><br><span class="line">32 aload_3</span><br><span class="line">33 aload 4</span><br><span class="line">35 if_acmpne 42 (+7)</span><br><span class="line">38 iconst_1</span><br><span class="line">39 goto 43 (+4)</span><br><span class="line">42 iconst_0</span><br><span class="line">43 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;</span><br><span class="line">46 return</span><br></pre></td></tr></table></figure><p><font color=orange><strong>字符串拼接操作性能对比</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    详情：① StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象</span></span><br><span class="line"><span class="comment">                  使用String的字符串拼接方式：创建过多个StringBuilder和String的对象</span></span><br><span class="line"><span class="comment">         ② 使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费额外的时间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下,建议使用构造器实例化：</span></span><br><span class="line"><span class="comment">               StringBuilder s = new StringBuilder(highLevel);//new char[highLevel]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//        method1(100000);//4014</span></span><br><span class="line">    method2(<span class="number">100000</span>);<span class="comment">//7</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> highLevel)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; highLevel;i++)&#123;</span><br><span class="line">        src = src + <span class="string">&quot;a&quot;</span>;<span class="comment">//每次循环都会创建一个StringBuilder、String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> highLevel)</span>&#123;</span><br><span class="line">    <span class="comment">//只需要创建一个StringBuilder</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    src.toString();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">        src.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure><h2 id="10-5-intern-的使用"><a href="#10-5-intern-的使用" class="headerlink" title="10.5. intern()的使用"></a>10.5. intern()的使用</h2><h3 id="10-5-1-intern-的基本介绍"><a href="#10-5-1-intern-的基本介绍" class="headerlink" title="10.5.1 intern()的基本介绍"></a>10.5.1 intern()的基本介绍</h3><p>官方 API 文档中的解释</p><blockquote><p>public String intern()</p><p>Returns a canonical representation for the string object.</p><p>A pool of strings, initially empty, is maintained privately by the class <code>String</code>.</p><p>When the intern method is invoked, if the pool already contains a string equal to this <code>String</code> object as determined by the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#equals-java.lang.Object-"><code>equals(Object)</code></a> method, then the string from the pool is returned. Otherwise, this <code>String</code> object is added to the pool and a reference to this <code>String</code> object is returned.</p><p>It follows that for any two strings <code>s</code> and <code>t</code>, <code>s.intern() == t.intern()</code> is <code>true</code> if and only if <code>s.equals(t)</code> is <code>true</code>.</p><p>All literal strings and string-valued constant expressions are interned. String literals are defined in section 3.10.5 of the The Java™ Language Specification.</p><ul><li><p><strong>Returns:</strong></p><p>a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings.</p></li></ul></blockquote><p>当调用 intern 方法时，如果池子里已经包含了一个与这个 String 对象相等的字符串，正如 equals(Object)方法所确定的，那么池子里的字符串会被返回。否则，这个 String 对象被添加到池中，并返回这个 String 对象的引用。</p><p>由此可见，对于任何两个字符串 s 和 t，当且仅当 s.equals(t)为真时，s.intern() &#x3D;&#x3D; t.intern()为真。</p><p>所有字面字符串和以字符串为值的常量表达式都是 interned。</p><p>返回一个与此字符串内容相同的字符串，但保证是来自一个唯一的字符串池。</p><hr><p>intern 是一个 native 方法，调用的是底层 C 的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法，它会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">myInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">string</span>(<span class="string">&quot;I love atguigu&quot;</span>).intern();</span><br></pre></td></tr></table></figure><p>也就是说，如果在任意字符串上调用 String.intern 方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="string">&quot;c&quot;</span>).intern() == <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure><p>通俗点讲，Interned string 就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302152325407.png" alt="image-20210511145542579"></p><p><strong>如何保证变量s指向的是字符串常量池中的数据呢？</strong></p><p>有两种方式：</p><ul><li><p>方式一： String s &#x3D; “shkstart”;&#x2F;&#x2F;字面量定义的方式</p></li><li><p>方式二： 调用intern()</p><p>String s &#x3D; new String(“shkstart”).intern();</p><p>String s &#x3D; new StringBuilder(“shkstart”).toString().intern();</p></li></ul><h3 id="10-5-2-关于String的两道面试题"><a href="#10-5-2-关于String的两道面试题" class="headerlink" title="10.5.2 关于String的两道面试题"></a>10.5.2 关于String的两道面试题</h3><p><strong><font color=orange>面试题：new String(“ab”)会创建几个对象？new String(“a”) + new String(“b”)呢？</font></strong></p><p>① <code>String str = new String(&quot;ab&quot;);</code></p><p>通过看字节码，就知道是两个。</p><ul><li><pre><code>一个对象是：new关键字在堆空间创建的</code></pre></li><li><pre><code>另一个对象是：字符串常量池中的对象&quot;ab&quot;。 字节码指令ldc ：在常量池中常见对象</code></pre></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302152324460.png" alt="image-20230215152940742"></p><blockquote><p>为什么要设计成两个？</p><p>那你使用字面量参数的时候，这个参数总要有地方放的，它是字面量，自然就放在字符串常量池<br>然后new String的这个操作，用这个参数在堆空间中赋值给new的对象，然后把new的对象地址交给str</p></blockquote><p>②<code>String str = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302152324451.png"></p><h3 id="10-5-3-intern-的使用：JDK6-vs-JDK7-8"><a href="#10-5-3-intern-的使用：JDK6-vs-JDK7-8" class="headerlink" title="10.5.3 intern 的使用：JDK6 vs JDK7&#x2F;8"></a>10.5.3 intern 的使用：JDK6 vs JDK7&#x2F;8</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 看一道关于intern的面试题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);<span class="comment">// s记录的地址：堆空间中new String(&quot;1&quot;)的地址</span></span><br><span class="line">        s.intern();<span class="comment">//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;<span class="comment">// s2记录的地址：常量池中对象的地址</span></span><br><span class="line">        System.out.println(s == s2);<span class="comment">//jdk6：false   jdk7/8：false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);<span class="comment">//s3变量记录的地址为：new String(&quot;11&quot;)</span></span><br><span class="line">        <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">        s3.intern();<span class="comment">//在字符串常量池中生成&quot;11&quot;。如何理解：jdk6:创建了一个新的对象&quot;11&quot;,也就有新的地址。</span></span><br><span class="line">                                            <span class="comment">//         jdk7:此时常量中并没有创建&quot;11&quot;,而是创建一个指向堆空间中new String(&quot;11&quot;)的地址</span></span><br><span class="line">                    <span class="comment">// 本来该生成两个地址，但是都是在堆空间，而且存11，那就没必要再开辟串池空间了。这是JDK的优化</span></span><br><span class="line">       </span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;<span class="comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//jdk6：false  jdk7/8：true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图解</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302152325655.png" alt="jdk6图"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302152325703.png" alt="jdk7图1"></p><p>总结 String 的 intern()的使用：</p><p>JDK1.6 中，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，会把此<mark>对象复制一份</mark>，放入串池，并返回串池中的对象地址</li></ul><p>JDK1.7 起，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，则会把<mark>对象的引用地址</mark>复制一份，放入串池，并返回串池中的引用地址</li></ul><p>参考文章：<a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">美团技术团队之深入解析String#intern</a></p><h3 id="10-5-4-关于intern-的练习题"><a href="#10-5-4-关于intern-的练习题" class="headerlink" title="10.5.4 关于intern()的练习题"></a>10.5.4 关于intern()的练习题</h3><p><font color=blue><strong>练习 1</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  20:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// String x = &quot;ab&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();<span class="comment">//jdk6中：在串池中创建一个字符串&quot;ab&quot;</span></span><br><span class="line">                               <span class="comment">//jdk8中：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，将此引用返回</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图解：</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302152325818.png" alt="image-20200711150859709"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302152325636.png" alt="image-20200711151326909"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302152325339.png" alt="image-20200711151433277"></p><p><font color=blue><strong>练习2</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 10行：false</span></span><br><span class="line"><span class="comment"> * 11行：jdk6:false jdk7/8:true </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  20:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);<span class="comment">//执行完以后，会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line"><span class="comment">//        String s1 = new String(&quot;a&quot;) + new String(&quot;b&quot;);////执行完以后，不会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line">        s1.intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-5-5-intern-的效率测试：空间角度"><a href="#10-5-5-intern-的效率测试：空间角度" class="headerlink" title="10.5.5 intern 的效率测试：空间角度"></a>10.5.5 intern 的效率测试：空间角度</h3><p>我们通过测试一下，使用了 intern 和不使用的时候，其实相差还挺多的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用intern()测试执行效率：空间使用上</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  21:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>   <span class="title class_">StringIntern2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[MAX_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] data = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line"><span class="comment">//            arr[i] = new String(String.valueOf(data[i % data.length]));</span></span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])).intern();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用Jprofiler或者JVisualVM观察String对象的创建情况：</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302152324463.png"></p><p><strong>结论</strong>：对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用 intern()方法能够节省内存空间。</p><p><strong>分析：<font color=orange>为什么可以降低内存呢？</font></strong></p><p>调用intern()会导致，每次会使用常量池中的对象。虽然堆空间中也创建了，但是我们用的是常量池中的，堆空间中的那份因为没有人使用之后就会被GC，从而可以降低内存</p><p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用 intern()方法，就会很明显降低内存的大小。</p><h2 id="10-6-StringTable-的垃圾回收"><a href="#10-6-StringTable-的垃圾回收" class="headerlink" title="10.6. StringTable 的垃圾回收"></a>10.6. StringTable 的垃圾回收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的垃圾回收:</span></span><br><span class="line"><span class="comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  21:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringGCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">            String.valueOf(j).intern(); <span class="comment">//通过源码可知 等价于 new String(..).intern()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302152324471.png" alt="image-20230215210718685"></p><h2 id="10-7-G1-中的-String-去重操作"><a href="#10-7-G1-中的-String-去重操作" class="headerlink" title="10.7. G1 中的 String 去重操作"></a>10.7. G1 中的 String 去重操作</h2><p>官网地址：<a href="http://openjdk.java.net/jeps/192">JEP 192: String Deduplication in G1 (java.net)</a></p><blockquote><h2 id="Motivation-1"><a href="#Motivation-1" class="headerlink" title="Motivation"></a>Motivation</h2><p>Many large-scale Java applications are currently bottlenecked on memory. Measurements have shown that roughly 25% of the Java heap live data set in these types of applications is consumed by <code>String</code> objects. Further, roughly half of those <code>String</code> objects are duplicates, where duplicates means <code>string1.equals(string2)</code> is true. Having duplicate <code>String</code> objects on the heap is, essentially, just a waste of memory. This project will implement automatic and continuous <code>String</code> deduplication in the G1 garbage collector to avoid wasting memory and reduce the memory footprint.</p></blockquote><p>目前，许多大规模的 Java 应用程序在内存上遇到了瓶颈。测量表明，在这些类型的应用程序中，大约 25%的 Java 堆实时数据集被<code>String&#39;对象所消耗。此外，这些 &quot;String &quot;对象中大约有一半是重复的，其中重复意味着 &quot;string1.equals(string2) &quot;是真的。在堆上有重复的</code>String’对象，从本质上讲，只是一种内存的浪费。这个项目将在 G1 垃圾收集器中实现自动和持续的&#96;String’重复数据删除，以避免浪费内存，减少内存占用。</p><hr><p>注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复</p><p>背景：对许多 Java 应用（有大的也有小的）做的测试得出以下结果：</p><ul><li>堆存活数据集合里面 string 对象占了 25%</li><li>堆存活数据集合里面重复的 string 对象有 13.5%</li><li>string 对象的平均长度是 45</li></ul><p>许多大规模的 Java 应用的瓶颈在于内存，测试表明，在这些类型的应用里面，<mark>Java 堆中存活的数据集合差不多 25%是 String 对象</mark>。更进一步，这里面差不多一半 string 对象是重复的，重复的意思是说： <code>stringl.equals(string2)= true</code>。<mark>堆上存在重复的 String 对象必然是一种内存的浪费</mark>。这个项目将在 G1 垃圾收集器中实现自动持续对重复的 string 对象进行去重，这样就能避免浪费内存。</p><p><strong>实现</strong></p><ol><li>当垃圾收集器工作的时候，会访问堆上存活的对象。<mark>对每一个访问的对象都会检查是否是候选的要去重的 String 对象</mark></li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的 string 对象。</li><li>使用一个 hashtable 来记录所有的被 String 对象使用的不重复的 char 数组。当去重的时候，会查这个 hashtable，来看堆上是否已经存在一个一模一样的 char 数组。</li><li>如果存在，String 对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char 数组会被插入到 hashtable，这样以后的时候就可以共享这个数组了。</li></ol><p><strong>命令行选项</strong></p><ul><li>UseStringDeduplication(bool) ：开启String去重，默认是不开启的，需要手动开启。</li><li>PrintStringDeduplicationStatistics(bool)  ：打印详细的去重统计信息</li><li>StringpeDuplicationAgeThreshold(uintx)：达到这个年龄的String对象被认为是去重的候选对象</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九、执行引擎</title>
      <link href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC09%E7%AB%A0_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
      <url>/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC09%E7%AB%A0_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="9-执行引擎"><a href="#9-执行引擎" class="headerlink" title="9. 执行引擎"></a>9. 执行引擎</h1><h2 id="9-1-执行引擎概述"><a href="#9-1-执行引擎概述" class="headerlink" title="9.1. 执行引擎概述"></a>9.1. 执行引擎概述</h2><p>执行引擎属于 JVM 的下层，里面包括<mark>解释器、及时编译器、垃圾回收器</mark></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9c0459b0f80a1c9bb534418b8e5a4ddd.png" alt="image-20200710080707873"></p><p>执行引擎是 Java 虚拟机核心的组成部分之一。</p><p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是&#x3D;&#x3D;物理机的执行引擎是直接建立在&#x3D;&#x3D;处理器、缓存、指令集和&#x3D;&#x3D;操作系统层面上的&#x3D;&#x3D;，而<mark>虚拟机的执行引擎则是由软件自行实现的</mark>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<mark>能够执行那些不被硬件直接支持的指令集格式</mark>。</p><p>JVM 的主要任务是负责<mark>装载字节码到其内部</mark>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被 JVM 所识别的字节码指令、符号表，以及其他辅助信息。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b28ff1d82bc72999d1cbbae3f419673d.png" alt="image-20200710081118053"></p><p>那么，如果想要让一个 Java 程序运行起来，执行引擎（Execution Engine）的任务就是<mark>将字节码指令解释&#x2F;编译为对应平台上的本地机器指令</mark>才可以。简单来说，JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202206261759338.png" alt="image-20220626175902352"></p><h3 id="9-1-1-执行引擎的工作流程"><a href="#9-1-1-执行引擎的工作流程" class="headerlink" title="9.1.1. 执行引擎的工作流程"></a>9.1.1. 执行引擎的工作流程</h3><ol><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于 PC 寄存器。</li><li>每当执行完一项指令操作后，PC 寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在 Java 堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/a03c1910e508456b690ec9088300de5f.png" alt="image-20200710081627217"></p><p>从外观上来看，所有的 Java 虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。</p><h2 id="9-2-Java-代码编译和执行过程"><a href="#9-2-Java-代码编译和执行过程" class="headerlink" title="9.2. Java 代码编译和执行过程"></a>9.2. Java 代码编译和执行过程</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207060113044.jpg"></p><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p><p>Java 代码编译是由 Java 源码编译器（<mark>前端编译器</mark>）来完成，最终形成一个线性字节码指令流。流程图如下所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/93e5f0b67767b7d783ace2471447f449.png" alt="image-20200710082433146"></p><p>Java 字节码的执行是由 JVM 执行引擎（<mark>后端编译器</mark>）来完成，流程图 如下所示</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bf1139f9652e2a1ac0cab00df869e23e.png" alt="image-20200710083036258"></p><h3 id="9-2-1-什么是解释器（Interpreter）？什么是-JIT-编译器？"><a href="#9-2-1-什么是解释器（Interpreter）？什么是-JIT-编译器？" class="headerlink" title="9.2.1. 什么是解释器（Interpreter）？什么是 JIT 编译器？"></a>9.2.1. 什么是解释器（Interpreter）？什么是 JIT 编译器？</h3><p>解释器：当 Java 虚拟机启动时会根据预定义的规范<mark>对字节码采用逐行解释的方式执行</mark>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p><h3 id="9-2-2-为什么-Java-是半编译半解释型语言？"><a href="#9-2-2-为什么-Java-是半编译半解释型语言？" class="headerlink" title="9.2.2. 为什么 Java 是半编译半解释型语言？"></a>9.2.2. 为什么 Java 是半编译半解释型语言？</h3><p>JDK1.0 时代，将 Java 语言定位为“解释执行”还是比较准确的。再后来，Java 也发展出可以直接生成本地代码的编译器。现在 JVM 在执行 Java 代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p><p><strong>图示</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202206261820153.jpg"></p><h2 id="9-3-机器码、指令、汇编语言"><a href="#9-3-机器码、指令、汇编语言" class="headerlink" title="9.3. 机器码、指令、汇编语言"></a>9.3. 机器码、指令、汇编语言</h2><h3 id="9-3-1-机器码"><a href="#9-3-1-机器码" class="headerlink" title="9.3.1. 机器码"></a>9.3.1. 机器码</h3><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</p><p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</p><p>用它编写的程序一经输入计算机，CPU 直接读取运行，因此和其他语言编的程序相比，执行速度最快。</p><p>机器指令与 CPU 紧密相关，所以不同种类的 CPU 所对应的机器指令也就不同。</p><h3 id="9-3-2-指令"><a href="#9-3-2-指令" class="headerlink" title="9.3.2. 指令"></a>9.3.2. 指令</h3><p>由于机器码是有 0 和 1 组成的二进制序列，可读性实在太差，于是人们发明了指令。</p><p>指令就是把机器码中特定的 0 和 1 序列，简化成对应的指令（一般为英文简写，如 mov，inc 等），可读性稍好</p><p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如 mov），对应的机器码也可能不同。</p><h3 id="9-3-3-指令集"><a href="#9-3-3-指令集" class="headerlink" title="9.3.3. 指令集"></a>9.3.3. 指令集</h3><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的</p><ul><li>x86 指令集，对应的是 x86 架构的平台</li><li>ARM 指令集，对应的是 ARM 架构的平台</li></ul><h3 id="9-3-4-汇编语言"><a href="#9-3-4-汇编语言" class="headerlink" title="9.3.4. 汇编语言"></a>9.3.4. 汇编语言</h3><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p><p>在汇编语言中，<mark>用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址</mark>。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p><p>由于计算机只认识指令码，所以用<mark>汇编语言编写的程序还必须翻译成机器指令码</mark>，计算机才能识别和执行。</p><h3 id="9-3-5-高级语言"><a href="#9-3-5-高级语言" class="headerlink" title="9.3.5. 高级语言"></a>9.3.5. 高级语言</h3><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言<mark>更接近人的语言</mark></p><p>当计算机执行高级语言编写的程序时，<mark>仍然需要把程序解释和编译成机器的指令码</mark>。完成这个过程的程序就叫做解释程序或编译程序。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202206261820278.jpg"></p><p>高级语言也不是直接翻译成机器指令，而是翻译成汇编语言码，如下面说的 C 和 C++</p><h4 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h4><p>编译过程又可以分成两个阶段：<strong>编译</strong>和<strong>汇编</strong>。</p><p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p><p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/71d4298a250e724d64d78a2d8ec67cdc.png" alt="image-20200710085553258"></p><h3 id="9-3-6-字节码"><a href="#9-3-6-字节码" class="headerlink" title="9.3.6. 字节码"></a>9.3.6. 字节码</h3><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p><p>字节码主要为了实现特定软件运行和软件环境、<mark>与硬件环境无关</mark>。</p><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。字节码典型的应用为：Java bytecode</p><p><img src="https://img-blog.csdnimg.cn/img_convert/cba8c417f20ae9f6671e64574d2e229a.png" alt="image-20210511092336091"></p><h2 id="9-4-解释器"><a href="#9-4-解释器" class="headerlink" title="9.4. 解释器"></a>9.4. 解释器</h2><p>JVM 设计者们的初衷仅仅只是单纯地为了<mark>满足 Java 程序实现跨平台特性</mark>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202206261821829.jpg"></p><p>为什么 Java 源文件不直接翻译成 JMV，而是翻译成字节码文件？可能是因为直接翻译的代价是比较大的</p><h3 id="9-4-1-解释器工作机制"><a href="#9-4-1-解释器工作机制" class="headerlink" title="9.4.1. 解释器工作机制"></a>9.4.1. 解释器工作机制</h3><p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><p>当一条字节码指令被解释执行完成后，接着再根据 PC 寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p><h3 id="9-4-2-解释器分类"><a href="#9-4-2-解释器分类" class="headerlink" title="9.4.2. 解释器分类"></a>9.4.2. 解释器分类</h3><p>在 Java 的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p><ul><li>字节码解释器在执行时通过<mark>纯软件代码模拟字节码</mark>的执行，效率非常低下。</li><li>而模板解释器将<mark>每一条字节码和一个模板函数相关联</mark>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</li></ul><p>在 HotSpot VM 中，解释器主要由 Interpreter 模块和 Code 模块构成。</p><ul><li>Interpreter 模块：实现了解释器的核心功能</li><li>Code 模块：用于管理 HotSpot VM 在运行时生成的本地机器指令</li></ul><h3 id="9-4-3-现状"><a href="#9-4-3-现状" class="headerlink" title="9.4.3. 现状"></a>9.4.3. 现状</h3><p>由于解释器在设计和实现上非常简单，因此除了 Java 语言之外，还有许多高级语言同样也是基于解释器执行的，比如 Python、Perl、Ruby 等。但是在今天，<mark>基于解释器执行已经沦落为低效的代名词</mark>，并且时常被一些 C&#x2F;C++程序员所调侃。</p><p>为了解决这个问题，JVM 平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是<mark>将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可</mark>，这种方式可以使执行效率大幅度提升。</p><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p><h2 id="9-5-JIT-编译器"><a href="#9-5-JIT-编译器" class="headerlink" title="9.5. JIT 编译器"></a>9.5. JIT 编译器</h2><h3 id="9-5-1-Java-代码的执行分类"><a href="#9-5-1-Java-代码的执行分类" class="headerlink" title="9.5.1. Java 代码的执行分类"></a>9.5.1. Java 代码的执行分类</h3><ul><li><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p></li><li><p>第二种是编译执行（直接编译成机器码，但是要知道不同机器上编译的机器码是不一样，而字节码是可以跨平台的）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p></li></ul><p>HotSpot VM 是目前市面上高性能虚拟机的代表作之一。它采用<mark>解释器与即时编译器并存的架构</mark>。在 Java 虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p><p>在今天，Java 程序的运行性能早已脱胎换骨，已经达到了可以和 C&#x2F;C++ 程序一较高下的地步。</p><p><strong>问题来了</strong></p><p>有些开发人员会感觉到诧异，<mark>既然 HotSpot VM 中已经内置 JIT 编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？</mark>比如 JRockit VM 内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p><p>首先明确： &#x3D;&#x3D;当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行&#x3D;&#x3D; (响应速度快)。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p><p>所以： 尽管 JRockit VM 中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，<mark>当 Java 虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间</mark>。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p><p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p><h3 id="9-5-2-HotSpot-JVM-执行方式"><a href="#9-5-2-HotSpot-JVM-执行方式" class="headerlink" title="9.5.2. HotSpot JVM 执行方式"></a>9.5.2. HotSpot JVM 执行方式</h3><p>当虚拟机启动的时候，<mark>解释器可以首先发挥作用</mark>，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，<mark>将有价值的字节码编译为本地机器指令</mark>，以换取更高的程序执行效率。</p><p><strong>案例来了</strong></p><p>注意解释执行与编译执行在线上环境微妙的辩证关系。<mark>机器在热机状态可以承受的负载要大于冷机状态</mark>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p><p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的 1&#x2F;8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的 JVM 均是解释执行，还没有进行热点代码统计和 JIT 动态编译，导致机器启动之后，当前 1&#x2F;2 发布成功的服务器马上全部宕机， 此故障说明了 JIT 的存在。—阿里团队</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7f26fbc3a6ec701fe4f84eea99811540.png" alt="image-20200710095417462"></p><h3 id="9-5-3-概念解释"><a href="#9-5-3-概念解释" class="headerlink" title="9.5.3. 概念解释"></a>9.5.3. 概念解释</h3><p>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个<mark>前端编译器</mark>（其实叫“编译器的前端”更准确一些）把.java 文件转变成.class 文件的过程；</p><p>也可能是指虚拟机的<mark>后端运行期编译器</mark>（JIT 编译器，Just In Time Compiler）把字节码转变成机器码的过程。</p><p>还可能是指使用<mark>静态提前编译器</mark>（AOT 编译器，Ahead of Time Compiler）直接把.java 文件编译成本地机器代码的过程。</p><ul><li><p>前端编译器：Sun 的 Javac、Eclipse JDT 中的增量式编译器（ECJ）。</p></li><li><p>JIT 编译器：HotSpot VM 的 C1、C2 编译器。</p></li><li><p>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</p></li></ul><h3 id="9-5-4-热点代码及探测技术"><a href="#9-5-4-热点代码及探测技术" class="headerlink" title="9.5.4. 热点代码及探测技术"></a>9.5.4. 热点代码及探测技术</h3><p>当然是否需要启动 JIT 编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT 编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升 Java 程序的执行性能。</p><p><mark>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</mark>，因此都可以通过 JIT 编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为<mark>OSR（On Stack Replacement）编译</mark>。</p><p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT 编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<mark>热点探测功能</mark>。</p><p><mark>目前 HotSpot VM 所采用的热点探测方式是基于计数器的热点探测</mark>。</p><p>采用基于计数器的热点探测，HotSpot VM 将会为每一个方法都建立 2 个不同类型的计数器，分别为<mark>方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）</mark>。</p><ul><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ul><h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在 Client 模式下是 1500 次，在 Server 模式下是 10000 次。超过这个阈值，就会触发 JIT 编译。</p><p>这个阀值可以通过虚拟机参数 <code>-XX:CompileThreshold</code>来人为设定。</p><p>当一个方法被调用时，会先检查该方法是否存在被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加 1，然后判断<mark>方法调用计数器与回边计数器值之和</mark>是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207060113103.jpg"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/26dc8459b4b31e3d9c40b3aec10b15cd.png" alt="image-20200710101829934"></p><h4 id="热点衰减"><a href="#热点衰减" class="headerlink" title="热点衰减"></a>热点衰减</h4><p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<mark>一段时间之内方法被调用的次数</mark>。当超过<mark>一定的时间限度</mark>，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的<mark>衰减（Counter Decay）</mark>，而这段时间就称为此方法统计的<mark>半衰周期（Counter Half Life Time）</mark></p><p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 <code>-XX:-UseCounterDecay</code> 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p><p>另外，可以使用<code>-XX:CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</p><h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>它的作用是统计一个<mark>方法中循环体代码执行的次数</mark>，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发 OSR 编译。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202206261822656.jpg"></p><h3 id="9-5-5-HotSpotVM-可以设置程序执行方法"><a href="#9-5-5-HotSpotVM-可以设置程序执行方法" class="headerlink" title="9.5.5. HotSpotVM 可以设置程序执行方法"></a>9.5.5. HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下 HotSpot VM 是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为 Java 虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li><code>-Xint</code>：完全采用解释器模式执行程序；</li><li><code>-Xcomp</code>：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li><code>-Xmixed</code>：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><h3 id="9-5-6-HotSpotVM-中-JIT-分类"><a href="#9-5-6-HotSpotVM-中-JIT-分类" class="headerlink" title="9.5.6. HotSpotVM 中 JIT 分类"></a>9.5.6. HotSpotVM 中 JIT 分类</h3><p>JIT 的编译器还分为了两种，分别是 C1 和 C2，在 HotSpot VM 中内嵌有两个 JIT 编译器，分别为 Client Compiler 和 Server Compiler，但大多数情况下我们简称为 C1 编译器 和 C2 编译器。开发人员可以通过如下命令显式指定 Java 虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li><code>-client</code>：指定 Java 虚拟机运行在 Client 模式下，并使用 C1 编译器；C1 编译器会对字节码<mark>进行简单和可靠的优化，耗时短</mark>，以达到更快的编译速度。</li><li><code>-server</code>：指定 Java 虚拟机运行在 server 模式下，并使用 C2 编译器。C2<mark>进行耗时较长的优化，以及激进优化</mark>，但优化的代码执行效率更高。</li></ul><p><mark>分层编译（Tiered Compilation）策略</mark>：程序解释执行（不开启性能监控）可以触发 C1 编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2 编译会根据性能监控信息进行激进优化。</p><p>不过在 Java7 版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由 C1 编译器和 C2 编译器相互协作共同来执行编译任务。</p><h4 id="C1-和-C2-编译器不同的优化策略"><a href="#C1-和-C2-编译器不同的优化策略" class="headerlink" title="C1 和 C2 编译器不同的优化策略"></a>C1 和 C2 编译器不同的优化策略</h4><p>在不同的编译器上有不同的优化策略，C1 编译器上主要有<mark>方法内联、去虚拟化、冗余消除</mark>。（轻量优化）</p><ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现类进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul><p>C2 的优化主要是在全局层面，逃逸分析（前面讲过，并不成熟）是优化的基础。基于逃逸分析在 C2 上有如下几种优化：</p><ul><li><mark>标量替换</mark>：用标量值代替聚合对象的属性值</li><li><mark>栈上分配</mark>：对于未逃逸的对象分配对象在栈而不是堆</li><li><mark>同步消除</mark>：清除同步操作，通常指 synchronized</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般来讲，JIT 编译出来的机器码性能比解释器高。C2 编译器启动时长比 C1 慢，系统稳定执行以后，C2 编译器执行速度远快于 C1 编译器</p><h3 id="写到最后-1：Graal-编译器"><a href="#写到最后-1：Graal-编译器" class="headerlink" title="写到最后 1：Graal 编译器"></a>写到最后 1：Graal 编译器</h3><ul><li>自 JDK10 起，HotSpot 又加入了一个全新的及时编译器：Graal 编译器</li><li>编译效果短短几年时间就追评了 C2 编译器，未来可期</li><li>目前，带着实验状态标签，需要使用开关参数<code>-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</code>去激活才能使用</li></ul><h3 id="写到最后-2：AOT-编译器"><a href="#写到最后-2：AOT-编译器" class="headerlink" title="写到最后 2：AOT 编译器"></a>写到最后 2：AOT 编译器</h3><p>jdk9 引入了 AOT 编译器（静态提前编译器，Ahead of Time Compiler）</p><p>Java 9 引入了实验性 AOT 编译工具 jaotc。它借助了 Graal 编译器，将所输入的 Java 类文件转换为机器码，并存放至生成的动态共享库之中。</p><p>所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，<mark>即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码</mark>，并部署至托管环境中的过程。而<mark>AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</mark></p><p>最大的好处：Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少 Java 应用给人带来“第一次运行慢” 的不良体验</p><p>缺点：</p><ul><li><mark>破坏了 java “ 一次编译，到处运行”的理念</mark>，必须为每个不同的硬件，OS 编译对应的发行包（因为不同平台的机器码是千差万别的）</li><li><mark>降低了 Java 链接过程的动态性</mark>，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持 Linux X64 java base</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八、对象实例化与直接内存</title>
      <link href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC08%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8F%8A%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/"/>
      <url>/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC08%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8F%8A%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="8-对象实例化及直接内存"><a href="#8-对象实例化及直接内存" class="headerlink" title="8. 对象实例化及直接内存"></a>8. 对象实例化及直接内存</h1><h2 id="8-1-对象实例化"><a href="#8-1-对象实例化" class="headerlink" title="8.1. 对象实例化"></a>8.1. 对象实例化</h2><p><strong>面试题</strong></p><blockquote><p><mark>美团</mark>：</p><p>对象在 JVM 中是怎么存储的？</p><p>对象头信息里面有哪些东西？</p><p><mark>蚂蚁金服</mark>：</p><p>Java 对象头有什么？</p></blockquote><h3 id="8-1-1-创建对象的方式"><a href="#8-1-1-创建对象的方式" class="headerlink" title="8.1.1. 创建对象的方式"></a>8.1.1. 创建对象的方式</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204241107371.png" alt="image-20220424110601507"></p><p><strong>代码演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  17:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果分析</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204241110845.png" alt="从字节码角度看对象创建过程"></p><h3 id="8-1-2-创建对象的步骤"><a href="#8-1-2-创建对象的步骤" class="headerlink" title="8.1.2. 创建对象的步骤"></a>8.1.2. 创建对象的步骤</h3><p>前面所述是从字节码角度看待对象的创建过程，现在从执行步骤的角度来分析：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204241107445.png" alt="image-20220424110627952"></p><h4 id="1-判断对象对应的类是否加载、链接、初始化"><a href="#1-判断对象对应的类是否加载、链接、初始化" class="headerlink" title="1. 判断对象对应的类是否加载、链接、初始化"></a>1. 判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条 new 指令，首先去检查这个指令的参数能否在 Metaspace 的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。</p><p>如果没有，那么在双亲委派模式下，使用当前类加载器以 ClassLoader + 包名 + 类名为 key 进行查找对应的 .class 文件；</p><ul><li>如果没有找到文件，则抛出 ClassNotFoundException 异常</li><li>如果找到，则进行类加载，并生成对应的 Class 对象</li></ul><h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2. 为对象分配内存"></a>2. 为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即 4 个字节大小 (引用变量只保存引用，所以大小能确定，而非引用变量大小都是固定的。)</p><p><strong>如果内存规整</strong>：虚拟机将采用的是<mark>指针碰撞法（Bump The Point）</mark>来为对象分配内存。</p><ul><li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是 Serial ，ParNew 这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带 Compact（整理）过程的收集器时，使用指针碰撞。</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204241136006.png" alt="指针碰撞"></p><p><strong>如果内存不规整</strong>：虚拟机需要维护一个<mark>空闲列表（Free List）</mark>来为对象分配内存。</p><ul><li>已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。</li></ul><p>&#x3D;&#x3D;选择哪种分配方式由 Java 堆是否规整所决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定&#x3D;&#x3D;。</p><h4 id="3-处理并发问题"><a href="#3-处理并发问题" class="headerlink" title="3. 处理并发问题"></a>3. 处理并发问题</h4><ul><li>采用 CAS(自旋锁) 失败重试、区域加锁保证更新的原子性</li><li>每个线程预先分配一块 TLAB：通过设置 <code>-XX:+UseTLAB</code>参数来设定</li></ul><h4 id="4-初始化分配到的内存-赋默认初始值"><a href="#4-初始化分配到的内存-赋默认初始值" class="headerlink" title="4. 初始化分配到的内存(赋默认初始值)"></a>4. 初始化分配到的内存(赋默认初始值)</h4><p>所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用</p><p>**举例:**对于基本数据类型byte,short,int,long,float,double为0,布尔类型为false,引用类型默认为NULL</p><h4 id="5-设置对象的对象头"><a href="#5-设置对象的对象头" class="headerlink" title="5. 设置对象的对象头"></a>5. 设置对象的对象头</h4><p>将对象的所属类（即类的元数据信息）、对象的 HashCode 和对象的 GC 信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于 JVM 实现。</p><h4 id="6-执行-init-方法进行初始化"><a href="#6-执行-init-方法进行初始化" class="headerlink" title="6. 执行 init 方法进行初始化"></a>6. 执行 init 方法进行初始化</h4><p>在 Java 程序的视角看来，初始化才正式开始。<mark>初始化成员变量，执行实例化代码块，调用类的构造方法</mark>，并把堆内对象的首地址赋值给引用变量。</p><p>因此一般来说（由字节码中跟随 invokespecial 指令所决定），&#x3D;&#x3D;new 指令之后会接着就是执行构造方法，把对象按照程序员的意愿进行初始化&#x3D;&#x3D;，这样一个真正可用的对象才算完成创建出来。</p><p><strong>补充:给对象属性赋值的操作</strong></p><p>① 属性的默认初始化(第4步) - ② 显式初始化 &#x2F; ③ 代码块中初始化 &#x2F; ④ 构造器中初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  给对象的属性赋值的操作：</span></span><br><span class="line"><span class="comment"> *  ① 属性的默认初始化 - ② 显式初始化 / ③ 代码块中初始化 - ④ 构造器中初始化</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 区别下两类构造器</span></span><br><span class="line"><span class="comment"> &lt;client&gt;类构造器:静态数据初始化 </span></span><br><span class="line"><span class="comment"> &lt;init&gt;实例构造器:非静态数据的初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  17:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;匿名客户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span>&#123;</span><br><span class="line">        acct = <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示初始化、代码块初始化、构造器中初始化都在<init>方法中进行</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204241208566.png" alt="初始化步骤"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>对象实例化的过程</strong></p><ol><li>加载类元信息</li><li>为对象分配内存</li><li>处理并发问题</li><li>属性的默认初始化（零值初始化）</li><li>设置对象头信息</li><li>属性的显示初始化、代码块中初始化、构造器中初始化</li></ol><h2 id="8-2-对象内存布局"><a href="#8-2-对象内存布局" class="headerlink" title="8.2. 对象内存布局"></a>8.2. 对象内存布局</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204241219545.jpg"></p><h3 id="8-2-1-对象头（Header）"><a href="#8-2-1-对象头（Header）" class="headerlink" title="8.2.1. 对象头（Header）"></a>8.2.1. 对象头（Header）</h3><p>对象头包含了两部分，分别是<mark>运行时元数据（Mark Word）</mark>和<mark>类型指针</mark>。如果是数组，还需要记录数组的长度</p><h4 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h4><ul><li>哈希值（HashCode）</li><li>GC 分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程 ID</li><li>翩向时间戳</li></ul><h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指向类元数据 InstanceKlass，确定该对象所属的类型。</p><h3 id="8-2-2-实例数据（Instance-Data）"><a href="#8-2-2-实例数据（Instance-Data）" class="headerlink" title="8.2.2. 实例数据（Instance Data）"></a>8.2.2. 实例数据（Instance Data）</h3><p>它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）</p><ul><li>相同宽度的字段总是被分配在一起</li><li>父类中定义的变量会出现在子类之前</li><li>如果 CompactFields 参数为 true（默认为 true）：子类的窄变量可能插入到父类变量的空隙</li></ul><h3 id="8-2-3-对齐填充（Padding）"><a href="#8-2-3-对齐填充（Padding）" class="headerlink" title="8.2.3. 对齐填充（Padding）"></a>8.2.3. 对齐填充（Padding）</h3><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;匿名客户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span> &#123;</span><br><span class="line">        acct = <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span>&#123;</span><br><span class="line">        Customer cust=<span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图示</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202206261812887.jpg"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/3be25c48b29d3cef51354f19cbe31d7d.png" alt="image-20210510225407119"></p><h2 id="8-3-对象的访问定位"><a href="#8-3-对象的访问定位" class="headerlink" title="8.3. 对象的访问定位"></a>8.3. 对象的访问定位</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202206261805696.jpg"></p><p>JVM 是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p><p><img src="https://img-blog.csdnimg.cn/img_convert/deab7773248ea150e5f7dee3901700cd.png" alt="image-20200709164149920"></p><h3 id="8-3-1-句柄访问"><a href="#8-3-1-句柄访问" class="headerlink" title="8.3.1. 句柄访问"></a>8.3.1. 句柄访问</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202206261806664.jpg"></p><p><strong>优点：</strong>reference 中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference 本身不需要被修改</p><p><strong>缺点：</strong>需要专门开辟一片空间用于句柄池，耗费空间多一点。访问时，需要先通过栈中引用找到句柄变量，再从句柄变量访问到对象实例，效率较低。</p><h3 id="8-3-2-直接指针（HotSpot-采用）"><a href="#8-3-2-直接指针（HotSpot-采用）" class="headerlink" title="8.3.2. 直接指针（HotSpot 采用）"></a>8.3.2. 直接指针（HotSpot 采用）</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202206261807975.jpg"></p><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p><p><strong>优点：</strong>栈中局部变量直指堆中实例，访问效率更高。也不需要专门开辟空间记录句柄。</p><p><strong>缺点：</strong>对象被移动时（垃圾收集时移动对象很普遍），reference 会改变。</p><h2 id="8-4-直接内存（Direct-Memory）"><a href="#8-4-直接内存（Direct-Memory）" class="headerlink" title="8.4. 直接内存（Direct Memory）"></a>8.4. 直接内存（Direct Memory）</h2><h3 id="8-4-1-直接内存概述"><a href="#8-4-1-直接内存概述" class="headerlink" title="8.4.1. 直接内存概述"></a>8.4.1. 直接内存概述</h3><ul><li>不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。</li><li><mark>直接内存是在 Java 堆外的、直接向系统申请的内存区间</mark>。</li><li>来源于 NIO，通过存在堆中的 DirectByteBuffer 操作 Native 内存。</li><li>通常，访问直接内存的速度会优于 Java 堆，即<mark>读写性能高</mark>。<ul><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li><li>Java 的 NIO 库允许 Java 程序使用直接内存，用于数据缓冲区</li></ul></li></ul><h3 id="8-4-2-非直接缓存区-传统的IO"><a href="#8-4-2-非直接缓存区-传统的IO" class="headerlink" title="8.4.2. 非直接缓存区(传统的IO)"></a>8.4.2. 非直接缓存区(传统的IO)</h3><p>使用 IO 读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要两份内存存储重复数据，效率低。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c691d62d73e977fb942748a81313f5e6.png" alt="image-20210510231408607"></p><h3 id="8-4-3-直接缓存区"><a href="#8-4-3-直接缓存区" class="headerlink" title="8.4.3. 直接缓存区"></a>8.4.3. 直接缓存区</h3><p>使用 NIO 时，操作系统划出的直接缓存区可以被 java 代码直接访问，只有一份。NIO 适合对大文件的读写操作。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d13b08447999ab32811a440496e4dac7.png" alt="image-20210510231456550"></p><p>也可能导致 OutOfMemoryError 异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">    at java.nio.Bits.reserveMemory(Bits.java:<span class="number">693</span>)</span><br><span class="line">    at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:<span class="number">123</span>)</span><br><span class="line">    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:<span class="number">311</span>)</span><br><span class="line">    at com.atguigu.java.BufferTest2.main(BufferTest2.java:<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>由于直接内存在 Java 堆外，因此它的大小不会直接受限于-Xmx 指定的最大堆大小，但是系统内存是有限的，Java 堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p><ul><li>分配回收成本较高</li><li>不受 JVM 内存回收管理</li></ul><p>直接内存大小可以通过<code>MaxDirectMemorySize</code>设置。如果不指定，默认与堆的最大值-Xmx 参数值一致</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0ac6c50a98325c93b5652602137b9dea.png" alt="image-20200709230647277"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七、方法区</title>
      <link href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC07%E7%AB%A0_%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
      <url>/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC07%E7%AB%A0_%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="7-方法区"><a href="#7-方法区" class="headerlink" title="7. 方法区"></a>7. 方法区</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204021827492.png" alt="image-20220402182731301"></p><p>从线程共享与否的角度来看</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f356e103d9f75e3c0086079bba2b28a9.png" alt="image-20210510141131860"></p><h2 id="7-1-栈、堆、方法区的交互关系"><a href="#7-1-栈、堆、方法区的交互关系" class="headerlink" title="7.1. 栈、堆、方法区的交互关系"></a>7.1. 栈、堆、方法区的交互关系</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204021826461.png" alt="image-20200708094747667"></p><h2 id="7-2-方法区的理解"><a href="#7-2-方法区的理解" class="headerlink" title="7.2. 方法区的理解"></a>7.2. 方法区的理解</h2><p>官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">Chapter 2. The Structure of the Java Virtual Machine (oracle.com)</a></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204201656695.png" alt="image-20210510195446194"></p><h3 id="7-2-1-方法区在哪里？"><a href="#7-2-1-方法区在哪里？" class="headerlink" title="7.2.1. 方法区在哪里？"></a>7.2.1. 方法区在哪里？</h3><p>《Java 虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于 HotSpotJVM 而言，方法区还有一个别名叫做 Non-Heap（非堆），目的就是要和堆分开。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204021830003.png" alt="image-20220402183005410"></p><p>所以，<mark>方法区看作是一块独立于 Java 堆的内存空间</mark>。</p><p>代码层面也可以进行演示:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204201655492.png" alt="image-20220420165511101"></p><hr><h3 id="7-2-2-方法区的基本理解"><a href="#7-2-2-方法区的基本理解" class="headerlink" title="7.2.2. 方法区的基本理解"></a>7.2.2. 方法区的基本理解</h3><ul><li>方法区（Method Area）与 Java 堆一样，是各个&#x3D;&#x3D;线程共享&#x3D;&#x3D;的内存区域。(当多个线程都需要调用某个类时,并且该类没有被加载,只需要其中一个线程加载即可)</li><li>方法区在 JVM 启动的时候被创建，并且它的实际的物理内存空间中和 Java 堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>&#x3D;&#x3D;方法区的大小决定了系统可以保存多少个类&#x3D;&#x3D;，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutOfMemoryError: PermGen space</code> 或者<code>java.lang.OutOfMemoryError: Metaspace</code><ul><li><mark>加载大量的第三方的 jar 包；Tomcat 部署的工程过多（30~50 个）；大量动态的生成反射类</mark></li></ul></li><li>关闭 JVM 就会释放这个区域的内存。</li></ul><h3 id="7-2-3-HotSpot-中方法区的演进"><a href="#7-2-3-HotSpot-中方法区的演进" class="headerlink" title="7.2.3. HotSpot 中方法区的演进"></a>7.2.3. HotSpot 中方法区的演进</h3><p>在 jdk7 及以前，习惯上把方法区，称为永久代。jdk8 开始，使用元空间取代了永久代。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fb71df89c52f89d3b711e0b648de244c.png" alt="image-20210510142516373"></p><p>本质上，方法区和永久代并不等价。仅是对 hotspot 而言的。《Java 虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit &#x2F; IBM J9 中不存在永久代的概念。</p><p><strong>补充:</strong> </p><ul><li><p>&#x3D;&#x3D;可以把方法区看成接口,永久代或者元空间看成其实现&#x3D;&#x3D;</p></li><li><p>元空间是方法区的一种实现.  方法区是一种规范，永久代和元空间是两种不同的实现方式</p></li><li><p>元空间不在虚拟机设置的内存中，而是使用了本地内存</p></li></ul><p>现在来看，当年使用永久代，不是好的 idea。导致 Java 程序更容易 OOM（超过<code>-XX:MaxPermsize</code>上限）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7d0789c206d53bfb4b6004052236197a.png" alt="image-20210510142656677"></p><p>而到了 JDK8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在&#x3D;&#x3D;本地内存中实现的元空间&#x3D;&#x3D;（Metaspace）来代替</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1c229dc39ffc79e8e4f3abf765378d3b.png" alt="image-20200708103055914"></p><p>元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代最大的区别在于：<mark>元空间不在虚拟机设置的内存中，而是使用本地内存</mark> (可以达到几个G..更不容易出现OOM)</p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p><p>根据《Java 虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OOM 异常</p><h2 id="7-3-设置方法区大小与-OOM"><a href="#7-3-设置方法区大小与-OOM" class="headerlink" title="7.3. 设置方法区大小与 OOM"></a>7.3. 设置方法区大小与 OOM</h2><h3 id="7-3-1-设置方法区内存的大小"><a href="#7-3-1-设置方法区内存的大小" class="headerlink" title="7.3.1. 设置方法区内存的大小"></a>7.3.1. 设置方法区内存的大小</h3><p>方法区的大小不必是固定的，JVM 可以根据应用的需要动态调整。</p><p><strong>jdk7 及以前</strong></p><ul><li><mark>通过<code>-XX:Permsize</code>来设置永久代初始分配空间。默认值是 20.75M</mark></li><li><mark>通过<code>-XX:MaxPermsize</code>来设定永久代最大可分配空间。32 位机器默认是 64M，64 位机器模式是 82M</mark></li><li>当 JVM 加载的类信息容量超过了这个值，会报异常<code>OutOfMemoryError:PermGen space</code>。</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204201749353.png" alt="image-20220420174924637"></p><p><strong>JDK8 以后</strong></p><ul><li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code>指定</li><li>默认值依赖于平台。windows 下，<code>-XX:MetaspaceSize=21M -XX:MaxMetaspaceSize=-1//即没有限制</code>。</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>OutOfMemoryError:Metaspace</code></li><li><code>-XX:MetaspaceSize</code>：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的<code>-XX:MetaspaceSize</code>值为 21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过<code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值。</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到 Full GC 多次调用。为了避免频繁地 GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</li></ul><p><strong>代码演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  测试设置方法区大小参数的默认值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  jdk7及以前：</span></span><br><span class="line"><span class="comment"> *  -XX:PermSize=100m -XX:MaxPermSize=100m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  jdk8及以后：</span></span><br><span class="line"><span class="comment"> *  -XX:MetaspaceSize=100m  -XX:MaxMetaspaceSize=100m</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  12:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204201808572.png" alt="image-20220420180823384"></p><p><strong>举例 1：《深入理解 Java 虚拟机》的例子</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204201759992.png" alt="image-20210510143959924"></p><p><strong>举例 2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6/7中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  22:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OOMTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OOMTest</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="type">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204201817879.png" alt="image-20220420181715469"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204201821586.png" alt="image-20220420182126371"></p><h3 id="7-3-2-如何解决这些-OOM"><a href="#7-3-2-如何解决这些-OOM" class="headerlink" title="7.3.2. 如何解决这些 OOM"></a>7.3.2. 如何解决这些 OOM</h3><ol><li><p>要解决 OOM 异常或 heap space 的异常，一般的手段是首先通过内存映像分析工具（如 Eclipse Memory Analyzer）对 dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</p></li><li><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GCRoots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及 GCRoots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p><p><strong>一句话:</strong> 内存泄漏就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</p></li><li><p>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（<code>-Xmx</code>与<code>-Xms</code>），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p></li></ol><h2 id="7-4-方法区的内部结构"><a href="#7-4-方法区的内部结构" class="headerlink" title="7.4. 方法区的内部结构"></a>7.4. 方法区的内部结构</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/8a5fcba10ccb773f185288ac22bde206.png" alt="image-20200708161728320"></p><h3 id="7-4-1-方法区（Method-Area）存储什么？"><a href="#7-4-1-方法区（Method-Area）存储什么？" class="headerlink" title="7.4.1. 方法区（Method Area）存储什么？"></a>7.4.1. 方法区（Method Area）存储什么？</h3><p>《深入理解 Java 虚拟机》书中对方法区（Method Area）存储内容描述如下：</p><blockquote><p>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p></blockquote><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204241024279.jpg" alt="第09章_方法区存储信息"></p><h3 id="7-4-2-方法区的内部结构"><a href="#7-4-2-方法区的内部结构" class="headerlink" title="7.4.2. 方法区的内部结构"></a>7.4.2. 方法区的内部结构</h3><h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：</p><ol><li>这个类型的&#x3D;&#x3D;完整有效名称&#x3D;&#x3D;（全名&#x3D;包名.类名）</li><li>这个类型直接父类的完整有效名（对于 interface 或是 java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final 的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ol><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204201921442.png" alt="image-20220420192128002"></p><h4 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h4><p>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p><p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient 的某个子集）</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204201921517.png" alt="image-20220420192156240"></p><p><strong>问题:方法区包含域信息，也就是包含成员变量？</strong></p><p>&#x3D;&#x3D;只是存放了成员变量的信息，具体的值会和对象一起放在堆中。类变量会存放在方法区&#x3D;&#x3D;</p><h4 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h4><p>JVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ol><li>方法名称</li><li>方法的返回类型（或 void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li><li>异常表（abstract 和 native 方法除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ol><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204222213192.png" alt="image-20220420192831101"></p><p>**备注:**以上代码皆来源于<code>MethodInnerStrucTest</code> 类的字节码文件, 可以通过 <code>javap -v -p Met hodInnerStrucTest.class &gt; test.txt</code> 命令,将字节码导出到文件中,便于观察.</p><ul><li><p>字节码文件中存放着类文件的类型详细信息.(如上所示)</p></li><li><p>类加载器将字节码文件加载到方法区后. 方法区中除了记录着类的详细信息,还包括该类是被哪个类加载器加载的等, 同时类加载器(也是类)也会记录加载了哪些类.</p></li></ul><h4 id="non-final-的类变量"><a href="#non-final-的类变量" class="headerlink" title="non-final 的类变量"></a>non-final 的类变量</h4><ul><li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li><li>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * non-final的类变量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  20:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;执行以上的main方法,并不会报错,amazing!&#x3D;&#x3D;</p><h4 id="补充说明：全局常量（static-final）"><a href="#补充说明：全局常量（static-final）" class="headerlink" title="补充说明：全局常量（static final）"></a>补充说明：全局常量（static final）</h4><p>被声明为 final 的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p><p><strong>通过字节码查看</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码同上面.....</span><br></pre></td></tr></table></figure><ul><li>对比final修饰的变量赋值操作</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204221817397.png" alt="image-20220422181701925"></p><ul><li>查看静态变量赋值操作</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204221826149.png" alt="image-20220422182618724"></p><h3 id="7-4-3-运行时常量池-VS-常量池"><a href="#7-4-3-运行时常量池-VS-常量池" class="headerlink" title="7.4.3. 运行时常量池 VS 常量池"></a>7.4.3. 运行时常量池 VS 常量池</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/7ec9b450764c623c89e7de7e0d3c8d19.png" alt="image-20200708171151384"></p><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚 ClassFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚 ClassFile 中的常量池。</li></ul><p>官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/be6d675673b353a266d48df43b0411f4.png" alt="image-20200708172357052"></p><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用. 也就是说&#x3D;&#x3D;一个方法的具体实现细节都藏在常量池中&#x3D;&#x3D;</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204221852583.png" alt="image-20220422185201108"></p><p><strong>举例:</strong></p><p>&#x3D;&#x3D;常量池中的信息相当于炒菜的基本原料,每个方法相当于一道道菜.每道菜都可能会用到那些基本原材料.对应到代码中,方法的字节码会用到常量池中的内容&#x3D;&#x3D;</p><h4 id="为什么需要常量池？"><a href="#为什么需要常量池？" class="headerlink" title="为什么需要常量池？"></a>为什么需要常量池？</h4><p>一个 java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。</p><p>比如：如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然只有 194 字节，但是里面却使用了 String、System、PrintStream 及 Object 等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204221902739.png" alt="image-20210510145947122"></p><h4 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么?"></a>常量池中有什么?</h4><p>击中常量池内存储的数据类型包括：</p><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204221901280.png" alt="image-20220422190144987"></p><p>例如下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Object obj = new Object();</code>将会被翻译成如下字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="keyword">new</span> #<span class="number">2</span>  <span class="comment">// Class java/lang/Object</span></span><br><span class="line"><span class="number">1</span>: dup</span><br><span class="line"><span class="number">2</span>: invokespecial <span class="comment">// Method java/lang/Object &quot;&lt;init&gt;&quot;() V</span></span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p><h3 id="7-4-4-运行时常量池"><a href="#7-4-4-运行时常量池" class="headerlink" title="7.4.4. 运行时常量池"></a>7.4.4. 运行时常量池</h3><ul><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li><li><mark>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</mark><ul><li>&#x3D;&#x3D;字节码中的常量池存放的都是符号引用&#x3D;&#x3D;,链接解析阶段将符号引用转化为直接引用.所以&#x3D;&#x3D;方法区的运行区常量池里面存放的都是直接引用&#x3D;&#x3D;.</li></ul></li><li>运行时常量池，在&#x3D;&#x3D;加载类和接口&#x3D;&#x3D;到虚拟机后，就会创建对应的运行时常量池。</li><li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过<mark>索引访问</mark>的。</li><li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为<mark>真实地址</mark>。</li><li>运行时常量池，相对于 Class 文件常量池的另一重要特征是：具备<mark>动态性</mark>。<ul><li>以String.intern()为例,编译器会将字符串添加到常量池中（StringTable维护），并返回指向该常量的引用</li></ul></li><li>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛 OutOfMemoryError 异常。</li></ul><p><strong>深入解析动态性:</strong></p><ul><li>动态性是运行时常量池可以动态的往里面添加本来没有的信息</li><li>而常量池，只能放代码中存在的信息，在编译期间，就确定了，不会再得到更改</li><li>运行时常量池，则可以通过代码动态的往里面塞信息。</li></ul><h2 id="7-5-方法区使用举例"><a href="#7-5-方法区使用举例" class="headerlink" title="7.5. 方法区使用举例"></a>7.5. 方法区使用举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>五个本地变量,所以本地变量表尾5. args存在下标为0的位置上</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204222228186.png" alt="image-20210510151436251"></p><ul><li>将500放入操作数栈,然后赋值给变量x中,并将x存放到局部变量表中.</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204222229591.png" alt="image-20210510151504259"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204222233643.png" alt="image-20210510151520952"></p><ul><li>将100放入操作数栈,然后赋值给变量y中,并将y存放到局部变量表中.</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204222233178.png" alt="image-20210510151609566"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/692908400668791ac383561affed3520.png" alt="image-20210510151648231"></p><ul><li>读取本地变量表下标为1、2的变量，将其放入到操作数栈中（等待运算）</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204222234921.png" alt="image-20210510151712355"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204222234034.png" alt="image-20210510151753579"></p><ul><li>进行除法运算，并将结果存放到操作数栈中。之后将结果赋值给a,并存放到局部变量表中。</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204222236604.png" alt="image-20210510151829404"></p><ul><li>将50放入操作数栈,然后赋值给变量b中,并将b存放到局部变量表中.</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204222236458.png" alt="image-20210510151918342"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204222237265.png" alt="image-20210510151951327"></p><ul><li>获取#2(System.out.printlen)的值,并将其放入操作数栈中.</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/dfba814e0c1b198df7175fe93284c3e0.png" alt="image-20200708205708057"></p><ul><li>将本地变量表下标为3、4的加入到操作数栈中，并执行<strong>加</strong>操作运算。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/35be7c27bee2aa8c0930cffbefa07cd8.png" alt="image-20210510152102989"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/5f2935ec0858f5a74f512018e582f19c.png" alt="image-20210510152138492"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f584ed9e2b6d99499b2a451a63f12449.png" alt="image-20210510195824437"></p><ul><li>弹出操作数栈中的参数，传入 # 2对应的方法(System.out.println) ，进行打印操作。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/b4428f7f351048601296fe211c40185e.png" alt="image-20210510195911639"></p><ul><li>执行return指令,结束方法.</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/bf50cc494594b4588794984df6448303.png" alt="image-20210510152243933"></p><p><strong>图解纠错</strong></p><p>&#x3D;&#x3D;程序计数器里面应该保存的是当前执行指令的下一条指令地址.&#x3D;&#x3D;</p><p>分析:PC计数器保存的是当前指令的下一条指令地址。当前指令执行完毕，CPU切换到其他线程，执行另外一个线程的指令。 当CPU再次切换回来时，从PC计数器拿到下一条要执行的指令继续进行执行。</p><p>(CPU不会执行一半就去执行其他线程的指令)</p><h2 id="7-6-方法区的演进细节"><a href="#7-6-方法区的演进细节" class="headerlink" title="7.6. 方法区的演进细节"></a>7.6. 方法区的演进细节</h2><ol><li>首先明确：只有 Hotspot 才有永久代。BEA JRockit、IBMJ9 等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java 虚拟机规范》管束，并不要求统一</li><li>Hotspot 中方法区的变化：</li></ol><table><thead><tr><th align="left">JDK1.6 及之前</th><th align="left">有永久代（permanet），静态变量存储在永久代上</th></tr></thead><tbody><tr><td align="left"><strong>JDK1.7</strong></td><td align="left"><strong>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</strong></td></tr><tr><td align="left"><strong>JDK1.8</strong></td><td align="left"><strong>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</strong></td></tr></tbody></table><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204231837143.jpg" alt="第08章_方法区的演进细节-hotspot"></p><h3 id="7-6-1-为什么永久代要被元空间替代？"><a href="#7-6-1-为什么永久代要被元空间替代？" class="headerlink" title="7.6.1. 为什么永久代要被元空间替代？"></a>7.6.1. 为什么永久代要被元空间替代？</h3><p>官网地址：<a href="http://openjdk.java.net/jeps/122">JEP 122: Remove the Permanent Generation (java.net)</a></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204231841298.png" alt="永久代为什么会被元空间替换"></p><p>随着 Java8 的到来，HotSpot VM 中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个<mark>与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）</mark>。</p><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p><p>这项改动是很有必要的，原因有：</p><ol><li>&#x3D;&#x3D;为永久代设置空间大小是很难确定的&#x3D;&#x3D;。在某些场景下，如果动态加载类过多，容易产生 Perm 区的 oom。比如某个实际 Web 工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Exception in thread &#x27;dubbo client x.x connector&#x27; java.lang.OutOfMemoryError:PermGen space&quot;</span></span><br></pre></td></tr></table></figure><p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</p><ol start="2"><li>&#x3D;&#x3D;对永久代进行调优是很困难的&#x3D;&#x3D;。</li></ol><p>有些人认为方法区（如 HotSpot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK 11 时期的 ZGC 收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 Sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏</p><p>方法区的垃圾收集主要回收两部分内容：&#x3D;&#x3D;常量池中废弃的常量和不再使用的类型&#x3D;&#x3D;</p><h3 id="7-6-2-StringTable-为什么要调整位置？"><a href="#7-6-2-StringTable-为什么要调整位置？" class="headerlink" title="7.6.2. StringTable 为什么要调整位置？"></a>7.6.2. StringTable 为什么要调整位置？</h3><p>jdk7 中将 StringTable 放到了堆空间中。因为永久代的回收效率很低，在 full gc 的时候才会触发。而 full gc 是老年代的空间不足、永久代不足时才会触发。</p><p>这就导致 StringTable 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h3 id="7-6-3-静态变量存放在那里？"><a href="#7-6-3-静态变量存放在那里？" class="headerlink" title="7.6.3. 静态变量存放在那里？"></a>7.6.3. 静态变量存放在那里？</h3><ul><li>示例1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态引用对应的对象实体始终都存在堆空间</span></span><br><span class="line"><span class="comment"> * jdk7:</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * jdk8:</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m-XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFieldTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(StaticFieldTest.arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204231859845.png" alt="image-20220423185916651"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204231903451.png" alt="image-20220423190316971"></p><p>结论:&#x3D;&#x3D;静态引用对应的对象实体始终都存在堆空间&#x3D;&#x3D;</p><ul><li>示例2</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 《深入理解Java虚拟机》中的案例：</span></span><br><span class="line"><span class="comment"> * staticObj、instanceObj、localObj存放在哪里？</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  11:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticObjTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">ObjectHolder</span> <span class="variable">staticObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">        <span class="type">ObjectHolder</span> <span class="variable">instanceObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">ObjectHolder</span> <span class="variable">localObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ObjectHolder</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticObjTest</span>.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 JHSDB 工具进行分析，这里细节略掉</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e8ced63603ee4a62c9eb7d4c48ae94dd.png" alt="image-20200708215218078"></p><p>**三个变量的引用:**staticobj 随着 Test 的类型信息存放在方法区，instanceobj 随着 Test 的对象实例存放在 Java 堆，localobject 则是存放在 foo()方法栈帧的局部变量表中。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e7c6b3dd5175466ee891da9e84577418.png" alt="image-20200708215025527"></p><p>测试发现：&#x3D;&#x3D;三个对象的数据在内存中的地址都落在 Eden 区范围内&#x3D;&#x3D;，所以结论：只要是对象实例必然会在 Java 堆中分配。</p><p>接着，找到了一个引用该 staticobj 对象的地方，是在一个 java.lang.Class 的实例里，并且给出了这个实例的地址，通过 Inspector 查看该对象实例，可以清楚看到这确实是一个 java.lang.Class 类型的对象实例，里面有一个名为 staticobj 的实例字段：</p><p>从《Java 虚拟机规范》所定义的概念模型来看，所有 Class 相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java 虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7 及其以后版本的 HotSpot 虚拟机选择把&#x3D;&#x3D;静态变量与类型在 Java 语言一端的映射 class 对象存放在一起，存储于 Java 堆之中&#x3D;&#x3D;，从我们的实验中也明确验证了这一点</p><p><strong>备注</strong>:前面已经说过了，没有栈上分配这码事，如果未逃逸，做标量替换，把一个对象分解为多个成员变量，也还是存在堆上。</p><h2 id="7-7-方法区的垃圾回收"><a href="#7-7-方法区的垃圾回收" class="headerlink" title="7.7. 方法区的垃圾回收"></a>7.7. 方法区的垃圾回收</h2><p>有些人认为方法区（如 Hotspot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 时期的 zGC 收集器就不支持类卸载）。</p><p>一般来说<mark>这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻</mark>。但是这部分区域的回收<mark>有时又确实是必要的</mark>。以前 sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。</p><p><mark>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</mark></p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot 虚拟机对常量池的回收策略是很明确的，<mark>只要常量池中的常量没有被任何地方引用，就可以被回收</mark>。</p><p>回收废弃常量与回收 Java 堆中的对象非常类似。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li><p><mark>该类所有的实例都已经被回收</mark>，也就是 Java 堆中不存在该类及其任何派生子类的实例。</p></li><li><p><mark>加载该类的类加载器已经被回收</mark>，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。</p></li><li><p><mark>该类对应的 java.lang.Class 对象没有在任何地方被引用</mark>，无法在任何地方通过反射访问该类的方法。</p></li></ul><p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“&#x3D;&#x3D;被允许&#x3D;&#x3D;”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot 虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code> 以及 <code>-XX:+TraceClassLoading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息</p><p>在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，<u>通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</u>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204241022575.jpg" alt="第09章_小结"></p><ul><li>关于MiniorGC和Full GC的区别. MinorGC是老年代的GC,FullGC是整个堆的GC</li><li>栈帧中的动态链接指向的是方法区中的方法,代表当前操作的是哪个方法</li></ul><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><blockquote><p><mark>百度</mark>：</p><p>说一下 JVM 内存模型吧，有哪些区？分别干什么的？</p><p><mark>蚂蚁金服</mark>：</p><p>Java8 的内存分代改进 JVM 内存分哪几个区，每个区的作用是什么？</p><p>一面：JVM 内存分布&#x2F;内存结构？栈和堆的区别？堆的结构？为什么两个 survivor 区？</p><p>二面：Eden 和 survior 的比例分配</p><p><mark>小米</mark>：</p><p>jvm 内存分区，为什么要有新生代和老年代</p><p><mark>字节跳动</mark>：</p><p>二面：Java 的内存分区</p><p>二面：讲讲 vm 运行时数据库区 什么时候对象会进入老年代？</p><p><mark>京东</mark>：</p><p>JVM 的内存结构，Eden 和 Survivor 比例。</p><p>JVM 内存为什么要分成新生代，老年代，持久代。</p><p>新生代中为什么要分为 Eden 和 survivor。</p><p><mark>天猫</mark>：</p><p>一面：Jvm 内存模型以及分区，需要详细到每个区放什么。</p><p>一面：JVM 的内存模型，Java8 做了什么改</p><p><mark>拼多多</mark>：</p><p>JVM 内存分哪几个区，每个区的作用是什么？</p><p><mark>美团</mark>：</p><p>java 内存分配 jvm 的永久代中会发生垃圾回收吗？</p><p>一面：jvm 内存分区，为什么要有新生代和老年代？</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六、堆</title>
      <link href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC06%E7%AB%A0_%E5%A0%86/"/>
      <url>/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC06%E7%AB%A0_%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="6-堆"><a href="#6-堆" class="headerlink" title="6. 堆"></a>6. 堆</h1><h2 id="6-1-堆（Heap）的核心概述"><a href="#6-1-堆（Heap）的核心概述" class="headerlink" title="6.1. 堆（Heap）的核心概述"></a>6.1. 堆（Heap）的核心概述</h2><p>堆针对一个 JVM 进程来说是唯一的，也就是一个进程只有一个 JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p><p><strong>一句话:</strong>&#x3D;&#x3D;一个进程对应一个JVM实例,一个进程包含多个线程.一个进程中的多个线程共享堆空间,方法区.每个线程各自有一套自己的程序计数器,本地方法栈,虚拟机栈.&#x3D;&#x3D;</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203291436968.png" alt="image-20220329143619498"></p><ul><li><p>一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。</p></li><li><p>Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存空间。</p><ul><li>&#x3D;&#x3D;堆内存的大小是可以调节的&#x3D;&#x3D;。</li></ul></li></ul><p><strong>代码演示:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms10m -Xmx10m:初始堆空间和最大堆空间设置都为10M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  16:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms20m -Xmx20m</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  16:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用Visual GC观察堆的大小</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203291440954.jpg" alt="Snipaste_2022-03-28_18-17-59"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203291440947.jpg" alt="Snipaste_2022-03-28_18-17-15"></p><ul><li><p>《Java 虚拟机规范》规定，堆可以处于&#x3D;&#x3D;物理上不连续&#x3D;&#x3D;的内存空间中，但在&#x3D;&#x3D;逻辑上&#x3D;&#x3D;它应该被视为&#x3D;&#x3D;连续&#x3D;&#x3D;的。</p></li><li><p>所有的线程共享 Java 堆，在这里还可以划分&#x3D;&#x3D;线程私有的缓冲区&#x3D;&#x3D;（Thread Local Allocation Buffer，TLAB）(可以更好的解决并发)。</p></li><li><p>《Java 虚拟机规范》中对 Java 堆的描述是：&#x3D;&#x3D;所有的对象实例以及数组都应当在运行时分配在堆上&#x3D;&#x3D;。（<code>The heap is the run-time data area from which memory for all class instances and arrays is allocated</code>）</p><ul><li>从实际角度看:<strong><font color=red>“几乎”所有的对象实例都在这里分配内存</font></strong>(出现逃逸分析,标量分配 会在栈上分配)</li></ul></li><li><p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p></li><li><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。(频繁的GC影响用户线程的执行)</p></li><li><p>堆，是 GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203291509428.png" alt="image-20200706201904057"></p><h3 id="6-1-1-堆内存细分"><a href="#6-1-1-堆内存细分" class="headerlink" title="6.1.1. 堆内存细分"></a>6.1.1. 堆内存细分</h3><p>Java 7 及之前堆内存逻辑上分为三部分：新生区+养老区+<mark>永久区</mark></p><ul><li>Young Generation Space 新生区 Young&#x2F;New 又被划分为 Eden 区和 Survivor 区</li><li>Tenure generation space 养老区 Old&#x2F;Tenure</li><li>Permanent Space 永久区 Perm</li></ul><p>Java 8 及之后堆内存逻辑上分为三部分：新生区+养老区+<mark>元空间</mark></p><ul><li>Young Generation Space 新生区 Young&#x2F;New 又被划分为 Eden 区和 Survivor 区</li><li>Tenure generation space 养老区 Old&#x2F;Tenure</li><li>Meta Space 元空间 Meta</li></ul><p>约定：新生区（代）&lt;&#x3D;&gt;年轻代 、 养老区&lt;&#x3D;&gt;老年区（代）、 永久区&lt;&#x3D;&gt;永久代</p><p><strong>图解</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203291851669.png" alt="image-20200706203835403"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203291852750.png" alt="Meta"></p><p><strong>代码演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数:-Xms10m -Xmx10m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  17:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHeap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//属性、成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleHeap</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">SimpleHeap</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHeap</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="type">SimpleHeap</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHeap</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">            Object[] arr1 = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203291900582.jpg" alt="Snipaste_2022-03-29_16-16-22"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203291901538.jpg" alt="Snipaste_2022-03-29_16-16-49"></p><h3 id="6-1-2-堆空间内部结构（JDK7）"><a href="#6-1-2-堆空间内部结构（JDK7）" class="headerlink" title="6.1.2. 堆空间内部结构（JDK7）"></a>6.1.2. 堆空间内部结构（JDK7）</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203291606983.jpg" alt="第08章_堆空间-java7"></p><h3 id="6-1-3-堆空间内部结构（JDK8）"><a href="#6-1-3-堆空间内部结构（JDK8）" class="headerlink" title="6.1.3. 堆空间内部结构（JDK8）"></a>6.1.3. 堆空间内部结构（JDK8）</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203291606152.jpg" alt="第08章_堆空间-java8"></p><h2 id="6-2-设置堆内存大小与-OOM"><a href="#6-2-设置堆内存大小与-OOM" class="headerlink" title="6.2. 设置堆内存大小与 OOM"></a>6.2. 设置堆内存大小与 OOM</h2><h3 id="6-2-1-堆空间大小的设置"><a href="#6-2-1-堆空间大小的设置" class="headerlink" title="6.2.1. 堆空间大小的设置"></a>6.2.1. 堆空间大小的设置</h3><p>Java 堆区用于存储 Java 对象实例，那么堆的大小在 JVM 启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p><ul><li>&#x3D;&#x3D;“-Xms”用于表示堆区的起始内存&#x3D;&#x3D;，等价于<code>-XX:InitialHeapSize</code></li><li>&#x3D;&#x3D;“-Xmx”则用于表示堆区的最大内存&#x3D;&#x3D;，等价于<code>-XX:MaxHeapSize</code></li></ul><p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出 OutOfMemoryError 异常。</p><p>通常会将-Xms 和-Xmx 两个参数配置相同的值，其目的是<mark>为了能够在 Java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</mark></p><p>默认情况下</p><ul><li>初始内存大小：物理电脑内存大小 &#x2F; 64</li><li>最大内存大小：物理电脑内存大小 &#x2F; 4</li></ul><p><strong>代码演示:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 设置堆空间大小的参数</span></span><br><span class="line"><span class="comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span></span><br><span class="line"><span class="comment"> *      -X 是jvm的运行参数</span></span><br><span class="line"><span class="comment"> *      ms 是memory start</span></span><br><span class="line"><span class="comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 默认堆空间的大小</span></span><br><span class="line"><span class="comment"> *    初始内存大小：物理电脑内存大小 / 64</span></span><br><span class="line"><span class="comment"> *             最大内存大小：物理电脑内存大小 / 4</span></span><br><span class="line"><span class="comment"> * 3. 手动设置：-Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。(避免堆区的扩容和释放，降低性能消耗)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span></span><br><span class="line"><span class="comment"> *                  方式二：-XX:+PrintGCDetails  //程序执行完之后打印</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  20:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSpaceInitial</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try &#123;</span></span><br><span class="line">        <span class="comment">//     Thread.sleep(1000000);</span></span><br><span class="line">        <span class="comment">// &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line">        <span class="comment">//     e.printStackTrace();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果分析</strong></p><ul><li>不进行任何配置,运行之</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203292222800.jpg" alt="JVM当下最大堆内存"></p><ul><li>手动设置：-Xms600m -Xmx600m,运行之. 我们出现了疑惑,后面进行解密!哈哈哈.</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203292225470.png" alt="image-20220329222554212"></p><ul><li>打开try…catch…,进行查看分析.</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203292246803.png" alt="命令行查看进程信息"></p><ul><li>使用PrintGCDetails,查看堆内存的详细信息.</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203292249351.png" alt="image-20220329224911087"></p><h3 id="6-2-2-OutOfMemory-举例"><a href="#6-2-2-OutOfMemory-举例" class="headerlink" title="6.2.2. OutOfMemory 举例"></a>6.2.2. OutOfMemory 举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  21:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Picture</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Picture</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] pixels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Picture</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pixels = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at com.atguigu.java.Picture.&lt;init&gt;(OOMTest.java:<span class="number">29</span>)</span><br><span class="line">at com.atguigu.java.OOMTest.main(OOMTest.java:<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p><strong>运行观察结果:</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203301217015.png" alt="image-20220330121733575"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203301219267.png" alt="image-20220330121951858"></p><h2 id="6-3-年轻代与老年代"><a href="#6-3-年轻代与老年代" class="headerlink" title="6.3. 年轻代与老年代"></a>6.3. 年轻代与老年代</h2><p>存储在 JVM 中的 Java 对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与 JVM 的生命周期保持一致</li></ul><p>Java 堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>其中年轻代又可以划分为 Eden 空间、Survivor0 空间和 Survivor1 空间（有时也叫做 from 区、to 区）</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203311433796.jpg" alt="第08章_堆空间细节"></p><p>下面这参数开发中一般不会调：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7d9c2d1f9ef9f315f01b3441c6e81660.png" alt="image-20200707080154039"></p><p>&#x3D;&#x3D;配置新生代与老年代在堆结构的占比。&#x3D;&#x3D;</p><ul><li>默认<code>-XX:NewRatio=2</code>，表示新生代占 1，老年代占 2，新生代占整个堆的 1&#x2F;3</li><li>可以修改<code>-XX:NewRatio=4</code>，表示新生代占 1，老年代占 4，新生代占整个堆的 1&#x2F;5</li></ul><p>在 HotSpot 中，Eden 空间和另外两个 survivor 空间缺省所占的比例是 8：1：1 (因为有个自适应的内存分配原则,<strong>实际测试<font color=red>6:1:1</font></strong>)</p><p>当然开发人员可以通过选项“<code>-xx:SurvivorRatio</code>”调整这个空间比例。比如<code>-xx:SurvivorRatio=8</code></p><p><mark>几乎所有的 Java 对象都是在 Eden 区被 new 出来的。</mark>绝大部分的 Java 对象的销毁都在新生代进行了。</p><ul><li>IBM 公司的专门研究表明，新生代中 80%的对象都是“朝生夕死”的。</li></ul><p>可以使用选项”<code>-Xmn</code>“设置新生代最大内存大小，这个参数一般使用默认值就可以了。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203311437944.png" alt="image-20210510105849497"></p><p><strong>图解</strong>:对象在Eden一段时间内没有被销毁,进入Survivor区,长时间仍未销毁进入老年区.</p><p><strong>代码演示:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是2.</span></span><br><span class="line"><span class="comment"> * -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8</span></span><br><span class="line"><span class="comment"> * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）</span></span><br><span class="line"><span class="comment"> * -Xmn:设置新生代的空间的大小。 （一般不设置）</span></span><br><span class="line"><span class="comment"> * 备注:-Xmn优先级比-XX:NewRatio高,所以当两个同时设置时(不推荐),会以前者为主</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  17:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EdenSurvivorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我只是来打个酱油~&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果分析</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203311448669.png" alt="image-20220331144815281"></p><h2 id="6-4-图解对象分配过程"><a href="#6-4-图解对象分配过程" class="headerlink" title="6.4. 图解对象分配过程"></a>6.4. 图解对象分配过程</h2><h3 id="6-4-1-对象分配基本过程分析"><a href="#6-4-1-对象分配基本过程分析" class="headerlink" title="6.4.1. 对象分配基本过程分析"></a>6.4.1. 对象分配基本过程分析</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p><ol><li><p>new 的对象先放伊甸园区。此区有大小限制。</p></li><li><p>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</p></li><li><p>然后将伊甸园中的剩余对象移动到幸存者 0 区。</p></li><li><p>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区的，如果没有回收，就会放到幸存者 1 区。</p></li><li><p>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区。</p></li><li><p>啥时候能去养老区呢？可以设置次数。默认是 15 次。</p><ul><li><mark>可以设置参数：<code>-Xx:MaxTenuringThreshold= N</code>进行设置</mark></li></ul></li><li><p>在养老区，相对悠闲。当养老区内存不足时，再次触发 GC：Major GC，进行养老区的内存清理</p></li><li><p>若养老区执行了 Major GC 之后，发现依然无法进行对象的保存，就会产生 OOM 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutofMemoryError: Java heap space</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203311539655.jpg" alt="第08章_新生代对象分配与回收过程"></p><p><strong>总结</strong></p><ul><li><mark>针对幸存者 s0，s1 区的总结：复制之后有交换，谁空谁是 to</mark></li><li><mark>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</mark></li></ul><h3 id="6-4-2-对象分配流程图"><a href="#6-4-2-对象分配流程图" class="headerlink" title="6.4.2. 对象分配流程图"></a>6.4.2. 对象分配流程图</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203311549048.png" alt="image-20200707091058346"></p><h3 id="6-4-3-对象分配代码演示"><a href="#6-4-3-对象分配代码演示" class="headerlink" title="6.4.3. 对象分配代码演示"></a>6.4.3. 对象分配代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  17:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapInstanceTest</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span> * <span class="number">200</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;HeapInstanceTest&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HeapInstanceTest&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">HeapInstanceTest</span>());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203311606998.png" alt="image-20220331160620414"></p><h3 id="6-4-4-常用调优工具"><a href="#6-4-4-常用调优工具" class="headerlink" title="6.4.4. 常用调优工具"></a>6.4.4. 常用调优工具</h3><p>在 JVM 下篇：性能监控与调优篇会详细介绍</p><ul><li>JDK 命令行</li><li>Eclipse:Memory Analyzer Tool</li><li>Jconsole</li><li>VisualVM</li><li>Jprofiler</li><li>Java Flight Recorder</li><li>GCViewer</li><li>GC Easy</li></ul><h2 id="6-5-Minor-GC、MajorGC和Full-GC对比"><a href="#6-5-Minor-GC、MajorGC和Full-GC对比" class="headerlink" title="6.5. Minor GC、MajorGC和Full GC对比"></a>6.5. Minor GC、MajorGC和Full GC对比</h2><h3 id="6-5-1-GC的分类"><a href="#6-5-1-GC的分类" class="headerlink" title="6.5.1. GC的分类"></a>6.5.1. GC的分类</h3><p>JVM 在进行 GC 时，并非每次都对上面三个内存区域(新生区,老年区,方法区)一起回收的，&#x3D;&#x3D;大部分时候回收的都是指新生代&#x3D;&#x3D;。</p><p>针对 Hotspot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p><ul><li>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC &#x2F; Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC &#x2F; Old GC）：只是老年代的圾收集。<ul><li>目前，只有 CMSGC 会有单独收集老年代的行为。</li><li><mark>注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</mark></li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有 G1 GC 会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个 java 堆和方法区(程序执行过程中需要加载的类)的垃圾收集。</li></ul><h3 id="6-5-2-年轻代-GC（Minor-GC）触发机制"><a href="#6-5-2-年轻代-GC（Minor-GC）触发机制" class="headerlink" title="6.5.2. 年轻代 GC（Minor GC）触发机制"></a>6.5.2. 年轻代 GC（Minor GC）触发机制</h3><ul><li>当年轻代空间不足时，就会触发 MinorGC。这里的年轻代满指的是 Eden 代满&#x3D;&#x3D;，Survivor 满不会引发 GC&#x3D;&#x3D;。（每次 Minor GC 会清理年轻代的内存。）</li><li>因为<mark>Java 对象大多都具备朝生夕灭的特性</mark>.，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li><li>Minor GC 会引发 STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li></ul><p>**备注:**当Survivor满了,超出部分直接放在老年区,其他部分保持不变.等下次Eden满了,触发Minor GC,再对Survivor进行垃圾清理. 即 <strong><font color=red>Survivor区的垃圾回收是被动的</font></strong></p><p><strong>threshold:阈值</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203312157369.png" alt="image-20200707095606813"></p><h3 id="6-5-3-老年代-GC（Major-GC-Full-GC）触发机制"><a href="#6-5-3-老年代-GC（Major-GC-Full-GC）触发机制" class="headerlink" title="6.5.3. 老年代 GC（Major GC &#x2F; Full GC）触发机制"></a>6.5.3. 老年代 GC（Major GC &#x2F; Full GC）触发机制</h3><ul><li><p>指发生在老年代的 GC，对象从老年代消失时，我们说 “Major GC” 或 “Full GC” 发生了</p></li><li><p>出现了 Major Gc，经常会伴随至少一次的 Minor GC（但非绝对的，在 Paralle1 Scavenge 收集器的收集策略里就有直接进行 MajorGC 的策略选择过程）</p><ul><li>&#x3D;&#x3D;也就是在老年代空间不足时，会先尝试触发 Minor Gc。如果之后空间还不足，则触发 Major GC&#x3D;&#x3D;(??)</li></ul></li><li><p>Major GC 的速度一般会比 Minor GC 慢 10 倍以上，STW 的时间更长(所以后序调优时,要尽量减少其出现次数.)</p></li><li><p>如果 Major GC 后，内存还不足，就报 OOM 了</p></li></ul><h3 id="6-5-4-Full-GC-触发机制（后面细讲）"><a href="#6-5-4-Full-GC-触发机制（后面细讲）" class="headerlink" title="6.5.4. Full GC 触发机制（后面细讲）"></a>6.5.4. Full GC 触发机制（后面细讲）</h3><p>触发 Full GC 执行的情况有如下五种：</p><ol><li>调用 System.gc()时，系统建议执行 Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存</li><li>由 Eden 区、survivor space0（From Space）区向 survivor space1（To Space）区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小，则会触发。</li></ol><p><mark>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</mark></p><h3 id="6-5-5-GC举例与日志分析"><a href="#6-5-5-GC举例与日志分析" class="headerlink" title="6.5.5. GC举例与日志分析"></a>6.5.5. GC举例与日志分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试MinorGC 、 MajorGC、FullGC</span></span><br><span class="line"><span class="comment"> * -Xms9m -Xmx9m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  14:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历次数为：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204011815662.png" alt="三种GC对比"></p><h2 id="6-6-堆空间分代思想"><a href="#6-6-堆空间分代思想" class="headerlink" title="6.6. 堆空间分代思想"></a>6.6. 堆空间分代思想</h2><p>为什么要把 Java 堆分代？不分代就不能正常工作了吗？</p><p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><ul><li>新生代：有 Eden、两块大小相同的 survivor（又称为 from&#x2F;to，s0&#x2F;s1）构成，to 总为空。</li><li>老年代：存放新生代中经历多次 GC 仍然存活的对象。</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204011822133.png" alt="image-20200707101511025"></p><p>其实不分代完全可以，分代的唯一理由就是&#x3D;&#x3D;优化 GC 性能&#x3D;&#x3D;。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC 的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当 GC 的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204011822653.png" alt="image-20200707101543871"></p><h2 id="6-7-内存分配策略"><a href="#6-7-内存分配策略" class="headerlink" title="6.7. 内存分配策略"></a>6.7. 内存分配策略</h2><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 survivor 空间中，并将对象年龄设为 1。对象在 survivor 区中每熬过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁，其实每个 JVM、每个 GC 都有所不同）时，就会被晋升到老年代</p><p>对象晋升老年代的年龄阀值，可以通过选项<code>-XX:MaxTenuringThreshold</code>来设置</p><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li>优先分配到 Eden</li><li>大对象直接分配到老年代（&#x3D;&#x3D;尽量避免程序中出现过多的大对象&#x3D;&#x3D;）</li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断：如果 survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄。</li><li>空间分配担保： <code>-XX:HandlePromotionFailure</code></li></ul><p><strong>注意:</strong>&#x3D;&#x3D;GC年龄在对象头中用4个字节存储，最大就是15，不可能超过15的&#x3D;&#x3D;</p><p><strong>代码演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 测试：大对象直接进入老年代</span></span><br><span class="line"><span class="comment"> * -Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  21:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YoungOldAreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">20</span>];<span class="comment">//20m</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204011850647.png" alt="image-20220401185049540"></p><h2 id="6-8-为对象分配内存：TLAB"><a href="#6-8-为对象分配内存：TLAB" class="headerlink" title="6.8. 为对象分配内存：TLAB"></a>6.8. 为对象分配内存：TLAB</h2><h3 id="6-8-1-为什么有-TLAB（Thread-Local-Allocation-Buffer）？"><a href="#6-8-1-为什么有-TLAB（Thread-Local-Allocation-Buffer）？" class="headerlink" title="6.8.1. 为什么有 TLAB（Thread Local Allocation Buffer）？"></a>6.8.1. 为什么有 TLAB（Thread Local Allocation Buffer）？</h3><ul><li><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p></li><li><p>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p></li><li><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p></li></ul><h3 id="6-8-2-什么是-TLAB？"><a href="#6-8-2-什么是-TLAB？" class="headerlink" title="6.8.2. 什么是 TLAB？"></a>6.8.2. 什么是 TLAB？</h3><ul><li><p>从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分，JVM 为<mark>每个线程分配了一个私有缓存区域</mark>，它包含在 Eden 空间内。</p></li><li><p>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<mark>快速分配策略</mark>。</p></li><li><p>据我所知&#x3D;&#x3D;所有 OpenJDK 衍生出来的 JVM 都提供了 TLAB 的设计&#x3D;&#x3D;。</p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204011906187.jpg" alt="第08章_TLAB"></p><h3 id="6-8-3-TLAB-的再说明"><a href="#6-8-3-TLAB-的再说明" class="headerlink" title="6.8.3. TLAB 的再说明"></a>6.8.3. TLAB 的再说明</h3><ul><li><p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但<mark>JVM 确实是将 TLAB 作为内存分配的首选</mark>。</p></li><li><p>在程序中，开发人员可以通过选项“<code>-XX:UseTLAB</code>”设置是否开启 TLAB 空间。</p></li><li><p>默认情况下，TLAB 空间的内存非常小，<mark>仅占有整个 Eden 空间的 1%</mark>，当然我们可以通过选项 “<code>-XX:TLABWasteTargetPercent</code>” 设置 TLAB 空间所占用 Eden 空间的百分比大小。</p></li><li><p>&#x3D;&#x3D;一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性&#x3D;&#x3D;，从而直接在 Eden 空间中分配内存。</p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203311434924.jpg" alt="第08章_对象分配过程"></p><p><strong>总结:</strong></p><ul><li>堆是共享的，访问需要加锁。而new对象是件很频繁的事情，为了提高效率，所以创建了TLAB区域</li><li>这个区域是线程独占，就无须考虑并发问题。</li><li>分配对象就先分配到TLAB区域。满了或对象过大，就还分配到外边,这时就需要加锁了</li><li>这就要求我们创建对象时候尽量创建小对象。提高效率</li></ul><h2 id="6-9-小结：堆空间的参数设置"><a href="#6-9-小结：堆空间的参数设置" class="headerlink" title="6.9. 小结：堆空间的参数设置"></a>6.9. 小结：堆空间的参数设置</h2><p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 详细的参数内容会在JVM下篇：性能监控与调优篇中进行详细介绍，这里先熟悉下</span></span><br><span class="line">-XX:+PrintFlagsInitial  <span class="comment">//查看所有的参数的默认初始值</span></span><br><span class="line">-XX:+PrintFlagsFinal  <span class="comment">//查看所有的参数的最终值（可能会存在修改，不再是初始值）</span></span><br><span class="line">-Xms  <span class="comment">//初始堆空间内存（默认为物理内存的1/64）</span></span><br><span class="line">-Xmx  <span class="comment">//最大堆空间内存（默认为物理内存的1/4）</span></span><br><span class="line">-Xmn  <span class="comment">//设置新生代的大小。（初始值及最大值）</span></span><br><span class="line">-XX:NewRatio  <span class="comment">//配置新生代与老年代在堆结构的占比</span></span><br><span class="line">-XX:SurvivorRatio  <span class="comment">//设置新生代中Eden和S0/S1空间的比例</span></span><br><span class="line">-XX:MaxTenuringThreshold  <span class="comment">//设置新生代垃圾的最大年龄</span></span><br><span class="line">-XX:+PrintGCDetails <span class="comment">//输出详细的GC处理日志</span></span><br><span class="line"><span class="comment">//打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc</span></span><br><span class="line">-XX:HandlePromotionFalilure：<span class="comment">//是否设置空间分配担保</span></span><br></pre></td></tr></table></figure><p>在发生 Minor GC 之前，虚拟机会<mark>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</mark>。</p><ul><li>如果大于，则此次 Minor GC 是安全的</li><li>如果小于，则虚拟机会查看<code>-XX:HandlePromotionFailure</code>设置值是否允担保失败。<ul><li>如果<code>HandlePromotionFailure=true</code>，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。<ul><li>如果大于，则尝试进行一次 Minor GC，但这次 Minor GC 依然是有风险的；</li><li>如果小于，则改为进行一次 Full GC。</li></ul></li><li>如果<code>HandlePromotionFailure=false</code>，则改为进行一次 Full Gc。</li></ul></li></ul><p>在 JDK6 Update24 之后(jdk7)，HandlePromotionFailure 参数不会再影响到虚拟机的空间分配担保策略，观察 openJDK 中的源码变化，虽然源码中还定义了 HandlePromotionFailure 参数，但是在代码中已经不会再使用它(该参数已经毫无意义了)。JDK6 Update 24 之后的规则变为<mark>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC</mark>，否则将进行 Full GC。</p><h2 id="6-X-堆是分配对象的唯一选择么？"><a href="#6-X-堆是分配对象的唯一选择么？" class="headerlink" title="6.X. 堆是分配对象的唯一选择么？"></a>6.X. 堆是分配对象的唯一选择么？</h2><p>在《深入理解 Java 虚拟机》中关于 Java 堆内存有这样一段描述：</p><blockquote><p>随着 JIT 编译期的发展与<mark>逃逸分析技术</mark>逐渐成熟，<mark>栈上分配</mark>、<mark>标量替换优化技术</mark>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p></blockquote><p>在 Java 虚拟机中，对象是在 Java 堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<mark>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</mark>.。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的&#x3D;&#x3D;堆外存储技术&#x3D;&#x3D;。</p><p>此外，前面提到的基于 OpenJDK 深度定制的 TaoBaoVM，其中创新的 GCIH（GC invisible heap）技术实现 off-heap，将生命周期较长的 Java 对象从 heap 中移至 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。</p><h3 id="6-X-1-逃逸分析概述"><a href="#6-X-1-逃逸分析概述" class="headerlink" title="6.X.1. 逃逸分析概述"></a>6.X.1. 逃逸分析概述</h3><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p><p>通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><p>&#x3D;&#x3D;逃逸分析的基本行为就是分析对象动态作用域：&#x3D;&#x3D;</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><p><strong>举例 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">my_method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">V</span>();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法如果想要<code>StringBuffer sb</code>不发生逃逸，可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例 2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 4:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeAnalysis</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="literal">null</span>? <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//基本数据类型和堆没关系，在栈帧中的局部变量表中。</span></span><br><span class="line"><span class="comment">//这里进行逃逸分析，是为了将本来分配在堆上的对象，分配到栈帧中。</span></span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> getInstance();</span><br><span class="line">        <span class="comment">//getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数设置</strong></p><p>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析</p><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项“<code>-XX:+DoEscapeAnalysis</code>“显式开启逃逸分析</li><li>通过选项“<code>-XX:+PrintEscapeAnalysis</code>“查看逃逸分析的筛选结果</li></ul><p><strong>结论</strong>：<mark>开发中能使用局部变量的，就不要使用在方法外定义。</mark></p><h3 id="6-X-2-逃逸分析：代码优化"><a href="#6-X-2-逃逸分析：代码优化" class="headerlink" title="6.X.2. 逃逸分析：代码优化"></a>6.X.2. 逃逸分析：代码优化</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p><p>一、<mark>栈上分配</mark>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</p><p>二、<mark>同步省略</mark>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p><p>三、<mark>分离对象或标量替换</mark>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器(栈)中。</p><h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>JIT 编译器在编译期间根据逃逸分析的结果，发现&#x3D;&#x3D;如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配&#x3D;&#x3D;。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><p><strong>常见的栈上分配的场景</strong></p><p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p><p><strong>代码演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配测试</span></span><br><span class="line"><span class="comment"> * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  10:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackAllocation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果分析:</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204012239235.png" alt="逃逸分析"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204012236617.png" alt="image-20220401223640281"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204012238234.png" alt="image-20220401223802722"></p><h4 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h4><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p><p>在动态编译同步块的时候，JIT 编译器可以<mark>借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</mark>。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫<mark>锁消除</mark>。</p><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">hellis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span>(hellis) &#123;</span><br><span class="line">        System.out.println(hellis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中对 hellis 这个对象加锁，但是 hellis 对象的生命周期只在 f()方法中，并不会被其他线程所访问到，所以在 JIT 编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">hellis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">System.out.println(hellis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p><mark>标量（scalar）</mark>是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p><p>相对的，那些还可以分解的数据叫做<mark>聚合量（Aggregate）</mark>，Java 中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 JIT 优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，经过标量替换后，就会变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Point 这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。</p><p><strong>标量替换参数设置</strong></p><p>参数<code>-XX:EliminateAllocations</code>：开启了标量替换（默认打开），允许将对象打散分配到栈上。</p><p>上述代码在主函数中进行了 1 亿次 alloc。调用进行对象创建，由于 User 对象实例需要占据约 16 字节的空间，因此累计分配空间达到将近 1.5GB。如果堆空间小于这个值，就必然会发生 GC。使用如下参数运行上述代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span><br></pre></td></tr></table></figure><p>这里设置参数如下：</p><ul><li>参数<code>-server</code>：启动 Server 模式，因为在 server 模式下，才可以启用逃逸分析。</li><li>参数<code>-XX:+DoEscapeAnalysis</code>：启用逃逸分析</li><li>参数<code>-Xmx10m</code>：指定了堆空间最大为 10MB</li><li>参数<code>-XX:+PrintGC</code>：将打印 Gc 日志</li><li>参数<code>-XX:+EliminateAllocations</code>：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有 id 和 name 两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ul><p><strong>代码演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标量替换测试</span></span><br><span class="line"><span class="comment"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  12:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScalarReplace</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//未发生逃逸</span></span><br><span class="line">        u.id = <span class="number">5</span>;</span><br><span class="line">        u.name = <span class="string">&quot;www.atguigu.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果分析:</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204012309577.png" alt="image-20220401230925542">**</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202204012311576.png" alt="image-20220401231123059"></p><h3 id="6-X-3-逃逸分析小结：逃逸分析并不成熟"><a href="#6-X-3-逃逸分析小结：逃逸分析并不成熟" class="headerlink" title="6.X.3. 逃逸分析小结：逃逸分析并不成熟"></a>6.X.3. 逃逸分析小结：逃逸分析并不成熟</h3><p>关于逃逸分析的论文在 1999 年就已经发表了，但直到 JDK1.6 才有实现，而且这项技术到如今也并不是十分成熟。</p><p>其根本原因就是<mark>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 </mark></p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是它也<mark>是即时编译器优化技术中一个十分重要的手段</mark>。</p><p>注意到有一些观点，认为通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。据我所知，Oracle Hotspot JVM 中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确<mark>所有的对象实例都是创建在堆上</mark>。</p><p>目前很多书籍还是基于 JDK7 以前的版本，JDK 已经发生了很大变化，intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p><p><strong>总结:</strong></p><ul><li>逃逸分析是栈上分配、同步省略、标量替换的前提，必须开启。HotSpot不支持栈上分配，所以他是用标量替换来优化的。标量替换和栈上分配没有关系！！！</li><li>&#x3D;&#x3D;所谓的栈上分配，其实就是分配到局部变量表中&#x3D;&#x3D;，而局部变量表中只能存放基本类型的变量和对象引用，所以必须通过标量替换将对象打散成基本类型变量，这前提是又要依赖逃逸分析，即对象未发生逃逸</li><li>逃逸分析和标量替换都可以设置开启&#x2F;关闭，栈上分配只是个概念并未实现，所以逃逸分析开启后的效果可以认为就是标量替换的效果</li></ul><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p><p>老年代放置长生命周期的对象，通常都是从 survivor 区域筛选拷贝过来的 Java 对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。当 GC 只发生在年轻代中，回收年轻代对象的行为被称为 MinorGc。</p><p>当 GC 发生在老年代时则被称为 MajorGc 或者 FullGC。一般的，MinorGc 的发生频率要比 MajorGC 高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五、本地方法栈</title>
      <link href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC05%E7%AB%A0_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"/>
      <url>/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC05%E7%AB%A0_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="5-本地方法接口和本地方法栈"><a href="#5-本地方法接口和本地方法栈" class="headerlink" title="5. 本地方法接口和本地方法栈"></a>5. 本地方法接口和本地方法栈</h1><h2 id="5-1-什么是本地方法？"><a href="#5-1-什么是本地方法？" class="headerlink" title="5.1. 什么是本地方法？"></a>5.1. 什么是本地方法？</h2><p>简单地讲，<mark>一个 Native Method 是一个 Java 调用非 Java 代码的接囗</mark>。一个 Native Method 是这样一个 Java 方法：该方法的实现由非 Java 语言实现，比如 C。这个特征并非 Java 所特有，很多其它的编程语言都有这一机制，比如在 C++中，你可以用 extern “c” 告知 c++编译器去调用一个 c 的函数。</p><blockquote><p>A native method is a Java method whose implementation is provided by non-java code.</p></blockquote><p>在定义一个 native method 时，并不提供实现体（有些像定义一个 Java interface），因为其实现体是由非 java 语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C&#x2F;C++程序。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203281157710.jpg" alt="第02章_JVM架构-英"></p><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IHaveNatives</span> &#123;</span><br><span class="line">    <span class="comment">//native与abstract的区别?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * native:表示有方法体,只不过方法体不是JAVA语言编写的</span></span><br><span class="line"><span class="comment">     * abstract:没有方法体.</span></span><br><span class="line"><span class="comment">     * 所以这两个修饰符不能够同时使用.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">Native1</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">Native2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="type">float</span> <span class="title function_">Native3</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">Native4</span><span class="params">(<span class="type">int</span>[] ary)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标识符 native 可以与其它 java 标识符连用，但是 abstract 除外</p><h2 id="5-2-为什么使用-Native-Method？"><a href="#5-2-为什么使用-Native-Method？" class="headerlink" title="5.2. 为什么使用 Native Method？"></a>5.2. 为什么使用 Native Method？</h2><p>Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><p><strong>与 Java 环境的交互</strong></p><p><mark>有时 Java 应用需要与 Java 外面的环境交互，这是本地方法存在的主要原因。</mark>你可以想想 Java 需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解 Java 应用之外的繁琐的细节。</p><p><strong>与操作系统的交互</strong></p><p>JVM 支持着 Java 语言本身和运行时库，它是 Java 程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。<mark>通过使用本地方法，我们得以用 Java 实现了 jre 的与底层系统的交互，甚至 JVM 的一些部分就是用 c 写的。</mark>还有，如果我们要使用一些 Java 语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p><p><strong>Sun’s Java</strong></p><p><mark>Sun 的解释器是用 C 实现的，这使得它能像一些普通的 C 一样与外部交互。</mark>jre 大部分是用 Java 实现的，它也通过一些本地方法与外界交互。例如：类 java.lang.Thread 的 setPriority()方法是用 Java 实现的，但是它实现调用的是该类里的本地方法 setPriority()。这个本地方法是用 C 实现的，并被植入 JVM 内部，在 Windows 95 的平台上，这个本地方法最终将调用 Win32 setPriority() ApI。这是一个本地方法的具体实现由 JVM 直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被 JVM 调用。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203281202402.png" alt="image-20220328120206672"></p><p><strong>现状</strong></p><p><mark>目前该方法使用的越来越少了，除非是与硬件有关的应用</mark>，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket 通信，也可以使用 Web Service 等等，不多做介绍。</p><h2 id="5-2-本地方法栈"><a href="#5-2-本地方法栈" class="headerlink" title="5.2. 本地方法栈"></a>5.2. 本地方法栈</h2><p><mark>Java 虚拟机栈于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。</mark></p><p>本地方法栈，也是线程私有的。</p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面和Java虚拟机栈是相同的）</p><ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</li></ul><p>本地方法是使用 C 语言实现的。(Java语言调用实现功能扩展.)</p><p>它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203281214376.jpg" alt="第02章_JVM架构-简图 (1)"></p><p><mark>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</mark></p><ul><li>本地方法可以通过本地方法接口来<mark>访问虚拟机内部的运行时数据区</mark>。</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存。</li></ul><p><mark>并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。</mark>如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。</p><p>&#x3D;&#x3D;在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一&#x3D;&#x3D;。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、虚拟机栈</title>
      <link href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC04%E7%AB%A0_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
      <url>/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC04%E7%AB%A0_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="4-虚拟机栈"><a href="#4-虚拟机栈" class="headerlink" title="4. 虚拟机栈"></a>4. 虚拟机栈</h1><h2 id="4-1-虚拟机栈概述"><a href="#4-1-虚拟机栈概述" class="headerlink" title="4.1. 虚拟机栈概述"></a>4.1. 虚拟机栈概述</h2><h3 id="4-1-1-虚拟机栈出现的背景"><a href="#4-1-1-虚拟机栈出现的背景" class="headerlink" title="4.1.1. 虚拟机栈出现的背景"></a>4.1.1. 虚拟机栈出现的背景</h3><p>由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。</p><p><mark>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</mark>。</p><h3 id="4-1-2-初步印象"><a href="#4-1-2-初步印象" class="headerlink" title="4.1.2. 初步印象"></a>4.1.2. 初步印象</h3><p>有不少 Java 开发人员一提到 Java 内存结构，就会非常粗粒度地将 JVM 中的内存区理解为仅有 Java 堆（heap）和 Java 栈（stack）？为什么？</p><h3 id="4-1-3-内存中的栈与堆"><a href="#4-1-3-内存中的栈与堆" class="headerlink" title="4.1.3. 内存中的栈与堆"></a>4.1.3. 内存中的栈与堆</h3><p><mark>栈是运行时的单位，而堆是存储的单位</mark></p><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231704822.png" alt="image-20200705163928652"></p><h3 id="4-1-4-虚拟机栈基本内容"><a href="#4-1-4-虚拟机栈基本内容" class="headerlink" title="4.1.4. 虚拟机栈基本内容"></a>4.1.4. 虚拟机栈基本内容</h3><h4 id="Java-虚拟机栈是什么？"><a href="#Java-虚拟机栈是什么？" class="headerlink" title="Java 虚拟机栈是什么？"></a>Java 虚拟机栈是什么？</h4><p>Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用，是线程私有的。</p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231706992.png" alt="image-20220323170600512" style="zoom:80%;" /><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>生命周期和线程一致</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>主管 Java 程序的运行，它保存方法的<strong>局部变量</strong>（8种基本数据类型、对象的引用类型）、部分结果，并参与方法的调用和返回。</p><p><strong>补充:</strong></p><ul><li>局部变量 VS 成员变量(或属性)</li><li>基本数据变量 VS 引用类型变量(类、数组、接口)</li></ul><h4 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h4><p>栈是一种快速有效的分配存储方式，访问速度仅次于PC计数器。</p><p>JVM 直接对 Java 栈的操作只有两个：</p><ul><li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li><li>执行结束后的<strong>出栈</strong>工作</li></ul><p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231736272.png" alt="image-20200705165025382"></p><h4 id="面试题：开发中遇到哪些异常？"><a href="#面试题：开发中遇到哪些异常？" class="headerlink" title="面试题：开发中遇到哪些异常？"></a>面试题：开发中遇到哪些异常？</h4><p><strong>栈中可能出现的异常</strong></p><p>Java 虚拟机规范允许<mark>Java 栈的大小是动态的或者是固定不变的</mark>。</p><ul><li><p>如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个<mark>StackOverflowError </mark>异常。</p></li><li><p>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<mark> OutOfMemoryError </mark>异常。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    main(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抛出异常：Exception in thread &quot;main&quot; java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">//程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。</span></span><br></pre></td></tr></table></figure><p><strong>设置栈内存大小</strong></p><p>我们可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示栈中的异常:StackOverflowError</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 9:08</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  默认情况下：count : 11417</span></span><br><span class="line"><span class="comment"> *  设置栈的大小： -Xss256k : count : 2460</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackErrorTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        count++;</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-栈的存储单位"><a href="#4-2-栈的存储单位" class="headerlink" title="4.2. 栈的存储单位"></a>4.2. 栈的存储单位</h2><h3 id="4-2-1-栈中存储什么？"><a href="#4-2-1-栈中存储什么？" class="headerlink" title="4.2.1. 栈中存储什么？"></a>4.2.1. 栈中存储什么？</h3><p>每个线程都有自己的栈，栈中的数据都是以<mark>栈帧（Stack Frame）的格式存在</mark>。</p><p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><h3 id="4-2-2-栈运行原理"><a href="#4-2-2-栈运行原理" class="headerlink" title="4.2.2. 栈运行原理"></a>4.2.2. 栈运行原理</h3><p>JVM 直接对 Java 栈的操作只有两个，就是对<mark>栈帧的压栈和出栈，遵循“先进后出”&#x2F;“后进先出”原则</mark>。</p><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<mark>当前栈帧（Current Frame）</mark>，与当前栈帧相对应的方法就是<mark>当前方法（Current Method）</mark>，定义这个方法的类就是<mark>当前类（Current Class）</mark>。</p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231740895.jpg" alt="第05章_方法与栈桢"></p><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java 方法有两种返回函数的方式，<mark>一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出</mark>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 4:11</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 方法的结束方式分为两种：① 正常结束，以return为代表  ② 方法执行中出现未捕获处理的异常，以抛出异常的方式结束</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackFrameTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">StackFrameTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackFrameTest</span>();</span><br><span class="line">            test.method1();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main()正常结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method1()开始执行...&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">        System.out.println(<span class="string">&quot;method1()执行结束...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2()开始执行...&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (<span class="type">int</span>) method3();</span><br><span class="line">        System.out.println(<span class="string">&quot;method2()即将结束...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i + m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method3()开始执行...&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20.0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;method3()即将结束...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231807747.png" alt="image-20220323180741442"></p><h3 id="4-2-3-栈帧的内部结构"><a href="#4-2-3-栈帧的内部结构" class="headerlink" title="4.2.3. 栈帧的内部结构"></a>4.2.3. 栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li><mark>局部变量表（Local Variables）</mark></li><li><mark>操作数栈（operand Stack）（或表达式栈）</mark></li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231814002.jpg" alt="第05章_栈桢内部结构"></p><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，<strong>栈帧的大小主要由局部变量表 和 操作数栈决定的</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231815553.png" alt="image-20200705205443993"></p><h2 id="4-3-局部变量表-Local-Variables"><a href="#4-3-局部变量表-Local-Variables" class="headerlink" title="4.3. 局部变量表(Local Variables)"></a>4.3. 局部变量表(Local Variables)</h2><p>局部变量表也被称之为局部变量数组或本地变量表</p><ul><li><mark>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</mark>，这些数据类型包括各类<strong>基本数据类型</strong>、<strong>对象引用</strong>（reference），以及 <strong>returnAddress</strong> 类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的<strong>私有</strong>数据，因此<mark>不存在数据安全问题</mark></li><li><mark>局部变量表所需的容量大小是在编译期确定下来的</mark>，并保存在方法的 Code 属性的 <strong>maximum local variables</strong> 数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li><mark>方法嵌套调用的次数由栈的大小决定</mark>。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li><li><mark>局部变量表中的变量只在当前方法调用中有效</mark>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul><p>**补充:**栈的大小决定方法嵌套的次数,也就是栈帧的多少,栈帧的大小由局部变量表决定.</p><p><strong>代码验证观察局部变量表:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 6:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariablesTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">        test2(date, name1);</span><br><span class="line">        System.out.println(date + name1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用javap反编译观察结果:</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203241640737.png" alt="image-20220324164038916"></p><p><strong>通过jclasslib进行观察:</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203241645670.png" alt="image-20220324164531126"></p><p><strong>根据jclasslib详细分析代码执行结构:</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203241721072.png" alt="image-20220324172149463"></p><p><strong>补充:</strong> <strong><font color=red>字节码中方法内部结构的剖析图(结合Jclasslib)</font></strong></p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203241759973.png"  /><h3 id="4-3-1-关于-Slot-的理解"><a href="#4-3-1-关于-Slot-的理解" class="headerlink" title="4.3.1. 关于 Slot 的理解"></a>4.3.1. 关于 Slot 的理解</h3><ul><li><p><font color=red>局部变量表，最基本的存储单元是 Slot（变量槽）</font></p></li><li><p>参数值的存放总是在局部变量数组的 index 0 开始，到数组长度-1 的索引结束。</p></li><li><p>局部变量表中存放编译期可知的各种&#x3D;&#x3D;基本数据类型（8 种），引用类型（reference），returnAddress&#x3D;&#x3D; 类型的变量。</p></li><li><p>在局部变量表里，&#x3D;&#x3D;32 位以内的类型只占用一个 slot（包括 returnAddress 类型），64 位的类型（long 和 double）占用两个 slot&#x3D;&#x3D;。</p><ul><li>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true。</li><li>long和double则占据两个Slot</li></ul></li><li><p>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p></li><li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<mark>按照顺序被复制</mark>到局部变量表中的每一个 slot 上</p></li><li><p><font color=red>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可</font>。（比如：访问 long 或 double 类型变量）</p></li><li><p><font color=red>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 slot 处</font>，其余的参数按照参数表顺序继续排列。</p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203241826079.png" alt="image-20200705212454445"></p><p><strong>方法与局部变量表对照图:</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203241928179.png" alt="方法与局部变量表对照图"></p><h3 id="4-3-2-Slot-的重复利用"><a href="#4-3-2-Slot-的重复利用" class="headerlink" title="4.3.2. Slot 的重复利用"></a>4.3.2. Slot 的重复利用</h3><p>栈帧中的局部变量表中的槽位是<strong>可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><p><strong>Slot重复利用示意图:</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203241925636.png" alt="Slot重复利用示意图"></p><h3 id="4-3-3-静态变量与局部变量的对比"><a href="#4-3-3-静态变量与局部变量的对比" class="headerlink" title="4.3.3. 静态变量与局部变量的对比"></a>4.3.3. 静态变量与局部变量的对比</h3><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p><p>我们知道类变量表有两次初始化的机会，第一次是在“<mark>准备阶段</mark>”，执行系统初始化，对类变量设置零值，另一次则是在“<mark>初始化</mark>”阶段，赋予程序员在代码中定义的初始值。</p><p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    System. out. println(i);<span class="comment">//System.out.println(num);//错误信息：Variable &#x27;num&#x27; might not have been initialized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码是错误的，没有赋值不能够使用。</p><p>&#x3D;&#x3D;**补充:**变量的分类：&#x3D;&#x3D;</p><ul><li>按照数据类型分：① 基本数据类型  ② 引用数据类型</li><li>按照在类中声明的位置分：<ul><li>成员变量：在使用前，都经历过默认初始化赋值.<ul><li>类变量(静态变量)： linking的prepare阶段：给类变量默认赋值  —&gt; initial阶段：给类变量显式赋值即静态代码块赋值</li><li>实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</li></ul></li><li>局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过</li></ul></li></ul><h3 id="4-3-4-补充说明"><a href="#4-3-4-补充说明" class="headerlink" title="4.3.4. 补充说明"></a>4.3.4. 补充说明</h3><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p><p><mark>局部变量表中的变量也是重要的<strong>垃圾回收根节点</strong>，只要被局部变量表中直接或间接引用的对象都不会被回收</mark>。</p><h2 id="4-4-操作数栈（Operand-Stack）"><a href="#4-4-操作数栈（Operand-Stack）" class="headerlink" title="4.4. 操作数栈（Operand Stack）"></a>4.4. 操作数栈（Operand Stack）</h2><p>每一个独立的栈帧除了包含&#x3D;&#x3D;局部变量表&#x3D;&#x3D;以外，还包含一个后进先出（Last-In-First-Out）的 <mark>操作数栈</mark>，也可以称之为<mark>表达式栈（Expression Stack）</mark></p><p><mark>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</mark></p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li><li>比如：执行复制、交换、求和等操作</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203251802024.png" alt="image-20200706090618332"></p><p>代码举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码指令信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void testAddOperation();</span><br><span class="line">    Code:</span><br><span class="line">    0: bipush 15</span><br><span class="line">    2: istore_1</span><br><span class="line">    3: bipush 8</span><br><span class="line">    5: istore_2</span><br><span class="line">    6:iload_1</span><br><span class="line">    7:iload_2</span><br><span class="line">    8:iadd</span><br><span class="line">    9:istore_3</span><br><span class="line">    10:return</span><br></pre></td></tr></table></figure><p>操作数栈，<font color=red>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</font>。</p><p>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<mark>这个方法的操作数栈是空的</mark>。</p><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的&#x3D;&#x3D;最大深度在编译期就定义好了&#x3D;&#x3D;，保存在方法的 Code 属性中，为 max_stack 的值。</p><p>栈中的任何一个元素都是可以任意的 Java 数据类型</p><ul><li>32bit 的类型占用一个栈单位深度</li><li>64bit 的类型占用两个栈单位深度</li></ul><p>操作数栈<mark>并非采用访问索引的方式来进行数据访问</mark>的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p><p><mark>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</mark>，并更新 PC 寄存器中下一条需要执行的字节码指令。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p><p>另外，我们说 Java 虚拟机的<mark>解释引擎是基于栈的执行引擎</mark>，其中的栈指的就是操作数栈。</p><p>**备注:**操作数栈和局部变量表的底层都是数组,所以对于double和long类型数据需要两个单位存储.</p><h2 id="4-5-代码追踪"><a href="#4-5-代码追踪" class="headerlink" title="4.5. 代码追踪"></a>4.5. 代码追踪</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 javap 命令反编译 class 文件：<code> javap -v 类名.class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddoperation</span><span class="params">()</span>; </span><br><span class="line">Code:</span><br><span class="line">     <span class="number">0</span> bipush <span class="number">15</span></span><br><span class="line">     <span class="number">2</span> istore_1</span><br><span class="line">     <span class="number">3</span> bipush <span class="number">8</span></span><br><span class="line">     <span class="number">5</span> istore_2</span><br><span class="line">     <span class="number">6</span> iload_1</span><br><span class="line">     <span class="number">7</span> iload_2</span><br><span class="line">     <span class="number">8</span> iadd</span><br><span class="line">     <span class="number">9</span> istore_3</span><br><span class="line">    <span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203251843453.png" alt="image-20200706093131621"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203251843854.png" alt="image-20200706093251302"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203251843783.png" alt="image-20200706093646406"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203251843159.png" alt="image-20200706093751711"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203251843083.png" alt="image-20200706093859191"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203251843759.png" alt="image-20200706093921573"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203251843994.png" alt="image-20200706094046782"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203251843340.png" alt="image-20200706094109629"></p><p>&#x3D;&#x3D;<strong>涉及操作数栈的字节码指令执行分析:</strong>&#x3D;&#x3D;</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203251848045.png" alt="设计操作数栈的字节码指令执行分析"></p><ul><li>istore 指令会导致出栈 并且写入局部变量表  ipush:放入操作数栈 </li><li>istore和istore一样，只不过istore只有0到3（其实是四个不同的指令，操作数隐式指定），再往后就得用istore了，因为还需要显式指出槽位，所以要占两个字节.</li></ul><h2 id="4-6-栈顶缓存技术（Top-Of-Stack-Cashing）技术"><a href="#4-6-栈顶缓存技术（Top-Of-Stack-Cashing）技术" class="headerlink" title="4.6. 栈顶缓存技术（Top Of Stack Cashing）技术"></a>4.6. 栈顶缓存技术（Top Of Stack Cashing）技术</h2><p>前面提过，基于&#x3D;&#x3D;栈式架构&#x3D;&#x3D;的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数。</p><p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 的设计者们提出了<font color=red>栈顶缓存</font>（Tos，Top-of-Stack Cashing）技术，<mark>将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率</mark>。</p><p>**寄存器的优点:**指令更少,执行速度更快</p><h2 id="4-7-动态链接（Dynamic-Linking）"><a href="#4-7-动态链接（Dynamic-Linking）" class="headerlink" title="4.7. 动态链接（Dynamic Linking）"></a>4.7. 动态链接（Dynamic Linking）</h2><p>&#x3D;&#x3D;动态链接、方法返回地址、附加信息 ： 有些地方被称为<strong>帧数据区</strong>&#x3D;&#x3D;</p><p>每一个栈帧内部都包含一个指向<mark>运行时常量池中该栈帧所属方法的引用</mark>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic 指令</p><p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 class 文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<mark>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</mark>。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203261615479.jpg" alt="第09章_方法区与栈的关联结构"></p><p><strong>代码演示:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicLinkingTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodB()....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        methodA();</span><br><span class="line"></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203261633457.png" alt="动态链接"></p><p><strong>为什么需要运行时常量池呢？</strong></p><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别. 也便于变量或者方法引用的多次引用.另外字节码文件中需要很多数据的支持,通常这些数据很大,我们不能直接保存在字节码中,所以我们通过符号引用相关的结构</p><h2 id="4-8-方法的调用：解析与分配"><a href="#4-8-方法的调用：解析与分配" class="headerlink" title="4.8. 方法的调用：解析与分配"></a>4.8. 方法的调用：解析与分配</h2><p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><h3 id="4-8-1-静态链接"><a href="#4-8-1-静态链接" class="headerlink" title="4.8.1. 静态链接"></a>4.8.1. 静态链接</h3><p>当一个字节码文件被装载进 JVM 内部时，如果被调用的<mark>目标方法在编译期可知，且运行期保持不变时</mark>，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p><h3 id="4-8-2-动态链接"><a href="#4-8-2-动态链接" class="headerlink" title="4.8.2. 动态链接"></a>4.8.2. 动态链接</h3><p>如果<mark>被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用的方法的符号转换为直接引用</mark>，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><p><mark>静态链接和动态链接不是名词，而是动词，这是理解的关键。</mark></p><hr><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<mark>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</mark></p><h3 id="4-8-3-早期绑定"><a href="#4-8-3-早期绑定" class="headerlink" title="4.8.3. 早期绑定"></a>4.8.3. 早期绑定</h3><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><h3 id="4-8-4-晚期绑定"><a href="#4-8-4-晚期绑定" class="headerlink" title="4.8.4. 晚期绑定"></a>4.8.4. 晚期绑定</h3><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p><hr><p>随着高级语言的横空出世，类似于 Java 一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然<mark>这一类的编程语言具备多态特征，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</mark></p><p>Java 中任何一个普通的方法其实都具备虚函数的特征，它们相当于 C++语言中的虚函数（C++中则需要使用关键字 virtual 来显式定义）。如果在 Java 程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字 &#x3D;&#x3D;final&#x3D;&#x3D; 来标记这个方法。</p><hr><p><strong>代码演示:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明早期绑定和晚期绑定的例子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 上午 11:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物进食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Huntable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Huntable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，多管闲事&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Huntable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.eat();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，天经地义&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAnimal</span><span class="params">(Animal animal)</span>&#123;</span><br><span class="line">        animal.eat();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showHunt</span><span class="params">(Huntable h)</span>&#123;</span><br><span class="line">        h.hunt();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-8-5-虚方法和非虚方法"><a href="#4-8-5-虚方法和非虚方法" class="headerlink" title="4.8.5. 虚方法和非虚方法"></a>4.8.5. 虚方法和非虚方法</h3><p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</p><p>&#x3D;&#x3D;静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法。其他方法称为虚方法。&#x3D;&#x3D;</p><p>虚拟机中提供了以下几条方法调用指令：</p><h4 id="普通调用指令："><a href="#普通调用指令：" class="headerlink" title="普通调用指令："></a>普通调用指令：</h4><ul><li><mark>invokestatic：调用静态方法，解析阶段确定唯一方法版本</mark></li><li><mark>invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本</mark></li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ul><p><strong>代码演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析调用中非虚方法、虚方法的测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * invokestatic指令和invokespecial指令调用的方法称为非虚方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 12:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">showFinal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father show final&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showCommon</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father 普通方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是重写的父类的静态方法，因为静态方法不能被重写！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showPrivate</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son private&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        showStatic(<span class="string">&quot;atguigu.com&quot;</span>);</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        <span class="built_in">super</span>.showStatic(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        showPrivate(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">super</span>.showCommon();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invokespecial:非虚方法,编译期便可知道.</span></span><br><span class="line">        <span class="built_in">super</span>.showFinal();</span><br><span class="line">        <span class="comment">//invokevirtual</span></span><br><span class="line">        showFinal();<span class="comment">//因为此方法声明有final，不能被子类重写(但是可以直接调用啊.)，所以也认为此方法是非虚方法。备注:虽然invokevirtual一般调用的是虚方法,但是 final修饰的方法例外.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//虚方法如下：</span></span><br><span class="line">        <span class="comment">//invokevirtual</span></span><br><span class="line">        showCommon();<span class="comment">//没有super调用,且当前类可能重写该方法.所以无法确定.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//info 在编译期间无法确定下来.首先它不属于父类的方法，是子类中额外加入的功能方法.如果Son的子类对其进行重写,可以构成多态.</span></span><br><span class="line">        <span class="comment">//例:如果存在一个类继承了Son，那具体用的是Son的info还是Son子类的info，编译器就确定不了了</span></span><br><span class="line">        info();</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodInterface</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//invokeinterface</span></span><br><span class="line">        in.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Father f)</span>&#123;</span><br><span class="line">        f.showCommon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">so</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        so.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MethodInterface</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态调用指令："><a href="#动态调用指令：" class="headerlink" title="动态调用指令："></a>动态调用指令：</h4><ul><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 invokedynamic 指令则支持由用户确定方法版本。<mark>其中 invokestatic 指令和 invokespecial 指令调用的方法称为非虚方法，其余的（fina1 修饰的除外）称为虚方法。</mark></p><p><strong>关于 invokedynamic 指令</strong></p><ul><li>JVM 字节码指令集一直比较稳定，一直到 Java7 中才增加了一个 invokedynamic 指令，这是<mark>Java 为了实现「动态类型语言」支持而做的一种改进。</mark> (Java本身还是一种静态类型语言)</li><li>但是在 Java7 中并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令。<mark>直到 Java8 的 Lambda 表达式的出现，invokedynamic 指令的生成，在 Java 中才有了直接的生成方式。</mark></li><li>Java7 中增加的动态语言类型支持的本质是对 Java 虚拟机规范的修改，而不是对 Java 语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在 Java 平台的动态语言的编译器。</li></ul><p><strong>代码演示:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 体会invokedynamic指令</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 3:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Func</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">func</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">(Func func)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lambda</span> <span class="variable">lambda</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lambda</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Func</span> <span class="variable">func</span> <span class="operator">=</span> s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        lambda.lambda(func);</span><br><span class="line"></span><br><span class="line">        lambda.lambda(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203261819890.png" alt="image-20220326181920325"></p><h4 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h4><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p><p>说的再直白一点就是，<mark>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</mark>，这是动态语言的一个重要特征。</p><p><strong>举例</strong></p><ul><li>Java:String info &#x3D; “lxylovejava”; &#x2F;&#x2F; info &#x3D; 123   这样就会报错.  info被赋予String的类型信息.</li><li>JS:var name &#x3D; “lxy123456”; var name &#x3D; 10;&#x2F;&#x2F;两种写法都可以,因为是运行期根据值确定类型的 name没有类型信息</li><li>Python: info &#x3D; 130.5; &#x2F;&#x2F;Python更牛叉,类型声明都不需要了…</li></ul><h3 id="4-8-6-方法重写的本质"><a href="#4-8-6-方法重写的本质" class="headerlink" title="4.8.6. 方法重写的本质"></a>4.8.6. 方法重写的本质</h3><p><strong>Java 语言中方法重写的本质：</strong></p><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。(也就是说重写会去操作数栈栈顶获取到对象的引用类型，也就是符号引用，通过这个对象的符号引用就可以在堆中找到这个对象.)</li><li>如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常。</li><li>否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodsError 异常。</li></ol><p><strong>总结:</strong></p><ul><li>在编译阶段，编译器只知道对象的静态类型(类)，而不知道实际类型，因此只能在class文件中确定调用父类的方法。</li><li>在执行过程中，它将判断对象的实际类型。如果实际类型实现了这种方法，它将被直接调用。如果没有实现，它将根据继承关系从下到上进行检索。只要检索到，它将被调用。如果没有检索到，它将被抛弃。继续向上层寻找.如果最后没有找到,则说明抽象方法没有被实现,则抛出<strong>AbstractMethodsError</strong></li></ul><p><strong>IllegalAccessError 介绍</strong></p><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p><h3 id="4-8-7-方法的调用：虚方法表"><a href="#4-8-7-方法的调用：虚方法表" class="headerlink" title="4.8.7. 方法的调用：虚方法表"></a>4.8.7. 方法的调用：虚方法表</h3><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派(invokevirtual)的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。<mark>因此，为了提高性能，JVM 采用在类的方法区建立一个虚方法表 （virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</mark>  </p><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。(每次调用方法,直接从虚方法表中找各个方法的是哪个类型的信息)</p><p>虚方法表是什么时候被创建的呢？</p><p>虚方法表会在&#x3D;&#x3D;类加载的链接阶段被创建并开始初始化&#x3D;&#x3D;，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</p><p><strong>代码演示:</strong></p><p>举例 1：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203261913070.png" alt="image-20200706144954070"></p><p>举例 2：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203261903895.png" alt="image-20220326190335430"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚方法表的举例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 1:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Friendly</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayGoodbye</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Friendly</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayGoodbye</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cat&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CockerSpaniel</span> <span class="keyword">extends</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Friendly</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayGoodbye</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualMethodTable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203261912699.png" alt="虚函数表"></p><h2 id="4-9-方法返回地址（return-address）"><a href="#4-9-方法返回地址（return-address）" class="headerlink" title="4.9. 方法返回地址（return address）"></a>4.9. 方法返回地址（return address）</h2><p>存放调用该方法的 pc 寄存器的值。一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<mark>调用者的 pc 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</mark>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><p><strong>总结:</strong></p><ul><li>当执行到A调用B的方法时，pc记录的是A的下一条指令，当B的栈帧被创建并作为当前栈帧时同时也获取到pc中的值并生成了返回地址，当B方法return，pc的值就是返回地址 (&#x3D;&#x3D;注意:返回地址和返回值是两回事哦&#x3D;&#x3D;)</li><li>方法返回地址记录的是当前栈帧的上一级栈帧的执行位置 而pc寄存器存储的永远是当前栈帧的执行位置</li></ul><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<mark>正常完成出口</mark>；<ul><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含 ireturn（当返回值是 boolean，byte，char，short 和 int 类型时使用），lreturn（Long 类型），freturn（Float 类型），dreturn（Double 类型），areturn。另外还有一个 return 指令声明为 void 的方法，实例初始化方法，类和接口的初始化方法使用。</li></ul></li><li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<mark>异常完成出口</mark>。</li></ol><p><strong>代码演示:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回指令包含ireturn（当返回值是boolean、byte、char、short和int类型时使用）、</span></span><br><span class="line"><span class="comment"> * lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、</span></span><br><span class="line"><span class="comment"> * 实例初始化方法、类和接口的初始化方法使用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 4:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnAddressTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造方法返回指令:return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">methodBoolean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//ireturn;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span> <span class="title function_">methodByte</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//ireturn;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">short</span> <span class="title function_">methodShort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//ireturn;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">methodChar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>;<span class="comment">//ireturn;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">methodInt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//ireturn;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">methodLong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;<span class="comment">//lreturn;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">methodFloat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0f</span>;<span class="comment">//freturn;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">methodDouble</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;<span class="comment">//dreturn;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">methodString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//areturn;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">methodDate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//areturn;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodVoid</span><span class="params">()</span> &#123;<span class="comment">//return;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        methodVoid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;atguigu.txt&quot;</span>);</span><br><span class="line">        <span class="type">char</span>[] cBuffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(cBuffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cBuffer, <span class="number">0</span>, len);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码,如下图所示:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception table:</span><br><span class="line">from  to   target  type</span><br><span class="line">4  16    19    any  //字节码4-16行出任何问题了,按照19行的解决方法处理.</span><br><span class="line">19  2119     any //字节码19-21行出任何问题了,按照19行的解决方法处理.</span><br></pre></td></tr></table></figure><p>本质上，<font color=red>方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值(用返回地址)等</font>，让调用者方法继续执行下去。</p><p><mark>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</mark></p><p><strong>注意:</strong></p><ul><li><p>返回地址和返回值是两回事，当前方法正常执行两者都有，既能接续上层方法又向其传递返回值；当前方法异常且未处理两者都没，此时能否接续上层方法的依据是上层方法的异常表.</p></li><li><p>每个方法对应一个异常处理表，方法对应着栈帧，栈帧存在于Java虚拟机栈，Java虚拟机栈和本地方法栈两者是不一样的.</p></li></ul><h2 id="4-10-一些附加信息"><a href="#4-10-一些附加信息" class="headerlink" title="4.10. 一些附加信息"></a>4.10. 一些附加信息</h2><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h2 id="4-11-栈的相关面试题"><a href="#4-11-栈的相关面试题" class="headerlink" title="4.11. 栈的相关面试题"></a>4.11. 栈的相关面试题</h2><ul><li>举例栈溢出的情况？（StackOverflowError）<ul><li>通过 -Xss 设置栈的大小 (内存空间不足出现OOM)</li></ul></li><li>调整栈大小，就能保证不出现溢出么？<ul><li>不能保证不溢出  (可以延迟其溢出时间..)</li></ul></li><li>分配的栈内存越大越好么？<ul><li>不是，一定时间内降低了 OOM 概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li></ul></li><li>垃圾回收是否涉及到虚拟机栈？<ul><li>不会</li></ul></li><li>方法中定义的局部变量是否线程安全？<ul><li>具体问题具体分析。如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul></li></ul><p>&#x3D;&#x3D;方法中定义的局部变量是否线程安全？&#x3D;&#x3D; </p><p><strong>代码演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：</span></span><br><span class="line"><span class="comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   何为线程安全？</span></span><br><span class="line"><span class="comment"> *      如果只有一个线程才可以操作此数据，则必是线程安全的。</span></span><br><span class="line"><span class="comment"> *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 7:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s1的声明方式是线程安全的  内部产生内部消亡就是线程安全的!</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder:线程不安全</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sBuilder的操作过程：是线程不安全的    sBuilder创建后除了当前方法,可能被其他多个线程操作..</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder sBuilder)</span>&#123;</span><br><span class="line">        sBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        sBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程不安全的  因为有返回值,可能被多个线程抢用.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程安全的  类似于情况1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();<span class="comment">//返回的String可能被多个线程强用,但是StringBuilder是安全的,随着方法的消亡而消亡.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="comment">//可以看出method2是线程不安全的.</span></span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        method2(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>&#x3D;&#x3D;比较运行时数据区的Error和GC的情况&#x3D;&#x3D;</li></ul><table><thead><tr><th align="left">运行时数据区</th><th align="left">是否存在 Error</th><th align="left">是否存在 GC</th></tr></thead><tbody><tr><td align="left">程序计数器</td><td align="left">否</td><td align="left">否</td></tr><tr><td align="left">虚拟机栈</td><td align="left">是（SOE）</td><td align="left">否</td></tr><tr><td align="left">本地方法栈</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">方法区</td><td align="left">是（OOM）</td><td align="left">是</td></tr><tr><td align="left">堆</td><td align="left">是</td><td align="left">是</td></tr></tbody></table><hr>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、运行时数据区及程序计数器</title>
      <link href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC03%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%8F%8A%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
      <url>/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC03%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%8F%8A%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="3-运行时数据区及程序计数器"><a href="#3-运行时数据区及程序计数器" class="headerlink" title="3. 运行时数据区及程序计数器"></a>3. 运行时数据区及程序计数器</h1><h2 id="3-1-运行时数据区"><a href="#3-1-运行时数据区" class="headerlink" title="3.1. 运行时数据区"></a>3.1. 运行时数据区</h2><h3 id="3-1-1-概述"><a href="#3-1-1-概述" class="headerlink" title="3.1.1. 概述"></a>3.1.1. 概述</h3><p>本节主要讲的是<strong>运行时数据区</strong>，也就是下图这部分，它是在类加载完成后的阶段</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231528290.jpg" alt="第02章_JVM架构-简图"></p><p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们<strong>运行时数据区</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231520121.jpg" alt="第03章_引入运行时数据区"></p><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行 JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。结合 JVM 虚拟机规范，来探讨一下经典的 JVM 内存布局。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231529403.png" alt="image-20220323152906086"></p><p>我们把大厨后面的东西（切好的菜，刀，调料），比作是<strong>运行时数据区</strong>。而厨师可以类比于<strong>执行引擎</strong>，将通过准备的东西进行制作成精美的菜品</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231650888.png" alt="image-20210509174543026"></p><p>我们通过磁盘或者网络 IO 得到的数据，都需要先加载到内存中，然后 CPU 从内存中获取数据进行读取，也就是说<mark>内存充当了 CPU 和磁盘之间的桥梁</mark></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231650261.png" alt="image-20200705112416101"></p><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括<strong>程序计数器、栈、本地栈</strong>。</li><li>线程间共享：堆、堆外内存（<strong>永久代或元空间</strong>、代码缓存）  &#x3D;&#x3D;&gt; 堆外内存可以理解为<strong>方法区</strong></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231533532.jpg" alt="第03章_线程共享和私有的结构"></p><p>每个 JVM 只有一个 &#x3D;&#x3D;Runtime&#x3D;&#x3D; 实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231544513.png" alt="image-20220323154418052"></p><h3 id="3-1-2-线程"><a href="#3-1-2-线程" class="headerlink" title="3.1.2. 线程"></a>3.1.2. 线程</h3><p>线程是一个程序里的运行单元。JVM 允许一个应用有多个线程并行的执行。 在 Hotspot JVM 里，每个线程都与操作系统的本地线程直接映射。</p><p>当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收。</p><p>操作系统负责所有线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用 Java 线程中的 run()方法。</p><h3 id="3-1-3-JVM-系统线程"><a href="#3-1-3-JVM-系统线程" class="headerlink" title="3.1.3. JVM 系统线程"></a>3.1.3. JVM 系统线程</h3><p>如果你使用 Jconsole 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[] args)</code>的 main 线程以及所有这个 main 线程自己创建的线程。</p><p>这些主要的后台系统线程在 Hotspot JVM 里主要是以下几个：</p><ul><li><mark>虚拟机线程</mark>：这种线程的操作是需要 JVM 达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li><mark>周期任务线程</mark>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li><mark>GC 线程</mark>：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持。</li><li><mark>编译线程</mark>：这种线程在运行时会将字节码编译成到本地代码。</li><li><mark>信号调度线程</mark>：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理。</li></ul><h2 id="3-2-程序计数器-PC-寄存器"><a href="#3-2-程序计数器-PC-寄存器" class="headerlink" title="3.2. 程序计数器(PC 寄存器)"></a>3.2. 程序计数器(PC 寄存器)</h2><p>JVM 中的<strong>程序计数寄存器</strong>（Program Counter Register）中，Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的现场信息。CPU 只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为 PC 计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<mark>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</mark>。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231650900.png" alt="image-20200705155551919"></p><p><strong>作用</strong></p><p>PC 寄存器用来<strong>存储指向下一条指令的地址</strong>，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231649112.png" alt="image-20200705155728557"></p><p>它是一块很小的内存空间，几乎可以忽略不记。也是<mark>运行速度最快的存储区域</mark>。</p><p>在 JVM 规范中，<mark>每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</mark>。</p><p><mark>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法</mark>。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行 native 方法(C&#x2F;C++编写的)，则是未指定值（undefined）。</p><p>它是程序控制流的<strong>指示器</strong>，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。&#x3D;&#x3D;&gt; 类似于Mysql中的游标,Java集合中的迭代器…</p><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>它是唯一一个在 Java 虚拟机规范中没有规定任何 OutofMemoryError 情况的区域。</p><p><strong>备注:</strong><mark>栈区和PC计数器都无GC.PC只负责获取下一条要执行的指令,也无OOM(OutofMemoryError),而堆,栈,方法区都可能出现OOM.</mark>所以PC计数器既没有GC有没有OOM,是一个很特殊的区域.</p><p><strong>举例说明</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PCRegisterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0: bipush        10# 赋值</span><br><span class="line">2: istore_1# 保存</span><br><span class="line">3: bipush        20# 赋值</span><br><span class="line">5: istore_2# 保存</span><br><span class="line">6: iload_1# 加载进来</span><br><span class="line">7: iload_2</span><br><span class="line">8: iadd# 相加</span><br><span class="line">9: istore_3# 保存</span><br><span class="line">10: ldc           #2                  // String abc</span><br><span class="line">12: astore        4</span><br><span class="line">14: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">17: iload_1</span><br><span class="line">18: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">21: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">24: iload_3</span><br><span class="line">25: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">28: return</span><br></pre></td></tr></table></figure><p><strong>图解:</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231629772.png" alt="image-20220323162940780"></p><p><strong>使用 PC 寄存器存储字节码指令地址有什么用呢？为什么使用 PC 寄存器记录当前线程的执行地址呢？</strong></p><p>因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p>JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231648074.png" alt="image-20200705161409533"></p><p><strong>PC 寄存器为什么被设定为私有的？</strong></p><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<mark>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器</mark>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231648873.png" alt="image-20220323164031610"></p><p><strong>CPU 时间片</strong></p><p>CPU 时间片即 CPU 分配给各个程序的时间，<strong>每个线程被分配一个时间段</strong>，称作它的时间片。</p><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个 CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231649873.png" alt="image-20200705161849557"></p><p><strong>补充:</strong></p><ul><li><p>并行 VS 串行  并行:同一时间点都在执行, 串行:排队依次执行.</p></li><li><p>并发 : 同一时间段都在执行，但同一时间点不一定都执行</p></li></ul><p>例子:并发是两个队列交替使用一台咖啡机，并行是两个队列同时使用两台咖啡机. </p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、类加载子系统</title>
      <link href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC02%E7%AB%A0_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC02%E7%AB%A0_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="2-类加载子系统"><a href="#2-类加载子系统" class="headerlink" title="2. 类加载子系统"></a>2. 类加载子系统</h1><h2 id="2-1-内存结构概述"><a href="#2-1-内存结构概述" class="headerlink" title="2.1. 内存结构概述"></a>2.1. 内存结构概述</h2><ul><li>Class 文件</li><li><mark>类加载子系统</mark></li><li>运行时数据区<ul><li>方法区</li><li>堆</li><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul></li><li>执行引擎</li><li>本地方法接口</li><li>本地方法库</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201818222.jpg" alt="第02章_JVM架构-简图"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201819909.jpg" alt="第02章_JVM架构-中"></p><p>如果自己想手写一个 Java 虚拟机的话，主要考虑哪些结构呢？</p><ul><li>类加载器</li><li>执行引擎</li></ul><h2 id="2-2-类加载器与类的加载过程"><a href="#2-2-类加载器与类的加载过程" class="headerlink" title="2.2. 类加载器与类的加载过程"></a>2.2. 类加载器与类的加载过程</h2><p><strong>类加载器子系统作用</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201820395.png" alt="image-20220320182023796"></p><ul><li>类加载器子系统负责从文件系统或者网络中加载 Class 文件，class 文件在文件开头有特定的文件标识。</li><li><font color=red>ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。</font></li><li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）</li></ul><p><strong>类加载器 ClasLoader 角色</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201821179.png" alt="image-20200705081913538"></p><ul><li>class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 JVM 当中来根据这个文件实例化出 n 个一模一样的实例。</li><li>class file 加载到 JVM 中，被称为 <strong>DNA 元数据模板</strong>，放在方法区。</li><li>在.class 文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器 Class Loader），扮演一个快递员的角色。</li></ul><p><strong>类的加载过程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *示例代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用流程图表示上述示例代码：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201822254.jpg" alt="第02章_类的加载过程"></p><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231110765.png" alt="image-20220323111017096"></p><ul><li><ol><li>通过一个类的全限定名获取定义此类的<strong>二进制字节流</strong></li></ol></li><li><ol start="2"><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构(<strong>jdk7之前叫永久代，7之后叫元空间</strong>)</li></ol></li><li><ol start="3"><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</li></ol></li></ul><p>**备注:**JDK8中 Class对象存放在堆区，类的元数据存在方法区（元空间），元数据<code>≠</code>类的Class对象！<br>Class对象是加载的最终产品，类的方法代码，变量名，方法名，访问权限，返回值等等在方法区（元空间）</p><p><strong>补充：加载 class 文件的方式</strong></p><ul><li>从<mark>本地系统</mark>中直接加载(日常在编译器中写的Java代码)</li><li>通过<mark>网络</mark>获取，典型场景：Web Applet</li><li>从 zip<mark>压缩包</mark>中读取，成为日后 jar、war 格式的基础</li><li>运行时计算生成，使用最多的是：<mark>动态代理技术</mark></li><li>由其他文件生成，典型场景：<mark>JSP 应用</mark></li><li>从专有<mark>数据库</mark>中提取.class 文件，比较少见</li><li>从<mark>加密文件</mark>中获取，典型的防 Class 文件被反编译的保护措施</li></ul><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><ul><li><strong>验证（Verify）</strong>：<ul><li>目的在子确保 Class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li><li>主要包括四种验证，<mark>文件格式验证，元数据验证，字节码验证，符号引用验证。</mark></li></ul></li><li><strong>准备（Prepare）</strong>：<ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值。(int类型0,浮点类型0.0,bool类型false,引用类型:null)</li><li><mark>这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显式初始化；</mark></li><li><mark>这里不会为实例变量分配初始化</mark>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</li></ul></li><li><strong>解析（Resolve）</strong>：<ul><li>将常量池内的<mark>符号引用转换为直接引用</mark>的过程。</li><li>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行。</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java 虚拟机规范》的 Class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等。</li></ul></li></ul><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><ul><li><mark>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</mark></li><li>此方法不需定义，是<font color=red> javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</font>。(如果该类中没有静态变量的赋值操作&#x2F;静态代码块,那么该clinit类则不会生成.)</li><li>构造器方法中指令按语句在源文件中出现的顺序执行。</li><li><mark>clinit()不同于类的构造器。</mark>（关联：构造器是虚拟机视角下的&lt;init&gt;()）</li><li>若该类具有父类，JVM 会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕。</li><li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203211500985.png" alt="image-20220321150016595"></p><h2 id="2-3-类加载器分类"><a href="#2-3-类加载器分类" class="headerlink" title="2.3. 类加载器分类"></a>2.3. 类加载器分类</h2><p>JVM 支持两种类型的类加载器 。分别为<mark>引导类加载器（Bootstrap ClassLoader）</mark>和<mark>自定义类加载器（User-Defined ClassLoader）</mark>。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是将<mark>所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器</mark>。</p><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有 3 个，如下所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203221525748.png" alt="image-20200705094149223"></p><p>这里的四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203221830043.png" alt="image-20220322183030556"></p><h3 id="2-3-1-虚拟机自带的加载器"><a href="#2-3-1-虚拟机自带的加载器" class="headerlink" title="2.3.1. 虚拟机自带的加载器"></a>2.3.1. 虚拟机自带的加载器</h3><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p><ul><li>这个类加载使用 C&#x2F;C++语言实现的，嵌套在 JVM 内部。(所以无法获取其对象…)</li><li>它用来加载 Java 的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类</li><li>并不继承自 ava.lang.ClassLoader，没有父加载器。</li><li><font color=red>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</font>。</li><li>出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类</li></ul><p><strong>扩展类加载器（Extension ClassLoader）</strong></p><ul><li>Java 语言编写，由 sun.misc.Launcher$<strong>ExtClassLoader</strong> 实现。</li><li>派生于 ClassLoader 类</li><li><strong>父类加载器为启动类加载器</strong></li><li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre&#x2F;1ib&#x2F;ext 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载。</li></ul><p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p><ul><li>java 语言编写，由 sun.misc.Launchers**$AppClassLoader** 实现</li><li>派生于 ClassLoader 类</li><li><strong>父类加载器为扩展类加载器</strong></li><li>它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库</li><li><font color=red>该类加载是程序中默认的类加载器，一般来说，Java 应用的类都是由它来完成加载</font></li><li>通过 ClassLoader#getSystemclassLoader() 方法可以获取到该类加载器</li></ul><p><strong>代码演示</strong></p><ul><li>验证三种类加载器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 上午 9:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1b6d3586</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：获取不到引导类加载器(因为底层使用C/C++编写)</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//null 引导类加载器无法获取</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>验证加载器加载的路径</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 上午 12:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;**********启动类加载器**************&quot;</span>);</span><br><span class="line">        <span class="comment">//获取BootstrapClassLoader能够加载的api的路径</span></span><br><span class="line">        URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL element : urLs) &#123;</span><br><span class="line">            System.out.println(element.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Provider.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;***********扩展类加载器*************&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">extDirs</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String path : extDirs.split(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> CurveDB.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203221851083.png" alt="image-20220322185150543"></p><h3 id="2-3-2-用户自定义类加载器"><a href="#2-3-2-用户自定义类加载器" class="headerlink" title="2.3.2. 用户自定义类加载器"></a>2.3.2. 用户自定义类加载器</h3><p>在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？</p><ul><li>隔离加载类(比如项目中的中间件和使用到的框架,有可能会有相同的类路径也一样,可能出现冲突问题,需要类加载器进行冲裁.)</li><li>修改类加载的方式(修改处理Bootstrap加载器外其他类加载器的使用方式,需要时进行加载.)</li><li>扩展加载源(比如:数据库,机顶盒..)</li><li>防止源码泄漏(利用自定义加载类对加密的字节码文件 加载并进行解密)</li></ul><p><strong><font color=red>用户自定义类加载器实现步骤：</font></strong></p><ol><li>开发人员可以通过继承抽象类 java.lang.<strong>ClassLoader</strong> 类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在 JDK1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但是在 JDK1.2 之后已不再建议用户去覆盖 loadclass() 方法，而是建议把自定义的类加载逻辑写在 <strong>findClass</strong>()方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 <strong>findClass</strong>() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><p><strong>代码演示:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义用户类加载器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019 下午 12:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> defineClass(name,result,<span class="number">0</span>,result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获取字节码文件的字节流</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassFromCustomPath(String name)&#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">customClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;One&quot;</span>,<span class="literal">true</span>,customClassLoader);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-ClassLoader-的使用说明"><a href="#2-4-ClassLoader-的使用说明" class="headerlink" title="2.4. ClassLoader 的使用说明"></a>2.4. ClassLoader 的使用说明</h2><p>ClassLoader 类是一个抽象类，其后所有的类加载器都继承自 <strong>ClassLoader</strong>（不包括启动类加载器）</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203221930878.png" alt="image-20220322192157097"></p><p><strong>常见方法如下:</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203221930938.png" alt="image-20200705103516138"></p><p>sun.misc.<strong>Launcher</strong> 它是一个 java 虚拟机的入口应用</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a22114b608dffe484041b591d486a7fd.png" alt="image-20200705103636003"></p><p><strong>获取 ClassLoader 的途径</strong></p><ul><li><p>方式一：获取当前 ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clazz.getClassLoader()</span><br></pre></td></tr></table></figure></li><li><p>方式二：获取当前线程上下文的 ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></table></figure></li><li><p>方式三：获取系统的 ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></table></figure></li><li><p>方式四：获取调用者的 ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></table></figure><p><strong>代码演示:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 上午 10:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);<span class="comment">//null</span></span><br><span class="line">            <span class="comment">//2.</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">            System.out.println(classLoader1);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader2</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">            System.out.println(classLoader2);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1b6d3586</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-5-双亲委派机制"><a href="#2-5-双亲委派机制" class="headerlink" title="2.5. 双亲委派机制"></a>2.5. 双亲委派机制</h2><p>Java 虚拟机对 class 文件采用的是**<mark>按需加载</mark><strong>的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是</strong><mark>双亲委派模式</mark>**，即把请求交由父类处理，它是一种任务委派模式。</p><p><strong>工作原理</strong></p><ul><li>1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>3）如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203222224506.png" alt="image-20200705105151258"></p><p><strong>代码演示:</strong></p><p>项目下建立java.lang包,里面创建String类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在java1包下创建StringTest类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        java.lang.<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.lang.String();</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,atguigu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">StringTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();</span><br><span class="line">        System.out.println(test.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行StringTest方法</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231159334.png" alt="加载分析"></p><p>在String类中增加Main方法,执行观察结果:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231204675.png" alt="image-20220323120444059"></p><p><strong>举例</strong></p><p>当我们加载 jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar 是基于 SPI 接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器(启动类)中加载 SPI 核心类.然后在加载 SPI 接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar 的加载。</p><p>**补充:**spi是引导类加载器加载，第三方的类库实现是系统类加载器加载。当使用spi时，是无法访问系统类加载器加载，所以引入了线程上下文类加载器，由线程上下文类加载器来加载第三方的库，这样就能使用到第三方的库了</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231210595.png" alt="image-20200705105810107"></p><p><strong>优势</strong></p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心 API 被随意篡改<ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang 开头的类）</li></ul></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203231218244.png" alt="image-20220323121843155"></p><p><strong>沙箱安全机制</strong></p><p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar 包中 java\lang\String.class），报错信息说<strong>没有 main 方法</strong>，就是因为加载的是 rt.jar 包中的 string 类。这样可以保证对 java 核心源代码的保护，这就是<font color=red>沙箱安全机制</font>。</p><h2 id="2-6-其他"><a href="#2-6-其他" class="headerlink" title="2.6. 其他"></a>2.6. 其他</h2><p><strong>如何判断两个 class 对象是否相同</strong></p><p>在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的 <strong>ClassLoader</strong>（指 ClassLoader 实例对象）必须相同。</li></ul><p>换句话说，在 JVM 中，即使这两个类对象（class 对象）来源同一个 Class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。</p><p><strong>对类加载器的引用</strong></p><p>JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会<mark>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</mark>。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。</p><p><strong>类的主动使用和被动使用</strong></p><p>Java 程序对类的使用方式分为：主动使用和被动使用。</p><p>主动使用，又分为七种情况：</p><ul><li><p>创建类的实例</p></li><li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p>调用类的静态方法</p></li><li><p>反射（比如：Class.forName（”com.atguigu.Test”））</p></li><li><p>初始化一个类的子类</p></li><li><p>Java 虚拟机启动时被标明为启动类的类</p></li><li><p>JDK 7 开始提供的动态语言支持：</p><p>java.lang.invoke.MethodHandle 实例的解析结果</p><p>REF_getStatic、REF_putStatic、REF_invokeStatic 句柄对应的类没有初始化，则初始化</p></li></ul><p>除了以上七种情况，其他使用 Java 类的方式都被看作是对<mark>类的被动使用</mark>，都<mark>不会导致类的初始化</mark>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、JVM与Java体系结构</title>
      <link href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC01%E7%AB%A0_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC01%E7%AB%A0_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-JVM-与-Java-体系结构"><a href="#1-JVM-与-Java-体系结构" class="headerlink" title="1.JVM 与 Java 体系结构"></a>1.JVM 与 Java 体系结构</h1><h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1. 前言"></a>1.1. 前言</h2><p>作为 Java 工程师的你曾被伤害过吗？你是否也遇到过这些问题？</p><ul><li>运行着的线上系统突然卡死，系统无法访问，甚至直接 OOM</li><li>想解决线上 JVM GC 问题，但却无从下手</li><li>新项目上线，对各种 JVM 参数设置一脸茫然，直接默认吧然后就 JJ 了</li><li>每次面试之前都要重新背一遍 JVM 的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优 JVM 参数，如何解决 GC、OOM 等问题，一脸懵逼</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201717418.png" alt="image-20220320151327223"></p><p><strong><font color=red>大部分 Java 开发人员，除会在项目中使用到与 Java 平台相关的各种高精尖技术，对于 Java 技术的核心 Java 虚拟机了解甚少</font></strong></p><p><strong>开发人员如何看待上层框架</strong></p><p>一些有一定工作经验的开发人员，打心眼儿里觉得 SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。</p><p>如果我们把核心类库的 API 比做数学公式的话，那么 Java 虚拟机的知识就好比公式的推导过程。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201513924.png" alt="image-20200704112119729"></p><p>计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言</p><p><strong>我们为什么要学习 JVM？</strong></p><ul><li>面试的需要（BATJ、TMD，PKQ 等面试都爱问）</li><li>中高级程序员必备技能<ul><li>项目管理、调优的需求</li></ul></li><li>追求极客的精神<ul><li>比如：垃圾回收算法、JIT、底层原理</li></ul></li></ul><p><strong>Java vs C++</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201515126.png" alt="image-20200704112700211"></p><p>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，<strong>懂得 JVM 内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础</strong>，也是 Java <strong>工程师</strong>进阶的必备能力。</p><h2 id="1-2-面向人群及参考书目"><a href="#1-2-面向人群及参考书目" class="headerlink" title="1.2. 面向人群及参考书目"></a>1.2. 面向人群及参考书目</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201516081.png" alt="image-20210507095948516"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201516458.png" alt="image-20200704145340513"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201516040.png" alt="image-20210507100021400"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201516972.png" alt="image-20210507100104455"></p><h2 id="1-3-Java-及-JVM-简介"><a href="#1-3-Java-及-JVM-简介" class="headerlink" title="1.3. Java 及 JVM 简介"></a>1.3. Java 及 JVM 简介</h2><p><strong>TIOBE 语言热度排行榜：<a href="https://tiobe.com/tiobe-index/">index | TIOBE - The Software Quality Company</a></strong></p><table><thead><tr><th align="left">Programming Language</th><th align="left">2021</th><th align="left">2016</th><th align="left">2011</th><th align="left">2006</th><th align="left">2001</th><th align="left">1996</th><th align="left">1991</th><th align="left">1986</th></tr></thead><tbody><tr><td align="left">C</td><td align="left">1</td><td align="left">2</td><td align="left">2</td><td align="left">2</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">Java</td><td align="left">2</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">3</td><td align="left">26</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">Python</td><td align="left">3</td><td align="left">5</td><td align="left">6</td><td align="left">8</td><td align="left">27</td><td align="left">19</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">C++</td><td align="left">4</td><td align="left">3</td><td align="left">3</td><td align="left">3</td><td align="left">2</td><td align="left">2</td><td align="left">2</td><td align="left">8</td></tr><tr><td align="left">C#</td><td align="left">5</td><td align="left">4</td><td align="left">5</td><td align="left">7</td><td align="left">13</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">Visual Basic</td><td align="left">6</td><td align="left">13</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">JavaScript</td><td align="left">7</td><td align="left">8</td><td align="left">10</td><td align="left">9</td><td align="left">10</td><td align="left">32</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">PHP</td><td align="left">8</td><td align="left">6</td><td align="left">4</td><td align="left">4</td><td align="left">11</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">SQL</td><td align="left">9</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">R</td><td align="left">10</td><td align="left">17</td><td align="left">31</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">Lisp</td><td align="left">34</td><td align="left">27</td><td align="left">13</td><td align="left">14</td><td align="left">17</td><td align="left">7</td><td align="left">4</td><td align="left">2</td></tr><tr><td align="left">Ada</td><td align="left">36</td><td align="left">28</td><td align="left">17</td><td align="left">16</td><td align="left">20</td><td align="left">8</td><td align="left">5</td><td align="left">3</td></tr><tr><td align="left">(Visual) Basic</td><td align="left">-</td><td align="left">-</td><td align="left">7</td><td align="left">6</td><td align="left">4</td><td align="left">3</td><td align="left">3</td><td align="left">5</td></tr></tbody></table><p>世界上没有最好的编程语言，只有最适用于具体应用场景的编程语言</p><p><strong>JVM：跨语言的平台</strong></p><p>Java 是目前应用最为广泛的软件开发平台之一。随着 Java 以及 Java 社区的不断壮大 Java 也早已不再是简简单单的一门计算机语言了，它更是<strong>一个平台、一种文化、一个社区</strong>。</p><ul><li>作为一个平台，Java 虚拟机扮演着举足轻重的作用<ul><li>Groovy、Scala、JRuby、Kotlin 等都是 Java 平台的一部分</li></ul></li><li>作为灯种文化，Java 几乎成为了“开源”的代名词。<ul><li>第三方开源软件和框架。如 Tomcat、Struts，MyBatis，Spring 等。</li><li>就连 JDK 和 JVM 自身也有不少开源的实现，如 openJDK、Harmony。</li></ul></li><li>作为一个社区，Java <strong>拥有全世界最多的技术拥护者和开源社区支持</strong>，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到 Java 的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201518134.png" alt="image-20200704151731216"></p><p>每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过 Java 虚拟机进行运行和处理</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201518202.png" alt="image-20200704152052489"></p><ul><li><p>随着 Java7 的正式发布，Java 虚拟机的设计者们通过 JSR-292 规范基本实现在<mark>Java 虚拟机平台上运行非 Java 语言编写的程序。</mark></p></li><li><p>Java 虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，<mark>它只关心“字节码”文件</mark>。也就是说 Java 虚拟机拥有语言无关性，并不会单纯地与 Java 语言“终身绑定”，只要其他编程语言的编译结果满足并包含 Java 虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p><p><strong><font color=red>Java不是最强大的语言,但是JVM是最强大的虚拟机</font></strong></p></li></ul><p><strong>字节码</strong></p><ul><li>我们平时说的 java 字节码，指的是用 java 语言编译成的字节码。准确的说任何能在 jvm 平台上执行的字节码格式都是一样的。所以应该统称为：<mark>jvm 字节码</mark>。</li><li>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的 JVM 上运行。</li><li>Java 虚拟机与 Java 语言并没有必然的联系，它只与特定的二进制文件格式—Class 文件格式所关联，Class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</li></ul><p><strong>多语言混合编程</strong></p><ul><li><mark>Java 平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</mark></li><li>试想一下，在一个项目之中，并行处理用 Clojure 语言编写，展示层使用 JRuby&#x2F;Rails，中间层则是 Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，<mark>各种语言之间的交互不存在任何困难，就像使用自己语言的原生 API 一样方便，因为它们最终都运行在一个虚拟机之上。</mark></li><li>对这些运行于 Java 虚拟机之上、Java 之外的语言，来自系统级的、底层的支持正在迅速增强，以 JSR-292 为核心的一系列项目和功能改进（如 Da Vinci Machine 项目、Nashorn 引擎、InvokeDynamic 指令、java.lang.invoke 包等），<mark>推动 Java 虚拟机从“Java 语言的虚拟机”向 “多语言虚拟机”的方向发展。</mark></li></ul><p><strong>如何真正搞懂 JVM？</strong></p><p>Java 虚拟机非常复杂，要想真正理解它的工作原理，最好的方式就是自己动手编写一个！</p><p>自己动手写一个 Java 虚拟机，难吗？</p><p>天下事有难易乎？</p><p>为之，则难者亦易矣；不为，则易者亦难矣</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201520264.png" alt="image-20210507102334642"></p><h2 id="1-4-Java-发展的重大事件"><a href="#1-4-Java-发展的重大事件" class="headerlink" title="1.4. Java 发展的重大事件"></a>1.4. Java 发展的重大事件</h2><ul><li>1990 年，在 Sun 计算机公司中，由 Patrick Naughton、MikeSheridan 及 James Gosling 领导的小组 Green Team，开发出的新的程序语言，命名为 oak，后期命名为 Java</li><li>1995 年，Sun 正式发布 Java 和 HotJava 产品，Java 首次公开亮相。</li><li>1996 年 1 月 23 日，Sun Microsystems 发布了 JDK 1.0。</li><li>1998 年，JDK1.2 版本发布。同时，sun 发布了 JSP&#x2F;Servlet、EJB 规范，以及将 Java 分成了 J2EE、J2SE 和 J2ME。这表明了 Java 开始向企业、桌面应用和移动设备应用 3 大领域挺进。</li><li>2000 年，JDK1.3 发布，<mark>Java HotSpot Virtual Machine 正式发布，成为 Java 的默认虚拟机。</mark></li><li>2002 年，JDK1.4 发布，古老的 Classic 虚拟机退出历史舞台。</li><li>2003 年年底，<mark>Java 平台的 Scala 正式发布，同年 Groovy 也加入了 Java 阵营。</mark></li><li>2004 年，JDK1.5 发布。同时 JDK1.5 改名为 JavaSE5.0。</li><li>2006 年，JDK6 发布。同年，<mark>Java 开源并建立了 OpenJDK</mark>。顺理成章，<mark>Hotspot 虚拟机也成为了 openJDK 中的默认虚拟机。</mark></li><li>2007 年，<mark>Java 平台迎来了新伙伴 Clojure。</mark></li><li>2008 年，Oracle 收购了 BEA，<mark>得到了 JRockit 虚拟机。</mark></li><li>2009 年，Twitter 宣布把后台大部分程序从 Ruby 迁移到 Scala，这是 Java 平台的又一次大规模应用。</li><li>2010 年，Oracle 收购了 Sun，<mark>获得 Java 商标和最真价值的 HotSpot 虚拟机</mark>。此时，Oracle 拥有市场占用率最高的两款虚拟机 HotSpot 和 JRockit，并计划在未来对它们进行整合：HotRockit</li><li>2011 年，JDK7 发布。在 JDK1.7u4 中，<mark>正式启用了新的垃圾回收器 G1。</mark></li><li>2017 年，JDK9 发布。<mark>将 G1 设置为默认 Gc，替代 CMS</mark></li><li>同年，<mark>IBM 的 J9 开源</mark>，形成了现在的 Open J9 社区</li><li>2018 年，Android 的 Java 侵权案判决，Google 赔偿 Oracle 计 88 亿美元</li><li>同年，Oracle 宣告 JavaEE 成为历史名词 JDBC、JMS、Servlet 赠予 Eclipse 基金会</li><li>同年，JDK11 发布，LTS 版本的 JDK，<mark>发布革命性的 ZGC，调整 JDK 授权许可</mark></li><li>2019 年，JDK12 发布，加入 RedHat 领导开发的<mark>shenandoah GC</mark></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201521294.png" alt="image-20200704182035810"></p><p>在 JDK11 之前，OracleJDK 中还会存在一些 OpenJDK 中没有的、闭源的功能。但在 JDK11 中，我们可以认为 OpenJDK 和 OracleJDK 代码实质上已经完全一致的程度。</p><p>不过，主流的 JDK 8 在 2019 年 01 月之后就被宣布停止更新了。另外， JDK 11 及以后的版本也不再提供免费的长期支持（LTS），而且 JDK 15 和 JDK 16 也不是一个长期支持的版本，最新的 JDK 15 只支持 6 个月时间，到 2021 年 3 月，所以千万不要把 JDK 15 等非长期支持版本用在生产。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201521865.png" alt="img"></p><h2 id="1-5-虚拟机与-Java-虚拟机"><a href="#1-5-虚拟机与-Java-虚拟机" class="headerlink" title="1.5. 虚拟机与 Java 虚拟机"></a>1.5. 虚拟机与 Java 虚拟机</h2><p><strong>虚拟机</strong></p><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p><ul><li>大名鼎鼎的 Visual Box，Mware 就属于系统虚拟机，它们<mark>完全是对物理计算机的仿真</mark>，提供了一个可运行完整操作系统的软件平台。</li><li>程序虚拟机的典型代表就是 Java 虚拟机，它<mark>专门为执行单个计算机程序而设计</mark>，在 Java 虚拟机中执行的指令我们称为 Java 字节码指令。</li></ul><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p><p><strong>Java 虚拟机</strong></p><ul><li>Java 虚拟机是一台执行 Java 字节码的虚拟计算机，它拥有独立的运行机制，其<strong>运行的 Java 字节码也未必由 Java 语言编译而成</strong>。(只要字节码符合规范就可执行)</li><li>JVM 平台的各种语言可以共享 Java 虚拟机带来的<strong>跨平台性、优秀的垃圾回器，以及可靠的即时编译器</strong>。</li><li><mark>Java 技术的核心就是 Java 虚拟机</mark>（JVM，Java Virtual Machine），因为所有的 Java 程序都运行在 Java 虚拟机内部。</li></ul><p><strong>作用</strong></p><ul><li>Java 虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器指令执行。每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</li></ul><p><strong>特点</strong></p><ul><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ul><p><strong>JVM 的位置</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201524561.png" alt="image-20200704183048061"></p><p>JVM 是运行在操作系统之上的，它与硬件没有直接的交互<br><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201524937.png" alt="image-20210507104030823"></p><h2 id="1-6-JVM-的整体结构"><a href="#1-6-JVM-的整体结构" class="headerlink" title="1.6. JVM 的整体结构"></a>1.6. JVM 的整体结构</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201525852.png" alt="image-20200704183436495"></p><ul><li>HotSpot VM 是目前市面上高性能虚拟机的代表作之一。</li><li>它采用&#x3D;&#x3D;解释器与即时编译器并存&#x3D;&#x3D;的架构。</li><li>在今天，Java 程序的运行性能早已脱胎换骨，已经达到了可以和 C&#x2F;C++程序一较高下的地步。</li></ul><h2 id="1-7-Java-代码执行流程"><a href="#1-7-Java-代码执行流程" class="headerlink" title="1.7. Java 代码执行流程"></a>1.7. Java 代码执行流程</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201525779.png" alt="image-20200704210429535"></p><h2 id="1-8-JVM-的架构模型"><a href="#1-8-JVM-的架构模型" class="headerlink" title="1.8. JVM 的架构模型"></a>1.8. JVM 的架构模型</h2><p>Java 编译器输入的指令流基本上是一种基于<mark>栈的指令集架构</mark>，另外一种指令集架构则是基于<mark>寄存器的指令集架构</mark>。</p><p>具体来说：这两种架构之间的区别：</p><p><strong>基于栈式架构的特点</strong></p><ul><li>设计和实现更简单，适用于资源受限的系统</li><li>避开了寄存器的分配难题：使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ul><p><strong>基于寄存器架构的特点</strong></p><ul><li>典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机</li><li>指令集架构则完全依赖硬件，可移植性差</li><li>性能优秀和执行更高效</li><li>花费更少的指令去完成一项操作</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li></ul><p><strong>举例 1</strong></p><p>同样执行 2+3 这种逻辑操作，其指令分别如下：</p><p>基于栈的计算流程（以 Java 虚拟机为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iconst_2 <span class="comment">//常量2入栈</span></span><br><span class="line">istore_1</span><br><span class="line">iconst_3 <span class="comment">// 常量3入栈</span></span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd <span class="comment">//常量2/3出栈，执行相加</span></span><br><span class="line">istore_0 <span class="comment">// 结果5入栈</span></span><br></pre></td></tr></table></figure><p>而基于寄存器的计算流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,<span class="number">2</span> <span class="comment">//将eax寄存器的值设为1</span></span><br><span class="line">add eax,<span class="number">3</span> <span class="comment">//使eax寄存器的值加3</span></span><br></pre></td></tr></table></figure><p><strong>举例 2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> c=<span class="number">300</span>;</span><br><span class="line">    <span class="keyword">return</span> (a + b) * c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; javap -c Test.class</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">    Stack=<span class="number">2</span>,Locals=<span class="number">4</span>,Args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">100</span></span><br><span class="line">       <span class="number">2</span>: istore_1</span><br><span class="line">       <span class="number">3</span>: sipush        <span class="number">200</span></span><br><span class="line">       <span class="number">6</span>: istore_2</span><br><span class="line">       <span class="number">7</span>: sipush        <span class="number">300</span></span><br><span class="line">      <span class="number">10</span>: istore_3</span><br><span class="line">      <span class="number">11</span>: iload_1</span><br><span class="line">      <span class="number">12</span>: iload_2</span><br><span class="line">      <span class="number">13</span>: iadd</span><br><span class="line">      <span class="number">14</span>: iload_3</span><br><span class="line">      <span class="number">15</span>: imul</span><br><span class="line">      <span class="number">16</span>: ireturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p><mark>由于跨平台性的设计，Java 的指令都是根据栈来设计的。</mark>不同平台 CPU 架构不同，所以不能设计为基于寄存器的。<strong>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</strong>。</p><p>时至今日，尽管嵌入式平台已经不是 Java 程序的主流运行平台了（准确来说应该是 HotSpotVM 的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p><h2 id="1-9-JVM-的生命周期"><a href="#1-9-JVM-的生命周期" class="headerlink" title="1.9. JVM 的生命周期"></a>1.9. JVM 的生命周期</h2><p><strong>虚拟机的启动</strong></p><p>Java 虚拟机的启动是通过<strong>引导类加载器</strong>（bootstrap class loader）<strong>创建一个初始类</strong>（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><p><strong>虚拟机的执行</strong></p><ul><li>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序。</li><li>程序开始执行时他才运行，程序结束时他就停止。</li><li><mark>执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程。</mark></li></ul><p><strong>虚拟机的退出</strong></p><p>有如下的几种情况：</p><ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统用现错误而导致 Java 虚拟机进程终止</li><li>某线程调用 Runtime 类或 system 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况。</li></ul><h2 id="X-JVM-的发展历程"><a href="#X-JVM-的发展历程" class="headerlink" title="X. JVM 的发展历程"></a>X. JVM 的发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ul><li>早在 1996 年 Java1.0 版本的时候，Sun 公司发布了一款名为 sun classic VM 的 Java 虚拟机，它同时也是<mark>世界上第一款商用 Java 虚拟机</mark>，JDK1.4 时完全被淘汰。</li><li>这款虚拟机内部只提供解释器。(现在的JVM还有及时编译器，因此当时的虚拟机效率比较低. 而<strong>及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高</strong>。)</li><li>如果使用 JIT 编译器，就需要进行外挂。但是一旦使用了 JIT 编译器，JIT 就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li><li>现在 hotspot 内置了此虚拟机。</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202203201621793.png" alt="image-20220320162135224"></p><p>由图可知:使用解释器和JIT任意一个都可将字节码转为机器码.所以最初的虚拟机只有解释器,但是它的工作流程是逐行解释字节码的,对于重复性较强的代码(比如for循环等)亦是如此,即每次都执行一遍. 导致效率极低.</p><p>JIT即时编译器:在程序执行过程中如果发现一些代码被反复执行,就将其确定为热点代码.然后就会将这些热点代码解释成机器指令后缓存起来,等下次执行到热点代码时,直接从缓存中取,无需重新解释执行.可以提高程序执行效率.</p><p><font color=red>那为啥不直接用JIT代替解释器呢?</font></p><p>因为JIT将代码编译成本地机器码也是需要时间的,如果全部都缓存,会导致程序刚开始时暂停时间过长.之后效率才会逐渐提高.  现在是<strong>混合模式，先cllient(解释)模式，再server(JIT)模式</strong></p><p>**一句话:**JIT理解为去思考到底怎么去才快，是步行还是做车还是坐飞机，这个思考阶段才算是JIT慢的原因.而不是像解释器那样一开始就做车. </p><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><ul><li>为了解决上一个虚拟机问题，jdk1.2 时，Sun 提供了此虚拟机。</li><li>Exact Memory Management：准确式内存管理<ul><li>也可以叫 Non-Conservative&#x2F;Accurate Memory Management</li><li><strong>虚拟机可以知道内存中某个位置的数据具体是什么类型</strong>。</li></ul></li><li>具备现代高性能虚拟机的维形<ul><li><strong>热点探测</strong></li><li><strong>编译器与解释器混合工作模式</strong></li></ul></li><li>只在 solaris 平台短暂使用，其他平台上还是 classic vm<ul><li>英雄气短，终被 Hotspot 虚拟机替换</li></ul></li></ul><h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h3><ul><li>HotSpot 历史<ul><li>最初由一家名为“Longview Technologies”的小公司设计</li><li>1997 年，此公司被 sun 收购；2009 年，Sun 公司被甲骨文收购。</li><li>JDK1.3 时，HotSpot VM 成为默认虚拟机</li></ul></li><li><mark>目前 Hotspot 占有绝对的市场地位，称霸武林。</mark><ul><li>不管是现在仍在广泛使用的 JDK6，还是使用比例较多的 JDK8 中，默认的虚拟机都是 HotSpot</li><li>Sun &#x2F; Oracle JDK 和 OpenJDK 的默认虚拟机</li><li>因此本课程中默认介绍的虚拟机都是 HotSpot，相关机制也主要是指 HotSpot 的 Gc 机制。（比如其他两个商用虚机都没有方法区的概念）</li></ul></li><li>从服务器、桌面到移动端、嵌入式都有应用。</li><li>名称中的 HotSpot 指的就是它的热点代码探测技术。<ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间(解释器做的最好)与最佳执行性能(编译器做的最好)中取得平衡</li></ul></li></ul><h3 id="JRockit"><a href="#JRockit" class="headerlink" title="JRockit"></a>JRockit</h3><ul><li><p><mark>专注于服务器端应用</mark></p></li><li><p>它可以不太关注程序启动速度，因此 JRockit 内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</p></li><li><p>大量的行业基准测试显示，<mark>JRockit JVM 是世界上最快的 JVM。</mark></p><ul><li>使用 JRockit 产品，客户已经体验到了显著的性能提高（一些超过了 70%）和硬件成本的减少（达 50%）。</li></ul></li><li><p>优势：全面的 Java 运行时解决方案组合</p><ul><li>JRockit 面向延迟敏感型应用的解决方案 JRockit Real Time 提供以毫秒或微秒级的 JVM 响应时间，适合财务、军事指挥、电信网络的需要</li><li>MissionControl 服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li></ul></li><li><p>2008 年，JRockit 被 oracle 收购。</p></li><li><p>Oracle 表达了整合两大优秀虚拟机的工作，大致在 JDK8 中完成。整合的方式是在 HotSpot 的基础上，移植 JRockit 的优秀特性。</p></li><li><p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p></li></ul><h3 id="IBM-的-J9"><a href="#IBM-的-J9" class="headerlink" title="IBM 的 J9"></a>IBM 的 J9</h3><ul><li><p>全称：IBM Technology for Java Virtual Machine，简称 IT4J，内部代号：J9</p></li><li><p>市场定位与 HotSpot 接近，服务器端、桌面应用、嵌入式等多用途 VM</p></li><li><p>广泛用于 IBM 的各种 Java 产品。</p></li><li><p>目前，<strong>有影响力的三大商用虚拟机之一，也号称是世界上最快的 Java 虚拟机</strong>。</p></li><li><p>2017 年左右，IBM 发布了开源 J9VM，命名为 openJ9，交给 EClipse 基金会管理，也称为 Eclipse OpenJ9</p></li></ul><h3 id="KVM-和-CDC-CLDC-Hotspot"><a href="#KVM-和-CDC-CLDC-Hotspot" class="headerlink" title="KVM 和 CDC &#x2F; CLDC Hotspot"></a>KVM 和 CDC &#x2F; CLDC Hotspot</h3><ul><li><p>Oracle 在 Java ME 产品线上的两款虚拟机为：CDC&#x2F;CLDC HotSpot Implementation VM</p></li><li><p>KVM（Kilobyte）是 CLDC-HI 早期产品</p></li><li><p>目前移动领域地位尴尬，智能机被 Android 和 iOS 二分天下。</p></li><li><p>KVM 简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p><ul><li>智能控制器、传感器</li><li>老人手机、经济欠发达地区的功能手机</li></ul></li><li><p>所有的虚拟机的原则：一次编译，到处运行。</p></li></ul><h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><ul><li><p>前面三大“高性能 Java 虚拟机”使用在通用硬件平台上这里 Azul VW 和 BEA Liquid VM 是<mark>与特定硬件平台绑定、软硬件配合的专有虚拟机</mark></p><ul><li>高性能 Java 虚拟机中的战斗机。</li></ul></li><li><p>Azul VM 是 Azul Systems 公司在 HotSpot 基础上进行大量改进，运行于 Azul Systems 公司的专有硬件 Vega 系统上的 Java 虚拟机。</p></li><li><p><mark>每个 Azul VM 实例都可以管理至少数十个 CPU 和数百 GB 内存的硬件资源，并提供在巨大内存范围内实现可控的 GC 时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</mark></p></li><li><p>2010 年，AzulSystems 公司开始从硬件转向软件，发布了自己的 Zing JVM，可以在通用 x86 平台上提供接近于 Vega 系统的特性。</p></li></ul><h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><ul><li><p>高性能 Java 虚拟机中的战斗机。</p></li><li><p>BEA 公司开发的，直接运行在自家 Hypervisor 系统上</p></li><li><p>Liquid VM 即是现在的 JRockit VE（Virtual Edition），<mark>Liquid VM 不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</mark></p></li><li><p>随着 JRockit 虚拟机终止开发，Liquid vM 项目也停止了。</p></li></ul><h3 id="Apache-Harmony"><a href="#Apache-Harmony" class="headerlink" title="Apache Harmony"></a>Apache Harmony</h3><ul><li><p>Apache 也曾经推出过与 JDK1.5 和 JDK1.6 兼容的 Java 运行平台 Apache Harmony。</p></li><li><p>它是 IBM 和 Intel 联合开发的开源 JVM，受到同样开源的 OpenJDK 的压制，Sun 坚决不让 Harmony 获得 JCP 认证，最终于 2011 年退役，IBM 转而参与 OpenJDK</p></li><li><p>虽然目前并没有 Apache Harmony 被大规模商用的案例，但是它的 Java 类库代码吸纳进了 Android SDK。</p></li></ul><h3 id="Micorsoft-JVM"><a href="#Micorsoft-JVM" class="headerlink" title="Micorsoft JVM"></a>Micorsoft JVM</h3><ul><li><p>微软为了在 IE3 浏览器中支持 Java Applets，开发了 Microsoft JVM。</p></li><li><p>只能在 Windows 平台下运行。但确是当时 Windows 下性能最好的 Java VM。</p></li><li><p>1997 年，Sun 以侵犯商标、不正当竞争罪名指控微软成功，赔了 Sun 很多钱。微软 WindowsXP SP3 中抹掉了其 VM。现在 Windows 上安装的 jdk 都是 HotSpot。</p></li></ul><h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><ul><li><p>由 AliJVM 团队发布。阿里，国内使用 Java 最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p></li><li><p><mark>基于 OpenJDK 开发了自己的定制版本 AlibabaJDK</mark>，简称 AJDK。是整个阿里 Java 体系的基石。</p></li><li><p>基于 OpenJDK Hotspot VM 发布的国内第一个优化、<mark>深度定制且开源的高性能服务器版 Java 虚拟机</mark>。</p><ul><li>创新的 GCIH（GC invisible heap）技术实现了 off-heap，<mark>即将生命周期较长的 Java 对象从 heap 中移到 heap 之外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。</mark></li><li>GCIH 中的<mark>对象还能够在多个 Java 虚拟机进程中实现共享</mark></li><li>使用 crc32 指令实现 JVM intrinsic 降低 JNI 的调用开销</li><li>PMU hardware 的 Java profiling tool 和诊断协助功能</li><li>针对大数据场景的 ZenGc</li></ul></li><li><p>taobao vm 应用在阿里产品上性能高，硬件严重依赖 intel 的 cpu，损失了兼容性，但提高了性能</p><ul><li><strong>目前已经在淘宝、天猫上线，把 oracle 官方 JvM 版本全部替换了</strong>。</li></ul></li></ul><h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><ul><li><p>谷歌开发的，应用于 Android 系统，并在 Android2.2 中提供了 JIT，发展迅猛。</p></li><li><p>Dalvik VM 只能称作虚拟机，而不能称作“Java 虚拟机”，它没有遵循 Java 虚拟机规范，不能直接执行 Java 的 Class 文件</p></li><li><p>基于寄存器架构，不是 jvm 的栈架构。</p></li><li><p>执行的是编译以后的 dex（Dalvik Executable）文件。执行效率比较高。</p><ul><li>它执行的 dex（Dalvik Executable）文件可以通过 class 文件转化而来，使用 Java 语法编写应用程序，可以直接使用大部分的 Java API 等。</li></ul></li><li><p>Android 5.0 使用支持提前编译（Ahead of Time Compilation，AoT）的 ART VM 替换 Dalvik VM。</p></li></ul><h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><ul><li><p>2018 年 4 月，oracle Labs 公开了 Graal VM，号称 “Run Programs Faster Anywhere”，野心勃勃。与 1995 年 java 的”write once，run anywhere”遥相呼应。</p></li><li><p>Graal VM 在 HotSpot VM 基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R 等</p></li><li><p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p></li><li><p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被 Graal VM 接受的中间表示。Graal VM 提供 Truffle 工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p></li><li><p><strong>如果说 HotSpot 有一天真的被取代，Graal VM 希望最大。</strong>但是 Java 的软件生态没有丝毫变化。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>具体 JVM 的内存结构，其实取决于其实现，不同厂商的 JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以 Oracle HotSpot VM 为默认虚拟机。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七、Redis消息队列</title>
      <link href="/2024/04/05/Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC08%E7%AB%A0_Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2024/04/05/Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC08%E7%AB%A0_Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="7、Redis消息队列"><a href="#7、Redis消息队列" class="headerlink" title="7、Redis消息队列"></a>7、Redis消息队列</h2><h3 id="7-1-Redis消息队列-认识消息队列"><a href="#7-1-Redis消息队列-认识消息队列" class="headerlink" title="7.1 Redis消息队列-认识消息队列"></a>7.1 Redis消息队列-认识消息队列</h3><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302140007695.png" alt="1653574849336"></p><p>使用队列的好处在于 <strong>解耦：</strong>所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p><p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p><p>这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p><h3 id="7-2-Redis消息队列-基于List实现消息队列"><a href="#7-2-Redis消息队列-基于List实现消息队列" class="headerlink" title="7.2 Redis消息队列-基于List实现消息队列"></a>7.2 Redis消息队列-基于List实现消息队列</h3><p><strong>基于List结构模拟消息队列</strong></p><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302140007676.png" alt="1653575176451"></p><p><strong>案例演示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####生产者######</span></span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH l1 e1 e2; </span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####消费者######</span></span></span><br><span class="line">127.0.0.1:6379&gt; BRPOP l1 20</span><br><span class="line">1) &quot;l1&quot;</span><br><span class="line">2) &quot;e1&quot;</span><br><span class="line">(11.81s)</span><br><span class="line">127.0.0.1:6379&gt; BRPOP l1 20</span><br><span class="line">1) &quot;l1&quot;</span><br><span class="line">2) &quot;e2;&quot;</span><br><span class="line">127.0.0.1:6379&gt; BRPOP l1 20 #队列没有元素会被阻塞，到超时时间还没有就返货null，结束获取</span><br><span class="line">(nil)</span><br><span class="line">(20.10s)</span><br></pre></td></tr></table></figure><p><strong>基于List的消息队列有哪些优缺点？</strong><br>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li>无法避免消息丢失【比如刚从消息队列取出一条消息，还没来得及处理，Redis就发生宕机，这个消息就会丢失】</li><li>只支持单消费者【一条消息只能被一个消费者消费，无法被多个消费者消费】</li></ul><h3 id="7-3-Redis消息队列-基于PubSub的消息队列"><a href="#7-3-Redis消息队列-基于PubSub的消息队列" class="headerlink" title="7.3 Redis消息队列-基于PubSub的消息队列"></a>7.3 Redis消息队列-基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，<code>消费者可以订阅一个或多个channel</code>，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p><code>SUBSCRIBE channel [channel]</code>：订阅一个或多个频道<br> <code>PUBLISH channel msg </code>：向一个频道发送消息<br> <code>PSUBSCRIBE pattern[pattern]</code> ：订阅与pattern格式匹配的所有频道</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302140007701.png" alt="1653575506373"></p><p><strong>案例演示</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302140007699.png"></p><p><strong>基于PubSub的消息队列有哪些优缺点？</strong><br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费【一个消息可以发给多个&#x2F;部分消费者，不同生产者往相同的频道发】</li></ul><p>缺点：</p><ul><li>不支持数据持久化<ul><li>为什么list作为消息队列可以持久化？是因为list本身是一个链表，用来做数据存储的。而我们把他当做消息队列来用了。而Redis中所有用来做数据存储的结构都支持持久化~ 而Pubsub就是用来做消息发送的，因此当我们发送一条消息，而这个消息没有被任何人订阅，频道没有被任何人订阅，那么这个消息就直接丢失了。</li></ul></li><li>无法避免消息丢失<ul><li>有人订阅消息就会被使用，没人订阅消息就会丢失~</li></ul></li><li>消息堆积有上限，超出时数据丢失<ul><li>如果发送消息时，有消费者在监听，在消费者那里有一个缓存区域，把消息缓存下来，让消费者去处理。如果消息处理的很慢，并且还有源源不断的消息到来，因为消费者那里的空间是有上限的，超出就会消息丢失~</li></ul></li></ul><blockquote><p>总结：这种模式的缺点较多，不适合做可靠性较高的消息模式~</p></blockquote><h3 id="7-4-Redis消息队列-基于Stream的消息队列"><a href="#7-4-Redis消息队列-基于Stream的消息队列" class="headerlink" title="7.4 Redis消息队列-基于Stream的消息队列"></a>7.4 Redis消息队列-基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><p>发送消息的命令：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302140007706.png" alt="1653577301737"></p><p>例如：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302140007722.png" alt="1653577349691"></p><p>读取消息的方式之一：XREAD</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302140007385.png" alt="1653577445413"></p><p>例如，使用XREAD读取第一个消息：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302140007441.png" alt="1653577643629"></p><p>XREAD阻塞方式，读取最新的消息：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302140007485.png" alt="1653577659166"></p><p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302140007529.png" alt="1653577689129"></p><p>注意：当我们指定起始ID为$时，代表<code>读取最新的消息</code>，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现<code>漏读消息</code>的问题</p><p><strong>案例演示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##生产者</span></span></span><br><span class="line">127.0.0.1:6379&gt; XADD s1 * k1 v1 # 向队列中发送消息</span><br><span class="line">&quot;1675947993952-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XLEN s1 #查看队列中的消息个数</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##消费者1&amp;&amp;消费者2</span></span></span><br><span class="line">127.0.0.1:6379&gt; XREAD COUNT 1 STREAMS s1 0 #读取队列中的第一条消息 [可以说明消息可回溯]</span><br><span class="line">1) 1) &quot;s1&quot;</span><br><span class="line">   2) 1) 1) &quot;1675947993952-0&quot;</span><br><span class="line">         2) 1) &quot;k1&quot;</span><br><span class="line">            2) &quot;v1&quot;</span><br><span class="line">            </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##生产者</span></span></span><br><span class="line">127.0.0.1:6379&gt; XADD s1 * k2 v2 # 向队列中发送消息</span><br><span class="line">&quot;1675948153658-0&quot;</span><br><span class="line">                   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##消费者1</span></span></span><br><span class="line">127.0.0.1:6379&gt; XREAD COUNT 1 BLOCK 0 STREAMS s1 $ #阻塞读</span><br><span class="line">1) 1) &quot;s1&quot;</span><br><span class="line">   2) 1) 1) &quot;1675948153658-0&quot;</span><br><span class="line">         2) 1) &quot;k2&quot;</span><br><span class="line">            2) &quot;v2&quot;</span><br></pre></td></tr></table></figure><p><strong>STREAM类型消息队列的XREAD命令特点：</strong></p><ul><li>消息可回溯【消息读完不消失，永久的保存在消息队列中，啥时候还想看可以随时回来】</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险【在消息处理的过程中，如果来了很多消息，我看不到，只能看到最新的消息】</li></ul><h3 id="7-5-Redis消息队列-基于Stream的消息队列-消费者组"><a href="#7-5-Redis消息队列-基于Stream的消息队列-消费者组" class="headerlink" title="7.5 Redis消息队列-基于Stream的消息队列-消费者组"></a>7.5 Redis消息队列-基于Stream的消息队列-消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302140007578.png" alt="image-20230210142845558"></p><p>创建消费者组：<br><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302140007629.png" alt="1653577984924"><br>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p><p> <strong>删除指定的消费者组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure><p> <strong>给指定的消费者组添加消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure><p> <strong>删除消费者组中的指定消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure><p>从消费者组读取消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure><ul><li><p>group：消费组名称</p></li><li><p>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</p></li><li><p>count：本次查询的最大数量</p></li><li><p>BLOCK milliseconds：当没有消息时最长等待时间</p></li><li><p>NOACK：无需手动ACK，获取到消息后自动确认</p></li><li><p>STREAMS key：指定队列名称</p></li><li><p>ID：获取消息的起始ID：</p><ul><li>“&gt;”：从下一个未消费的消息开始 【正常情况下】</li><li>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始 【异常情况下】</li></ul></li></ul><p><strong>案例演示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##生产者</span></span></span><br><span class="line">127.0.0.1:6379&gt; XADD s1 * k1 v1  #向s1中加入消息</span><br><span class="line">&quot;1676013442138-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD s1 * k2 v2</span><br><span class="line">&quot;1676013446154-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD s1 * k3 v3</span><br><span class="line">&quot;1676013453085-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD s1 * k4 v4</span><br><span class="line">&quot;1676013459707-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD s1 * k5 v5</span><br><span class="line">&quot;1676013469043-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD s1 * k6 v6</span><br><span class="line">&quot;1676013473875-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XADD s1 * k7 v7</span><br><span class="line">&quot;1676013478635-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XLEN s1 # 查看队列长度</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; XGROUP CREATE s1 g1 0 # 创建消费者组</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 消费者1</span></span></span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span><br><span class="line">1) 1) &quot;s1&quot;</span><br><span class="line">   2) 1) 1) &quot;1676013442138-0&quot;</span><br><span class="line">         2) 1) &quot;k1&quot;</span><br><span class="line">            2) &quot;v1&quot;</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span><br><span class="line">1) 1) &quot;s1&quot;</span><br><span class="line">   2) 1) 1) &quot;1676013446154-0&quot;</span><br><span class="line">         2) 1) &quot;k2&quot;</span><br><span class="line">            2) &quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span><br><span class="line">1) 1) &quot;s1&quot;</span><br><span class="line">   2) 1) 1) &quot;1676013469043-0&quot;</span><br><span class="line">         2) 1) &quot;k5&quot;</span><br><span class="line">            2) &quot;v5&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 消费者2</span></span></span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt; </span><br><span class="line">1) 1) &quot;s1&quot;</span><br><span class="line">   2) 1) 1) &quot;1676013453085-0&quot;</span><br><span class="line">         2) 1) &quot;k3&quot;</span><br><span class="line">            2) &quot;v3&quot;</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span><br><span class="line">1) 1) &quot;s1&quot;</span><br><span class="line">   2) 1) 1) &quot;1676013459707-0&quot;</span><br><span class="line">         2) 1) &quot;k4&quot;</span><br><span class="line">            2) &quot;v4&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##根据消费者1&amp;消费者2的消费，可以看出消费组中的消费者是竞争关系的，并且同一个消费组中不会出现重复消费~</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 消费者1</span></span></span><br><span class="line">127.0.0.1:6379&gt; XACK s1 g1 1676013442138-0 1676013446154-0 1676013453085-0 1676013459707-0 1676013469043-0</span><br><span class="line">(integer) 5 #对前五条消息进行ACK确认</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt; #继续消费消息</span><br><span class="line">1) 1) &quot;s1&quot;</span><br><span class="line">   2) 1) 1) &quot;1676013473875-0&quot;</span><br><span class="line">         2) 1) &quot;k6&quot;</span><br><span class="line">            2) &quot;v6&quot;</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span><br><span class="line">1) 1) &quot;s1&quot;</span><br><span class="line">   2) 1) 1) &quot;1676013478635-0&quot;</span><br><span class="line">         2) 1) &quot;k7&quot;</span><br><span class="line">            2) &quot;v7&quot;</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span><br><span class="line">(nil)</span><br><span class="line">(2.08s)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">由于1676013473875-0 和 1676013478635-0 被消费者消费后并没有ACK确认，会进入pending_list</span></span><br><span class="line">127.0.0.1:6379&gt; XPENDING s1 g1 - + 10 #查看pending_list中的消息，可以看出共两条消费失败的消息</span><br><span class="line">1) 1) &quot;1676013473875-0&quot;</span><br><span class="line">   2) &quot;c1&quot;</span><br><span class="line">   3) (integer) 37154</span><br><span class="line">   4) (integer) 1</span><br><span class="line">2) 1) &quot;1676013478635-0&quot;</span><br><span class="line">   2) &quot;c1&quot;</span><br><span class="line">   3) (integer) 35353</span><br><span class="line">   4) (integer) 1</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0 #从pending_list中获取消息</span><br><span class="line">1) 1) &quot;s1&quot;</span><br><span class="line">   2) 1) 1) &quot;1676013473875-0&quot;</span><br><span class="line">         2) 1) &quot;k6&quot;</span><br><span class="line">            2) &quot;v6&quot;</span><br><span class="line">127.0.0.1:6379&gt; XACK s1 g1 1676013473875-0 # 消费完进行ACK确认</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0 #从pending_list中获取消息</span><br><span class="line">1) 1) &quot;s1&quot;</span><br><span class="line">   2) 1) 1) &quot;1676013478635-0&quot;</span><br><span class="line">         2) 1) &quot;k7&quot;</span><br><span class="line">            2) &quot;v7&quot;</span><br><span class="line">127.0.0.1:6379&gt; XACK s1 g1 1676013478635-0 # 消费完进行ACK确认</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0 #再次获取，pending_list已经为空</span><br><span class="line">1) 1) &quot;s1&quot;</span><br><span class="line">   2) (empty array)</span><br></pre></td></tr></table></figure><p>消费者监听消息的基本思路：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302140007036.png" alt="image-20230210153808554"></p><p>STREAM类型消息队列的XREADGROUP命令特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险[因为读取过的消息会有标记，下次直接从有标记的下一条消息读取即可]</li><li>有消息确认机制，保证消息至少被消费一次</li></ul><p>最后我们来个小对比</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302140007085.png" alt="image-20230210145602447"></p><blockquote><p>Redis的Stream基本满足中小项目的需求，如果是大型项目，则可以使用专门的MQ：RocketMQ、RabbitMQ、Kfaka等</p></blockquote><h3 id="7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><p>需求：</p><ul><li><p>创建一个Stream类型的消息队列，名为stream.orders</p></li><li><p>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</p></li><li><p>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单</p></li></ul><p>①创建消息队列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XGROUP CREATE stream.orders g1 0 MKSTREAM</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>②修改lua表达式，新增3.5</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302140007125.png" alt="image-20230211163737153"></p><p>③VoucherOrderServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优惠券订单处理器【基于消息队列】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;stream.orders&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取消息队列中的订单信息  XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders &gt;</span></span><br><span class="line">                List &lt;MapRecord &lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                    StreamOffset.create(queueName, ReadOffset.lastConsumed())</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断消息是否获取成功</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果获取失败，说明没有消息，继续下一次循环</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3.解析消息中的订单信息</span></span><br><span class="line">                MapRecord &lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map &lt;Object, Object&gt; values = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(values, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(),<span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 4.如果获取成功，可以下单</span></span><br><span class="line">                handleVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 5.ACK确认 SACK strea.orders g1 id</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(queueName,<span class="string">&quot;g1&quot;</span>,record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理订单异常：&quot;</span>, e);</span><br><span class="line">                handlePendingList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理PendingList中的订单</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.获取pending-list中的订单信息  XREADGROUP GROUP g1 c1 COUNT 1  STREAMS stream.orders 0</span></span><br><span class="line">                List &lt;MapRecord &lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                    StreamOffset.create(queueName, ReadOffset.from(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// 2.判断消息是否获取成功</span></span><br><span class="line">                <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 如果获取失败，说明pending-list没有异常消息，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3.解析消息中的订单信息</span></span><br><span class="line">                MapRecord &lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                Map &lt;Object, Object&gt; values = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(values, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(),<span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 4.如果获取成功，可以下单</span></span><br><span class="line">                handleVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">// 5.ACK确认 SACK stream.orders g1 id</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(queueName,<span class="string">&quot;g1&quot;</span>,record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;处理pending-list订单异常：&quot;</span>, e);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果出现异常,休眠一会再尝试,避免一直尝试一直异常~</span></span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException interruptedException) &#123;</span><br><span class="line">                    interruptedException.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Lua脚本 + Stream消息队列实现秒杀下单</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voucherId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 获取订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// 1.执行Lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">        SECKILL_SCRIPT,</span><br><span class="line">        Collections.emptyList(),</span><br><span class="line">        voucherId.toString(),</span><br><span class="line">        userId.toString(),</span><br><span class="line">        String.valueOf(orderId)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1 不为0，代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(result == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.2 为0，有购买资格，把下单信息保存到消息队列【已经在LUA做过了】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.获取代理对象</span></span><br><span class="line">    proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>秒杀压测</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302111636814.png" alt="image-20230211163645535"></p><blockquote><p>可以看出咱们秒杀的接口性能非常好~</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六、秒杀优化</title>
      <link href="/2024/04/05/Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC07%E7%AB%A0_%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96/"/>
      <url>/2024/04/05/Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC07%E7%AB%A0_%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="6、秒杀优化"><a href="#6、秒杀优化" class="headerlink" title="6、秒杀优化"></a>6、秒杀优化</h2><h3 id="6-0-压力测试"><a href="#6-0-压力测试" class="headerlink" title="6.0 压力测试"></a>6.0 压力测试</h3><p><strong>目的</strong>：测试1000个用户抢购优惠券时秒杀功能的并发性能~</p><p>①数据库中创建1000+用户</p><p>这里推荐使用开源工具：<a href="https://www.sqlfather.com/">https://www.sqlfather.com/</a> ，导入以下配置即可一键生成模拟数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;dbName&quot;:&quot;hmdp&quot;,&quot;tableName&quot;:&quot;tb_user&quot;,&quot;tableComment&quot;:&quot;用户表&quot;,&quot;mockNum&quot;:<span class="number">100</span>,&quot;fieldList&quot;:[&#123;&quot;fieldName&quot;:&quot;id&quot;,&quot;fieldType&quot;:&quot;bigint(20)&quot;,&quot;defaultValue&quot;:<span class="keyword">null</span>,&quot;notNull&quot;:<span class="literal">true</span>,&quot;comment&quot;:&quot;主键id&quot;,&quot;primaryKey&quot;:<span class="literal">true</span>,&quot;autoIncrement&quot;:<span class="literal">true</span>,&quot;mockType&quot;:&quot;递增&quot;,&quot;mockParams&quot;:<span class="number">2</span>,&quot;onUpdate&quot;:<span class="keyword">null</span>&#125;,&#123;&quot;fieldName&quot;:&quot;phone&quot;,&quot;fieldType&quot;:&quot;varchar(33)&quot;,&quot;defaultValue&quot;:<span class="keyword">null</span>,&quot;notNull&quot;:<span class="literal">false</span>,&quot;comment&quot;:<span class="keyword">null</span>,&quot;primaryKey&quot;:<span class="literal">false</span>,&quot;autoIncrement&quot;:<span class="literal">false</span>,&quot;mockType&quot;:&quot;随机&quot;,&quot;mockParams&quot;:&quot;手机号&quot;,&quot;onUpdate&quot;:<span class="keyword">null</span>&#125;,&#123;&quot;fieldName&quot;:&quot;password&quot;,&quot;fieldType&quot;:&quot;varchar(384)&quot;,&quot;defaultValue&quot;:<span class="keyword">null</span>,&quot;notNull&quot;:<span class="literal">false</span>,&quot;comment&quot;:<span class="keyword">null</span>,&quot;primaryKey&quot;:<span class="literal">false</span>,&quot;autoIncrement&quot;:<span class="literal">false</span>,&quot;mockType&quot;:&quot;随机&quot;,&quot;mockParams&quot;:&quot;字符串&quot;,&quot;onUpdate&quot;:<span class="keyword">null</span>&#125;,&#123;&quot;fieldName&quot;:&quot;nick_name&quot;,&quot;fieldType&quot;:&quot;varchar(96)&quot;,&quot;defaultValue&quot;:<span class="keyword">null</span>,&quot;notNull&quot;:<span class="literal">false</span>,&quot;comment&quot;:<span class="keyword">null</span>,&quot;primaryKey&quot;:<span class="literal">false</span>,&quot;autoIncrement&quot;:<span class="literal">false</span>,&quot;mockType&quot;:&quot;规则&quot;,&quot;mockParams&quot;:&quot;user_\\w&#123;10&#125;$&quot;,&quot;onUpdate&quot;:<span class="keyword">null</span>&#125;,&#123;&quot;fieldName&quot;:&quot;icon&quot;,&quot;fieldType&quot;:&quot;varchar(765)&quot;,&quot;defaultValue&quot;:<span class="keyword">null</span>,&quot;notNull&quot;:<span class="literal">false</span>,&quot;comment&quot;:<span class="keyword">null</span>,&quot;primaryKey&quot;:<span class="literal">false</span>,&quot;autoIncrement&quot;:<span class="literal">false</span>,&quot;mockType&quot;:&quot;固定&quot;,&quot;mockParams&quot;:&quot;/imgs/blogs/blog1.jpg&quot;,&quot;onUpdate&quot;:<span class="keyword">null</span>&#125;,&#123;&quot;fieldName&quot;:&quot;create_time&quot;,&quot;fieldType&quot;:&quot;timestamp&quot;,&quot;defaultValue&quot;:<span class="keyword">null</span>,&quot;notNull&quot;:<span class="literal">false</span>,&quot;comment&quot;:<span class="keyword">null</span>,&quot;primaryKey&quot;:<span class="literal">false</span>,&quot;autoIncrement&quot;:<span class="literal">false</span>,&quot;mockType&quot;:&quot;固定&quot;,&quot;mockParams&quot;:&quot;2023-01-01 00:00:00&quot;,&quot;onUpdate&quot;:<span class="keyword">null</span>&#125;,&#123;&quot;fieldName&quot;:&quot;update_time&quot;,&quot;fieldType&quot;:&quot;timestamp&quot;,&quot;defaultValue&quot;:<span class="keyword">null</span>,&quot;notNull&quot;:<span class="literal">false</span>,&quot;comment&quot;:<span class="keyword">null</span>,&quot;primaryKey&quot;:<span class="literal">false</span>,&quot;autoIncrement&quot;:<span class="literal">false</span>,&quot;mockType&quot;:&quot;固定&quot;,&quot;mockParams&quot;:&quot;2023-01-01 00:00:01&quot;,&quot;onUpdate&quot;:<span class="keyword">null</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><p>②将1000个用户处于登录状态(本质就是为1000个用户生成token，并保存到Redis中)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在Redis中保存1000个用户信息并将其token写入文件中，方便测试多人秒杀业务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMultiLogin</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    List &lt;User&gt; userList = userService.lambdaQuery().last(<span class="string">&quot;limit 1000&quot;</span>).list();</span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">        Map &lt;String,Object&gt; userMap = BeanUtil.beanToMap(userDTO,<span class="keyword">new</span> <span class="title class_">HashMap</span> &lt;&gt;(),</span><br><span class="line">                CopyOptions.create().ignoreNullValue()</span><br><span class="line">                        .setFieldValueEditor((fieldName,fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line">        stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">        stringRedisTemplate.expire(tokenKey, <span class="number">60</span>,TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">    Set &lt;String&gt; keys = stringRedisTemplate.keys(RedisConstants.LOGIN_USER_KEY + <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="meta">@Cleanup</span> <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;\\tokens.txt&quot;</span>);</span><br><span class="line">    <span class="meta">@Cleanup</span> <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fileWriter);</span><br><span class="line">    <span class="keyword">assert</span> keys != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> key.substring(RedisConstants.LOGIN_USER_KEY.length());</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> token + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        bufferedWriter.write(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③在Jmeter中进行压力测试：1000个线程请求接口，观察结果</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302111411390.png" alt="image-20230207170914570"></p><blockquote><p>这接口被Leader发现，估计要被骂死~</p></blockquote><h3 id="6-1-秒杀优化-异步秒杀思路"><a href="#6-1-秒杀优化-异步秒杀思路" class="headerlink" title="6.1 秒杀优化-异步秒杀思路"></a>6.1 秒杀优化-异步秒杀思路</h3><p>我们来回顾一下下单流程</p><p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤</p><p>1、<code>查询优惠卷</code></p><p>2、判断秒杀库存是否足够</p><p>3、<code>查询订单</code></p><p>4、校验是否是一人一单</p><p>5、<code>扣减库存</code></p><p>6、<code>创建订单</code></p><p>在这六步操作中，又有很多操作是要去<code>操作数据库</code>的，而且还是一个线程<code>串行</code>执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行，那么如何加速呢？</p><p>在这里笔者想给大家分享一下课程内没有的思路，看看有没有小伙伴这么想，比如，我们可以不可以使用<strong>异步编排</strong>来做，或者说我开启N多线程，N多个线程，一个线程执行查询优惠卷，一个执行判断扣减库存，一个去创建订单等等，然后再统一做返回，这种做法和课程中有哪种好呢？答案是课程中的好，因为如果你采用我刚说的方式，如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302111411438.png" alt="1653560986599"></p><p><strong>优化方案：</strong>我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池。当然这里边有两个难点</p><p>第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</p><p>第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。【饭店的运营流程】</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302111411459.png" alt="1653561657295"></p><p>我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要到redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用<code>lua</code>来操作</p><p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302111411447.png" alt="1653562234886"></p><h3 id="6-2-秒杀优化-Redis完成秒杀资格判断"><a href="#6-2-秒杀优化-Redis完成秒杀资格判断" class="headerlink" title="6.2 秒杀优化-Redis完成秒杀资格判断"></a>6.2 秒杀优化-Redis完成秒杀资格判断</h3><p>需求：</p><ul><li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p></li><li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p></li><li><p>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</p></li><li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302111411471.png" alt="1656080546603"></p></li></ul><p>VoucherServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整lua表达式</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1 优惠券Id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2 用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1 库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2 订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1 判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.1.2 库存不足,返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.2 判断用户是否已经下过单</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.2 存在，说明重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.3 扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.4 下单(保存用户) sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.5 用户有下单资格，返回0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了</p><p>VoucherOrderServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Lua脚本+消息队列实现秒杀下单</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voucherId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 1.执行Lua脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">        SECKILL_SCRIPT,</span><br><span class="line">        Collections.emptyList(),</span><br><span class="line">        voucherId.toString(),</span><br><span class="line">        userId.toString()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1 不为0，代表没有购买资格</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(result == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 保存阻塞队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>压力测试：</strong>因为目前前两步骤做完，后面的加入阻塞队列执行时间就很短了~</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302111411483.png" alt="image-20230207165653386"></p><blockquote><p>可以看到并发性能大大提升，请求响应值在0.1s左右，吞吐量可达到1500&#x2F;sec~ 速度飞起</p></blockquote><h3 id="6-3-秒杀优化-基于阻塞队列实现秒杀优化"><a href="#6-3-秒杀优化-基于阻塞队列实现秒杀优化" class="headerlink" title="6.3 秒杀优化-基于阻塞队列实现秒杀优化"></a>6.3 秒杀优化-基于阻塞队列实现秒杀优化</h3><p>VoucherOrderServiceImpl</p><p>修改下单动作，现在我们去下单时，是通过lua表达式去原子执行判断逻辑，如果判断我出来不为0 ，则要么是库存不足，要么是重复下单，返回错误信息，如果是0，则把下单的逻辑保存到队列中去，然后异步执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将代理对象声明成全局</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> IVoucherOrderService proxy;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 存放任务的阻塞队列</span></span><br><span class="line"><span class="comment">  * 特点：当一个线程尝试从队列中获取元素，没有元素，线程就会被阻塞，直到队列中有元素，线程才会被唤醒，并去获取元素</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> BlockingQueue &lt;VoucherOrder&gt; orderTasks = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span> &lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 思考一个问题：为什么要使用线程池呢，而不是直接创建一个线程？</span></span><br><span class="line"><span class="comment">  * 其实直接创建一个线程也行，但是创建一个线程开销很大的，用阻塞队列+线程池的形式实现了线程的的复用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 由于用户秒杀的时间可能是随时的，所以需要我们项目已启动 线程池就应该从消息队列获取任务，然后工作...</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@PostConstruct</span>类初始花后立刻执行</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@PostConstruct</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">     SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// 1.获取队列中的订单信息</span></span><br><span class="line">                 <span class="comment">// take()：获取和删除该队列的头部，如果没有则阻塞等待，直到有元素可用。所以使用该方法，如果有元素，线程就工作，没有线程就阻塞（卡）在这里，不用担心CPU会空转~</span></span><br><span class="line">                 <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                 <span class="comment">// 2.创建订单</span></span><br><span class="line">                 handleVoucherOrder(voucherOrder);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 log.error(<span class="string">&quot;处理订单异常：&quot;</span>, e);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建订单</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> voucherOrder</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 其实这里可以不加锁了:（方式一）</span></span><br><span class="line"><span class="comment">      * ①:前面的Lua脚本已经进判断过库存和一人一单了，并且也可以保证执行的原子性（一次只有一个线程执行）。</span></span><br><span class="line"><span class="comment">      * ②:此时线程池中只有一个线程,是单线程哦~</span></span><br><span class="line"><span class="comment">      * ③:之后从消息队列取任务执行并不需要保证其原子性，因为就不存在并发安全问题了</span></span><br><span class="line"><span class="comment">      * 加锁算是一种兜底~</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 方式一：加分布式锁再创建订单</span></span><br><span class="line">     <span class="comment">// // 1.获取用户</span></span><br><span class="line">     <span class="comment">// // 注意：这里userId不能从UserHolder中去取，因为当前并不是主线程，而是子线程，无法拿到父线程ThreadLocal中的数据</span></span><br><span class="line">     <span class="comment">// Long userId = voucherOrder.getUserId();</span></span><br><span class="line">     <span class="comment">// // 2.获取分布式锁</span></span><br><span class="line">     <span class="comment">// RLock lock = redissonClient.getLock(&quot;lock:order:&quot; + userId);</span></span><br><span class="line">     <span class="comment">// boolean isLock = lock.tryLock();</span></span><br><span class="line">     <span class="comment">// // 3.判断是否获取锁成功</span></span><br><span class="line">     <span class="comment">// if (!isLock) &#123;</span></span><br><span class="line">     <span class="comment">//     // 获取锁失败，返回错误和重试</span></span><br><span class="line">     <span class="comment">//     log.error(&quot;不允许重复下单~&quot;);</span></span><br><span class="line">     <span class="comment">// &#125;</span></span><br><span class="line">     <span class="comment">// try &#123;</span></span><br><span class="line">     <span class="comment">//     // 获取代理对象（只有通过代理对象调用方法，事务才会生效）</span></span><br><span class="line">     <span class="comment">//     // 注意：这里直接通过以下方式获取肯定是不行的。因为方法底层也是基于ThreadLocal获取的，子线程是无法获取父线程ThreadLocal中的对象的</span></span><br><span class="line">     <span class="comment">//     // 解决办法：在seckillVoucher中提前获取，然后通过消息队列传入或者声明成全局变量，从而就可以使用了</span></span><br><span class="line">     <span class="comment">//     // IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();</span></span><br><span class="line">     <span class="comment">//     proxy.createVoucherOrder(voucherOrder.getVoucherId());</span></span><br><span class="line">     <span class="comment">// &#125; finally &#123;</span></span><br><span class="line">     <span class="comment">//     lock.unlock();</span></span><br><span class="line">     <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 方式二：直接创建订单</span></span><br><span class="line">     proxy.createVoucherOrder(voucherOrder);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// RedisScript需要加载seckill.lua文件，为了避免每次释放锁时都加载，我们可以提前加载好。否则每次读取文件就会产生IO，效率很低</span></span><br><span class="line"> <span class="keyword">static</span> &#123;</span><br><span class="line">     SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span> &lt;&gt;();</span><br><span class="line">     SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">     SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使用Lua脚本+消息队列实现秒杀下单</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> voucherId</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">     <span class="comment">// 获取用户id</span></span><br><span class="line">     <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">     <span class="comment">// 1.执行Lua脚本</span></span><br><span class="line">     <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">             SECKILL_SCRIPT,</span><br><span class="line">             Collections.emptyList(),</span><br><span class="line">             voucherId.toString(),</span><br><span class="line">             userId.toString()</span><br><span class="line">     );</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2.判断结果是否为0</span></span><br><span class="line">     <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 2.1 不为0，代表没有购买资格</span></span><br><span class="line">         <span class="keyword">return</span> Result.fail(result == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 2.2 为0，有购买资格，把下单信息保存到消息队列</span></span><br><span class="line">     <span class="comment">// 2.3 创建订单</span></span><br><span class="line">     <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">     <span class="comment">// 2.4 订单id</span></span><br><span class="line">     <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">     voucherOrder.setId(orderId);</span><br><span class="line">     <span class="comment">// 2.5 用户id</span></span><br><span class="line">     voucherOrder.setUserId(userId);</span><br><span class="line">     <span class="comment">// 2.6代金券id</span></span><br><span class="line">     voucherOrder.setVoucherId(voucherId);</span><br><span class="line">     <span class="comment">// 2.7放入阻塞队列【理论上只要放入消息队列就有购买资格】</span></span><br><span class="line">     orderTasks.add(voucherOrder);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 3.获取代理对象</span></span><br><span class="line">     proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 4. 返回订单id</span></span><br><span class="line">     <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//注意：因为我们在Lua中已经校验过库存和一人一单了，这里就不需要校验拉~</span></span><br><span class="line">     <span class="comment">// 1.扣减库存</span></span><br><span class="line">     <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).</span><br><span class="line">             eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId())</span><br><span class="line">             .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">             .update();</span><br><span class="line">     <span class="comment">//这里其实不判断也是OK的，因为Lua脚本中校验过了，所以一定是充足的</span></span><br><span class="line">     <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">         log.error(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2.保存订单</span></span><br><span class="line">     <span class="built_in">this</span>.save(voucherOrder);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>并发测试：</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302111411347.png" alt="image-20230208233049812"></p><blockquote><p>可以看出平均每个请求40ms，并发达到1000&#x2F;sec，速度非常快。</p></blockquote><p><strong>小总结：</strong></p><p>秒杀业务的优化思路是什么？</p><ul><li>先利用Redis完成库存余量、一人一单判断，完成抢单业务</li><li>再将下单业务放入阻塞队列，利用独立线程异步下单</li><li>基于阻塞队列的异步秒杀存在哪些问题？<ul><li><code>内存限制问题</code>：因为我们使用的是JDK的阻塞队列，它使用的是内存。不加以限制的时候，在高并发的情况下，无数订单进入队列，可能导致内存溢出。所以我们在创建队列的时候设置了上限。另外如果此时队列已经存满了，又有新的任务忘里面塞，就放不进去了。</li><li><code>数据安全问题</code>：目前是基于内存来保存这些订单信息的，<ul><li>①如果内存突然宕机，那么内存中所有的订单信息都丢失了。从而就可能出现用户下单成功但是数据库里面并没有订单记录，造成数据不一致的问题。</li><li>②如果有一个线程从队列中取出了下单的任务，即将执行的时候发生了严重的事故（异常等），那么这个任务就没有执行，而且因为这个任务已经取出队列了，以后就再也不会执行了。从而这个任务就丢失了，再次出现数据不一致的问题。</li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五、分布式锁-Redission</title>
      <link href="/2024/04/05/Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC06%E7%AB%A0_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-redission/"/>
      <url>/2024/04/05/Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC06%E7%AB%A0_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-redission/</url>
      
        <content type="html"><![CDATA[<h2 id="5、分布式锁-redission"><a href="#5、分布式锁-redission" class="headerlink" title="5、分布式锁-redission"></a>5、分布式锁-redission</h2><h3 id="5-1-分布式锁-redission功能介绍"><a href="#5-1-分布式锁-redission功能介绍" class="headerlink" title="5.1 分布式锁-redission功能介绍"></a>5.1 分布式锁-redission功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212260230913.png" alt="1653546070602"></p><p>那么什么是Redission呢</p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>Redission提供了分布式锁的多种多样的功能</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212260230911.png" alt="image-20221226022903663"></p><h3 id="5-2-分布式锁-Redission快速入门"><a href="#5-2-分布式锁-Redission快速入门" class="headerlink" title="5.2 分布式锁-Redission快速入门"></a>5.2 分布式锁-Redission快速入门</h3><p>引入依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置Redisson客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.174.128:6379&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 VoucherOrderServiceImpl使用Redisson带的分布式锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取优惠券信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> voucher.getBeginTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> voucher.getEndTime();</span><br><span class="line">    <span class="keyword">if</span>(beginTime.isAfter(LocalDateTime.now()) || endTime.isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;不再秒杀时段内！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getStock() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 这个代码我们不用了，下面要用Redisson中的分布式锁</span></span><br><span class="line">    <span class="comment">// SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;order:&quot;</span> + userId);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="comment">// 判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">        <span class="comment">// 获取锁失败，返回错误和重试</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取代理对象（只有通过代理对象调用方法，事务才会生效）</span></span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进行测试：</strong></p><p>在集群环境下，一秒一千次请求~ 一个用户只能下一单。分布式锁测试成功~ </p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212260230922.png" alt="image-20221221131219831"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212260230924.png" alt="image-20221221131345069"></p><h3 id="5-3-分布式锁-redission可重入锁原理"><a href="#5-3-分布式锁-redission可重入锁原理" class="headerlink" title="5.3 分布式锁-redission可重入锁原理"></a>5.3 分布式锁-redission可重入锁原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。  </p><p>在redission中，我们的也支持支持可重入锁</p><p>在分布式锁中，他&#x3D;&#x3D;采用hash结构&#x3D;&#x3D;用来存储锁，其中<font color=red>大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有</font>。流程图如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212260230927.png" alt="image-20221221155020125"></p><blockquote><p>为什么每次获取锁成功 或 释放锁 后都要重新设置锁的有效期呢?</p><p>这样是为了下面的业务有足够的时间去执行~</p></blockquote><p><strong><font color=orange>1、接下来我们一起分析一下当前的可重入锁实现的lua表达式</font></strong></p><ul><li>获取锁的Lua脚本：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"><span class="comment">-- 判断是否存在</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;exists&#x27;</span>, key) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 不存在, 获取锁</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>); </span><br><span class="line">    <span class="comment">-- 设置有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 锁已经存在，判断threadId是否是自己</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 存在, 获取锁，重入次数+1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>); </span><br><span class="line">    <span class="comment">-- 设置有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">-- 代码走到这里,说明获取锁的不是自己，获取锁失败</span></span><br></pre></td></tr></table></figure><ul><li>释放锁的Lua脚本：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"><span class="comment">-- 判断当前锁是否还是被自己持有</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, threadId) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">-- 如果已经不是自己，则直接返回</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 是自己的锁，则重入次数-1</span></span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, threadId, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">-- 判断是否重入次数是否已经为0 </span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 大于0说明不能释放锁，重置有效期然后返回</span></span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">-- 等于0说明可以释放锁，直接删除</span></span><br><span class="line">    redis.call(<span class="string">&#x27;DEL&#x27;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p><strong><font color=orange>2、测试Redission的分布式锁的可重入效果</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 测试Redisson的分布式锁的可重入性质</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/12/21 16:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">        lock = redissonClient.getLock(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!isLock)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;获取锁失败....1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;获取锁成功....1&quot;</span>);</span><br><span class="line">            method2();</span><br><span class="line">            log.info(<span class="string">&quot;开始执行业务....1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;开始释放锁....1&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">        <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;获取锁失败....2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;获取锁成功....2&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;开始执行业务....2&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;准备释放锁....2&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Debug测试：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212260230938.png"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212260230697.png"></p><p><strong><font color=orange>3、接下来我们可以查看下Redisson中的分布式锁的实现：</font></strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212260230707.png" alt="image-20221221163708051"></p><blockquote><p>注意源码中的KEYS[1]指外边的大Key，AVG[1]：大Key的过期时间，AVG[2]：当前的线程ID</p></blockquote><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212260230745.png" alt="image-20221221163825349"></p><blockquote><p>源码中的KEYS[1]指外边的大Key，AVG[2]：大Key的过期时间，AVG[3]：当前的线程ID。KEYS[2]和ARGV[1]所代表的含义我们后面会讲解~</p></blockquote><h3 id="5-4-分布式锁-redission锁重试和WatchDog机制"><a href="#5-4-分布式锁-redission锁重试和WatchDog机制" class="headerlink" title="5.4 分布式锁-redission锁重试和WatchDog机制"></a>5.4 分布式锁-redission锁重试和WatchDog机制</h3><p>关于锁可重试的原理见：<a href="https://www.processon.com/view/link/63a86e6534446c6f609d3a3f">https://www.processon.com/view/link/63a86e6534446c6f609d3a3f</a></p><p>关于锁超时续约 和 锁释放的原理见：<a href="https://www.processon.com/view/link/63a891cece3d3c6150d7c2ac">https://www.processon.com/view/link/63a891cece3d3c6150d7c2ac</a></p><p><strong>Redission分布式锁原理</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212260230750.png" alt="image-20221226021503722"></p><blockquote><p>注意:只有leaseTime&#x3D;-1,才会走WatchDog的逻辑</p></blockquote><p><strong>总结：Redisson分布式锁原理</strong></p><ul><li>可重入：利用hash结构记录线程id和重入次数</li><li>可重试：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制</li><li>超时续约：利用watchDog，每隔一段时间（releaseTime &#x2F; 3），重置超时时间</li></ul><h3 id="5-5-分布式锁-redission锁的MutiLock原理"><a href="#5-5-分布式锁-redission锁的MutiLock原理" class="headerlink" title="5.5 分布式锁-redission锁的MutiLock原理"></a>5.5 分布式锁-redission锁的MutiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212260230763.png" alt="image-20221226022637870"></p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212260230772.png" alt="image-20221226022539880"></p><p>那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明</p><p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212260230606.png" alt="1653553093967"></p><h3 id="5-6-总结"><a href="#5-6-总结" class="headerlink" title="5.6 总结"></a>5.6 总结</h3><p><strong>1）不可重入Redis分布式锁：</strong><br>原理：利用setnx的互斥性；利用ex避免死锁；释放锁时判断线程标示<br>缺陷：不可重入、无法重试、锁超时失效<br><strong>2）可重入的Redis分布式锁：</strong><br>原理：利用hash结构，记录线程标示和重入次数；利用watchDog延续锁时间；利用信号量控制锁重试等待<br>缺陷：redis宕机引起锁失效问题<br><strong>3）Redisson的multiLock：</strong><br>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功<br>缺陷：运维成本高、实现复杂</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、分布式锁</title>
      <link href="/2024/04/05/Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC05%E7%AB%A0_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2024/04/05/Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC05%E7%AB%A0_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="4、分布式锁"><a href="#4、分布式锁" class="headerlink" title="4、分布式锁"></a>4、分布式锁</h2><h3 id="4-1-、基本原理和实现方式对比"><a href="#4-1-、基本原理和实现方式对比" class="headerlink" title="4.1 、基本原理和实现方式对比"></a>4.1 、基本原理和实现方式对比</h3><p>分布式锁：&#x3D;&#x3D;满足分布式系·统或集群模式下多进程可见并且互斥的锁&#x3D;&#x3D;。</p><p>分布式锁的核心思想就是&#x3D;&#x3D;让大家都使用同一把锁&#x3D;&#x3D;，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217484.png" alt="image-20221220204024594"></p><p>那么分布式锁他应该满足一些什么样的条件呢？</p><ul><li><p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p></li><li><p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p></li><li><p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p></li><li><p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p></li><li><p>安全性：安全也是程序中必不可少的一环</p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217312.png" alt="1653381992018"></p><p>常见的分布式锁有三种</p><p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p><p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用<code>setnx</code>这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p><p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217573.png" alt="1653382219377"></p><h3 id="4-2-、Redis分布式锁的实现核心思路"><a href="#4-2-、Redis分布式锁的实现核心思路" class="headerlink" title="4.2 、Redis分布式锁的实现核心思路"></a>4.2 、Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p>获取锁：</p><ul><li><p>互斥：确保只能有一个线程获取锁</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217766.png" alt="image-20221220204244460"></p></li><li><p>非阻塞：尝试一次，成功返回true，失败返回false</p></li></ul></li><li><p>释放锁：</p><ul><li>手动释放</li><li>超时释放：获取锁时添加一个超时时间</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217550.png" alt="1653382669900"></p></li></ul><p><strong>核心思路：</strong></p><p>我们利用redis 的<code>setNx </code>方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可(当然这里也可以直接进行返回~)</p><p> <img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217742.png" alt="1653382830810"></p><h3 id="4-3-实现分布式锁版本一"><a href="#4-3-实现分布式锁版本一" class="headerlink" title="4.3 实现分布式锁版本一"></a>4.3 实现分布式锁版本一</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217726.png" alt="image-20221220204155419"></p><p><font color=blue><strong>1、锁的基本接口</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeoutSec 锁持有的超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 代表获取锁成功；false代表获取锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=blue><strong>2、SimpleRedisLock</strong></font></p><p>利用&#x3D;&#x3D;setnx方法进行加锁，同时增加过期时间，防止死锁&#x3D;&#x3D;，此方法可以保证加锁和增加过期时间具有原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取线程标示</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().</span><br><span class="line">                setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 记得 包装类型到基本类型转换时要注意 空指针问题</span></span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=blue>3、修改业务代码</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取优惠券信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> voucher.getBeginTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> voucher.getEndTime();</span><br><span class="line">    <span class="keyword">if</span>(beginTime.isAfter(LocalDateTime.now()) || endTime.isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;不再秒杀时段内！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getStock() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1200</span>);</span><br><span class="line">    <span class="comment">// 判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">        <span class="comment">// 获取锁失败，返回错误和重试</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取代理对象（只有通过代理对象调用方法，事务才会生效）</span></span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进行测试：</strong>分别在三个端口启动模拟集群的形式~</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217175.png" alt="image-20221220225649952"></p><ul><li>创建三个请求并发送</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210218271.png" alt="image-20221220225838787"></p><ul><li><p>观察后台结果</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217638.png" alt="image-20221220230251399"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217247.png" alt="image-20221220230202928"></p></li></ul><p><strong>结论：</strong>分布式锁测试成功，达到了集群环境下 相同用户同一时间只有一个线程获取到锁~ 可以实现一户一单的情况，防止刷单~</p><h3 id="4-4-Redis分布式锁误删情况说明"><a href="#4-4-Redis分布式锁误删情况说明" class="headerlink" title="4.4 Redis分布式锁误删情况说明"></a>4.4 Redis分布式锁误删情况说明</h3><p>逻辑说明：</p><p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p><p>解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217840.png" alt="image-20221221000108203"></p><h3 id="4-5-解决Redis分布式锁误删问题"><a href="#4-5-解决Redis分布式锁误删问题" class="headerlink" title="4.5 解决Redis分布式锁误删问题"></a>4.5 解决Redis分布式锁误删问题</h3><p>需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示）<br>在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p><ul><li>如果一致则释放锁</li><li>如果不一致则不释放锁</li></ul><p>核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217894.png" alt="1653387398820"></p><p>具体代码如下：加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程表示前缀</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>)+<span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX+Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().</span><br><span class="line">        setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 记得 包装类型到基本类型转换时要注意 空指针问题</span></span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX+Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().</span><br><span class="line">        setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 记得 包装类型到基本类型转换时要注意 空指针问题</span></span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>有关代码实操说明：</strong>&#x3D;&#x3D;</p><p>在我们修改完此处代码后，我们重启工程，然后启动三个线程。</p><ul><li>第一个线程持有锁后，手动释放锁，</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217733.png"></p><ul><li>第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217613.png"></p><ul><li><p>当第二个线程里面的秒杀业务执行完，此时第二个线程能够正确释放锁~</p></li><li><p>在第二个线程执行期间，第三个线程会获取锁失败~ 如果第三个线程在第二个线程锁释放后，仍然可以获取锁、执行业务、释放锁~</p><p>通过这个案例初步说明我们解决了锁误删的问题~ </p><blockquote><p>注意：以上在同一时刻还是只能有一把锁存在，所以并不存在超卖的情况~</p></blockquote></li></ul><h3 id="4-6-分布式锁的原子性问题"><a href="#4-6-分布式锁的原子性问题" class="headerlink" title="4.6 分布式锁的原子性问题"></a>4.6 分布式锁的原子性问题</h3><p><font color=blue>更为极端的误删逻辑说明：</font></p><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时出现了阻塞（比如GC），他的锁到期了~ 那么此时线程2进来，就可以重新获取锁，过了一段时间，线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，<strong>相当于条件判断并没有起到作用</strong>，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的&#x3D;&#x3D;判读锁，删除锁并不是原子性的&#x3D;&#x3D;，所以导致了刚才误删锁的发生~</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217037.png" alt="image-20221221005109289"></p><h3 id="4-7-Lua脚本解决多条命令原子性问题"><a href="#4-7-Lua脚本解决多条命令原子性问题" class="headerlink" title="4.7 Lua脚本解决多条命令原子性问题"></a>4.7 Lua脚本解决多条命令原子性问题</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C==%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lua%E5%8E%BB%E6%93%8D%E4%BD%9Credis%EF%BC%8C%E5%8F%88%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BB%96%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7==%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8B%BF%E9%94%81%E6%AF%94%E9%94%81%E5%88%A0%E9%94%81%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8A%A8%E4%BD%9C%E4%BA%86%EF%BC%8C%E4%BD%9C%E4%B8%BAJava%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%99%E4%B8%80%E5%9D%97%E5%B9%B6%E4%B8%8D%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A6%81%E6%B1%82%EF%BC%8C%E5%B9%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E5%A4%A7%E5%AE%B6%E8%BF%87%E4%BA%8E%E7%B2%BE%E9%80%9A%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E4%BB%96%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E5%8D%B3%E5%8F%AF%E3%80%82">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，==我们可以使用lua去操作redis，又能保证他的原子性==，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。</a></p><p>这里重点介绍Redis提供的调用函数，语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure><p>例如，我们要执行set name jack，则脚本是这样：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure><p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 先执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>)</span><br><span class="line"># 再执行 get name</span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"># 返回</span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure><p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217783.png" alt="1653392181413"></p><p>例如，我们要执行 redis.call(‘set’, ‘name’, ‘jack’) 这个脚本，语法如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217430.png" alt="1653392218531"></p><p>如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217463.png" alt="1653392438917"></p><p>接下来我们来回顾一下我们释放锁的逻辑：</p><p>​1、获取锁中的线程标示</p><p>​2、判断是否与指定的标示（当前线程标示）一致</p><p>​3、如果一致则释放锁（删除）</p><p>​4、如果不一致则什么都不做</p><p>如果用Lua脚本来表示则是这样的：</p><p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 当前线程标示</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">--获取锁中的线程标示 get key</span></span><br><span class="line"><span class="keyword">local</span> id = redis.call(<span class="string">&#x27;get&#x27;</span>,key)</span><br><span class="line"><span class="comment">-- 比较线程标示与锁中的标示是否一致</span></span><br><span class="line"><span class="keyword">if</span>(id == threadId) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 释放锁 del key</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">------------------ 简化版本如下-------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="4-8-利用Java代码调用Lua脚本改造分布式锁"><a href="#4-8-利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="4.8 利用Java代码调用Lua脚本改造分布式锁"></a>4.8 利用Java代码调用Lua脚本改造分布式锁</h3><p>lua脚本本身并不需要大家花费太多时间去研究，只需要知道如何调用，大致是什么意思即可，所以在笔记中并不会详细的去解释这些lua表达式的含义。</p><p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212210217208.png" alt="1653393304844"></p><p><strong>Redis分布式锁代码改进</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RedisScript需要加载unlock.lua文件，为了避免每次释放锁时都加载，我们可以提前加载好，否则每次读取文件就会产生IO，效率很低</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~</span></span><br></pre></td></tr></table></figure><p><strong>测试逻辑：</strong></p><p>第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。</p><p>&#x3D;&#x3D;至此，我们已经实现了一个生产可用的Redis分布式锁~&#x3D;&#x3D;</p><p><font color=blue><strong>总结：基于Redis的分布式锁实现思路</strong></font></p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁</li></ul><p>特性：</p><ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul><p>笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p><p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、优惠券秒杀</title>
      <link href="/2024/04/05/Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC04%E7%AB%A0_%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80/"/>
      <url>/2024/04/05/Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC04%E7%AB%A0_%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="3、优惠卷秒杀"><a href="#3、优惠卷秒杀" class="headerlink" title="3、优惠卷秒杀"></a>3、优惠卷秒杀</h1><h2 id="3-1-全局唯一ID"><a href="#3-1-全局唯一ID" class="headerlink" title="3.1 -全局唯一ID"></a>3.1 -全局唯一ID</h2><p>每个店铺都可以发布优惠券：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161235341.png" alt="1653362612286"></p><p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p><ul><li>id的规律性太明显</li><li>受单表数据量的限制</li></ul><p>场景分析一：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。</p><p>场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。</p><p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161235663.png" alt="1653363100502"></p><p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161235117.png" alt="1653363172079"></p><p>ID的组成部分：</p><p>符号位：1bit，永远为0</p><p>时间戳：31bit，以秒为单位，可以使用69年</p><p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p><h2 id="3-2-Redis实现全局唯一Id"><a href="#3-2-Redis实现全局唯一Id" class="headerlink" title="3.2 -Redis实现全局唯一Id"></a>3.2 -Redis实现全局唯一Id</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> ID生成器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/12/12 12:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1670803200L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.生成序列号</span></span><br><span class="line">        <span class="comment">//2.1 获取当天日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.2自增长</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testIdWorker</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> ()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;id = &quot;</span>+id);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        es.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time = &quot;</span>+(end - begin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>知识小贴士：关于countdownlatch</p><p>countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题</p><p>我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch</p><p>CountDownLatch 中有两个最重要的方法</p><p>1、countDown</p><p>2、await</p><p>await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。</p></blockquote><h2 id="3-3-添加优惠卷"><a href="#3-3-添加优惠卷" class="headerlink" title="3.3 添加优惠卷"></a>3.3 添加优惠卷</h2><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161236382.png" alt="1653365145124"></p><p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等<br>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p><p>平价卷由于优惠力度并不是很大，所以是可以任意领取</p><p>而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p><p>**新增普通卷代码：  **VoucherController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.save(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>新增秒杀卷代码：</strong></p><p><strong>VoucherController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;seckill&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">    voucherService.addSeckillVoucher(voucher);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>VoucherServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-实现秒杀下单"><a href="#3-4-实现秒杀下单" class="headerlink" title="3.4 实现秒杀下单"></a>3.4 实现秒杀下单</h2><p>下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161236036.png" alt="1653365839526"></p><p>下单时需要判断两点：</p><ul><li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li><li>库存是否充足，不足则无法下单</li></ul><p>下单核心逻辑分析：</p><p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p><p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161236261.png" alt="1653366238564"></p><p>VoucherOrderServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取优惠券信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> voucher.getBeginTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> voucher.getEndTime();</span><br><span class="line">    <span class="keyword">if</span>(beginTime.isAfter(LocalDateTime.now()) || endTime.isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;不再秒杀时段内！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getStock() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="comment">//这里二次判断的原因在于：高并发场景下会有时间差A在更新库存的时间内，B把最后一件买走了，就会导致A更新失败！</span></span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.1 订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.2 用户id</span></span><br><span class="line">    voucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.3代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    <span class="built_in">this</span>.save(voucherOrder);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><p>当我们用两百个线程模拟秒杀的时候，竟然出现了 库存 -9 的情况，很显然出现了超卖问题~</p><h2 id="3-5-库存超卖问题分析"><a href="#3-5-库存超卖问题分析" class="headerlink" title="3.5 库存超卖问题分析"></a>3.5 库存超卖问题分析</h2><p>有关超卖问题分析：在我们原有代码中是这么写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="comment">// 库存不足</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//5，扣减库存</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">           .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">           .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">   <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">       <span class="comment">//扣减库存</span></span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161236293.png" alt="1653368335155"></p><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161248325.png" alt="image-20221213200152980"></p><p><strong>悲观锁：</strong></p><p>悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p><p><strong>乐观锁：</strong></p><p>乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas</p><p>乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 &#x3D;&#x3D; 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p><p>其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var5;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">&#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> var5;</span><br></pre></td></tr></table></figure><p><strong>课程中的使用方式：</strong></p><p>课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version&#x3D;1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version &#x3D;1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version&#x3D;1 的条件了，所以线程2无法执行成功</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161248939.png" alt="1653369268550"></p><h2 id="3-6-乐观锁解决超卖问题"><a href="#3-6-乐观锁解决超卖问题" class="headerlink" title="3.6 乐观锁解决超卖问题"></a>3.6 乐观锁解决超卖问题</h2><p><strong>修改代码方案一、</strong></p><p>VoucherOrderServiceImpl 在扣减库存时，改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>) <span class="comment">//set stock = stock -1</span></span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock()).update(); <span class="comment">//where id = ？ and stock = ?</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161248211.png" alt="image-20221213201606432"></p><p>以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败</p><p><strong>修改代码方案二、</strong></p><p>之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>); <span class="comment">//where id = ? and stock &gt; 0</span></span><br></pre></td></tr></table></figure><p><strong>知识小扩展：</strong></p><p>针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决</p><p>Java8 提供的一个对AtomicLong改进后的一个类，LongAdder</p><p>大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好</p><p>所以利用这么一个类，LongAdder来进行优化</p><p>如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161248691.png" alt="1653370271627"></p><h2 id="3-7-优惠券秒杀-一人一单"><a href="#3-7-优惠券秒杀-一人一单" class="headerlink" title="3.7 优惠券秒杀-一人一单"></a>3.7 优惠券秒杀-一人一单</h2><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p><p><strong>现在的问题在于：</strong></p><p>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单</p><p>具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161248971.png" alt="1653371854389"></p><p>VoucherOrderServiceImpl  </p><p><strong>初步代码：增加一人一单逻辑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取优惠券信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> voucher.getBeginTime();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> voucher.getEndTime();</span><br><span class="line">    <span class="keyword">if</span>(beginTime.isAfter(LocalDateTime.now()) || endTime.isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;不再秒杀时段内！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span>(voucher.getStock() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 一人一单</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 4.1 查询订单</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;user_id&quot;</span>, userId).count();</span><br><span class="line">    <span class="comment">// 4.2 判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).</span><br><span class="line">        eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">        .gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>)</span><br><span class="line">        .update();</span><br><span class="line">    <span class="comment">//这里二次判断的原因在于：高并发场景下会有时间差A在更新库存的时间内，B把最后一件买走了，就会导致A更新失败！</span></span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 6.1 订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.2 用户id</span></span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.3代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    <span class="built_in">this</span>.save(voucherOrder);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>存在问题：</strong>现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是&#x3D;&#x3D;乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作&#x3D;&#x3D;</p><p><strong>注意：</strong>在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 4. 一人一单</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 4.1 查询订单</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;user_id&quot;</span>, userId).count();</span><br><span class="line">    <span class="comment">// 4.2 判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).</span><br><span class="line">        eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">        .gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>)</span><br><span class="line">        .update();</span><br><span class="line">    <span class="comment">//这里二次判断的原因在于：高并发场景下会有时间差A在更新库存的时间内，B把最后一件买走了，就会导致A更新失败！</span></span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 6.1 订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.2 用户id</span></span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.3代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    <span class="built_in">this</span>.save(voucherOrder);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>，但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制<strong>锁粒度</strong> 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：<br>intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span>  Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 4. 一人一单</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">        <span class="comment">// 4.1 查询订单</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;user_id&quot;</span>, userId).count();</span><br><span class="line">        <span class="comment">// 4.2 判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过一次了~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().setSql(<span class="string">&quot;stock = stock - 1&quot;</span>).</span><br><span class="line">                eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">                .gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>)</span><br><span class="line">                .update();</span><br><span class="line">        <span class="comment">//这里二次判断的原因在于：高并发场景下会有时间差A在更新库存的时间内，B把最后一件买走了，就会导致A更新失败！</span></span><br><span class="line">        <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 6.1 订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 6.2 用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 6.3代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="built_in">this</span>.save(voucherOrder);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会&#x3D;&#x3D;导致当前方法事务还没有提交，但是锁已经释放也会导致问题&#x3D;&#x3D;，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：</p><p>在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161248563.png" alt="image-20221215234431160"></p><p>但是以上做法依然有问题，因为你调用的方法，其实是<code>this.</code>的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161248970.png" alt="image-20221215234511307"></p><p><strong>注意：</strong>代理需要搭配<code>@EnableAspectJAutoProxy(exposeProxy = true)</code> 和aspectjweaver 依赖</p><h2 id="3-8-集群环境下的并发问题"><a href="#3-8-集群环境下的并发问题" class="headerlink" title="3.8 集群环境下的并发问题"></a>3.8 集群环境下的并发问题</h2><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p><p>1、我们将服务启动两份，端口分别为8081和8082：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161248538.png" alt="image-20221216104419719"></p><p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161248491.png" alt="1653373908620"></p><p><strong>具体操作(略)</strong></p><p>我们在Postman中发送两个一模一样的秒杀请求，结果发现请求分别进入了两个服务的synchronized方法内，出现了锁失效的问题~</p><p><strong>有关锁失效原因分析</strong></p><p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212161248107.png" alt="image-20221216114317798"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、商品查询缓存（缓存基本使用 | 缓存更新 | 缓存穿透 | 缓存雪崩 | 缓存击穿 | Redis缓存工具类）</title>
      <link href="/2024/04/05/Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC03%E7%AB%A0_%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/"/>
      <url>/2024/04/05/Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC03%E7%AB%A0_%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="2、商户查询缓存"><a href="#2、商户查询缓存" class="headerlink" title="2、商户查询缓存"></a>2、商户查询缓存</h2><h3 id="2-1-什么是缓存"><a href="#2-1-什么是缓存" class="headerlink" title="2.1 什么是缓存?"></a>2.1 什么是缓存?</h3><p><strong>前言</strong>:<strong>什么是缓存?</strong></p><p>就像自行车,越野车的避震器<img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050213959.gif"></p><p>举个例子:越野车,山地自行车,都拥有”避震器”,<strong>防止</strong>车体加速后因惯性,在酷似”U”字母的地形上飞跃,硬着陆导致的<strong>损害</strong>,像个弹簧一样;</p><p>同样,实际开发中,系统也需要”避震器”,防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪;</p><p>这在实际开发中对企业讲,对产品口碑,用户评价都是致命的;所以企业非常重视缓存技术;</p><p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码(例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1</span>:Static <span class="keyword">final</span> ConcurrentHashMap&lt;K,V&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(); 本地用于高并发</span><br><span class="line"></span><br><span class="line">例<span class="number">2</span>:<span class="keyword">static</span> <span class="keyword">final</span> Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存</span><br><span class="line"></span><br><span class="line">例<span class="number">3</span>:Static <span class="keyword">final</span> Map&lt;K,V&gt; map =  <span class="keyword">new</span> <span class="title class_">HashMap</span>(); 本地缓存</span><br></pre></td></tr></table></figure><p>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(&#x3D;)导致缓存失效;</p><h4 id="2-1-1-为什么要使用缓存"><a href="#2-1-1-为什么要使用缓存" class="headerlink" title="2.1.1 为什么要使用缓存"></a>2.1.1 为什么要使用缓存</h4><p>一句话:因为&#x3D;&#x3D;<strong>速度快,好用</strong>&#x3D;&#x3D;</p><p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p><p>实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以企业会大量运用到缓存技术;</p><p>但是缓存也会增加代码复杂度和运营的成本:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050213234.png" alt="image-20221127121416381"></p><h4 id="2-1-2-如何使用缓存"><a href="#2-1-2-如何使用缓存" class="headerlink" title="2.1.2 如何使用缓存"></a>2.1.2 如何使用缓存</h4><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050213191.png" alt="image-20221127121510971"></p><h3 id="2-2-添加商户缓存"><a href="#2-2-添加商户缓存" class="headerlink" title="2.2 添加商户缓存"></a>2.2 添加商户缓存</h3><p>在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//这里是直接查询数据库</span></span><br><span class="line">    <span class="keyword">return</span> shopService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-1-、缓存模型和思路"><a href="#2-2-1-、缓存模型和思路" class="headerlink" title="2.2.1 、缓存模型和思路"></a>2.2.1 、缓存模型和思路</h4><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050213775.png" alt="image-20221127122419377"></p><h4 id="2-2-2、代码如下"><a href="#2-2-2、代码如下" class="headerlink" title="2.2.2、代码如下"></a>2.2.2、代码如下</h4><p>代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.从查询Redis中是否有数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="comment">// 2.如果有则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.如果没有，就去查数据库</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="built_in">this</span>.baseMapper.selectById(id);</span><br><span class="line">    <span class="comment">// 4.如果没找到则返回错误信息</span></span><br><span class="line">    <span class="keyword">if</span>(shop==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.如果查到了就加入到Redis,并返回</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id, JSONUtil.toJsonStr(shop));</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-练习：为店铺类型接口添加缓存"><a href="#2-2-3-练习：为店铺类型接口添加缓存" class="headerlink" title="2.2.3 练习：为店铺类型接口添加缓存"></a>2.2.3 练习：为店铺类型接口添加缓存</h4><p>店铺类型在首页和其它多个页面都会用到，如图：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050213289.png" alt="image-20221127165136055"></p><p>需求：修改ShopTypeController中的queryTypeList方法，添加查询缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryTypeList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.先去Redis查缓存首页缓存数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopTypeListJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_TYPE_KEY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.如果为不为空，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopTypeListJson)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(JSONUtil.toList(shopTypeListJson,ShopType.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.如果为空，去查询数据库</span></span><br><span class="line">    List &lt;ShopType&gt; shopTypeList = <span class="built_in">this</span>.query().orderByDesc(<span class="string">&quot;sort&quot;</span>).list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.如果查询为空，则直接返回错误信息</span></span><br><span class="line">    <span class="keyword">if</span> (shopTypeList == <span class="literal">null</span> || shopTypeList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;商品类型查询失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.如果不为空，则把数据存入到Redis,并返回结果 (这里可以使用List,String等结构)</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_TYPE_KEY,JSONUtil.toJsonStr(shopTypeList));</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shopTypeList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-缓存更新策略"><a href="#2-3-缓存更新策略" class="headerlink" title="2.3 缓存更新策略"></a>2.3 缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p><p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p><p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050213495.png" alt="1653322506393"></p><h4 id="2-3-1-、数据库缓存不一致解决方案"><a href="#2-3-1-、数据库缓存不一致解决方案" class="headerlink" title="2.3.1 、数据库缓存不一致解决方案"></a>2.3.1 、数据库缓存不一致解决方案</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p><ul><li><p><strong><font color=red>Cache Aside Pattern</font></strong> 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为&#x3D;&#x3D;双写&#x3D;&#x3D;方案</p><ul><li>特点:需要依靠程序员在CRUD之外进行额外的代码处理!</li></ul></li><li><p><strong><font color=red>Read&#x2F;Write Through Pattern</font></strong> : 由系统本身完成，数据库与缓存的问题交由系统本身去处理 </p><ul><li>如:Canel + Kafaka 搭建的服务,但是维护和开发成本较高!</li></ul></li><li><p><strong><font color=red>Write Behind Caching Pattern</font></strong> ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致 </p><ul><li>优点:调用者多次操作缓存,经过一段时间线程只需要把最后一次更新后的结果同步到数据库,效率极高 </li><li>缺点:维护这个异步线程比较困难; 如果在一段时间内有大量更新,但是还没有触发异步线程的更新,就会导致数据库和缓存数据差别很大; 缓存宕机 会导致 数据丢失,可靠性较差</li></ul></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050213777.png" alt="1653322857620"></p><h4 id="2-3-2-、双写方案存在的问题"><a href="#2-3-2-、双写方案存在的问题" class="headerlink" title="2.3.2 、双写方案存在的问题"></a>2.3.2 、双写方案存在的问题</h4><p>综合考虑使用方案一，&#x3D;&#x3D;<strong>可控性比较高</strong>~  (实际企业中用的也比较多)&#x3D;&#x3D;</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p><font color=blue>1、删除缓存还是更新缓存？</font></p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多  <strong><font color=red>×</font></strong></li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存  <strong><font color=green>√</font></strong></li></ul><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><p><font color=blue>2、如何保证缓存与数据库的操作的同时成功或失败？</font></p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul><p><font color=blue>3、先操作缓存还是先操作数据库？</font></p><ul><li>先删除缓存，再操作数据库  <strong><font color=red>×</font></strong></li><li>先操作数据库，再删除缓存  <strong><font color=green>√</font></strong></li></ul><p>在不考虑并发的情况下，都是可以的。但是在并发场景下，我们应当是&#x3D;&#x3D;先操作数据库，再删除缓存&#x3D;&#x3D;，我们简单分析一下：</p><ul><li><p>如果你选择第一种方案，如左图所示：在两个线程（线程1是更新线程，线程2是查询线程）并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入缓存的是旧的数据，新的数据被旧数据覆盖了。</p></li><li><p>如果你选择第二种方案，如右图所示，两个线程（线程1是查询线程，线程2是更新线程）并发来访问时，假如此时缓存是被删除的状态，线程1过来了，发现未命中，就去数据库擦汗寻数据了，刚查询完还没写入缓存!!!  此时线程2过来了，就更新数据库了（下面删除缓存这一步就不用做了）。然后，线程1又抢到了时间片，继续进行写入缓存操作，就会导致写入缓存的仍是旧数据</p></li></ul><p>既然我们发现两种方案都有并发修改的风险，但是为啥选择方案二呢？</p><p>因为 查询操作时间非常短，容易产生并发风险概率较低~</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050213960.png" alt="1653323595206"></p><p>&#x3D;&#x3D;<strong>总结：缓存更新策略的最佳实践方案</strong>&#x3D;&#x3D;</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050214319.png" alt="image-20221203180617553"></p><h4 id="2-3-2-实现商铺和缓存与数据库双写一致"><a href="#2-3-2-实现商铺和缓存与数据库双写一致" class="headerlink" title="2.3.2 实现商铺和缓存与数据库双写一致"></a>2.3.2 实现商铺和缓存与数据库双写一致</h4><p>核心思路如下：</p><p>修改ShopController中的业务逻辑，满足下面的需求：</p><p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p><p>根据id修改店铺时，先修改数据库，再删除缓存</p><p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p><p><strong>设置redis缓存时添加过期时间</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050214096.png" alt="image-20221204222609860"></p><p><strong>修改重点代码2</strong></p><p>代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;id不能为null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.updateById(shop);</span><br><span class="line">    <span class="comment">// 删除缓存</span></span><br><span class="line">    stringRedisTemplate.delete(RedisConstants.CACHE_SHOP_KEY+id);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-缓存穿透"><a href="#2-4-缓存穿透" class="headerlink" title="2.4 缓存穿透"></a>2.4 缓存穿透</h3><h4 id="2-4-1-问题的解决思路"><a href="#2-4-1-问题的解决思路" class="headerlink" title="2.4.1 问题的解决思路"></a>2.4.1 问题的解决思路</h4><p>&#x3D;&#x3D;缓存穿透&#x3D;&#x3D; ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能 (因为可能出现hash冲突)</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到数据库了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050214991.png" alt="1653326156516"></p><p><strong>代码修改：</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050214031.png" alt="image-20221204224430936"></p><h4 id="2-4-2-编码解决商品查询的缓存穿透问题："><a href="#2-4-2-编码解决商品查询的缓存穿透问题：" class="headerlink" title="2.4.2 编码解决商品查询的缓存穿透问题："></a>2.4.2 编码解决商品查询的缓存穿透问题：</h4><p>核心思路如下：</p><p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的</p><p>现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050214160.png" alt="1653327124561"></p><p><strong>小总结：</strong></p><p>缓存穿透产生的原因是什么？</p><ul><li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li></ul><p>缓存穿透的解决方案有哪些？</p><ul><li>缓存null值 （被动解决）</li><li>布隆过滤      （被动解决）</li><li>增强id的复杂度，避免被猜测id规律 （比如随机数，防止用户猜到…）</li><li>做好数据的基础格式校验 （比如id的位数）</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h3 id="2-5-缓存雪崩问题及解决思路"><a href="#2-5-缓存雪崩问题及解决思路" class="headerlink" title="2.5 缓存雪崩问题及解决思路"></a>2.5 缓存雪崩问题及解决思路</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值 （可以防止同一时间短缓存都失效~）</li><li>利用Redis集群提高服务的可用性 （后面会讲）</li><li>给缓存业务添加降级限流策略 （比如sentinel的一些策略）</li><li>给业务添加多级缓存 （Nginx缓存、JVM缓存、MySQL缓存、Redis缓存 只要有一个命中就可~）</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050214792.png" alt="1653327884526"></p><h3 id="2-6-缓存击穿"><a href="#2-6-缓存击穿" class="headerlink" title="2.6 缓存击穿"></a>2.6 缓存击穿</h3><h4 id="2-6-1-问题及解决思路"><a href="#2-6-1-问题及解决思路" class="headerlink" title="2.6.1 问题及解决思路"></a>2.6.1 问题及解决思路</h4><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050214078.png" alt="image-20221204232839336"></p><p><font color=blue>解决方案一、使用锁来解决：</font></p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050214408.png" alt="image-20221204233045795"></p><p><font color=blue>解决方案二、逻辑过期方案</font></p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于&#x3D;&#x3D;我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题&#x3D;&#x3D;，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，&#x3D;&#x3D;异步的构建缓存&#x3D;&#x3D;，缺点在于在构建完缓存之前，返回的都是脏数据。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050214649.png" alt="image-20221204233315960"></p><p><strong><font color=blue>进行对比</font></strong></p><p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050214255.png" alt="image-20221204233506235"></p><h4 id="2-6-2-利用互斥锁解决缓存击穿问题"><a href="#2-6-2-利用互斥锁解决缓存击穿问题" class="headerlink" title="2.6.2 利用互斥锁解决缓存击穿问题"></a>2.6.2 利用互斥锁解决缓存击穿问题</h4><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询</p><p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050214353.png" alt="image-20221205005716282"></p><p><strong>操作锁的代码：</strong></p><p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取锁：使用setnx模拟互斥锁</span></span><br><span class="line"><span class="comment"> * 为了防止出现死锁，所以应该为其设置过期时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, RedisConstants.LOCK_SHOP_TTL, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>操作代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 互斥锁解决缓存击穿</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.从查询Redis中是否有数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        <span class="comment">// 存在则直接返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.判断命中的是否是空值</span></span><br><span class="line">    <span class="keyword">if</span>(shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY+id;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 4.1 获取互斥锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(key);</span><br><span class="line">        <span class="comment">// 4.2判断是否获取成功</span></span><br><span class="line">        <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">            <span class="comment">// 4.3失败，则休眠并重试</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="comment">// 注意：获取锁的同时应该再次检测redis缓存是否存在，做DoubleCheck,如果存在则无需重建缓存</span></span><br><span class="line">            <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.4成功，根据id查询数据库</span></span><br><span class="line">        shop = getById(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟重建时的延时</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span>(shop==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 将空值写入到redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id,<span class="string">&quot;&quot;</span>,RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在就加入到Redis,并返回</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id, JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 7.释放互斥锁</span></span><br><span class="line">        unlock(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color=blue>测试：5s 1000次请求的高并发测试</font></strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050214399.png" alt="image-20221205015020479"></p><p>观察控制台，可以发现只向数据库请求了一次~其他请求都打在了缓存上！！！</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212050214159.png" alt="image-20221205015122987"></p><p>从而可以得出结论，&#x3D;&#x3D;使用互斥锁可以解决缓存击穿的问题~~~&#x3D;&#x3D;</p><h4 id="2-6-3-利用逻辑过期解决缓存击穿问题"><a href="#2-6-3-利用逻辑过期解决缓存击穿问题" class="headerlink" title="2.6.3 利用逻辑过期解决缓存击穿问题"></a>2.6.3 利用逻辑过期解决缓存击穿问题</h4><p>思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212102007038.png" alt="image-20221205231155904"></p><p>封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。</p><p><font color=blue>步骤一、 新建RedisData类</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=blue>步骤二、 在ShopServiceImpl 新增此方法，利用单元测试进行缓存预热</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存重建（预热）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expireSeconds</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShop2Redis</span><span class="params">(Long id, Long expireSeconds)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 1.查询店铺信息</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="comment">// 2.封装逻辑过期时间</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(shop);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line">    <span class="comment">// 3.写入Redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSave2Redis</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    shopService.saveShop2Redis(<span class="number">1L</span>,<span class="number">30L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=blue>步骤三：编写逻辑过期的核心代码</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逻辑过期解决缓存击穿</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.从Redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">redisDataJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="comment">// 2.判断是否命中</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(redisDataJson)) &#123;</span><br><span class="line">        <span class="comment">// 3.未命中，则返回空(因为预热过了，所以如果缓存中没有，则一定就是没有该店铺数据)</span></span><br><span class="line">        <span class="comment">// 为什么不用考虑缓存穿透的情况，因为所有的数据都放入到redis中预热了，一旦缓存查询出是null的，说明数据库没这个数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(redisDataJson, RedisData.class);</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">shopJSONObj</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJSONObj, Shop.class);</span><br><span class="line">    <span class="comment">// 5.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (redisData.getExpireTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 5.1未过期，则返回商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.2已过期，需要缓存重建</span></span><br><span class="line">    <span class="comment">// 6.缓存重建</span></span><br><span class="line">    <span class="comment">// 6.1尝试获取互斥锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(RedisConstants.LOCK_SHOP_KEY + id);</span><br><span class="line">    <span class="comment">// 6.2判断互斥锁是否获取成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="comment">// 6.3获取成功，则开启独立线程</span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 6.4进行缓存重建</span></span><br><span class="line">                <span class="comment">// 注意：这里写的是20S只是为了测试方便，实际项目中要用 30min</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id, <span class="number">20L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 6.5释放锁</span></span><br><span class="line">                unlock(RedisConstants.LOCK_SHOP_KEY + id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7.获取互斥锁失败，则直接返回过期的shop数据</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=blue>步骤四：测试</font></p><ul><li><p>先执行单元测试方法预热缓存</p></li><li><p>进行高并发请求 1s 100次</p></li><li><p>观察请求的结果：<code>缓存重建前返回的是旧数据，重建后得到的是新数据</code></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212102007430.png" alt="image-20221205233255665"></p></li><li><p>观察控制台，也只有一条查询的SQL，说明互斥锁起到了作用！只缓存重建了一次~</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212102007405.png" alt="image-20221205233340769"></p></li></ul><h3 id="2-7、封装Redis缓存工具类"><a href="#2-7、封装Redis缓存工具类" class="headerlink" title="2.7、封装Redis缓存工具类"></a>2.7、封装Redis缓存工具类</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p><ul><li>方法1：将Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</li><li>方法2：根据指定的key查询缓存，并利用缓存空值来解决缓存穿透问题</li><li>方法3：根据指定的key查询缓存，并利用互斥锁解决缓存击穿解决缓存击穿问题</li><li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li></ul><p><strong>代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> Redis操作缓存的工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/12/6 0:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value),time,unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  逻辑过期解决缓存击穿问题中的缓存重建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key,Object value,Long time,TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定的key查询缓存,并利用缓存空值来解决缓存穿透问题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPrefix key前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dbFallback 降级的函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time       时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit       单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;ID&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type,</span></span><br><span class="line"><span class="params">                                          Function &lt;ID,R&gt; dbFallback,Long time,TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从Redis中查询R数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在,则直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.判断命中的是否是空值 (上面已经判断过不为空的情况了，下面只有 “” 和 null的两种情况，为null说明不存在，为“”说明空缓存)</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.如果没有，就去查数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 4.如果没找到则返回错误信息</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.如果查到了就加入到Redis,并返回</span></span><br><span class="line">        <span class="built_in">this</span>.set(key,r,time,unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定的key查询缓存，并利用逻辑过期时间来解决缓存击穿问题</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(String keyPrefix,ID id,Class&lt;R&gt; type</span></span><br><span class="line"><span class="params">    ,Function &lt;ID,R&gt; dbFallback,Long time,TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从Redis中查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisDataJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否命中</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(redisDataJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.未命中，则返回空(因为预热过了，所以如果缓存中没有，则一定就是没有该店铺数据)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(redisDataJson, RedisData.class);</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObj</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean(jsonObj, type);</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span> (redisData.getExpireTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1未过期，则返回商铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1尝试获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2判断互斥锁是否获取成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">            <span class="comment">// 6.3获取成功，则开启独立线程</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 进行缓存重建</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key,newR,time,unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 6.6释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7.获取互斥锁失败，则直接返回过期的R数据</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定的key查询缓存，并利用互斥锁解决缓存击穿解决缓存击穿问题</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(String keyPrefix,ID id,Class&lt;R&gt; type,</span></span><br><span class="line"><span class="params">                                    Function &lt;ID,R&gt; dbFallback,Long time,TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从查询Redis中是否有数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 存在则直接返回</span></span><br><span class="line">            <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean(json, type);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.判断命中的是否是 “” (缓存空值)</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4.1 获取互斥锁</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3失败，则休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="comment">// 注意：获取锁的同时应该再次检测redis缓存是否存在，做DoubleCheck,如果存在则无需重建缓存</span></span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix,id,type,dbFallback,time,unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟重建时的延时</span></span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入到redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在就加入到Redis,并返回</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(r),time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放互斥锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁：使用setnx模拟互斥锁</span></span><br><span class="line"><span class="comment">     * 为了防止出现死锁，所以应该为其设置过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, RedisConstants.LOCK_SHOP_TTL, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可能有人好奇为什么工具类的方法不用static修饰？</p><p>ioc是通过new的方式创建bean,new出来的对象是在堆里面, static修饰的东西是优先于对象存在,<br>如果我们用了static，那么方法里面涉及到的方法调用也得是Static，但是我们因为用的是ioc容器里面的bean，所以不能这样搞！</p></blockquote><p><strong>在ShopServiceImpl 中测试工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存穿透</span></span><br><span class="line">    <span class="comment">// Shop shop = cacheClient.queryWithPassThrough(RedisConstants.CACHE_SHOP_KEY, id, Shop.class,</span></span><br><span class="line">    <span class="comment">//         this::getById, RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥锁解决缓存击穿</span></span><br><span class="line">    <span class="comment">// Shop shop = cacheClient.queryWithMutex(RedisConstants.CACHE_SHOP_KEY,id,Shop.class,this::getById,RedisConstants.CACHE_SHOP_TTL,TimeUnit.MINUTES);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑过期解决缓存击穿</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient.queryWithLogicalExpire(RedisConstants.CACHE_SHOP_KEY,id,Shop.class,<span class="built_in">this</span>::getById,RedisConstants.CACHE_SHOP_TTL,TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、短信登录</title>
      <link href="/2024/04/05/Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC02%E7%AB%A0_%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95/"/>
      <url>/2024/04/05/Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC02%E7%AB%A0_%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1、导入黑马点评项目"><a href="#1-1、导入黑马点评项目" class="headerlink" title="1.1、导入黑马点评项目"></a>1.1、导入黑马点评项目</h2><h3 id="1-1-1-、导入SQL"><a href="#1-1-1-、导入SQL" class="headerlink" title="1.1.1 、导入SQL"></a>1.1.1 、导入SQL</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301745969.png" alt="1653057872536"></p><h3 id="1-1-2、有关当前模型"><a href="#1-1-2、有关当前模型" class="headerlink" title="1.1.2、有关当前模型"></a>1.1.2、有关当前模型</h3><p>手机或者app端发起请求，请求我们的nginx服务器，&#x3D;&#x3D;nginx&#x3D;&#x3D;基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也&#x3D;&#x3D;可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器&#x3D;&#x3D;，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。</p><p>在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会选择使用<strong>mysql集群</strong>，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用<strong>Redis集群</strong>使得Redis对外提供更好的服务。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301746942.png" alt="1653059409865"></p><h3 id="1-1-3、导入后端项目"><a href="#1-1-3、导入后端项目" class="headerlink" title="1.1.3、导入后端项目"></a>1.1.3、导入后端项目</h3><p>在资料中提供了一个项目源码：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301746489.png" alt="image-20221123234818386"></p><h3 id="1-1-4、导入前端工程"><a href="#1-1-4、导入前端工程" class="headerlink" title="1.1.4、导入前端工程"></a>1.1.4、导入前端工程</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301746760.png"></p><h3 id="1-1-5-运行前端项目"><a href="#1-1-5-运行前端项目" class="headerlink" title="1.1.5 运行前端项目"></a>1.1.5 运行前端项目</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301746471.png" alt="image-20221123235538872"></p><h2 id="1-2-、基于Session实现登录流程"><a href="#1-2-、基于Session实现登录流程" class="headerlink" title="1.2 、基于Session实现登录流程"></a>1.2 、基于Session实现登录流程</h2><p><strong>发送验证码：</strong></p><p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p><p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p><p><strong>短信验证码登录、注册：</strong></p><p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p><p><strong>校验登录状态:</strong></p><p>用户在请求时候，&#x3D;&#x3D;会从cookie中携带者JsessionId到后台&#x3D;&#x3D;，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p><blockquote><p><strong>补充：</strong>    <strong><font color=red>为什么要使用ThreadLocal？</font></strong><br>ThreadLoal是线程独享的，每个进入Tomcat的请求都对应着一个线程，将来ThreadLocal会在线程内开辟一片空间来保存用户信息，这些线程互不干扰.。这样的话，不同的用户访问相同的Controller都有自己的线程，也就会有自己的ThreadLocal信息，大家互不干扰。<br><strong>如何进行退出呢？</strong><br>在拦截器的最后一个方法中，清空thread local的信息，第一可以做到退出登录，第二可以防止内存泄露</p></blockquote><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301746407.png" alt="image-20221123235626516"></p><h2 id="1-3-、实现发送短信验证码功能"><a href="#1-3-、实现发送短信验证码功能" class="headerlink" title="1.3 、实现发送短信验证码功能"></a>1.3 、实现发送短信验证码功能</h2><p><strong>页面流程</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301746999.png" alt="1653067054461"></p><blockquote><p><strong><font color=red>问题：为啥后端接口是8081，但是请求确实8080呢？</font></strong></p><p>这里为了解决跨域问题请求位于8080的Nginx服务,Nginx的代理再去请求8081Tomcat服务器</p></blockquote><p><strong>具体代码如下</strong></p><p><strong>贴心小提示：</strong></p><p>具体逻辑上文已经分析，我们仅仅只需要按照提示的逻辑写出代码即可。</p><ul><li>发送验证码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.如果符合，生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.保存验证码到session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>+phone,code);</span><br><span class="line">    <span class="comment">// 5.发送验证码</span></span><br><span class="line">    String[] phoneNumber = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1</span>];</span><br><span class="line">    String[] templateParam = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line">    phoneNumber[<span class="number">0</span>] = phone;</span><br><span class="line">    templateParam[<span class="number">0</span>] = code;</span><br><span class="line">    templateParam[<span class="number">1</span>] = <span class="string">&quot;5&quot;</span>;</span><br><span class="line">    SendSmsUtil.sendSms(phoneNumber,templateParam);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>登录</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.验证手机号是否正确</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询手机号对应的验证码是否一致（存在）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;code&quot;</span> + loginForm.getPhone());</span><br><span class="line">    <span class="keyword">if</span>(cacheCode != <span class="literal">null</span> &amp;&amp; !cacheCode.equals(code))&#123;</span><br><span class="line">        <span class="comment">// 3.不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.一致，根据手机号查询对应的用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">    <span class="comment">// 5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 6.不存在，则创建新用户，并保存到数据库</span></span><br><span class="line">        user  = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7.存在，则保存用户到session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>&#x3D;&#x3D;这里是否需要返回登录成功的凭证信息呢？&#x3D;&#x3D;<br>不需要，因为登录或注册后会在session中存放user,一个session对应一个sessionID，sessionID会被自动放到Cookie，下次请求时，Cookie会带着JSessionID找到对应的session</p></blockquote><h2 id="1-4、实现登录拦截功能"><a href="#1-4、实现登录拦截功能" class="headerlink" title="1.4、实现登录拦截功能"></a>1.4、实现登录拦截功能</h2><p><strong>温馨小贴士：tomcat的运行原理</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301746255.png" alt="1653068196656"></p><p>当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应</p><p>通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p><p><strong>温馨小贴士：关于threadlocal</strong></p><p>如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是&#x3D;&#x3D;先从获得当前用户的线程，然后从线程中取出线程的成员变量map&#x3D;&#x3D;，只要线程不一样，map就不一样，所以可以通过这种方式来做到&#x3D;&#x3D;线程隔离&#x3D;&#x3D;</p><blockquote><p><strong><font color=red>为什么要使用拦截器呢？</font></strong></p><p>如图：如果没有拦截器，那么对于每个Controller都需要一个校验用户是否登录的逻辑代码，<strong>代码冗余较大</strong>。所有的请求到Controller之前可以被拦截器或者过滤器 拦截，这样的话只要我们在拦截器这一步进行校验就不用再进入Controller了，<strong>大大减少了性能损耗</strong>！</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301746615.png" alt="image-20221124003222322"></p></blockquote><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301746431.png" alt="1653068874258"></p><p>拦截器代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 登录拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/24 1:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在进入Controller之前会被执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">// 2.获取session中的用户</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.如果用户不存在，则拦截,返回401状态码</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.如果存在，则保存到ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser((User) user);</span><br><span class="line">        <span class="comment">// 5.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在执行完Controller里面的逻辑后执行下面代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让拦截器生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> MVC配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/24 1:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 增加登录拦截器，并对不必要的请求路径排除拦截</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>()).excludePathPatterns(</span><br><span class="line">                <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/voucher/**&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5、隐藏用户敏感信息"><a href="#1-5、隐藏用户敏感信息" class="headerlink" title="1.5、隐藏用户敏感信息"></a>1.5、隐藏用户敏感信息</h2><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p><p><strong>在登录方法处修改</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 7.存在，则保存用户到session</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, BeanUtil.copyProperties(user,UserDTO.class));</span><br></pre></td></tr></table></figure><p><strong>在拦截器处：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.如果存在，则保存到ThreadLocal</span></span><br><span class="line">UserHolder.saveUser((UserDTO) user);</span><br></pre></td></tr></table></figure><p><strong>在UserHolder处：将user对象换成UserDTO</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端登录结果：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301746216.png" alt="image-20221124230507123"></p><h2 id="1-6、session共享问题"><a href="#1-6、session共享问题" class="headerlink" title="1.6、session共享问题"></a>1.6、session共享问题</h2><p><strong>核心思路分析：</strong></p><p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是&#x3D;&#x3D;session拷贝&#x3D;&#x3D;，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p><p>但是这种方案具有两个大问题</p><p>1、每台服务器中都有完整的一份session数据，服务器压力过大。</p><p>2、session拷贝数据时，可能会出现延迟</p><p>所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301746807.png" alt="1653069893050"></p><h2 id="1-7-Redis代替session的业务流程"><a href="#1-7-Redis代替session的业务流程" class="headerlink" title="1.7 Redis代替session的业务流程"></a>1.7 Redis代替session的业务流程</h2><h3 id="1-7-1、设计key的结构"><a href="#1-7-1、设计key的结构" class="headerlink" title="1.7.1、设计key的结构"></a>1.7.1、设计key的结构</h3><p>首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图。</p><ul><li><p>如果使用String，注意他的value，会多占用一点空间（比如标点，括号等），而且字段修改，只能对Value整体修改，然后再设置进去</p></li><li><p>如果使用哈希，则他的value中只会存储数据本身，而且可以做到精确的修改Value中的某个字段（name,age）</p><p>如果不是特别在意内存，其实使用String就可以啦。</p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301746631.png" alt="1653319261433"></p><h3 id="1-7-2、设计key的具体细节"><a href="#1-7-2、设计key的具体细节" class="headerlink" title="1.7.2、设计key的具体细节"></a>1.7.2、设计key的具体细节</h3><p>所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session（因为是在ThreadLocal中的），但是redis的key是共享的，咱们就不能使用code了</p><p>在设计这个key的时候，我们之前讲过需要满足两点</p><p>1、key要具有唯一性</p><p>2、key要方便携带</p><p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适(信息容易泄露)，所以我们在后台生成一个&#x3D;&#x3D;随机串token&#x3D;&#x3D;，然后让前端带来这个token就能完成我们的整体逻辑了</p><h3 id="1-7-3、整体访问流程"><a href="#1-7-3、整体访问流程" class="headerlink" title="1.7.3、整体访问流程"></a>1.7.3、整体访问流程</h3><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301746208.png" alt="1653319474181"></p><p><strong><font color=red>session和Redis 验证用户登录原理的区别</font></strong></p><ul><li><p>之前我们使用session进行登录的时候，当把User存到session后，会自动把SessionID存到Cookie中，下次发送请求的时候会携带着。通过SessionId便可知道用户是否登录。</p></li><li><p>当我们使用Redis后，key &#x3D;&#x3D; 》token:随机字符串，value是User。这时 &#x3D;&#x3D;为了让用户下次发送请求携带着key&#x3D;&#x3D;,就需要前端特殊处理了~</p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301746581.png" alt="image-20221124235455820"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301746110.png" alt="image-20221125000104800"></p><h2 id="1-8-基于Redis实现短信登录"><a href="#1-8-基于Redis实现短信登录" class="headerlink" title="1.8 基于Redis实现短信登录"></a>1.8 基于Redis实现短信登录</h2><p>这里具体逻辑就不分析了，之前咱们已经重点分析过这个逻辑啦。</p><p><strong>UserServiceImpl代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.验证手机号是否正确</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询手机号对应的验证码是否一致（存在）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> (String) stringRedisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + phone);</span><br><span class="line">    <span class="keyword">if</span> (cacheCode != <span class="literal">null</span> &amp;&amp; !cacheCode.equals(code)) &#123;</span><br><span class="line">        <span class="comment">// 3.不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.一致，根据手机号查询对应的用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">    <span class="comment">// 5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.不存在，则创建新用户，并保存到数据库</span></span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.存在，则保存用户到Redis</span></span><br><span class="line">    <span class="comment">// 7.1 随机生成token,作为登录令牌   参数：生成一段没有连接符的随机数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 7.2 准备用户基本信息</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">    <span class="comment">//注意：这里如果直接这样写 BeanUtil.beanToMap(userDTO) 会报错: Long cannot be cast to String。</span></span><br><span class="line">    <span class="comment">//     因为我们使用的是stringRedisTemplate,里面存的map的key和value都必须是String.</span></span><br><span class="line">    <span class="comment">//解决办法：1.不使用该方法，而是手动把userDTO放入Map&lt;String,String&gt;，该转换的手动转</span></span><br><span class="line">    <span class="comment">//        2.自定义value的转换规则，可以通过 BeanUtil.beanToMap(obj,map,copyOptions)</span></span><br><span class="line">    Map &lt;String, Object&gt; map = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span> &lt;&gt;(), CopyOptions.create()</span><br><span class="line">                                                  .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                                                  .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">    <span class="comment">// 7.3 保存到Redis  （这里也可使用put（），但是Value中的key和value是分开放的，需要多次和数据库交互~）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(tokenKey, map);</span><br><span class="line">    <span class="comment">// 7.4 设置token有效期</span></span><br><span class="line">    stringRedisTemplate.expire(tokenKey, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.把token返回给前端</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LoginInterceptor代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 登录拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/24 1:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为LoginInterceptor是new 出来的，并没有交给Spring容器管理，所以我们不能使用Autowire或者<span class="doctag">@Resource</span>注入，</span></span><br><span class="line"><span class="comment">     * 这里可以使用构造函数，在使用到拦截器的时候，传入需要的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在进入Controller之前会被执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="comment">// 不存在</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.根据token获取用户信息</span></span><br><span class="line">        Map &lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY+token);</span><br><span class="line">        <span class="keyword">if</span>(userMap==<span class="literal">null</span>)&#123;</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.如果存在，则保存到ThreadLocal</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.刷新用户token的有效时间 (只要用户在这段时间内用户在线，那么就不会过期)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY+token;</span><br><span class="line">        stringRedisTemplate.expire(tokenKey,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在执行完Controller里面的逻辑后执行下面代码</span></span><br><span class="line"><span class="comment">     */</span>    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-9-解决状态登录刷新问题"><a href="#1-9-解决状态登录刷新问题" class="headerlink" title="1.9 解决状态登录刷新问题"></a>1.9 解决状态登录刷新问题</h2><h3 id="1-9-1-初始方案思路总结："><a href="#1-9-1-初始方案思路总结：" class="headerlink" title="1.9.1 初始方案思路总结："></a>1.9.1 初始方案思路总结：</h3><p>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径（比如首页），那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301747398.png" alt="1653320822964"></p><h3 id="1-9-2-优化方案"><a href="#1-9-2-优化方案" class="headerlink" title="1.9.2 优化方案"></a>1.9.2 优化方案</h3><p>既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以&#x3D;&#x3D;添加一个拦截器&#x3D;&#x3D;，在&#x3D;&#x3D;第一个拦截器中拦截所有的路径&#x3D;&#x3D;，把第二个拦截器做的事情放入到第一个拦截器中，同时&#x3D;&#x3D;刷新令牌&#x3D;&#x3D;（token）。因为第一个拦截器有了threadLocal的数据，所以此时&#x3D;&#x3D;第二个拦截器只需要判断拦截器中的user对象是否存在即可&#x3D;&#x3D;，完成整体拦截（这次拦截是对那些需要登录的资源）功能。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202211301747638.png" alt="1653320764547"></p><h3 id="1-9-3-代码"><a href="#1-9-3-代码" class="headerlink" title="1.9.3 代码"></a>1.9.3 代码</h3><p><strong>RefreshTokenInterceptor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 登录拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/24 1:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为RefreshTokenInterceptor是new 出来的，并没有交给Spring容器管理，所以我们不能使用Autowire或者<span class="doctag">@Resource</span>注入，</span></span><br><span class="line"><span class="comment">     * 这里可以使用构造函数，在使用到拦截器的时候，传入需要的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在进入Controller之前会被执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="comment">// 此处return true是对的，若return false，第一次访问登录页面时就会被拦截；</span></span><br><span class="line">            <span class="comment">// 若return true，第一次访问登录页会进入Login拦截器，由于登录页为放行路径，放行~</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.根据token获取用户信息</span></span><br><span class="line">        Map &lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY+token);</span><br><span class="line">        <span class="keyword">if</span>(userMap==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.如果存在，则保存到ThreadLocal</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.刷新用户token的有效时间 (只要用户在这段时间内用户在线，那么就不会过期)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY+token;</span><br><span class="line">        stringRedisTemplate.expire(tokenKey,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在执行完Controller里面的逻辑后执行下面代码</span></span><br><span class="line"><span class="comment">     */</span>    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LoginInterceptor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 登录拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/24 1:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在进入Controller之前会被执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 如果没有登录则拦截</span></span><br><span class="line">        <span class="keyword">if</span>(UserHolder.getUser()==<span class="literal">null</span>)&#123;</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用户已经登录则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;总结：Redis代替Session需要考虑的问题&#x3D;&#x3D;</p><ul><li>选择合适的数据结构<ul><li>比如为什么code选择用string，token选择用Hash</li></ul></li><li>选择合适的Key<ul><li>比如为什么验证码key是phone, token的key是一个随机字符串</li></ul></li><li>选择合适的存储力度<ul><li>比如我们存储的是UserDTO，相对于User把其中敏感的信息去掉，也可以节约内存空间</li></ul></li><li>选择合适的有效期</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零、带你走进Redis的世界 ⭐必看必看⭐</title>
      <link href="/2024/04/05/Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC01%E7%AB%A0_%E5%B8%A6%E4%BD%A0%E8%B5%B0%E8%BF%9BRedis%E7%9A%84%E4%B8%96%E7%95%8C/"/>
      <url>/2024/04/05/Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC01%E7%AB%A0_%E5%B8%A6%E4%BD%A0%E8%B5%B0%E8%BF%9BRedis%E7%9A%84%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="1-NoSQL数据库简介"><a href="#1-NoSQL数据库简介" class="headerlink" title="1. NoSQL数据库简介"></a>1. NoSQL数据库简介</h1><h2 id="1-1-技术发展"><a href="#1-1-技术发展" class="headerlink" title="1.1  技术发展"></a>1.1  技术发展</h2><p><font color=blue>技术的分类</font></p><p>1、解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</p><p>2、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis</p><p>3、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</p><h3 id="1-1-1-Web1-0时代"><a href="#1-1-1-Web1-0时代" class="headerlink" title="1.1.1.  Web1.0时代"></a>1.1.1.  Web1.0时代</h3><p>​Web1.0的时代，数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020035121.png" alt="image-20220127230749355"></p><h3 id="1-1-2-Web2-0时代"><a href="#1-1-2-Web2-0时代" class="headerlink" title="1.1.2  Web2.0时代"></a>1.1.2  Web2.0时代</h3><p>​随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。</p><p>​                                    <img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020035319.png" alt="image-20220127231010869"></p><h3 id="1-1-3-解决CPU及内存压力-采用分布式"><a href="#1-1-3-解决CPU及内存压力-采用分布式" class="headerlink" title="1.1.3.  解决CPU及内存压力(采用分布式)"></a>1.1.3.  解决CPU及内存压力(采用分布式)</h3><pre><code>    但是Session存在哪里?因为每次访问的服务器可能不是同一台.上次用户的数据保存在服务器1,用户是登录状态,下一次可能访问的服务器2,没有该用户的session,用户显示的未登录状态.</code></pre><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020035577.png" alt="image-20220127231230724"></p><h3 id="1-1-4-解决IO压力"><a href="#1-1-4-解决IO压力" class="headerlink" title="1.1.4.  解决IO压力"></a>1.1.4.  解决IO压力</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020035165.png" alt="image-20220127231339820"></p><h2 id="1-2-NoSQL数据库"><a href="#1-2-NoSQL数据库" class="headerlink" title="1.2.  NoSQL数据库"></a>1.2.  NoSQL数据库</h2><h3 id="1-2-1-NoSQL数据库概述"><a href="#1-2-1-NoSQL数据库概述" class="headerlink" title="1.2.1.  NoSQL数据库概述"></a>1.2.1.  NoSQL数据库概述</h3><p><strong>NoSQL</strong>(NoSQL &#x3D; Not Only SQL )，意即“不仅仅是SQL”，泛指&#x3D;&#x3D;<strong>非关系型的数据库</strong>&#x3D;&#x3D;。 </p><p><font color=red>NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</font></p><ul><li><p>不遵循SQL标准。</p></li><li><p>不支持ACID。</p></li><li><p>远超于SQL的性能。</p></li></ul><h3 id="1-2-2-NoSQL适用场景"><a href="#1-2-2-NoSQL适用场景" class="headerlink" title="1.2.2  NoSQL适用场景"></a>1.2.2  NoSQL适用场景</h3><ul><li><p>对数据高并发的读写</p></li><li><p>海量数据的读写</p></li><li><p>对数据高可扩展性的</p></li></ul><h3 id="1-2-3-NoSQL不适用场景"><a href="#1-2-3-NoSQL不适用场景" class="headerlink" title="1.2.3  NoSQL不适用场景"></a>1.2.3  NoSQL不适用场景</h3><ul><li><p>需要事务支持</p></li><li><p>基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</p></li><li><p><font color=red>（用不着 sql 的和用了 sql 也不行的情况，请考虑用 NoSql）</font></p></li></ul><h3 id="1-2-4-Memcache"><a href="#1-2-4-Memcache" class="headerlink" title="1.2.4 Memcache"></a>1.2.4 Memcache</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020035703.png" alt="image-20220127232722449"></p><h3 id="1-2-5-Redis"><a href="#1-2-5-Redis" class="headerlink" title="1.2.5 Redis"></a>1.2.5 Redis</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020035489.png" alt="image-20220127232802506"></p><h3 id="1-2-6-MongoDB"><a href="#1-2-6-MongoDB" class="headerlink" title="1.2.6. MongoDB"></a>1.2.6. MongoDB</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020035726.png" alt="image-20220127232953050"></p><h2 id="1-3-行式存储数据库（大数据时代）"><a href="#1-3-行式存储数据库（大数据时代）" class="headerlink" title="1.3. 行式存储数据库（大数据时代）"></a>1.3. 行式存储数据库（大数据时代）</h2><h3 id="1-3-1-行式数据库"><a href="#1-3-1-行式数据库" class="headerlink" title="1.3.1. 行式数据库"></a>1.3.1. 行式数据库</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020035879.png" alt="image-20220127233719653"></p><h3 id="1-3-2-列式数据库"><a href="#1-3-2-列式数据库" class="headerlink" title="1.3.2. 列式数据库"></a>1.3.2. 列式数据库</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020035423.png" alt="image-20220127233756939"></p><h2 id="1-4-图关系型数据库"><a href="#1-4-图关系型数据库" class="headerlink" title="1.4. 图关系型数据库"></a>1.4. 图关系型数据库</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020043512.png" alt="image-20220127233900089"></p><p>主要应用：社会关系，公共交通网络，地图及网络拓谱(n*(n-1)&#x2F;2)</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020035305.png" alt="image-20220127233919283"></p><h2 id="1-5-DB-Engines-数据库排名"><a href="#1-5-DB-Engines-数据库排名" class="headerlink" title="1.5. DB-Engines 数据库排名"></a>1.5. DB-Engines 数据库排名</h2><p><a href="http://db-engines.com/en/ranking">http://db-engines.com/en/ranking</a></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020035877.png" alt="image-20220127234052885"></p><h1 id="2-Redis-概述安装"><a href="#2-Redis-概述安装" class="headerlink" title="2. Redis 概述安装"></a>2. Redis 概述安装</h1><p>➢ Redis 是一个开源的 &#x3D;&#x3D;key-value 存储系统&#x3D;&#x3D;。 </p><p>➢ 和 Memcached 类似，它支持存储的 value 类型相对更多，包括 &#x3D;&#x3D;string(字符串)、 list(链表)、set(集合)、zset(sorted set –有序集合)和 hash（哈希类型）&#x3D;&#x3D;。</p><p> ➢ 这些数据类型都支持 push&#x2F;pop、add&#x2F;remove 及取交集并集和差集及更丰富的操作， 而且这些操作都是原子性的。 </p><p>➢ 在此基础上，Redis 支持各种不同方式的排序。 </p><p>➢ 与 memcached 一样，为了保证效率，&#x3D;&#x3D;数据都是缓存在内存中&#x3D;&#x3D;。 </p><p>➢ 区别的是 Redis 会&#x3D;&#x3D;周期性的把更新的数据写入磁盘&#x3D;&#x3D;或者把修改操作&#x3D;&#x3D;写入追加的记 录文件&#x3D;&#x3D;。 </p><p>➢ 并且在此基础上实现了 &#x3D;&#x3D;master-slave(主从)同步&#x3D;&#x3D;。</p><h2 id="2-1-应用场景"><a href="#2-1-应用场景" class="headerlink" title="2.1. 应用场景"></a>2.1. 应用场景</h2><h3 id="2-1-1-配合关系型数据库做高速缓存"><a href="#2-1-1-配合关系型数据库做高速缓存" class="headerlink" title="2.1.1. 配合关系型数据库做高速缓存"></a>2.1.1. 配合关系型数据库做高速缓存</h3><p>➢ 高频次，热门访问的数据，降低数据库 IO </p><p>➢ 分布式架构，做 session 共享</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020035920.png" alt="image-20220130164924992"></p><h3 id="2-1-2-多样的数据结构存储持久化数据"><a href="#2-1-2-多样的数据结构存储持久化数据" class="headerlink" title="2.1.2. 多样的数据结构存储持久化数据"></a>2.1.2. 多样的数据结构存储持久化数据</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036894.png" alt="image-20220130165019016"></p><h2 id="2-2-Redis-安装"><a href="#2-2-Redis-安装" class="headerlink" title="2.2. Redis 安装"></a>2.2. Redis 安装</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036223.png" alt="image-20220130165138807"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036750.png" alt="image-20220130165209747"></p><h3 id="2-2-1-安装版本"><a href="#2-2-1-安装版本" class="headerlink" title="2.2.1. 安装版本"></a>2.2.1. 安装版本</h3><p>➢ 6.2.1 for Linux（&#x3D;&#x3D;redis-6.2.1.tar.gz&#x3D;&#x3D;） </p><p>➢ 不用考虑在 windows 环境下对 Redis 的支持</p><h3 id="2-2-2-安装步骤"><a href="#2-2-2-安装步骤" class="headerlink" title="2.2.2. 安装步骤"></a>2.2.2. 安装步骤</h3><h4 id="2-2-2-1-准备工作：下载安装最新版的-gcc-编译器-安装-C-语言的编译环境"><a href="#2-2-2-1-准备工作：下载安装最新版的-gcc-编译器-安装-C-语言的编译环境" class="headerlink" title="2.2.2.1. 准备工作：下载安装最新版的 gcc 编译器  安装 C 语言的编译环境"></a>2.2.2.1. 准备工作：下载安装最新版的 gcc 编译器  安装 C 语言的编译环境</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build </span><br><span class="line">yum install -y devtoolset-8-toolchain </span><br><span class="line">scl enable devtoolset-8 bash </span><br></pre></td></tr></table></figure><p>测试 gcc 版本</p><p><strong>gcc –version</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036159.png" alt="image-20220130170103407"></p><h4 id="2-2-2-2-下载-redis-6-2-1-tar-gz-放-opt-目录"><a href="#2-2-2-2-下载-redis-6-2-1-tar-gz-放-opt-目录" class="headerlink" title="2.2.2.2. 下载 redis-6.2.1.tar.gz 放&#x2F;opt 目录"></a>2.2.2.2. 下载 redis-6.2.1.tar.gz 放&#x2F;opt 目录</h4><h4 id="2-2-2-3-解压命令：tar-zxvf-redis-6-2-1-tar-gz"><a href="#2-2-2-3-解压命令：tar-zxvf-redis-6-2-1-tar-gz" class="headerlink" title="2.2.2.3. 解压命令：tar -zxvf redis-6.2.1.tar.gz"></a>2.2.2.3. 解压命令：tar -zxvf redis-6.2.1.tar.gz</h4><h4 id="2-2-2-4-解压完成后进入目录：cd-redis-6-2-1"><a href="#2-2-2-4-解压完成后进入目录：cd-redis-6-2-1" class="headerlink" title="2.2.2.4. 解压完成后进入目录：cd redis-6.2.1"></a>2.2.2.4. 解压完成后进入目录：cd redis-6.2.1</h4><h4 id="2-2-2-5-在-redis-6-2-1-目录下再次执行-make-命令（只-是编译好）"><a href="#2-2-2-5-在-redis-6-2-1-目录下再次执行-make-命令（只-是编译好）" class="headerlink" title="2.2.2.5. 在 redis-6.2.1 目录下再次执行 make 命令（只 是编译好）"></a>2.2.2.5. 在 redis-6.2.1 目录下再次执行 make 命令（只 是编译好）</h4><h4 id="2-2-2-6-如果没有准备好-C-语言编译环境，make-会报错-—Jemalloc-jemalloc-h：没有那个文件"><a href="#2-2-2-6-如果没有准备好-C-语言编译环境，make-会报错-—Jemalloc-jemalloc-h：没有那个文件" class="headerlink" title="2.2.2.6. 如果没有准备好 C 语言编译环境，make 会报错 —Jemalloc&#x2F;jemalloc.h：没有那个文件"></a>2.2.2.6. 如果没有准备好 C 语言编译环境，make 会报错 —Jemalloc&#x2F;jemalloc.h：没有那个文件</h4><p> 解决方案：先安装gcc,之后运行 <strong>make distclean</strong> </p><h4 id="2-2-2-8-在-redis-6-2-1-目录下再次执行-make-命令（只-是编译好）"><a href="#2-2-2-8-在-redis-6-2-1-目录下再次执行-make-命令（只-是编译好）" class="headerlink" title="2.2.2.8. 在 redis-6.2.1 目录下再次执行 make 命令（只 是编译好）"></a>2.2.2.8. 在 redis-6.2.1 目录下再次执行 make 命令（只 是编译好）</h4><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036719.png" alt="image-20220130165912341"></p><h4 id="2-2-2-9-跳过-make-test-继续执行-make-install"><a href="#2-2-2-9-跳过-make-test-继续执行-make-install" class="headerlink" title="2.2.2.9. 跳过 make test 继续执行: make install"></a>2.2.2.9. 跳过 make test 继续执行: make install</h4><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020044200.png" alt="image-20220130165934887"></p><h3 id="2-2-3-安装目录：-usr-local-bin"><a href="#2-2-3-安装目录：-usr-local-bin" class="headerlink" title="2.2.3. 安装目录：&#x2F;usr&#x2F;local&#x2F;bin"></a>2.2.3. 安装目录：&#x2F;usr&#x2F;local&#x2F;bin</h3><p>查看默认安装目录： </p><ul><li><p>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何 </p></li><li><p>redis-check-aof：修复有问题的 AOF 文件，rdb 和 aof 后面讲 </p></li><li><p>redis-check-dump：修复有问题的 dump.rdb 文件 </p></li><li><p>redis-sentinel：<strong>Redis 集群使用</strong> </p></li><li><p>redis-server：Redis 服务器启动命令</p></li><li><p>redis-cli：<strong>客户端，操作入口</strong></p></li></ul><h3 id="2-2-4-前台启动（不推荐）"><a href="#2-2-4-前台启动（不推荐）" class="headerlink" title="2.2.4. 前台启动（不推荐）"></a>2.2.4. 前台启动（不推荐）</h3><p>前台启动，命令行窗口不能关闭，否则服务器停止</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036078.png" alt="image-20220130170604162"></p><h3 id="2-2-5-后台启动（推荐）"><a href="#2-2-5-后台启动（推荐）" class="headerlink" title="2.2.5. 后台启动（推荐）"></a>2.2.5. 后台启动（推荐）</h3><h4 id="2-2-5-1-备份-redis-conf"><a href="#2-2-5-1-备份-redis-conf" class="headerlink" title="2.2.5.1.备份 redis.conf"></a>2.2.5.1.备份 redis.conf</h4><p>拷贝一份 redis.conf 到其他目录,防止后期把文件修改坏无法恢复.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/module/redis-6.2.6/redis.conf /etc/redis.conf</span><br></pre></td></tr></table></figure><h4 id="2-2-5-2-后台启动设置-daemonize-no-改成-yes"><a href="#2-2-5-2-后台启动设置-daemonize-no-改成-yes" class="headerlink" title="2.2.5.2.后台启动设置 &#x3D;&#x3D;daemonize no 改成 yes&#x3D;&#x3D;"></a>2.2.5.2.后台启动设置 &#x3D;&#x3D;daemonize no 改成 yes&#x3D;&#x3D;</h4><p>修改 redis.conf(257 行)文件将里面的 daemonize no 改成 yes，让服务在后台启动</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036350.png" alt="image-20220130171051853"></p><h4 id="2-2-5-3-Redis-启动"><a href="#2-2-5-3-Redis-启动" class="headerlink" title="2.2.5.3.Redis 启动"></a>2.2.5.3.Redis 启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><h4 id="2-2-5-4-用客户端访问：redis-cli"><a href="#2-2-5-4-用客户端访问：redis-cli" class="headerlink" title="2.2.5.4.用客户端访问：redis-cli"></a>2.2.5.4.用客户端访问：redis-cli</h4><h4 id="2-2-5-5-多个端口可以：redis-cli-p6379"><a href="#2-2-5-5-多个端口可以：redis-cli-p6379" class="headerlink" title="2.2.5.5.多个端口可以：redis-cli -p6379"></a>2.2.5.5.多个端口可以：redis-cli -p6379</h4><h4 id="2-2-5-6-测试验证：-ping"><a href="#2-2-5-6-测试验证：-ping" class="headerlink" title="2.2.5.6.测试验证： ping"></a>2.2.5.6.测试验证： ping</h4><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036830.png" alt="image-20220130171216335"></p><h4 id="2-2-5-7-Redis-关闭"><a href="#2-2-5-7-Redis-关闭" class="headerlink" title="2.2.5.7.Redis 关闭"></a>2.2.5.7.Redis 关闭</h4><p><font color=red>shutdown+quit</font></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036847.png" alt="image-20220130171304170"></p><p><font color=red>exit+kill</font></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036910.png" alt="image-20220130171340864"></p><h3 id="2-2-6-Redis-介绍相关知识"><a href="#2-2-6-Redis-介绍相关知识" class="headerlink" title="2.2.6. Redis 介绍相关知识"></a>2.2.6. Redis 介绍相关知识</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036919.png" alt="image-20220130171416048"></p><p>Redis 是**<font color=red>单线程+多路 IO 复用技术 </font>**</p><p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用 select 和 poll 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则 阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启 动线程执行（比如使用线程池）</p><p>&#x3D;&#x3D;串行 vs 多线程+锁（memcached） vs 单线程+多路 IO 复用(Redis)&#x3D;&#x3D;</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036606.png" alt="image-20220130171454534"></p><h1 id="3-常用五大数据类型"><a href="#3-常用五大数据类型" class="headerlink" title="3. 常用五大数据类型"></a>3. 常用五大数据类型</h1><p>哪里去获得 redis 常见数据类型操作命令  <a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p><h2 id="3-1-Redis-键-key"><a href="#3-1-Redis-键-key" class="headerlink" title="3.1. Redis 键(key)"></a>3.1. Redis 键(key)</h2><ul><li><p>**keys *** 查看当前库所有 key (匹配：keys *1)</p></li><li><p><strong>exists key</strong> 判断某个 key 是否存在 </p></li><li><p><strong>type key</strong> 查看你的 key 是什么类型 </p></li><li><p><strong>del key</strong> 删除指定的 key 数据</p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036455.png" alt="image-20220130172127695"></p><ul><li>&#x3D;&#x3D;unlink key 根据 value 选择非阻塞删除&#x3D;&#x3D;</li></ul><p>仅将 keys 从 keyspace 元数据中删除，真正的删除会在后续异步操作。</p><ul><li><p><strong>expire key 10</strong> 10 秒钟：为给定的 key 设置过期时间</p></li><li><p><strong>ttl key</strong> 查看还有多少秒过期，-1 表示永不过期，-2 表示已过期</p></li><li><p><strong>select</strong> 命令切换数据库</p></li><li><p><strong>dbsize</strong> 查看当前数据库的 key 的数量</p></li><li><p><strong>flushdb</strong> 清空当前库 </p></li><li><p><strong>flushall</strong> 通杀全部库</p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036813.png" alt="image-20220130172423322"></p><h2 id="3-2-Redis-字符串-String"><a href="#3-2-Redis-字符串-String" class="headerlink" title="3.2. Redis 字符串(String)"></a>3.2. Redis 字符串(String)</h2><h3 id="3-2-1-简介"><a href="#3-2-1-简介" class="headerlink" title="3.2.1. 简介"></a>3.2.1. 简介</h3><ul><li>&#x3D;&#x3D;String 是 Redis 最基本的类型&#x3D;&#x3D;，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</li><li>&#x3D;&#x3D;String 类型是二进制安全的&#x3D;&#x3D;。意味着 Redis 的 string 可以包含任何数据。比如 jpg 图片 或者序列化的对象。</li><li>String 类型是 Redis 最基本的数据类型，&#x3D;&#x3D;一个 Redis 中字符串 value 最多可以是 512M&#x3D;&#x3D;</li></ul><h3 id="3-2-2-常用命令"><a href="#3-2-2-常用命令" class="headerlink" title="3.2.2. 常用命令"></a>3.2.2. 常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set &lt;key&gt; &lt;value&gt; #添加键值对</span><br></pre></td></tr></table></figure><p>注意: 当数据库中 key 不存在时，可以将 key-value 添加数据,如果存在时，新value将覆盖旧value.</p><ul><li><p><strong>get</strong>  <key> 查询对应键值</p></li><li><p><strong>append</strong> <key> <value> 将给定的<value> 追加到原值的末尾</p></li><li><p><strong>strlen</strong> <key>获得值的长度</p></li><li><p><strong>setnx <key> <value></strong> 只有在 key 不存在时  设置 key 的值</p></li><li><p><strong>incr</strong> <key></p><p>将 key 中储存的数字值增1</p><p>只能对数字值操作，如果为空，新增值为1</p></li><li><p><strong>decr</strong> <key></p><p>将 key 中储存的数字值减1</p><p>只能对数字值操作，如果为空，新增值为-1</p></li><li><p><strong>incrby &#x2F; decrby</strong> <key>&lt;步长&gt; 将 key 中储存的数字值增减。自定义步长。</p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036638.png" alt="image-20220130173641841"></p><ul><li><p><strong>mset</strong> <key1><value1><key2><value2> ….. </p><p>同时设置一个或多个 key-value对 </p></li><li><p><strong>mget</strong> <key1><key2><key3> …..</p><p>同时获取一个或多个 value </p></li><li><p><strong>msetnx</strong> <key1><value1><key2><value2> ….. </p><p>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</p></li></ul><p><font color=red><strong>原子性，有一个失败则都失败</strong></font></p><ul><li><p><strong>getrange</strong> <key>&lt;起始位置&gt;&lt;结束位置&gt;</p><p>获得值的范围，类似java中的substring，<strong>前包，后包</strong></p></li><li><p><strong>setrange</strong> <key>&lt;起始位置&gt;<value></p><p>用 <value> 覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始(<strong>索引从0****开始</strong>)。</p></li><li><p><strong>setex <key>&lt;****过期时间****&gt;<value></strong></p><p>设置键值的同时，设置过期时间，单位秒。</p></li><li><p><strong>getset</strong> <key><value></p><p>以新换旧，设置了新值同时获得旧值。</p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036591.png" alt="image-20220130174027591"></p><h3 id="3-2-3-数据结构"><a href="#3-2-3-数据结构" class="headerlink" title="3.2.3. 数据结构"></a>3.2.3. 数据结构</h3><p>String的数据结构为&#x3D;&#x3D;简单动态字符串&#x3D;&#x3D;(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用&#x3D;&#x3D;预分配冗余空间&#x3D;&#x3D;的方式来减少内存的频繁分配.</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020044463.png" alt="image-20220130174207172"></p><p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p><h2 id="3-3-Redis-列表-List"><a href="#3-3-Redis-列表-List" class="headerlink" title="3.3. Redis 列表(List)"></a>3.3. Redis 列表(List)</h2><h3 id="3-3-1-简介"><a href="#3-3-1-简介" class="headerlink" title="3.3.1. 简介"></a>3.3.1. 简介</h3><p><strong><font color=red>单键多值</font></strong></p><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>它的底层实际是个&#x3D;&#x3D;双向链表&#x3D;&#x3D;，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036957.png" alt="image-20220130174353132"></p><h3 id="3-3-2-常用命令"><a href="#3-3-2-常用命令" class="headerlink" title="3.3.2. 常用命令"></a>3.3.2. 常用命令</h3><ul><li><p>&#x3D;&#x3D;<strong>lpush&#x2F;rpush</strong>&#x3D;&#x3D; <key><value1><value2><value3> …. 从左边&#x2F;右边插入一个或多个值。</p></li><li><p>&#x3D;&#x3D;<strong>lpop&#x2F;rpop</strong>&#x3D;&#x3D; <key>从左边&#x2F;右边吐出一个值。值在键在，值光键亡。</p></li><li><p><strong>rpop&#x2F;lpush</strong> <key1><key2>从<key1>列表右边吐出一个值，插到<key2>列表左边。</p></li><li><p><strong>lrange</strong> <key><start><stop> 按照索引下标获得元素(从左到右)</p></li><li><p>&#x3D;&#x3D;<strong>lrange mylist 0 -1</strong>&#x3D;&#x3D;  0左边第一个，<font color=red>-1右边第一个，（0-1表示获取所有）</font></p></li><li><p><strong>lindex</strong> <key><index>按照索引下标获得元素(从左到右)</p></li><li><p><strong>llen</strong> <key> 获得列表长度 </p></li><li><p><strong>linsert <key> before</strong> <value><newvalue>在<value>的后面插入<newvalue>插入值</p></li><li><p><strong>lrem <key><n><value></strong> 从左边删除n个value(从左到右)</p></li><li><p><strong>lset</strong><key><index><value>将列表key下标为index的值替换成value</p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036311.png" alt="image-20220130175139456"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020046384.png" alt="image-20220130201405991"></p><h3 id="3-2-3-数据结构-1"><a href="#3-2-3-数据结构-1" class="headerlink" title="3.2.3 数据结构"></a>3.2.3 数据结构</h3><p>List 的数据结构为&#x3D;&#x3D;快速链表 quickList&#x3D;&#x3D;。</p><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是 压缩列表。 </p><p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。 当数据量比较多的时候才会改成 quicklist。 因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只 是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020036175.png" alt="image-20220210214301430"></p><p>Redis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指 针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h3 id="3-2-4-补充：原子性"><a href="#3-2-4-补充：原子性" class="headerlink" title="3.2.4 补充：原子性"></a>3.2.4 补充：原子性</h3><p><font color=red>所谓原子操作是指不会被线程调度机制打断的操作</font> ；<br>这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另<br>一个线程）。<br>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中<br>断只能发生于指令之间。<br>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。<br>Redis 单命令的原子性主要得益于 Redis的单线程。</p><p>案例：<br>java 中的 i++是否是原子操作？不是<br>i&#x3D;0;两个线程分别对 i进行++100次,值是多少？ </p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020037909.png" alt="image-20220210223238563"></p><h2 id="3-4-Redis-集合-Set"><a href="#3-4-Redis-集合-Set" class="headerlink" title="3.4. Redis 集合(Set)"></a>3.4. Redis 集合(Set)</h2><h3 id="3-4-1-简介"><a href="#3-4-1-简介" class="headerlink" title="3.4.1. 简介"></a>3.4.1. 简介</h3><p>Redis set 对外提供的功能与 list 类似是一个列表的功能，特殊之处在于 set 是可以<font color=red>自动排重</font>的，当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选 择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。</p><p>Redis 的 Set 是 &#x3D;&#x3D;string 类型的无序集合&#x3D;&#x3D;。它底层其实是一个 value 为 null 的 &#x3D;&#x3D;hash 表&#x3D;&#x3D;，所 以添加，删除，查找的复杂度都是 O(1)。</p><p>一个算法，随着数据的增加，执行时间的长短，如果是 O(1)，数据增加，查找数据的 时间不变</p><h3 id="3-4-2-常用命令"><a href="#3-4-2-常用命令" class="headerlink" title="3.4.2. 常用命令"></a>3.4.2. 常用命令</h3><ul><li><p><strong>sadd  <key><value1><value2> …..</strong> 将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</p></li><li><p><strong>smembers</strong> 取出该集合的所有值</p></li><li><p><strong>sismember<key><value></strong> 判断集合是否为含有该值，有 1，没有 0</p></li><li><p><strong>scard <key></strong> 返回该集合的元素个数。</p></li><li><p><strong>srem  <key><value1><value2> …</strong> 删除集合中的某个元素。 </p></li><li><p>**spop <key>**随机从该集合中吐出一个值。</p></li><li><p>**srandmember <key><n>**随机从该集合中取出 n 个值。不会从集合中删除 。</p></li><li><p><strong>move <source><destination>value</strong> 把集合中一个值从一个集合移动到另一个集合</p></li><li><p>**sinter <key1><key2>**返回两个集合的&#x3D;&#x3D;交集&#x3D;&#x3D;元素。</p></li><li><p>**sunion <key1><key2>**返回两个集合的&#x3D;&#x3D;并集&#x3D;&#x3D;元素。</p></li><li><p>**sdiff <key1><key2>**返回两个集合的&#x3D;&#x3D;差集&#x3D;&#x3D;元素(key1 中的，不包含 key2中的)</p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020037224.png" alt="image-20220210215939742"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020037551.png" alt="image-20220210220038515"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020037926.png" alt="image-20220210220053731"></p><h3 id="3-4-3-数据结构"><a href="#3-4-3-数据结构" class="headerlink" title="3.4.3. 数据结构"></a>3.4.3. 数据结构</h3><p>Set 数据结构是 &#x3D;&#x3D;dict字典&#x3D;&#x3D;，字典是用&#x3D;&#x3D;哈希表&#x3D;&#x3D;实现的。<br>Java 中 HashSet 的内部实现使用的是 HashMap，只不过所有的 value 都指向同一个对象。<br>Redis的 set结构也是一样，它的内部也使用 hash结构，所有的 value都指向同一个内部值。</p><h2 id="3-5-Redis-哈希-Hash"><a href="#3-5-Redis-哈希-Hash" class="headerlink" title="3.5. Redis 哈希(Hash)"></a>3.5. Redis 哈希(Hash)</h2><h3 id="3-5-1-简介"><a href="#3-5-1-简介" class="headerlink" title="3.5.1. 简介"></a>3.5.1. 简介</h3><p>Redis hash 是一个键值对集合。<br>Redis hash 是一个 &#x3D;&#x3D;string 类型的 field 和 value 的映射表&#x3D;&#x3D;，hash 特别适合用于存储对象。<br>类似 Java 里面的 Map&lt;String,Object&gt;<br>用户 ID 为查找的 key，存储的 value用户对象包含姓名，年龄，生日等信息，如果用<br>普通的 key&#x2F;value结构来存储<br><strong>主要有以下 3 种存储方式：</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020037072.png" alt="image-20220210220339056"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020037639.png" alt="image-20220210220359629"></p><h3 id="3-5-2-常用命令"><a href="#3-5-2-常用命令" class="headerlink" title="3.5.2. 常用命令"></a>3.5.2. 常用命令</h3><ul><li><strong>hset <key><field><value>:</strong> 给<key>集合中的 <field>键赋值<value></li><li>**hget <key1><field>: **从<key1>集合<field>取出 value</li><li>**hmset <key1><field1><value1><field2><value2>… : ** 批量设置 hash 的值</li><li>**hexists<key1><field>: **查看哈希表 key 中，给定域 field 是否存在。</li><li>**hkeys <key>: **列出该 hash 集合的所有 field</li><li>**hvals <key>: **列出该 hash 集合的所有 value</li><li>**hincrby <key><field><increment>: **为哈希表 key 中的域 field 的值加上增量 1 -1</li><li>**hsetnx <key><field><value>: **将哈希表 key 中的域 field 的值设置为 value ，当且仅当域<br>field 不存在</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020037710.png" alt="image-20220210220723448"></p><h3 id="3-5-3-数据结构"><a href="#3-5-3-数据结构" class="headerlink" title="3.5.3. 数据结构"></a>3.5.3. 数据结构</h3><p>Hash 类型对应的数据结构是两种：&#x3D;&#x3D;ziplist（压缩列表），hashtable（哈希表）&#x3D;&#x3D;。当field-value 长度较短且个数较少时，使用 ziplist，否则使用 hashtable。</p><h2 id="3-6-Redis-有序集合-Zset-sorted-set"><a href="#3-6-Redis-有序集合-Zset-sorted-set" class="headerlink" title="3.6. Redis 有序集合 Zset(sorted set)"></a>3.6. Redis 有序集合 Zset(sorted set)</h2><h3 id="3-6-1-简介"><a href="#3-6-1-简介" class="headerlink" title="3.6.1. 简介"></a>3.6.1. 简介</h3><p>Redis 有序集合 zset与普通集合 set 非常相似，是一个&#x3D;&#x3D;没有重复元素的字符串集合&#x3D;&#x3D;。<br>不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。<font color=red>集合的成员是唯一的，但是评分可以是重复了</font> 。<br>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。<br>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><h3 id="3-6-2-常用命令"><a href="#3-6-2-常用命令" class="headerlink" title="3.6.2. 常用命令"></a>3.6.2. 常用命令</h3><ul><li><strong>zadd <key><score1><value1><score2><value2>… :</strong> 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</li><li><strong>zrange <key><start><stop> [WITHSCORES]:</strong> 返回有序集 key 中下标在<start><stop>之间的元素 . 带 WITHSCORES，可以让分数一起和值返回到结果集。</li><li>**zrangebyscore key minmax [withscores] [limit offset count]:**返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。 &#x3D;&#x3D;有序集成员按 score 值递增(从小到大)次序排列&#x3D;&#x3D;。</li><li><strong>zrevrangebyscore key maxmin [withscores] [limit offset count]:</strong> 同上，改为从大到小排列。</li><li><strong>zincrby <key><increment><value>:</strong> 为元素的 score加上增量</li><li><strong>zrem <key><value>:</strong> 删除该集合下，指定值的元素</li><li><strong>zcount <key><min><max>:</strong> 统计该集合，分数区间内的元素个数</li><li><strong>zrank <key><value>:</strong> 返回该值在集合中的排名，从 0 开始。</li></ul><p>案例：<font color=red>如何利用 zset 实现一个文章访问量的排行榜？</font></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020037958.png" alt="image-20220210221727819"></p><h3 id="3-6-3-数据结构"><a href="#3-6-3-数据结构" class="headerlink" title="3.6.3. 数据结构"></a>3.6.3. 数据结构</h3><p>SortedSet(zset)是 Redis 提供的一个非常特别的数据结构，一方面它<font color=red>等价于 Java的数据结构 Map&lt;String, Double&gt;</font>，可以给每一个元素 value 赋予一个权重 score，另一方面它又<font color=red>类似于 TreeSet</font>，<strong>内部的元素会按照权重 score 进行排序，可以得到每个元素的名次，还可以通过 score 的范围来获取元素的列表。</strong></p><p><strong>zset 底层使用了两个数据结构:</strong><br>（1）hash，hash 的作用就是关联元素 value 和权重 score，保障元素 &#x3D;&#x3D;value 的唯一性&#x3D;&#x3D;，可以通过元素 value 找到相应的 score 值。<br>（2）跳跃表，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表。</p><h3 id="3-6-4-跳跃表（跳表）"><a href="#3-6-4-跳跃表（跳表）" class="headerlink" title="3.6.4. 跳跃表（跳表）"></a>3.6.4. 跳跃表（跳表）</h3><p><font color=blue>1、简介</font><br>有序集合在生活中比较常见，例如&#x3D;&#x3D;根据成绩对学生排名，根据得分对玩家排名等&#x3D;&#x3D;。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p><p><font color=blue>2、实例</font><br>对比有序链表和跳跃表，从链表中查询出 51</p><p>（1） 有序链表</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020037399.png" alt="image-20220210222530470"></p><p>（2） 跳跃表</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020037294.png" alt="image-20220210222735699"></p><p>从此可以看出&#x3D;&#x3D;跳跃表比有序链表效率要高&#x3D;&#x3D;</p><p><a href="https://www.aliyundrive.com/s/ebUnLzhokVr">https://www.aliyundrive.com/s/ebUnLzhokVr</a></p><h1 id="4-Redis-Redis-配置文件介绍"><a href="#4-Redis-Redis-配置文件介绍" class="headerlink" title="4. Redis Redis 配置文件介绍"></a>4. Redis Redis 配置文件介绍</h1><p>自定义目录：<code>/etc/redis.conf</code></p><h2 id="4-1-Units-单位"><a href="#4-1-Units-单位" class="headerlink" title="4.1. ###Units 单位###"></a>4.1. ###Units 单位###</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020037567.png" alt="image-20220214234408885"></p><h2 id="4-2-INCLUDES-包含"><a href="#4-2-INCLUDES-包含" class="headerlink" title="4.2. ###INCLUDES 包含###"></a>4.2. ###INCLUDES 包含###</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020037584.png" alt="image-20220214234519712"></p><p>类似 jsp 中的 include，多实例的情况可以把公用的配置文件提取出来</p><h2 id="4-3-网络相关配置"><a href="#4-3-网络相关配置" class="headerlink" title="4.3. ### 网络相关配置"></a>4.3. ### 网络相关配置</h2><h3 id="4-3-1-bind"><a href="#4-3-1-bind" class="headerlink" title="4.3.1. bind"></a>4.3.1. bind</h3><p>默认情况 <strong>bind&#x3D;127.0.0.1</strong> 只能接受本机的访问请求. 不写的情况下，无限制接受任何 ip 地址的访问<br>生产环境肯定要写你应用服务器的地址；<strong>服务器是需要远程访问的，所以需要将其注释掉</strong></p><p><strong><font color=red>如果开启了 protected-mode，那么在没有设定 bind ip且没有设密码的情况下，Redis<br>只允许接受本机的响应</font></strong>(后续将对其进行关闭)</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020037102.png" alt="image-20220216215546907"></p><h3 id="4-3-2-protected-mode"><a href="#4-3-2-protected-mode" class="headerlink" title="4.3.2. protected- -mode"></a>4.3.2. protected- -mode</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020037550.png" alt="image-20220216220224864"></p><h3 id="4-3-3-Port"><a href="#4-3-3-Port" class="headerlink" title="4.3.3. Port"></a>4.3.3. Port</h3><p>端口号，默认 6379</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020037319.png" alt="image-20220216220542814"></p><h3 id="4-3-4-tcp–backlog"><a href="#4-3-4-tcp–backlog" class="headerlink" title="4.3.4. tcp–backlog"></a>4.3.4. tcp–backlog</h3><p>设置 tcp 的 backlog，backlog 其实是一个连接队列，backlog队列总和&#x3D;未完成三次握手队列 + 已经完成三次握手队列。<br>在高并发环境下你需要一个高 backlog 值来避免慢客户端连接问题。<br>注意 Linux内核会将这个值减小到&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn 的值（128），所以需要确认增大&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn 和&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog（128）两个值来达到想要的效果</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038133.png" alt="image-20220216220745374"></p><h3 id="4-3-5-timeout"><a href="#4-3-5-timeout" class="headerlink" title="4.3.5. timeout"></a>4.3.5. timeout</h3><p>一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能。即永不关闭。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038542.png" alt="image-20220216221234044"></p><h3 id="4-3-6-tcp—keepalive"><a href="#4-3-6-tcp—keepalive" class="headerlink" title="4.3.6. tcp—keepalive"></a>4.3.6. tcp—keepalive</h3><p>对访问客户端的一种心跳检测，每隔n 秒检测一次。<br>单位为秒，如果设置为 0，则不会进行 Keepalive检测，建议设置成 60</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038855.png" alt="image-20220216221701077"></p><h2 id="4-4-GENERAL-通用"><a href="#4-4-GENERAL-通用" class="headerlink" title="4.4. ###GENERAL 通用###"></a>4.4. ###GENERAL 通用###</h2><h3 id="4-4-1-daemonize"><a href="#4-4-1-daemonize" class="headerlink" title="4.4.1. daemonize"></a>4.4.1. daemonize</h3><p>是否为后台进程，设置为 yes. 守护进程，后台启动</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038309.png" alt="image-20220216222015341"></p><h3 id="4-4-2-pidfile"><a href="#4-4-2-pidfile" class="headerlink" title="4.4.2. pidfile"></a>4.4.2. pidfile</h3><p>存放 pid 文件的位置，每个实例会产生一个不同的 pid文件</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038949.png" alt="image-20220216222549532"></p><h3 id="4-4-3-loglevel"><a href="#4-4-3-loglevel" class="headerlink" title="4.4.3. loglevel"></a>4.4.3. loglevel</h3><p>指定日志记录级别，Redis 总共支持四个级别：&#x3D;&#x3D;debug、verbose、notice、warning&#x3D;&#x3D;，默认为 notice<br>四个级别根据使用阶段来选择，生产环境选择 notice 或者 warning</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038461.png" alt="image-20220216222621998"></p><h3 id="4-4-4-logfile"><a href="#4-4-4-logfile" class="headerlink" title="4.4.4. logfile"></a>4.4.4. logfile</h3><p>日志文件名称</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038574.png" alt="image-20220216222740748"></p><h3 id="4-4-5-databases-16"><a href="#4-4-5-databases-16" class="headerlink" title="4.4.5. databases 16"></a>4.4.5. databases 16</h3><p>设定库的数量 默认 16，默认数据库为 0，可以使用 SELECT <dbid>命令在连接上指定数据库 id</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038333.png" alt="image-20220216222829307"></p><h2 id="4-5-SECURITY-安全"><a href="#4-5-SECURITY-安全" class="headerlink" title="4.5. ###SECURITY 安全###"></a>4.5. ###SECURITY 安全###</h2><h3 id="4-5-1-设置密码"><a href="#4-5-1-设置密码" class="headerlink" title="4.5.1. 设置密码"></a>4.5.1. 设置密码</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038311.png" alt="image-20220216224220227"></p><p>&#x3D;&#x3D;访问密码的查看、设置和取消在命令中设置密码，只是临时的&#x3D;&#x3D;。重启 redis服务器，密码就还原了。<br>永久设置，需要再配置文件中进行设置。</p><h2 id="4-6-LIMITS-限制"><a href="#4-6-LIMITS-限制" class="headerlink" title="4.6. #### LIMITS 限制"></a>4.6. #### LIMITS 限制</h2><h3 id="4-6-1-maxclients"><a href="#4-6-1-maxclients" class="headerlink" title="4.6.1. maxclients"></a>4.6.1. maxclients</h3><p>➢ 设置 redis 同时可以与多少个客户端进行连接。<br>➢ 默认情况下为 <font color=red>10000 </font>个客户端。<br>➢ 如果达到了此限制，redis 则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038647.png" alt="image-20220216224547099"></p><h3 id="4-6-2-maxmemory"><a href="#4-6-2-maxmemory" class="headerlink" title="4.6.2. maxmemory"></a>4.6.2. maxmemory</h3><p>➢ 建议**<font color=red>必须设置</font>**，否则，将内存占满，造成服务器宕机<br>➢ 设置 redis 可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过 <strong><font color=red>maxmemory-policy</font></strong> 来指定。<br>➢ 如果 redis 无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么 redis则会针对那些需要申请内存的指令返回错误信息，比如 SET、LPUSH等。 但是对于无内存申请的指令，仍然会正常响应，比如 GET 等。<br>➢如果你的 redis 是主redis（说明你的 redis 有从 redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038432.png" alt="image-20220216224927129"></p><h3 id="4-6-3-maxmemory—policy"><a href="#4-6-3-maxmemory—policy" class="headerlink" title="4.6.3. maxmemory—policy"></a>4.6.3. maxmemory—policy</h3><p>➢ volatile-lru：使用 LRU算法移除 key，只对设置了过期时间的键；（最近最少使用）<br>➢ allkeys-lru：在所有集合 key中，使用 LRU算法移除 key<br>➢ volatile-random：在过期集合中移除随机的 key，只对设置了过期时间的键<br>➢ allkeys-random：在所有集合 key中，移除随机的 key<br>➢ volatile-ttl：移除那些 TTL值最小的 key，即那些最近要过期的 key<br>➢ noeviction：不进行移除。针对写操作，只是返回错误信息</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038174.png" alt="image-20220216225459951"></p><h3 id="4-6-4-maxmemory—samples"><a href="#4-6-4-maxmemory—samples" class="headerlink" title="4.6.4. maxmemory—samples"></a>4.6.4. maxmemory—samples</h3><p>➢ 设置样本数量，LRU 算法和最小 TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis 默认会检查这么多个 key 并选择其中 LRU 的那个。<br>➢ 一般设置 3 到 7的数字，数值越小样本越不准确，但 性能消耗越小。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038494.png" alt="image-20220216225631696"></p><h1 id="5-Redis-Redis-的发布和订阅"><a href="#5-Redis-Redis-的发布和订阅" class="headerlink" title="5. Redis Redis 的发布和订阅"></a>5. Redis Redis 的发布和订阅</h1><h2 id="5-1-什么是发布和订阅"><a href="#5-1-什么是发布和订阅" class="headerlink" title="5.1. 什么是发布和订阅"></a>5.1. 什么是发布和订阅</h2><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：&#x3D;&#x3D;发送者 (pub) 发送消息，订阅者(sub) 接收消息&#x3D;&#x3D;。<br>Redis 客户端可以订阅任意数量的频道。</p><h2 id="5-2-Redis-的发布和订阅"><a href="#5-2-Redis-的发布和订阅" class="headerlink" title="5.2. Redis 的发布和订阅"></a>5.2. Redis 的发布和订阅</h2><p>1、客户端可以订阅频道如下图</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038615.png" alt="image-20220216225959304"></p><p>2、当给这个频道发布消息后，消息就会发送给订阅的客户端</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038446.png" alt="image-20220216230015561"></p><h2 id="5-3-发布订阅命令行实现"><a href="#5-3-发布订阅命令行实现" class="headerlink" title="5.3. 发布订阅命令行实现"></a>5.3. 发布订阅命令行实现</h2><p>1、 打开一个客户端订阅 channel1— <code>SUBSCRIBE channel1</code></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038182.png" alt="image-20220216230107720"></p><p>2、打开另一个客户端，给 channel1 发布消息 hello —<code>publish channel1 hello</code></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038399.png" alt="image-20220216230140160"></p><p><strong>返回的 1 是订阅者数量</strong></p><p>3、打开第一个客户端可以看到发送的消息</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038478.png" alt="image-20220216230219641"></p><p>注：&#x3D;&#x3D;发布的消息没有持久化，如果在订阅的客户端收不到 hello，只能收到订阅后发布的消息&#x3D;&#x3D;</p><h1 id="6-Redis常见命令"><a href="#6-Redis常见命令" class="headerlink" title="6.Redis常见命令"></a>6.Redis常见命令</h1><h2 id="6-1-Redis数据结构介绍"><a href="#6-1-Redis数据结构介绍" class="headerlink" title="6.1 Redis数据结构介绍"></a>6.1 Redis数据结构介绍</h2><p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038047.png" alt="1652887393157"></p><p><strong>贴心小建议：命令不要死记，学会查询就好啦</strong></p><p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ <a href="https://redis.io/commands">https://redis.io/commands</a> ）可以查看到不同的命令：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038726.png" alt="1652887648826"></p><p>当然我们也可以通过Help命令来帮助我们去查看命令</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020039047.png" alt="1652887748279"></p><h2 id="6-2-Redis-通用命令"><a href="#6-2-Redis-通用命令" class="headerlink" title="6.2 Redis 通用命令"></a>6.2 Redis 通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期</li></ul><p>通过help [command] 可以查看一个命令的具体用法，例如：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020038367.png" alt="1652887865189"></p><p>课堂代码如下</p><ul><li>KEYS</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询以a开头的key</span></span><br><span class="line">127.0.0.1:6379&gt; keys a*</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>贴心小提示：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高</strong></p><ul><li>DEL</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> del</span><br><span class="line"></span><br><span class="line">  DEL key [key ...]</span><br><span class="line">  summary: Delete a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: generic</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; del name <span class="comment">#删除单个</span></span><br><span class="line">(<span class="built_in">integer</span>) 1  <span class="comment">#成功删除1个</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 <span class="comment">#批量添加数据</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k3&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">4) <span class="string">&quot;age&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; del k1 k2 k3 k4</span><br><span class="line">(<span class="built_in">integer</span>) 3   <span class="comment">#此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys * <span class="comment">#再查询全部的key</span></span><br><span class="line">1) <span class="string">&quot;age&quot;</span><span class="comment">#只剩下一个了</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>贴心小提示：同学们在拷贝代码的时候，只需要拷贝对应的命令哦~</strong></p><ul><li>EXISTS</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> EXISTS</span><br><span class="line"></span><br><span class="line">  EXISTS key [key ...]</span><br><span class="line">  summary: Determine <span class="keyword">if</span> a key exists</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: generic</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; exists age</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; exists name</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><ul><li>EXPIRE</li></ul><p><strong>贴心小提示</strong>：内存非常宝贵，对于一些数据，我们应当给他一些过期时间，当过期时间到了之后，他就会自动被删除~</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire age 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -2  <span class="comment">#当这个key过期了，那么此时查询出来就是-2 </span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 10 <span class="comment">#如果没有设置过期时间</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -1  <span class="comment"># ttl的返回值就是-1</span></span><br></pre></td></tr></table></figure><h2 id="6-3-Redis命令-String命令"><a href="#6-3-Redis命令-String命令" class="headerlink" title="6.3 Redis命令-String命令"></a>6.3 Redis命令-String命令</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增.自减操作</li><li>float：浮点类型，可以做自增.自减操作</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020039967.png" alt="1652890121291"></p><p>String的常见命令有：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><p><strong>贴心小提示</strong>：以上命令除了INCRBYFLOAT 都是常用命令</p><ul><li>SET 和GET: 如果key不存在则是新增，如果存在则是修改</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Rose  <span class="comment">//原来不存在</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name </span><br><span class="line"><span class="string">&quot;Rose&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Jack <span class="comment">//原来存在，就是修改</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name</span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br></pre></td></tr></table></figure><ul><li>MSET和MGET</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MSET k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MGET name age k1 k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Jack&quot;</span> <span class="comment">//之前存在的name</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;10&quot;</span>   <span class="comment">//之前存在的age</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;v2&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure><ul><li>INCR和INCRBY和DECY</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age </span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incr age <span class="comment">//增加1</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age <span class="comment">//获得age</span></span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age <span class="number">2</span> <span class="comment">//一次增加2</span></span><br><span class="line">(integer) <span class="number">13</span> <span class="comment">//返回目前的age的值</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">15</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age -<span class="number">1</span> <span class="comment">//也可以增加负数，相当于减</span></span><br><span class="line">(integer) <span class="number">14</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age -<span class="number">2</span> <span class="comment">//一次减少2个</span></span><br><span class="line">(integer) <span class="number">12</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DECR age <span class="comment">//相当于 incr 负数，减少正常用法</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age </span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>SETNX</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; help setnx</span><br><span class="line"></span><br><span class="line">  SETNX key value</span><br><span class="line">  summary: Set the value of a key, only <span class="keyword">if</span> the key does not exist</span><br><span class="line">  since: <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">  group: string</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Jack  <span class="comment">//设置名称</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx name lisi <span class="comment">//如果key不存在，则添加成功</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name <span class="comment">//由于name已经存在，所以lisi的操作失败</span></span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx name2 lisi <span class="comment">//name2 不存在，所以操作成功</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name2 </span><br><span class="line"><span class="string">&quot;lisi&quot;</span></span><br></pre></td></tr></table></figure><ul><li>SETEX</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex name 10 jack</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><h2 id="6-4-Redis命令-Key的层级结构"><a href="#6-4-Redis命令-Key的层级结构" class="headerlink" title="6.4 Redis命令-Key的层级结构"></a>6.4 Redis命令-Key的层级结构</h2><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020039600.png" alt="1652941631682"></p><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1, “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1, “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><p>一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020039261.png" alt="1652941883537"></p><h2 id="6-5-Redis命令-Hash命令"><a href="#6-5-Redis命令-Hash命令" class="headerlink" title="6.5 Redis命令-Hash命令"></a>6.5 Redis命令-Hash命令</h2><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020039150.png" alt="1652941995945"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020039782.png" alt="1652942027719"></p><p><strong>Hash类型的常见命令</strong></p><ul><li><p>HSET key field value：添加或者修改hash类型key的field的值</p></li><li><p>HGET key field：获取一个hash类型key的field的值</p></li><li><p>HMSET：批量添加多个hash类型key的field的值</p></li><li><p>HMGET：批量获取多个hash类型key的field的值</p></li><li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p></li><li><p>HKEYS：获取一个hash类型的key中的所有的field</p></li><li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p></li><li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p></li></ul><p><strong>贴心小提示</strong>：哈希结构也是我们以后实际开发中常用的命令哟</p><ul><li>HSET和HGET</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> name Lucy<span class="comment">//大key是 heima:user:3 小key是name，小value是Lucy</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> age <span class="number">21</span><span class="comment">// 如果操作不存在的数据，则是新增</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> age <span class="number">17</span> <span class="comment">//如果操作存在的数据，则是修改</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET heima:user:<span class="number">3</span> name </span><br><span class="line"><span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET heima:user:<span class="number">3</span> age</span><br><span class="line"><span class="string">&quot;17&quot;</span></span><br></pre></td></tr></table></figure><ul><li>HMSET和HMGET</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET heima:user:<span class="number">4</span> name HanMeiMei</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET heima:user:<span class="number">4</span> name LiLei age <span class="number">20</span> sex man</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMGET heima:user:<span class="number">4</span> name age sex</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure><ul><li>HGETALL</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure><ul><li>HKEYS和HVALS</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HKEYS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HVALS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure><ul><li>HINCRBY</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HINCRBY  heima:user:<span class="number">4</span> age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">22</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HVALS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;22&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HINCRBY  heima:user:<span class="number">4</span> age -<span class="number">2</span></span><br><span class="line">(integer) <span class="number">20</span></span><br></pre></td></tr></table></figure><ul><li>HSETNX</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSETNX heima:user4 sex <span class="title function_">woman</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;17&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSETNX heima:user:<span class="number">3</span> sex <span class="title function_">woman</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;17&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;woman&quot;</span></span><br></pre></td></tr></table></figure><h2 id="6-6-Redis命令-List命令"><a href="#6-6-Redis命令-List命令" class="headerlink" title="6.6 Redis命令-List命令"></a>6.6 Redis命令-List命令</h2><p>**<font color=red>Redis中的List类型与Java中的LinkedList类似</font>**，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p><strong>List的常见命令有：</strong></p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020039446.png" alt="1652943604992"></p><ul><li>LPUSH和RPUSH</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH users <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPUSH users <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">(integer) <span class="number">6</span></span><br></pre></td></tr></table></figure><ul><li>LPOP和RPOP</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPOP users</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPOP users</span><br><span class="line"><span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure><ul><li>LRANGE</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LRANGE users <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br></pre></td></tr></table></figure><h2 id="6-7-Redis命令-Set命令"><a href="#6-7-Redis命令-Set命令" class="headerlink" title="6.7 Redis命令-Set命令"></a>6.7 Redis命令-Set命令</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集.并集.差集等功能</li></ul><p><strong>Set类型的常见命令</strong></p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li><li>SDIFF key1 key2 … ：求key1与key2的差集</li><li>SUNION key1 key2 ..：求key1和key2的并集</li></ul><p>例如两个集合：s1和s2:</p><p><img src="https://i.imgur.com/ha8x86R.png"></p><p>求交集：SINTER s1 s2</p><p>求s1与s2的不同：SDIFF s1 s2</p><p><img src="https://i.imgur.com/L9vTv2X.png"></p><p><strong>具体命令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd s1 a b <span class="title function_">c</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers s1</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; srem s1 <span class="title function_">a</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER s1 <span class="title function_">a</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER s1 <span class="title function_">b</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SCARD <span class="title function_">s1</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><ul><li>将下列数据用Redis的Set集合来存储：</li><li>张三的好友有：李四.王五.赵六</li><li>李四的好友有：王五.麻子.二狗</li><li>利用Set的命令实现下列功能：</li><li>计算张三的好友有几人</li><li>计算张三和李四有哪些共同好友</li><li>查询哪些人是张三的好友却不是李四的好友</li><li>查询张三和李四的好友总共有哪些人</li><li>判断李四是否是张三的好友</li><li>判断张三是否是李四的好友</li><li>将李四从张三的好友列表中移除</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD zs lisi wangwu <span class="title function_">zhaoliu</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD ls wangwu mazi <span class="title function_">ergou</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SCARD <span class="title function_">zs</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SINTER zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SDIFF zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SUNION zs ls</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;lisi&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;mazi&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;ergou&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER zs <span class="title function_">lisi</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SISMEMBER ls <span class="title function_">zhangsan</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SREM zs <span class="title function_">lisi</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SMEMBERS zs</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure><h2 id="6-8-Redis命令-SortedSet类型"><a href="#6-8-Redis命令-SortedSet类型" class="headerlink" title="6.8 Redis命令-SortedSet类型"></a>6.8 Redis命令-SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF.ZINTER.ZUNION：求差集.交集.并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li><li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul><h1 id="7-Redis的Java客户端-Jedis"><a href="#7-Redis的Java客户端-Jedis" class="headerlink" title="7.Redis的Java客户端-Jedis"></a>7.Redis的Java客户端-Jedis</h1><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p><p><img src="https://i.imgur.com/9f68ivq.png"></p><p>其中Java客户端也包含很多：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212012343760.png" alt="image-20220609102817435"></p><p>标记为❤的就是推荐使用的java客户端，包括：</p><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h2 id="7-1-Jedis快速入门"><a href="#7-1-Jedis快速入门" class="headerlink" title="7.1 Jedis快速入门"></a>7.1 Jedis快速入门</h2><p><strong>入门案例详细步骤</strong></p><p>案例分析：</p><p>0）创建工程：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020039686.png" alt="1652959239813"></p><p>1）引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）建立连接</p><p>新建一个单元测试类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.建立连接</span></span><br><span class="line">    <span class="comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span></span><br><span class="line">    jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">    <span class="comment">// 2.设置密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.选择库</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 存入数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 插入hash数据</span></span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-Jedis连接池"><a href="#7-2-Jedis连接池" class="headerlink" title="7.2 Jedis连接池"></a>7.2 Jedis连接池</h2><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</p><p>有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如我们tomcat中的线程池，这些都是池化思想的体现。</p><h3 id="7-2-1-创建Jedis的连接池"><a href="#7-2-1-创建Jedis的连接池" class="headerlink" title="7.2.1.创建Jedis的连接池"></a>7.2.1.创建Jedis的连接池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/27 21:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        <span class="comment">//最大连接数 （最多允许创建的连接数）</span></span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 最大空闲连接 （最多预备的连接数）</span></span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">//最小空闲连接（在一段时间内，没有人使用，则可释放连接数到MinIdle）</span></span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//设置最长等待时间，ms (连接池中没有连接时，等待的时长。默认是 -1，无限制的等待)</span></span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、（密码）</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig, <span class="string">&quot;192.168.174.128&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Jedis对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明：</strong></p><ul><li><p>1） JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式</p></li><li><p>2）静态代码块：<font color=red>随着类的加载而加载，确保只能执行一次</font>，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化</p></li><li><p>3）最后提供返回连接池中连接的方法.</p></li></ul><h3 id="7-2-2-改造原始代码"><a href="#7-2-2-改造原始代码" class="headerlink" title="7.2.2.改造原始代码"></a>7.2.2.改造原始代码</h3><p><strong>代码说明:</strong></p><p>1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得。而不用直接去new对象，降低耦合，并且使用的还是连接池对象。</p><p>2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@BeforeEach</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//建立连接</span></span><br><span class="line">     <span class="comment">/*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/</span></span><br><span class="line">     jedis = JedisConnectionFacotry.getJedis();</span><br><span class="line">      <span class="comment">//选择库</span></span><br><span class="line">     jedis.select(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">         jedis.close();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意此时<code>jedis.close();</code>的底层调用的不再是关闭连接，而是将连接放回到连接池中</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020039599.png" alt="image-20221015201419871"></p><h1 id="8-Redis的Java客户端-SpringDataRedis"><a href="#8-Redis的Java客户端-SpringDataRedis" class="headerlink" title="8.Redis的Java客户端-SpringDataRedis"></a>8.Redis的Java客户端-SpringDataRedis</h1><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现（基于Redis重新实现）</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020039975.png" alt="1652976773295"></p><h2 id="8-1-快速入门"><a href="#8-1-快速入门" class="headerlink" title="8.1.快速入门"></a>8.1.快速入门</h2><p>SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单：</p><h3 id="8-1-1-导入pom坐标"><a href="#8-1-1-导入pom坐标" class="headerlink" title="8.1.1 导入pom坐标"></a>8.1.1 导入pom坐标</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redis-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>redis-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-1-2-配置文件"><a href="#8-1-2-配置文件" class="headerlink" title="8.1.2 配置文件"></a>8.1.2 配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.174</span><span class="number">.128</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span>  <span class="comment">#最大连接</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span>   <span class="comment">#最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span>   <span class="comment">#最小空闲连接</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span> <span class="comment">#连接等待时间</span></span><br></pre></td></tr></table></figure><h3 id="8-1-3-测试代码"><a href="#8-1-3-测试代码" class="headerlink" title="8.1.3 测试代码"></a>8.1.3 测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>贴心小提示：SpringDataJpa使用起来非常简单，记住如下几个步骤即可</strong></p><p>SpringDataRedis的使用步骤：</p><ul><li>引入spring-boot-starter-data-redis依赖</li><li>在application.yml配置Redis信息</li><li>注入RedisTemplate</li></ul><h2 id="8-2-数据序列化器"><a href="#8-2-数据序列化器" class="headerlink" title="8.2 .数据序列化器"></a>8.2 .数据序列化器</h2><p>RedisTemplate可以接收任意Object作为值写入Redis：</p><p><img src="https://i.imgur.com/OEMcbuu.png"></p><p>当我们执行完上面6.1 的测试方法后，从redis-cli下 获取name的值，结果如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020040324.png" alt="image-20221030174718267"></p><p>为啥我们存入的值 和我们看到的不一样呢？</p><p>因为写入前后会把 Java对象 利用 JDK序列化器转成可处理的字节 来存储到Redis中，而序列化器底层是ObjectOutputStream。得到的结果就是上面那样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTemplate</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">RedisAccessor</span> <span class="keyword">implements</span> <span class="title class_">RedisOperations</span>&lt;K, V&gt;, BeanClassLoaderAware &#123;</span><br><span class="line"><span class="comment">//四个序列化器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> <span class="type">RedisSerializer</span> <span class="variable">keySerializer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> <span class="type">RedisSerializer</span> <span class="variable">valueSerializer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> <span class="type">RedisSerializer</span> <span class="variable">hashKeySerializer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> <span class="type">RedisSerializer</span> <span class="variable">hashValueSerializer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">super</span>.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">defaultUsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (defaultSerializer == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">defaultSerializer = <span class="keyword">new</span> <span class="title class_">JdkSerializationRedisSerializer</span>(</span><br><span class="line">classLoader != <span class="literal">null</span> ? classLoader : <span class="built_in">this</span>.getClass().getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JdkSerializationRedisSerializer底层</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(outputStream);</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>分析系统中的序列化器：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020040102.png" alt="image-20221112182438644"></p><p>**<font color=red>我们可以自定义RedisTemplate的序列化方式</font>**，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/12 18:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 配置Redis的序列化器 </span></span><br><span class="line"><span class="comment"> * key：使用字符串序列化器，value的类型不确定，也就是Object，所以我们使用JSON序列化器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate &lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate &lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span> &lt;&gt;();</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化器</span></span><br><span class="line">        <span class="comment">//RedisSerializer.string(),RedisSerializer.json() 也可以得到对应的序列化器.</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置key的序列化</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终结果如图：</p><ul><li>当存储字符串时</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020040981.png" alt="image-20221120172922088"></p><ul><li>当存储对象时</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020040085.png" alt="image-20221120174216014"></p><p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p><p><strong><font color=blue>注意：如果运行后报下面的错误，可能是需要引入 <code>jackson-databind</code></font></strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020040391.png" alt="image-20221120172000470"></p><h2 id="8-3-StringRedisTemplate"><a href="#8-3-StringRedisTemplate" class="headerlink" title="8.3 StringRedisTemplate"></a>8.3 StringRedisTemplate</h2><p>尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020040566.png" alt="image-20221120180904416"></p><p>为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p><p>&#x3D;&#x3D;为了减少内存的消耗，我们可以采用手动序列化的方式&#x3D;&#x3D;。换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020040470.png" alt="1653054744832"></p><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：**<font color =red>StringRedisTemplate</font>**，它的key和value的序列化方式默认就是String方式。</p><p><img src="https://i.imgur.com/zXH6Qn6.png"></p><p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisTemplateTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;大李&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取String数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;大李&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">//手动序列化（这里也可以使用fastjson的相关方法）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>,json);</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span>  stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1:&quot;</span>+user1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们再来看一看存储的数据，小伙伴们就会发现那个class数据已经不在了，节约了我们的空间~</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020040613.png" alt="image-20221120181737759"></p><p>总结：RedisTemplate的两种序列化实践方案</p><ul><li><p>方案一：</p><ul><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li></ul></li><li><p>方案二：</p><ul><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ul></li></ul><h2 id="8-4-Hash结构操作"><a href="#8-4-Hash结构操作" class="headerlink" title="8.4 Hash结构操作"></a>8.4 Hash结构操作</h2><p>在基础篇的最后，咱们对Hash结构操作一下，收一个小尾巴，这个代码咱们就不再解释啦</p><p>马上就开始新的篇章~~~进入到我们的Redis实战篇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;大李&quot;</span>);</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;21&quot;</span>);</span><br><span class="line"><span class="comment">// 获取所有的键值对</span></span><br><span class="line">        Map &lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(<span class="string">&quot;user:400&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;entries = &quot;</span>+entries);</span><br><span class="line"><span class="comment">// 获取所有的keys</span></span><br><span class="line">        Set &lt;Object&gt; keys = stringRedisTemplate.opsForHash().keys(<span class="string">&quot;user:400&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;keys = &quot;</span>+keys);</span><br><span class="line">        <span class="comment">//获取所有的values</span></span><br><span class="line">        List &lt;Object&gt; values = stringRedisTemplate.opsForHash().values(<span class="string">&quot;user:400&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;values = &quot;</span>+values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212020040638.png" alt="image-20221120182810267"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十六、主从复制</title>
      <link href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC16%E7%AB%A0%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC16%E7%AB%A0%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1、主从复制概述"><a href="#1、主从复制概述" class="headerlink" title="1、主从复制概述"></a>1、主从复制概述</h2><h3 id="1-1-如何提升数据库并发能力"><a href="#1-1-如何提升数据库并发能力" class="headerlink" title="1.1 如何提升数据库并发能力"></a>1.1 如何提升数据库并发能力</h3><p>在实际工作中常常将<code>Redis</code>作为缓存与<code>MySQL</code>配合来使用，当有请求的时候，首先会从缓存中进行查找，如果存在就直接取出。如果不存在再访问数据库，这样就<code>提升了读取的效率</code>，也减少了对后端数据库的<code>访问压力</code>。Redis的缓存架构是<code>高并发架构</code>中非常重要的一环。</p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011213491.png" alt="image-20230930143700163" style="zoom:80%;" /><p>此外，一般应用对数据库而言都是“ <code>读多写少</code> ”，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做<code>主从架构</code>、进行<code>读写分离</code> ，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p><p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何 <code>优化SQL和索引</code> ，这种方式简单有效；其次才是采用 <code>缓存</code>的策略 ，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用<code>主从架构</code> ，进行读写分离。</p><p>按照上面的方式进行优化，使用和维护的成本是由低到高的。</p><h3 id="1-2-主从复制的作用"><a href="#1-2-主从复制的作用" class="headerlink" title="1.2 主从复制的作用"></a>1.2 主从复制的作用</h3><p>主从同步设计不仅可以提高数据库的吞吐量，还有以下 3 个方面的作用。</p><p><strong>第1个作用：读写分离。</strong><br>我们可以通过主从复制的方式来<code>同步数据</code>，然后通过读写分离提高数据库并发处理能力</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011212076.png" alt="image-20230930143925602"></p><p>其中一个是Master主库，负责写入数据，我们称之为：写库。</p><p>其它都是Slave从库，负责读取数据，我们称之为：读库。</p><p>当主库进行更新的时候，会自动将数据复制到从库中，而在客户端读取数据的时候，会从从库中进行读取。</p><p>面对“<code>读多写少</code>“的需求，采用读写分离的方式，可以实现<code>更高的并发访问</code>。同时还能对从服务器进行<code>负载均衡</code>，让不同的读请求按照策略均匀地分发到不同的从服务器上，让读取更加顺畅。读取顺畅的另一个原因，就是减少了锁表的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行SELECT的读取。</p><p><strong>第2个作用就是数据备份</strong><br>通过主从复制将主库上的数据复制到了从库上，相当于是一种热备份机制，也就是在主库正常运行的情况下进行的备份，不会影响到服务</p><p><strong>第3个作用是具有高可用性</strong></p><p>数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现<code>故障</code>或<code>宕机</code>的情况下，可以切换到从服务器上，保证服务的正常运行。</p><p>关于高可用性的程度，我们可以用一个指标衡量，即正常可用时间&#x2F;全年时间。比如要达到全年99.999%的时间都可用，就意味着系统在一年中的不可用时间不得超过<code>365*24*60*(1-99.999%)=5.256</code>分钟(含系统崩溃的时间、日常维护操作导致的停机时间等)，其他时间都需要保持可用的状态。</p><p>实际上，更高的高可用性，意味着需要付出更高的成本代价。在现实中需要结合业务需求和成本来进行选择。</p><h2 id="2、主从复制的原理"><a href="#2、主从复制的原理" class="headerlink" title="2、主从复制的原理"></a>2、主从复制的原理</h2><p><strong><font color=red><code>Slave</code>会从 <code>Master</code>读取 <code>binlog</code>来进行数据同步。</font></strong></p><h3 id="2-1-原理剖析"><a href="#2-1-原理剖析" class="headerlink" title="2.1 原理剖析"></a>2.1 原理剖析</h3><p><strong>三个线程</strong></p><p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于 <code>3 个线程</code> 来操作，一个主库线程，两个从库线程。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011212072.png" alt="image-20230930144217966"></p><p><code>二进制日志转储线程</code> （Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上 <code>加锁</code> ，读取完成之后，再将锁释放掉。–&gt;**<font color=red>二进制日志转储线程负责将数据发送出去</font>**。</p><p><code>从库 I/O 线程 </code>会连接到主库，向主库发送请求更新 Binlog。这时从库的 I&#x2F;O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的<code>中继日志</code> （Relay log）。</p><p><code>从库 SQL 线程</code> 会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011213684.png" style="zoom:80%;" /><blockquote><p>注意:不是所有版本的MySQL都默认开启服务器的二进制日志。在进行主从同步的时候，需要先检查服务器是否已经开启了二进制日志。</p><p>除非特殊指定，默认情况下从服务器会执行所有主服务器中保存的事件。也可以通过配置，使从服务器执行特定的事件。</p></blockquote><p><strong>复制三步骤</strong></p><ul><li>步骤1： <code>Master</code> 将写操作记录到二进制日志（ binlog ）。这些记录叫做二进制日志事件(binary log event)</li><li>步骤2： <code>Slave </code>将 <code>Master </code>的binary log events拷贝到它的中继日志（ <code>relay log</code> ）；</li><li>步骤3： <code>Slave </code>重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从<code>接入点</code>开始复制。</li></ul><blockquote><p>复制的最大问题：&#x3D;&#x3D;延时&#x3D;&#x3D;</p></blockquote><h3 id="2-2-复制的基本原则"><a href="#2-2-复制的基本原则" class="headerlink" title="2.2 复制的基本原则"></a>2.2 复制的基本原则</h3><ul><li>每个Slave 只有一个Master</li><li>每个Slave 只能有一个唯一的服务器ID</li><li>每个Master 可以有多个Slave</li></ul><h2 id="3、一主一从架构搭建"><a href="#3、一主一从架构搭建" class="headerlink" title="3、一主一从架构搭建"></a>3、一主一从架构搭建</h2><p>一台<code>主机</code>用于处理所有<code>写请求</code> ，一台<code>从机</code>负责所有<code>读请求</code> ，架构图如下：</p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011213709.png" alt="image-20230930144845781" style="zoom:80%;" /><h3 id="3-1-准备工作"><a href="#3-1-准备工作" class="headerlink" title="3.1 准备工作"></a>3.1 准备工作</h3><p>1、准备 <code>2台</code> CentOS 虚拟机</p><p>2、每台虚拟机上需要安装好MySQL (可以是MySQL8.0 )</p><blockquote><p>说明：前面我们讲过如何克隆一台CentOS。大家可以在一台CentOS上安装好MySQL，进而通过克隆的方式复制出1台包含MySQL的虚拟机</p><p>注意：克隆的方式需要修改新克隆出来主机的：① MAC地址 ② hostname ③ IP 地址 ④ UUID 。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">① 修改编辑虚拟机设置-&gt;网络适配器-&gt;高级-&gt;生成MAC地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">② 修改hostname</span></span><br><span class="line">vim /etc/hostname </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">③修改IP地址和UUID</span></span><br><span class="line">[root@hadoop102_son ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33 </span><br><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;4977dbfa-6b67-45bb-b0b1-4daa4fgs9c41&quot;</span><br><span class="line">DEVICE=&quot;ens33&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line"></span><br><span class="line">IPADDR=192.168.174.122</span><br><span class="line">GATEWAY=192.168.174.2</span><br><span class="line">DNS1=192.168.174.2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">④重启网络</span></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><p>此外，克隆的方式生成的虚拟机（包含MySQL Server），则克隆的虚拟机MySQL Server的UUID相同，必须修改，否则在有些场景会报错。比如： show slave status\G ，报如下的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last_IO_Error: Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work.</span><br></pre></td></tr></table></figure><p>修改MySQL Server 的UUID方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /var/lib/mysql/auto.cnf </span><br></pre></td></tr></table></figure><h3 id="3-2-主机配置文件"><a href="#3-2-主机配置文件" class="headerlink" title="3.2 主机配置文件"></a>3.2 主机配置文件</h3><p>建议mysql版本一致且后台以服务运行，主从所有配置项都配置在 [mysqld] 节点下，且都是小写字母。</p><p>具体参数配置(<code>/etc/my.cng</code>)如下：</p><ul><li>必选</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[必须]主服务器唯一ID</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[必须]启用二进制日志,指明路径。比如：自己本地的路径/log/mysqlbin</span> </span><br><span class="line">log-bin=atguigu-bin</span><br></pre></td></tr></table></figure><ul><li>可选</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选] 0（默认）表示读写（主机），1表示只读（从机）</span></span><br><span class="line">read-only=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置日志文件保留的时长，单位是秒</span></span><br><span class="line">binlog_expire_logs_seconds=6000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">控制单个二进制日志大小。此参数的最大和默认值是1GB</span></span><br><span class="line">max_binlog_size=200M</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选]设置不要复制的数据库</span></span><br><span class="line">binlog-ignore-db=test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选]设置需要复制的数据库,默认全部记录。比如：binlog-do-db=atguigu_master_slave</span> </span><br><span class="line">binlog-do-db=需要复制的主数据库名字</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选]设置binlog格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br></pre></td></tr></table></figure><p>重启后台mysql服务，使配置生效。</p><blockquote><p>注意:</p><p>先搭建完主从复制，再创建数据库。</p><p>MySQL主从复制起始时，从机不继承主机数据</p></blockquote><h3 id="3-3-从机配置文件"><a href="#3-3-从机配置文件" class="headerlink" title="3.3 从机配置文件"></a>3.3 从机配置文件</h3><p>要求主从所有配置项都配置在 my.cnf（<code>/etc/my.cng</code>） 的 [mysqld] 栏位下，且都是小写字母。</p><ul><li>必选</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[必须]从服务器唯一ID</span></span><br><span class="line">server-id=2</span><br></pre></td></tr></table></figure><ul><li>可选</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">[可选]启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure><blockquote><p>注意：主从机都关闭防火墙，否则主从复制时可能出问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop #CentOS 6</span><br><span class="line">systemctl stop firewalld.service #CentOS 7</span><br></pre></td></tr></table></figure><p>查看防火墙状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop102_son ~]# systemctl status firewalld;</span><br><span class="line">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line">     Docs: man:firewalld(1)</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-4-主机：建立账户并授权"><a href="#3-4-主机：建立账户并授权" class="headerlink" title="3.4 主机：建立账户并授权"></a>3.4 主机：建立账户并授权</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在主机MySQL里执行授权主从复制的命令</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;从机器数据库IP&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;abc123&#x27;</span>; #<span class="number">5.5</span>,<span class="number">5.7</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：如果使用的是MySQL8，需要如下的方式建立账户，并授权slave：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">CREATE USER <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">GRANT REPLICATION SLAVE ON *.* TO <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show grants <span class="keyword">for</span> <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span></span><br><span class="line">+------------------------------------------------+</span><br><span class="line">| Grants for slave1@%                            |</span><br><span class="line">+------------------------------------------------+</span><br><span class="line">| GRANT REPLICATION SLAVE ON *.* TO `slave1`@`%` |</span><br><span class="line">+------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意下面这句必须执行，不然就会报授权插件错误</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">ALTER USER <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;123456&#x27;</span>;</span> </span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">flush privileges;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>注意：在从机执行show slave status\G时报错：</p><p>Last_IO_Error: error connecting to master ‘<a href="mailto:&#115;&#108;&#x61;&#118;&#101;&#49;&#x40;&#x31;&#57;&#50;&#x2e;&#49;&#54;&#x38;&#46;&#49;&#55;&#52;&#46;&#x31;&#x30;&#50;">&#115;&#108;&#x61;&#118;&#101;&#49;&#x40;&#x31;&#57;&#50;&#x2e;&#49;&#54;&#x38;&#46;&#49;&#55;&#52;&#46;&#x31;&#x30;&#50;</a>:3306’ - retry-time: 60 retries: 1 message: Authentication plugin ‘caching_sha2_password’ reported error: Authentication requires secure connection.</p></blockquote><p>查询Master的状态，并记录下File和Position的值</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011212079.png" alt="image-20230930162726667"></p><blockquote><p>注意：</p><ul><li><p>执行完此步骤后不要再操作主服务器MySQL，防止主服务器状态值变化。</p></li><li><p>为什么不先创建主从数据库的原因是，从机是从FIle-Position开始复制。事先创建好就会导致建表语句不在bin_log中，从而备份的日志不完整~</p></li></ul></blockquote><h3 id="3-5-从机：配置需要复制的主机"><a href="#3-5-从机：配置需要复制的主机" class="headerlink" title="3.5 从机：配置需要复制的主机"></a>3.5 从机：配置需要复制的主机</h3><p><strong>步骤1：</strong>从机上复制主机的命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span></span><br><span class="line">MASTER_HOST<span class="operator">=</span><span class="string">&#x27;主机的IP地址&#x27;</span>,</span><br><span class="line">MASTER_USER<span class="operator">=</span><span class="string">&#x27;主机用户名&#x27;</span>,</span><br><span class="line">MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;主机用户名的密码&#x27;</span>,</span><br><span class="line">MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;mysql-bin.具体数字&#x27;</span>,</span><br><span class="line">MASTER_LOG_POS<span class="operator">=</span>具体值;</span><br></pre></td></tr></table></figure><p>演示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;192.168.174.102&#x27;</span>,MASTER_USER<span class="operator">=</span><span class="string">&#x27;slave1&#x27;</span>,MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>,MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;atguigu-bin.000011&#x27;</span>,MASTER_LOG_POS<span class="operator">=</span><span class="number">1137</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011212081.png" alt="image-20230930172217155"></p><p><strong>步骤2</strong> ：启动slave同步 <code>START SLAVE;</code></p><p>如果报错</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011212086.png" alt="image-20230930173752806"></p><p>可以执行如下操作，删除之前的relay_log信息。然后重新执行 CHANGE MASTER TO …语句即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">reset slave; <span class="comment">#删除SLAVE数据库的relaylog日志文件，并重新启用新的relaylog文件</span></span></span><br></pre></td></tr></table></figure><p>接着，查看同步状态。两个参数都是Yes，则说明主从配置成功！</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011212098.png" alt="image-20230930163429724"></p><blockquote><p>显示为NO，则是不正确的。则可能是如下的原因</p><ul><li>网络不通</li><li>账户密码错误</li><li>防火墙</li><li>mysql配置文件问题</li><li>连接服务器时语法</li><li>主服务器mysql权限</li></ul></blockquote><h3 id="3-6-测试"><a href="#3-6-测试" class="headerlink" title="3.6 测试"></a>3.6 测试</h3><p>主机新建库、新建表、insert记录，从机复制：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">CREATE DATABASE atguigu_master_slave;</span></span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">use atguigu_master_slave;</span></span><br><span class="line">Database changed</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"> mysql&gt; </span><span class="language-bash">show tables;</span></span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">CREATE TABLE student(<span class="built_in">id</span> INT,NAME VARCHAR(15));</span></span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">INSERT INTO student VALUES(1, <span class="string">&#x27;Tom&#x27;</span>);</span></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">INSERT INTO student VALUES(2,@@hostname);</span></span><br><span class="line">Query OK, 1 row affected, 1 warning (0.01 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from student;</span></span><br><span class="line">+------+-----------+</span><br><span class="line">| id   | NAME      |</span><br><span class="line">+------+-----------+</span><br><span class="line">|    1 | Tom       |</span><br><span class="line">|    2 | hadoop102 |</span><br><span class="line">+------+-----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>查看从机的情况，可以看到主机数据被复制到了从机~ Amazing</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show databases;</span></span><br><span class="line">+----------------------+</span><br><span class="line">| Database             |</span><br><span class="line">+----------------------+</span><br><span class="line">| atguigu_master_slave |</span><br><span class="line">| atguigudb            |</span><br><span class="line">| atguigudb1           |</span><br><span class="line">| atguigudb2           |</span><br><span class="line">| atguigudb3           |</span><br><span class="line">| dbtest2              |</span><br><span class="line">| information_schema   |</span><br><span class="line">| mysql                |</span><br><span class="line">| performance_schema   |</span><br><span class="line">| sys                  |</span><br><span class="line">| testdb1              |</span><br><span class="line">+----------------------+</span><br><span class="line">11 rows in set (0.02 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">use atguigu_master_slave;</span></span><br><span class="line">Database changed</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show tables;</span></span><br><span class="line">+--------------------------------+</span><br><span class="line">| Tables_in_atguigu_master_slave |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| student                        |</span><br><span class="line">+--------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from student;</span></span><br><span class="line">+------+---------------+</span><br><span class="line">| id   | NAME          |</span><br><span class="line">+------+---------------+</span><br><span class="line">|    1 | Tom           |</span><br><span class="line">|    2 | hadoop102_son |</span><br><span class="line">+------+---------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="3-7-停止主从同步"><a href="#3-7-停止主从同步" class="headerlink" title="3.7 停止主从同步"></a>3.7 停止主从同步</h3><ul><li>停止主从同步命令：<code>stop slave;</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止主从(要在从机执行哦)</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">stop slave;</span></span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.01 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看主从复制状态</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SHOW SLAVE STATUS\G;</span></span><br><span class="line">//...</span><br><span class="line">             Slave_IO_Running: No</span><br><span class="line">            Slave_SQL_Running: No</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;验证:主机重新插入新的数据,观察从机是否进行恢复&#x3D;&#x3D;</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011212663.png" alt="image-20230930192409457"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011212705.png" alt="image-20230930192507184"></p><ul><li>如何重新配置主从</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave; #从机执行</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011212741.png" alt="image-20230930192917574"></p><blockquote><p>注意：如果报错,则可以执行<code>reset slave</code>~  删除SLAVE数据库的relaylog日志文件，并重新启用新的relaylog文件。特殊情况下可以使用<code>reset master</code>~ 重置Master中所有的binlog日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> reset slave; #删除SLAVE数据库的relaylog日志文件，并重新启用新的relaylog文件</span><br><span class="line">reset master; #删除Master中所有的binglog文件，并将日志索引文件清空，重新开始所有新的日志文件(慎用)</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-8-后续-搭建双主双从"><a href="#3-8-后续-搭建双主双从" class="headerlink" title="3.8 后续 - 搭建双主双从"></a>3.8 后续 - 搭建双主双从</h3><p>一个主机m1用于处理所有写请求，它的从机s1和另一台主机m2还有它的从机s2负责所有读请求。当m1主机宕机后，m2主机负责写请求，mi、m2互为备机。架构图如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011212779.png" alt="image-20231001112213456"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011212993.png" alt="image-20231001112219443"></p><blockquote><p>具体可以看MyCat教程</p></blockquote><h3 id="3-9-补充：binlog-格式设置说明"><a href="#3-9-补充：binlog-格式设置说明" class="headerlink" title="3.9 补充：binlog 格式设置说明"></a>3.9 补充：binlog 格式设置说明</h3><p>**<font color=blue>格式1： <code>STATEMENT</code>模式 </font>**（基于SQL语句的复制(statement-based replication, SBR)）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog_format=STATEMENT</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;每一条会修改数据的sql语句会记录到binlog中&#x3D;&#x3D;。这是默认的binlog格式。</p><p>SBR 的优点：</p><ul><li>历史悠久，技术成熟</li><li>不需要记录每一行的变化，减少了binlog日志量，文件较小</li><li>binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况</li><li>binlog可以用于实时的还原，而不仅仅用于复制</li><li>主从版本可以不一样，从服务器版本可以比主服务器版本高（因为从和主执行的SQL一样，从可以兼容主）</li></ul><p>SBR 的缺点：</p><ul><li>不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候</li><li>使用以下函数的语句也无法被复制：LOAD_FILE()、UUID()、USER()、FOUND_ROWS()、SYSDATE()(除非启动时启用了 –sysdate-is-now 选项)</li><li>INSERT … SELECT 会产生比 RBR 更多的行级锁</li><li>复制需要进行全表扫描(WHERE 语句中没有使用到索引)的 UPDATE 时，需要比 RBR 请求更多的行级锁</li><li>对于有 AUTO_INCREMENT 字段的 InnoDB表而言，INSERT 语句会阻塞其他 INSERT 语句</li><li>对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而 RBR 模式下，只会对那个发生变化的记录产生影响</li><li>执行复杂语句如果出错的话，会消耗更多资源</li><li>数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错</li></ul><p>**<font color=blue>② ROW模式</font>**（基于行的复制(row-based replication, RBR)）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog_format=ROW</span><br></pre></td></tr></table></figure><blockquote><p>5.1.5版本的MySQL才开始支持，不记录每条sql语句的上下文信息，仅记录哪条数据被修改了，修改成什么样了。</p></blockquote><p>RBR 的优点：</p><ul><li>任何情况都可以被复制，这对复制来说是最安全可靠的。（比如：不会出现某些特定情况下的存储过程、function、trigger的调用和触发无法被正确复制的问题）</li><li>多数情况下，从服务器上的表如果有主键的话，复制就会快了很多</li><li>复制以下几种语句时的行锁更少：INSERT … SELECT、包含 AUTO_INCREMENT 字段的</li><li>INSERT、没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句</li><li>执行 INSERT，UPDATE，DELETE 语句时锁更少</li><li>从服务器上采用多线程 来执行复制成为可能</li></ul><p>RBR 的缺点：</p><ul><li>binlog 大了很多</li><li>复杂的回滚时 binlog 中会包含大量的数据</li><li>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog的并发写问题</li><li>无法从 binlog 中看到都复制了些什么语句</li></ul><p>**<font color=blue>③ MIXED模式</font>**（混合模式复制(mixed-based replication, MBR)）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog_format=MIXED</span><br></pre></td></tr></table></figure><blockquote><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合</p></blockquote><p>在Mixed模式下，一般的语句修改使用statment格式保存binlog。如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog。</p><p>MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</p><h2 id="4、同步数据一致性问题"><a href="#4、同步数据一致性问题" class="headerlink" title="4、同步数据一致性问题"></a>4、同步数据一致性问题</h2><p><strong>主从同步的要求：</strong></p><ul><li>读库和写库的数据一致(最终一致)；</li><li>写数据必须写到写库；</li><li>读数据必须到读库(不一定)；</li></ul><h3 id="4-1-理解主从延迟问题"><a href="#4-1-理解主从延迟问题" class="headerlink" title="4.1 理解主从延迟问题"></a>4.1 理解主从延迟问题</h3><p>进行主从同步的内容是二进制日志，它是一个文件，在进行<code>网络传输</code>的过程中就一定会存在<code>主从延迟</code>(比如500ms)，这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的<code>数据不一致性</code>问题。</p><p><strong>举例:</strong> 导致主从延迟的时间点主要包括以下三个:</p><ul><li>主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</li><li>之后传给从库B，我们把从库B接收完这个binlog的时刻记为T2;</li><li>从库B执行完成这个事务，我们把这个时刻记为T3。</li></ul><h3 id="4-2-主从延迟问题原因"><a href="#4-2-主从延迟问题原因" class="headerlink" title="4.2 主从延迟问题原因"></a>4.2 主从延迟问题原因</h3><p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T2-T1的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p><p>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。造成原因：</p><ul><li>从库的机器性能比主库要差</li><li>从库的压力大</li><li>大事务的执行</li></ul><p><font color=blue>举例1：一次性用delete语句删除太多数据</font></p><p>结论：后续再删除数据的时候，要控制每个事务删除的数据量，分成多次删除。</p><p><font color=blue>举例2：一次性用insert…select插入太多数据</font></p><p><font color=blue>举例:3：大表DDL</font></p><p>比如在主库对一张500W的表添加一个字段耗费了10分钟，那么从节点上也会耗费10分钟。</p><h3 id="4-3-如何减少主从延迟"><a href="#4-3-如何减少主从延迟" class="headerlink" title="4.3 如何减少主从延迟"></a>4.3 如何减少主从延迟</h3><p>若想要减少主从延迟的时间，可以采取下面的办法：</p><ul><li>降低多线程大事务并发的概率，优化业务逻辑</li><li>优化SQL，避免慢SQL，<code>减少批量操作 </code>，建议写脚本以update-sleep这样的形式完成。</li><li><code>提高从库机器的配置</code> ，减少主库写binlog和从库读binlog的效率差。</li><li>尽量采用<code>短的链路</code>，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。</li><li>实时性要求的业务读强制走主库，从库只做灾备，备份。</li></ul><h3 id="4-4-如何解决一致性问题"><a href="#4-4-如何解决一致性问题" class="headerlink" title="4.4 如何解决一致性问题"></a>4.4 如何解决一致性问题</h3><p>如果操作的数据存储在同一个数据库中，那么对数据进行更新的时候，可以对记录加写锁，这样在读取的时候就不会发生数据不一致的情况。但这时从库的作用就是<code>备份</code> ，并没有起到<code>读写分离</code> ，分担主库<code>读压力</code>的作用。</p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011213434.png" alt="image-20231001112415354" style="zoom:80%;" /><p>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间<code>数据复制方式</code>的问题，如果按照数据一致性 <code>从弱到强 </code>来进行划分，有以下 3 种复制方式。</p><p><strong><font color=blue>方法 1：异步复制</font></strong></p><p>异步模式就是客户端提交COMMIT之后不需要等从库返回任何结果，而是直接将结果返回给客户端，这样做的好处是不会影响主库写的效率，但可能会存在主库宕机，而Binlog还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库中选择一个作为新主，那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的。</p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011213840.png" style="zoom:80%;" /><p><strong><font color=blue>方法 2：半同步复制</font></strong><br>MySQL5.5版本之后开始支持半同步复制的方式。原理是在客户端提交COMMIT之后不直接将结果返回给客户端，而是等待至少有一个从库接收到了Binlog，并且写入到中继日志中，再返回给客户端。</p><p>这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。</p><p>在MySQL5.7版本中还增加了一个<code>rpl_semi_sync_master_wait_for_slave_count</code>参数，可以对应答的从库数量进行设置，默认为1，也就是说只要有1个从库进行了响应，就可以返回给客户端。如果将这个参数调大，可以提升数据一致性的强度，但也会增加主库等待从库响应的时间【以时间换取一致性】</p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011213592.png" style="zoom:80%;" /><p><strong><font color=blue>方法 3：组复制</font></strong><br>异步复制和半同步复制都无法最终保证数据的一致性问题，半同步复制是通过判断从库响应的个数来决定是否返回给客户端，虽然数据一致性相比于异步复制有提升，但仍然无法满足对数据一致性要求高的场景，比如金融领域。MGR 很好地弥补了这两种复制模式的不足。</p><p>组复制技术，简称 MGR（MySQL Group Replication）。是 MySQL 在 5.7.17 版本中推出的一种新的数据复制技术，这种复制技术是基于 Paxos 协议的状态机复制。</p><p>&#x3D;&#x3D;MGR 是如何工作的&#x3D;&#x3D;</p><p>首先我们将多个节点共同组成一个复制组，在<code>执行读写（RW）事务</code> 的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于 （N&#x2F;2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对 <code>只读（RO）事务</code> 则不需要经过组内同意，直接 COMMIT 即可。</p><p>在一个复制组内有多个节点组成，它们各自维护了自己的数据副本，并且在一致性协议层实现了原子消息和全局有序消息，从而保证组内数据的一致性。</p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011213064.png" style="zoom:80%;" /><p>MGR 将 MySQL 带入了数据强一致性的时代，是一个划时代的创新，其中一个重要的原因就是MGR 是基于<code>Paxos </code>协议的。Paxos 算法是由 2013 年的图灵奖获得者 Leslie Lamport 于 1990 年提出的，有关这个算法的决策机制可以搜一下。事实上，Paxos 算法提出来之后就作为 <code>分布式一致性算法</code> 被广泛应用，比如Apache 的 ZooKeeper 也是基于 Paxos 实现的。</p><h2 id="5、知识延伸"><a href="#5、知识延伸" class="headerlink" title="5、知识延伸"></a>5、知识延伸</h2><p>在主从架构的配置中，如果想要采取读写分离的策略，我们可以<code>自己编写程序</code> ，也可以通过<code>第三方的中间件</code>来实现。</p><p>自己编写程序的好处就在于比较自主，我们可以自己判断哪些查询在从库上来执行，针对实时性要求高的需求，我们还可以考虑哪些查询可以在主库上执行。同时，程序直接连接数据库，减少了中间件层，相当于减少了性能损耗。</p><p>采用中间件的方法有很明显的优势，功能强大 ，使用简单 。但因为在客户端和数据库之间增加了中间件层会有一些性能损耗，同时商业中间件也是有使用成本的。我们也可以考虑采取一些优秀的开源工具。</p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011213662.png" alt="image-20231001113303910" style="zoom:80%;" /><p>① Cobar 属于阿里B2B事业群，始于2008年，在阿里服役3年多，接管3000+个MySQL数据库的schema,集群日处理在线SQL请求50亿次以上。由于Cobar发起人的离职，Cobar停止维护。</p><p>② Mycat 是开源社区在阿里cobar基础上进行二次开发，解决了cobar存在的问题，并且加入了许多新的功能在其中。青出于蓝而胜于蓝。</p><p>③ OneProxy 基于MySQL官方的proxy思想利用c语言进行开发的，OneProxy是一款商业 收费 的中间件。舍弃了一些功能，专注在性能和稳定性上 。</p><p>④ kingshard 由小团队用go语言开发，还需要发展，需要不断完善。</p><p>⑤ Vitess 是Youtube生产在使用，架构很复杂。不支持MySQL原生协议，使用 需要大量改造成本。</p><p>⑥ Atlas 是360团队基于mysql proxy改写，功能还需完善，高并发下不稳定。</p><p>⑦ MaxScale 是mariadb（MySQL原作者维护的一个版本） 研发的中间件</p><p>⑧ MySQLRoute 是MySQL官方Oracle公司发布的中间件</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011212160.png"></p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011214183.png" style="zoom:80%;" /><p>主备切换：</p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202310011214840.png" alt="image-20231001113941363" style="zoom:80%;" /><ul><li>主动切换</li><li>被动切换</li><li>如何判断主库出问题了？如何解决过程中的数据不一致性问题？</li></ul><blockquote><p>以上这些使我们后序开发和工作中需要进行不断扩展和学习的~</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十五、其他数据库日志</title>
      <link href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC15%E7%AB%A0%20%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97/"/>
      <url>/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC15%E7%AB%A0%20%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><hr><p>我们在讲解数据库事务时，讲过两种日志:<code>重做日志</code>、<code>回滚日志</code>。</p><p>对于线上数据库应用系统，突然遭遇<code>数据库宕机</code>怎么办?在这种情况下，定位宕机的原因就非常关键。可以查看数据库的错误日志。因为日志中记录了数据库运行中的诊断信息，包括了错误、警告和注释等信息。比如:从日志中发现某个连接中的SQL操作发生了死循环，导致内存不足，被系统强行终止了。明确了原因，处理起来也就轻松了，系统很快就恢复了运行。</p><p>除了发现错误，日志在数据复制、数据恢复、操作审计，以及确保数据的永久性和一致性等方面，都有着不可替代的作用。</p><p>&#x3D;&#x3D;千万不要小看日志&#x3D;&#x3D;。很多看似奇怪的问题，答案往往就藏在日志里。很多情况下，只有通过查看日志才能发现问题的原因，真正解决问题。所以，一定要学会查看日志，养成检查日志的习惯，对提升你的数据库应用开发能力至关重要。</p><p>MySQL8.0官网日志地址: <a href="https://dev.mysql.com/doc/refman/8.0/en/server-logs.html">https://dev.mysql.com/doc/refman/8.0/en/server-logs.html</a></p><h2 id="1-MySQL支持的日志"><a href="#1-MySQL支持的日志" class="headerlink" title="1. MySQL支持的日志"></a>1. MySQL支持的日志</h2><h3 id="1-1-日志类型"><a href="#1-1-日志类型" class="headerlink" title="1.1 日志类型"></a>1.1 日志类型</h3><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为<code>二进制日志</code>、<code>错误日志</code>、<code>通用查询日志</code>和<code>慢查询日志</code>，这也是常用的4种。MySQL 8又新增两种支持的日志:<code>中继日志</code>和<code>数据定义语句日志</code>。使用这些日志文件，可以查看MySQL内部发生的事情。</p><p><strong>这6类日志分别为：</strong></p><ul><li><code>慢查询日志</code>:记录所有执行时间超过long_query_time的所有查询，方便对查询进行优化。</li><li><code>通用查询日志</code>:记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</li><li><code>错误日志</code>:记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而从而对服务器进行维护。</li><li><code>二进制日志</code>:记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</li><li><code>中继日志</code>:用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</li><li><code>数据定义语句日志</code>:记录数据定义语句执行的元数据操作。</li></ul><p>除二进制日志外，其他日志都是<code>文本文件</code>。默认情况下，所有日志创建于<code>MySQL数据目录</code>中。</p><h3 id="1-2-日志的弊端"><a href="#1-2-日志的弊端" class="headerlink" title="1.2 日志的弊端"></a>1.2 日志的弊端</h3><ul><li>日志功能会<code>降低MySQL数据库的性能</code>。例如，在查询非常频繁的MySQL数据库系统中，如果开启了通用查询日志和慢查询日志，MySQL数据库会花费很多时间记录日志。</li><li>日志会占用<code>大量的磁盘空间</code>。对于用户量非常大、操作非常频繁的数据库，日志文件需要的存储空间设置比数据库文件需要的存储空间还要大。</li></ul><hr><h2 id="2-慢查询日志-slow-query-log"><a href="#2-慢查询日志-slow-query-log" class="headerlink" title="2. 慢查询日志(slow query log)"></a>2. 慢查询日志(slow query log)</h2><p>前面章节《第09章 性能分析工具的使用》已经详细讲述</p><h2 id="3-通用查询日志"><a href="#3-通用查询日志" class="headerlink" title="3. 通用查询日志"></a>3. 通用查询日志</h2><p>通用查询日志用来<code>记录用户的所有操作</code>，包括启动和关闭MysQL服务、所有用户的连接开始时间和截止时间、发给MySQL数据库服务器的所有SQL指令等。当我们的数据发生异常时<strong>，查看通用查询日志，还原操作时的具体场景</strong>，可以帮助我们准确定位问题。</p><h3 id="3-1-问题场景"><a href="#3-1-问题场景" class="headerlink" title="3.1 问题场景"></a>3.1 问题场景</h3><p>在电商系统中，购买商品并且使用微信支付完成以后，却发现支付中心的记录并没有新增，此时用户再次使用支付宝支付，就会出现<code>重复支付</code>的问题。但是当去数据库中查询数据的时候，会发现只有一条记录存在。那么此时给到的现象就是只有一条支付记录，但是用户却支付了两次。</p><p>对系统进行了仔细检查，没有发现数据问题，因为用户编号和订单编号以及第三方流水号都是对的。可是用户确实支付了两次，这个时候，我们想到了检查通用查询日志，看看当天到底发生了什么。</p><p>查看之后，发现: 1月1日下午2点，用户使用微信支付完以后，但是由于网络故障，支付中心没有及时收到微信支付的回调通知，导致当时没有写入数据。1月1日下午2点30，用户又使用支付宝支付，此时记录更新到支付中心。1月1日晚上9点，微信的回调通知过来了，但是支付中心已经存在了支付宝的记录，所以只能覆盖记录了。</p><p>由于网络的原因导致了重复支付。至于解决问题的方案就很多了，这里省略。</p><p>可以看到通用查询日志可以帮助我们了解操作发生的具体时间和操作的细节，对找出异常发生的原因极其关键。</p><h3 id="3-2-查看当前状态"><a href="#3-2-查看当前状态" class="headerlink" title="3.2 查看当前状态"></a>3.2 查看当前状态</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>                        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log      <span class="operator">|</span> OFF                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>hadoop102.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>说明1∶系统变量general_log的值是OFF，即通用查询日志处于关闭状态。在MySQL中，这个参数的<code>默认值是关闭的</code>。因为一旦开启记录通用查询日志，MySQL 会记录所有的连接起止和相关的SQL操作，这样会消耗系统资源并且占用磁盘空间。我们可以通过手动修改变量的值，在<code>要的时候开启日志</code>。</p><p>说明2:通用查询日志文件的名称是主机.log(hadoop102.log)。存储路径是<code>/var/lib/mysql/</code>，默认也是数据路径。这样我们就知道在哪里可以查看通用查询日志的内容了</p><h3 id="3-3-启动日志"><a href="#3-3-启动日志" class="headerlink" title="3.3 启动日志"></a>3.3 启动日志</h3><p><strong>方式1：永久性方式</strong></p><p>修改<code>my.cnf</code>或者<code>my.ini</code>配置文件来设置。在[mysqld]组下加入log选项，并重启MySQL服务。格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">general_log<span class="operator">=</span><span class="keyword">ON</span></span><br><span class="line">general_log_file<span class="operator">=</span>[path[filename]] #日志文件所在目录路径，filename为日志文件名</span><br></pre></td></tr></table></figure><p>如果不指定目录和文件名，通用查询日志将默认存储在MySQL数据目录中的hostname.log文件中，hostname表示主机名。</p><p><strong>方式2：临时性方式</strong></p><p>使用SET语句停止MySQL通用查询日志功能:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log<span class="operator">=</span><span class="keyword">on</span>; # 开启通用查询日志</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log_file<span class="operator">=</span><span class="string">&#x27;path/filename&#x27;</span>; # 设置日志文件保存位置</span><br></pre></td></tr></table></figure><p>对应的，关闭操作SQL命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log<span class="operator">=</span>off; # 关闭通用查询日志</span><br></pre></td></tr></table></figure><p>查看设置后情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;general_log%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="3-4-查看日志"><a href="#3-4-查看日志" class="headerlink" title="3.4 查看日志"></a>3.4 查看日志</h3><p>通用查询日志是以<code>文本文件</code> 的形式存储在文件系统中的，可以使用文本编辑器 直接打开日志文件。每台MySQL服务器的通用查询日志内容是不同的。</p><ul><li>在Windows操作系统中，使用文本文件查看器；</li><li>在Linux系统中，可以使用vi工具或者gedit工具查看；</li><li>在Mac OSX系统中，可以使用文本文件查看器或者vi等工具查看。</li></ul><p>从<code>SHOW VARIABLES LIKE ‘general_log%’;</code> 结果中可以看到通用查询日志的位置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@hadoop102</span> mysql]# cat hadoop102.log </span><br><span class="line"><span class="operator">/</span>usr<span class="operator">/</span>sbin<span class="operator">/</span>mysqld, Version: <span class="number">8.0</span><span class="number">.25</span> (MySQL Community Server <span class="operator">-</span> GPL). started <span class="keyword">with</span>:</span><br><span class="line">Tcp port: <span class="number">3306</span>  Unix socket: <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysql.sock</span><br><span class="line"><span class="type">Time</span>                 Id Command    Argument</span><br><span class="line"><span class="number">2023</span><span class="number">-07</span><span class="number">-09</span>T11:<span class="number">06</span>:<span class="number">37.920806</span>Z   <span class="number">12</span> Query<span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%general%&#x27;</span></span><br><span class="line"><span class="number">2023</span><span class="number">-07</span><span class="number">-10</span>T00:<span class="number">49</span>:<span class="number">48.408063</span>Z   <span class="number">12</span> Quit</span><br><span class="line"><span class="operator">/</span>usr<span class="operator">/</span>sbin<span class="operator">/</span>mysqld, Version: <span class="number">8.0</span><span class="number">.25</span> (MySQL Community Server <span class="operator">-</span> GPL). started <span class="keyword">with</span>:</span><br><span class="line">Tcp port: <span class="number">3306</span>  Unix socket: <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysql.sock</span><br><span class="line"><span class="type">Time</span>                 Id Command    Argument</span><br><span class="line"><span class="number">2023</span><span class="number">-07</span><span class="number">-22</span>T06:<span class="number">29</span>:<span class="number">01.004735</span>Z   <span class="number">11</span> Query<span class="keyword">SELECT</span> DATABASE()</span><br><span class="line"><span class="number">2023</span><span class="number">-07</span><span class="number">-22</span>T06:<span class="number">29</span>:<span class="number">01.004903</span>Z   <span class="number">11</span> Init DBatguigudb2</span><br><span class="line"><span class="number">2023</span><span class="number">-07</span><span class="number">-22</span>T06:<span class="number">29</span>:<span class="number">01.005518</span>Z   <span class="number">11</span> Query<span class="keyword">show</span> databases</span><br><span class="line"><span class="number">2023</span><span class="number">-07</span><span class="number">-22</span>T06:<span class="number">29</span>:<span class="number">01.006686</span>Z   <span class="number">11</span> Query<span class="keyword">show</span> tables</span><br><span class="line"><span class="number">2023</span><span class="number">-07</span><span class="number">-22</span>T06:<span class="number">29</span>:<span class="number">01.007981</span>Z   <span class="number">11</span> Field Lista </span><br><span class="line"><span class="number">2023</span><span class="number">-07</span><span class="number">-22</span>T06:<span class="number">29</span>:<span class="number">01.008874</span>Z   <span class="number">11</span> Field Listb </span><br><span class="line"><span class="number">2023</span><span class="number">-07</span><span class="number">-22</span>T06:<span class="number">29</span>:<span class="number">01.009481</span>Z   <span class="number">11</span> Field Listbook </span><br><span class="line"><span class="number">2023</span><span class="number">-07</span><span class="number">-22</span>T06:<span class="number">29</span>:<span class="number">01.010170</span>Z   <span class="number">11</span> Field Listclass </span><br><span class="line"><span class="number">2023</span><span class="number">-07</span><span class="number">-22</span>T06:<span class="number">29</span>:<span class="number">01.011040</span>Z   <span class="number">11</span> Field Liststudent </span><br><span class="line"><span class="number">2023</span><span class="number">-07</span><span class="number">-22</span>T06:<span class="number">29</span>:<span class="number">01.011209</span>Z   <span class="number">11</span> Field Listtype </span><br><span class="line"><span class="number">2023</span><span class="number">-07</span><span class="number">-22</span>T06:<span class="number">29</span>:<span class="number">01.011303</span>Z   <span class="number">11</span> Field Listuser3 </span><br><span class="line"><span class="number">2023</span><span class="number">-07</span><span class="number">-22</span>T06:<span class="number">29</span>:<span class="number">13.504517</span>Z   <span class="number">11</span> Query<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student</span><br><span class="line"><span class="number">2023</span><span class="number">-07</span><span class="number">-22</span>T06:<span class="number">29</span>:<span class="number">32.236803</span>Z   <span class="number">11</span> Query<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> type</span><br><span class="line"><span class="number">2023</span><span class="number">-07</span><span class="number">-22</span>T06:<span class="number">29</span>:<span class="number">58.236644</span>Z   <span class="number">11</span> Quit</span><br></pre></td></tr></table></figure><p>在通用查询日志里面，我们可以清楚地看到，什么时候开启了新的客户端登陆数据库，登录之后做了什么 SQL 操作，针对的是哪个数据表等信息。</p><h3 id="3-5-停止日志"><a href="#3-5-停止日志" class="headerlink" title="3.5 停止日志"></a>3.5 停止日志</h3><p><strong>方式1：永久性方式</strong><br>修改 my.cnf 或者 my.ini 文件，把[mysqld]组下的 general_log 值设置为 OFF 或者把general_log一项注释掉。修改保存后，再 重启MySQL服务 ，即可生效。</p><p>举例1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">general_log<span class="operator">=</span>OFF</span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#general_log<span class="operator">=</span><span class="keyword">ON</span></span><br></pre></td></tr></table></figure><p><strong>方式2：临时性方式</strong><br>使用SET语句停止MySQL通用查询日志功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log<span class="operator">=</span>off;</span><br></pre></td></tr></table></figure><p>查询通用日志功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;general_log%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="3-6-删除-刷新日志"><a href="#3-6-删除-刷新日志" class="headerlink" title="3.6 删除\刷新日志"></a>3.6 删除\刷新日志</h3><p>如果数据的使用非常频繁，那么通用查询日志会占用服务器非常大的磁盘空间。数据管理员可以删除很长时间之前的查询日志，以保证MySQL服务器上的硬盘空间</p><p><strong>手动删除文件</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;general_log%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以看出，通用查询日志的目录默认为MySQL数据目录。在该目录下手动删除通用查询日志hadoop01.log。</p><p>使用如下命令重新生成查询日志文件，具体命令如下。刷新MySQL数据目录，发现创建了新的日志文件。前提一定要开启通用日志。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs</span><br></pre></td></tr></table></figure><p>如果希望备份旧的通用查询日志，就必须先将旧的日志文件复制出来或者改名，然后执行上面的mysqladmin命令。正确流程如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd mysql<span class="operator">-</span>data<span class="operator">-</span>directory #输入自己的通用日志文件所在目录</span><br><span class="line">mv mysql.general.log mysql.general.log.old #指名就的文件名 以及新的文件名</span><br><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs</span><br></pre></td></tr></table></figure><h2 id="4-错误日志-error-log"><a href="#4-错误日志-error-log" class="headerlink" title="4. 错误日志(error log)"></a>4. 错误日志(error log)</h2><p>错误日志记录了MySQL服务器启动、停止运行的时间，以及系统启动、运行和停止过程中的诊断信息，包括<code>错误</code>、<code>警告</code>和<code>提示</code>等。</p><p>通过错误日志可以查看系统的运行状态，便于即时发现故障、修复故障。如果MysQL服务<code>出现异常</code>，错误日志是发现问题、解决故障的<code>首选</code>。</p><h3 id="4-1-启动日志"><a href="#4-1-启动日志" class="headerlink" title="4.1 启动日志"></a>4.1 启动日志</h3><p>在MySQL数据库中，错误日志功能是 <code>默认开启</code> 的。而且，错误日志 <code>无法被禁止</code> 。</p><p>默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认为 <code>mysqld.log </code>（Linux系统）或 <code>hostname.err</code> （mac系统）。如果需要制定文件名，则需要在my.cnf或者my.ini中做如下配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log<span class="operator">-</span>error<span class="operator">=</span>[path<span class="operator">/</span>[filename]] #path为日志文件所在的目录路径，filename为日志文件名</span><br></pre></td></tr></table></figure><p>修改配置项后，需要重启MySQL服务以生效。</p><h3 id="4-2-查看日志"><a href="#4-2-查看日志" class="headerlink" title="4.2 查看日志"></a>4.2 查看日志</h3><p>MySQL错误日志是以文本文件形式存储的，可以使用文本编辑器直接查看。</p><p>查询错误日志的存储路径：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;log_err%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name              <span class="operator">|</span> <span class="keyword">Value</span>                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> log_error                  <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysqld.log                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_error_services         <span class="operator">|</span> log_filter_internal; log_sink_internal <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_error_suppression_list <span class="operator">|</span>                                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_error_verbosity        <span class="operator">|</span> <span class="number">2</span>                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+----------------------------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>执行结果中可以看到错误日志文件是mysqld.log，位于MySQL默认的数据目录下。</p><p>下面我们查看一下错误日志的内容。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@hadoop102</span> log]# cat mysqld.log</span><br><span class="line"><span class="number">2022</span><span class="number">-05</span><span class="number">-09</span>T13:<span class="number">36</span>:<span class="number">18.316947</span>Z <span class="number">0</span> [<span class="keyword">System</span>] [MY<span class="number">-013169</span>] [Server] <span class="operator">/</span>usr<span class="operator">/</span>sbin<span class="operator">/</span>mysqld (mysqld <span class="number">8.0</span><span class="number">.25</span>) initializing <span class="keyword">of</span> server <span class="keyword">in</span> progress <span class="keyword">as</span> process <span class="number">8770</span></span><br><span class="line"><span class="number">2022</span><span class="number">-05</span><span class="number">-09</span>T13:<span class="number">36</span>:<span class="number">18.339461</span>Z <span class="number">1</span> [<span class="keyword">System</span>] [MY<span class="number">-013576</span>] [InnoDB] InnoDB initialization has started.</span><br><span class="line"><span class="number">2022</span><span class="number">-05</span><span class="number">-09</span>T13:<span class="number">36</span>:<span class="number">18.969919</span>Z <span class="number">1</span> [<span class="keyword">System</span>] [MY<span class="number">-013577</span>] [InnoDB] InnoDB initialization has ended.</span><br><span class="line"><span class="number">2022</span><span class="number">-05</span><span class="number">-09</span>T13:<span class="number">36</span>:<span class="number">20.519755</span>Z <span class="number">6</span> [Note] [MY<span class="number">-010454</span>] [Server] A temporary password <span class="keyword">is</span> generated <span class="keyword">for</span> root<span class="variable">@localhost</span>: wtOQr<span class="operator">&lt;</span>yC9NHM</span><br><span class="line"><span class="number">2022</span><span class="number">-05</span><span class="number">-09</span>T13:<span class="number">37</span>:<span class="number">00.981062</span>Z <span class="number">0</span> [<span class="keyword">System</span>] [MY<span class="number">-010116</span>] [Server] <span class="operator">/</span>usr<span class="operator">/</span>sbin<span class="operator">/</span>mysqld (mysqld <span class="number">8.0</span><span class="number">.25</span>) starting <span class="keyword">as</span> process <span class="number">8872</span></span><br><span class="line"><span class="number">2022</span><span class="number">-05</span><span class="number">-09</span>T13:<span class="number">37</span>:<span class="number">00.993416</span>Z <span class="number">1</span> [<span class="keyword">System</span>] [MY<span class="number">-013576</span>] [InnoDB] InnoDB initialization has started.</span><br><span class="line"><span class="number">2022</span><span class="number">-05</span><span class="number">-09</span>T13:<span class="number">37</span>:<span class="number">01.118904</span>Z <span class="number">1</span> [<span class="keyword">System</span>] [MY<span class="number">-013577</span>] [InnoDB] InnoDB initialization has ended.</span><br><span class="line"><span class="number">2022</span><span class="number">-05</span><span class="number">-09</span>T13:<span class="number">37</span>:<span class="number">01.211523</span>Z <span class="number">0</span> [<span class="keyword">System</span>] [MY<span class="number">-011323</span>] [Server] X Plugin ready <span class="keyword">for</span> connections. Bind<span class="operator">-</span>address: <span class="string">&#x27;::&#x27;</span> port: <span class="number">33060</span>, socket: <span class="operator">/</span>var<span class="operator">/</span>run<span class="operator">/</span>mysqld<span class="operator">/</span>mysqlx.sock</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>...</span><br></pre></td></tr></table></figure><p>可以看到，错误日志文件中记录了服务器启动的时间，以及存储引擎InnoDB启动和停止等，我们在做初始化时候生成的数据库初始密码也是记录在error.log中。</p><h3 id="4-3-删除-刷新日志"><a href="#4-3-删除-刷新日志" class="headerlink" title="4.3 删除\刷新日志"></a>4.3 删除\刷新日志</h3><p>对于很久以前的错误日志，数据库管理员查看这些错误日志的可能性不大，可以将这些错误日志删除，以保证MySQL服务器上的 <code>硬盘空间</code> 。MySQL的错误日志是以文本文件的形式存储在文件系统中的，可以<code>直接删除</code>。</p><ul><li>第1步(方式1)︰删除操作 <code>rm</code>   （ 在运行状态下删除错误日志文件后，MySQL并不会自动创建日志文件）</li><li>第1步(方式2)︰重命名文件 <code>mv</code></li><li>第2步：重建日志 <code>mysqladmin -uroot -p flush-logs</code></li></ul><p>可能报错</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@atguigu01</span> log]# mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs</span><br><span class="line">Enter password:</span><br><span class="line">mysqladmin: refresh failed; error: <span class="string">&#x27;Could not open file &#x27;</span><span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysqld.log<span class="string">&#x27; for error logging.&#x27;</span></span><br></pre></td></tr></table></figure><p>官网提示:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557335.png" alt="image-20230722145912407"></p><p>执行下面命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install <span class="operator">-</span>omysql <span class="operator">-</span>gmysql <span class="operator">-</span>m0644 <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysqld.log</span><br></pre></td></tr></table></figure><p><code>flush-logs</code>指令操作:</p><p>MySQL 5.5.7以前的版本，flush-logs将错误日志文件重命名为filename.err_old，并创建新的日志文件。<br>从MySQL 5.5.7开始，flush-logs只是重新打开日志文件，并不做日志备份和创建的操作。<br>如果日志文件不存在，MySQL启动或者执行flush-logs时会自动创建新的日志文件。重新创建错误日志，大小为0字节。</p><h3 id="4-4-MySQL8-0新特性"><a href="#4-4-MySQL8-0新特性" class="headerlink" title="4.4 MySQL8.0新特性"></a>4.4 MySQL8.0新特性</h3><p>MySQL8.0里对错误日志的改进。MySQL8.0的错误日志可以理解为一个全新的日志，在这个版本里，接受了来自社区的广泛批评意见，在这些意见和建议的基础上生成了新的日志。</p><ul><li>下面这些是来自社区的意见:</li><li>默认情况下内容过于冗长</li><li>遗漏了有用的信息</li><li>难以过滤某些信息</li><li>没有标识错误信息的子系统源</li><li>没有错误代码，解析消息需要识别错误</li><li>引导消息可能会丢失</li><li>固定格式</li></ul><p>针对这些意见，MySQL做了如下改变:</p><ul><li>采用组件架构，通过不同的组件执行日志的写入和过滤功能</li><li>写入错误日志的全部信息都具有唯一的错误代码从10000开始</li><li>增加了一个新的消息分类《system》用于在错误日志中始终可见的非错误但服务器状态更改事件的消息。增加了额外的附加信息，例如关机时的版本信息，谁发起的关机等等</li><li>两种过滤方式，Internal和Dragnet</li><li>三种写入形式，经典、JSON和syseventlog</li></ul><blockquote><p>小结:</p><p>通常情况下，管理员不需要查看错误日志。但是，MySQL服务器发生异常时，管理员可以从错误日志中找到发生异常的时间、原因，然后根据这些信息来解决异常。</p></blockquote><h2 id="5-二进制日志-bin-log"><a href="#5-二进制日志-bin-log" class="headerlink" title="5. 二进制日志(bin log)"></a>5. 二进制日志(bin log)</h2><p>binlog可以说是MySQL中比较 <code>重要</code> 的日志了，在日常开发及运维过程中，经常会遇到。</p><p>binlog即binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的<code>DD </code>和 <code>DML</code> 等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、show等）。</p><p>它以<code>事件形式</code>记录并保存在<code>二进制文件</code>中。通过这些信息，我们可以再现数据更新操作的全过程。</p><blockquote><p>如果想要记录所有语句（例如，为了识别有问题的查询)，需要使用通用查询日志。</p></blockquote><p>binlog主要应用场景:</p><ul><li>一是用于<code>数据恢复</code>，如果MySQL数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。</li><li>二是用于<code>数据复制</code>，由于日志的延续性和时效性，master把它的二进制日志传递给slaves来达到master-slave数据—致的目的。<br>可以说MySQL数据库的<strong>数据备份、主备、主主、主从</strong>都离不开binlog，需要依靠binlog来同步数据，保证数据—致性。</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557329.png" alt="image-20230722145925374"></p><h3 id="5-1-查看默认情况"><a href="#5-1-查看默认情况" class="headerlink" title="5.1 查看默认情况"></a>5.1 查看默认情况</h3><p>查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制文件是开启的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                   <span class="operator">|</span> <span class="keyword">Value</span>                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> log_bin                         <span class="operator">|</span> <span class="keyword">ON</span>                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_basename                <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>binlog       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_index                   <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>binlog.index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_trust_function_creators <span class="operator">|</span> OFF                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_use_v1_row_events       <span class="operator">|</span> OFF                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sql_log_bin                     <span class="operator">|</span> <span class="keyword">ON</span>                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+-----------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><code>log_bin_basename </code>: 是binlog日志的基本文件名，后面会追加标识来表示每一个文件</p><p> <code>log_bin_index</code>:是binlog文件的索引文件，这个文件管理了所有的binlog文件的目录</p><p><code>log_bin_trust_function_creators</code>: 限制存储过程，前面我们已经讲过了，这是因为二进制日志的一个重要功能是用于主从复制，而存储函数有可能导致主从的数据不一致。所以当开启二进制日志后，需要限制存储函数的创建、修改、调用</p><p><code>log_bin_use_v1_row_events </code>：此只读系统变量已弃用。ON表示使用版本1二进制日志行，OFF表示使用版本2二进制日志行(MysQL 5.6的默认值为2)。</p><p>每次服务重启，都会新创建一个binlog</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557357.png" alt="image-20230722152900088"></p><h3 id="5-2-日志参数设置"><a href="#5-2-日志参数设置" class="headerlink" title="5.2 日志参数设置"></a>5.2 日志参数设置</h3><p><strong>方式1：永久性方式</strong></p><p>修改MySQL的 my.cnf 或 my.ini 文件可以设置二进制日志的相关参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#启用二进制日志</span><br><span class="line">log<span class="operator">-</span>bin<span class="operator">=</span>atguigu<span class="operator">-</span>bin</span><br><span class="line">binlog_expire_logs_seconds<span class="operator">=</span><span class="number">600</span></span><br><span class="line">max_binlog_size<span class="operator">=</span><span class="number">100</span>M</span><br></pre></td></tr></table></figure><blockquote><p>提示:</p><ol><li>log-bin&#x3D;mysql-bin #打开日志(主机需要打开)，这个mysql-bin也可以自定义，这里也可以加上路径，如: &#x2F;home&#x2F;www&#x2F;mysql_bin_log&#x2F;mysql-bin</li><li>binlog_expire_logs_seconds:此参数控制二进制日志文件保留的时长，单位是秒，默认2592000 3(天– 14400 4小时; 86400 1天; 259200 3天;</li><li>max_binlog_size:控制单个二进制日志大小，当前日志文件大小超过此变量时，执行切换动作。此参数的<code>最大和默认值是1GB</code>，该设置并不能严格控制Binlog的大小，尤其是Binlog比较靠近最大值而又遇到一个比较大事务时，为了保证事务的完整性，可能不做切换日志的动作，只能将该事务的所有SQL都记录进当前日志，直到事务结束。一般情况下可采取默认值</li></ol></blockquote><p>重新启动MySQL服务，查询二进制日志的信息，执行结果：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557333.png" alt="image-20230722161129546"></p><p><strong>设置带文件夹的bin-log日志存放目录</strong></p><p>如果想改变日志文件的目录和名称，可以对my.cnf或my.ini中的log_bin参数修改如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log<span class="operator">-</span>bin<span class="operator">=</span>&quot;/var/lib/mysql/binlog/atguigu-bin&quot;</span><br></pre></td></tr></table></figure><p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown <span class="operator">-</span>R <span class="operator">-</span>v mysql:mysql binlog</span><br></pre></td></tr></table></figure><p>重启MySQL服务之后，新的二进制日志文件将出现在&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;binlog&#x2F;文件夹下面:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                   <span class="operator">|</span> <span class="keyword">Value</span>                            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> log_bin                         <span class="operator">|</span> <span class="keyword">ON</span>                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_basename                <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu<span class="operator">-</span>bin       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_index                   <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu<span class="operator">-</span>bin.index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_trust_function_creators <span class="operator">|</span> OFF                              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_use_v1_row_events       <span class="operator">|</span> OFF                              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sql_log_bin                     <span class="operator">|</span> <span class="keyword">ON</span>                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+----------------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><blockquote><p>提示：<code>数据库文件最好不要与日志文件放在同一个磁盘上!</code> 这样，当数据库文件所在的磁盘发生故障时，可以使用日志文件恢复数据。</p></blockquote><p><strong>方式2：临时性方式</strong></p><p>如果不希望通过修改配置文件并重启的方式设置二进制日志的话，还可以使用如下指令，需要注意的是在mysql8中只有 会话级别 的设置，没有了global级别的设置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">global</span> 级别</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> sql_log_bin<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">#ERROR <span class="number">1228</span> (HY000): Variable <span class="string">&#x27;sql_log_bin&#x27;</span> <span class="keyword">is</span> a SESSION variable <span class="keyword">and</span> can`t be used <span class="keyword">with</span> <span class="keyword">SET</span> <span class="keyword">GLOBAL</span></span><br><span class="line"></span><br><span class="line"># session级别</span><br><span class="line"><span class="keyword">SET</span> sql_log_bin<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">#Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> 秒)</span><br></pre></td></tr></table></figure><h3 id="5-3-查看日志"><a href="#5-3-查看日志" class="headerlink" title="5.3 查看日志"></a>5.3 查看日志</h3><p>当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一个以“filename”为名称、以“.000001”为后缀的文件。</p><p>MySQL服务 <code>重新启动一次</code> ，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的个数与MySQL服务启动的次数相同；如果日志长度超过了 <code>max_binlog_size </code>的上限（默认是1GB），就会创建一个新的日志文件。</p><p>查看当前的二进制日志文件列表及大小。指令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS; </span><br><span class="line">ERROR <span class="number">2013</span> (HY000): Lost connection <span class="keyword">to</span> MySQL server during query</span><br><span class="line"><span class="keyword">No</span> connection. Trying <span class="keyword">to</span> reconnect...</span><br><span class="line">Connection id:    <span class="number">8</span></span><br><span class="line"><span class="keyword">Current</span> database: <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="keyword">NONE</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Log_name           <span class="operator">|</span> File_size <span class="operator">|</span> Encrypted <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span>       <span class="number">179</span> <span class="operator">|</span> <span class="keyword">No</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span>       <span class="number">156</span> <span class="operator">|</span> <span class="keyword">No</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>所有对数据库的修改都会记录在binglog中。但binlog是二进制文件，无法直接查看，想要更直观的观测它就要借助<code>mysqlbinlog</code>命令工具了。指令如下:在查看执行，先执行两条SQL语句，如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">18</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;四班&#x27;</span>);</span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>开始查看binlog</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@hadoop102</span> mysql]# mysqlbinlog &quot;/var/lib/mysql/atguigu-bin.000002&quot;</span><br><span class="line"><span class="comment">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/</span>;</span><br><span class="line"><span class="comment">/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/</span>;</span><br><span class="line">DELIMITER <span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">4</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">20</span> server id <span class="number">1</span>  end_log_pos <span class="number">125</span> CRC32 <span class="number">0xfbe10f64</span> <span class="keyword">Start</span>: binlog v <span class="number">4</span>, server v <span class="number">8.0</span><span class="number">.25</span> created <span class="number">230722</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">20</span> <span class="keyword">at</span> startup</span><br><span class="line"># Warning: this binlog <span class="keyword">is</span> either <span class="keyword">in</span> use <span class="keyword">or</span> was <span class="keyword">not</span> closed properly.</span><br><span class="line"><span class="keyword">ROLLBACK</span><span class="comment">/*!*/</span>;</span><br><span class="line">BINLOG <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">547</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02</span> server id <span class="number">1</span>  end_log_pos <span class="number">637</span> CRC32 <span class="number">0x0e4d6052</span> Querythread_id<span class="operator">=</span><span class="number">8</span>exec_time<span class="operator">=</span><span class="number">0</span>error_code<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span><span class="number">1690013942</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>......</span><br><span class="line"># <span class="keyword">at</span> <span class="number">776</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02</span> server id <span class="number">1</span>  end_log_pos <span class="number">807</span> CRC32 <span class="number">0x6f80cb79</span> Xid <span class="operator">=</span> <span class="number">15</span></span><br><span class="line"><span class="keyword">COMMIT</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;AUTOMATIC&#x27;</span> <span class="comment">/* added by mysqlbinlog */</span> <span class="comment">/*!*/</span>;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># <span class="keyword">End</span> <span class="keyword">of</span> log file</span><br><span class="line"><span class="comment">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/</span>;</span><br><span class="line"><span class="comment">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/</span>;</span><br></pre></td></tr></table></figure><p>执行结果可以看到，这是一个简单的日志文件，日志中记录了用户的一些操作，这里并没有出现具体的SQL语句，这是因为binlog关键字后面的内容是经过编码后的<code>二进制日志</code>。</p><p>这里一个update语句包含如下事件</p><ul><li>Query事件负责开始一个事务(BEGIN)</li><li>Table_map事件负责映射需要的表.</li><li>Update_rows事件负责写入数据</li><li>Xid事件负责结束事务</li></ul><p>下面命令将行事件以 <code>伪SQL的形式</code> 表现出来</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@hadoop102</span> mysql]# mysqlbinlog <span class="operator">-</span>v &quot;/var/lib/mysql/atguigu-bin.000002&quot;</span><br><span class="line"><span class="comment">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/</span>;</span><br><span class="line"><span class="comment">/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/</span>;</span><br><span class="line">DELIMITER <span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">4</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">20</span> server id <span class="number">1</span>  end_log_pos <span class="number">125</span> CRC32 <span class="number">0xfbe10f64</span> <span class="keyword">Start</span>: binlog v <span class="number">4</span>, server v <span class="number">8.0</span><span class="number">.25</span> created <span class="number">230722</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">20</span> <span class="keyword">at</span> startup</span><br><span class="line"># Warning: this binlog <span class="keyword">is</span> either <span class="keyword">in</span> use <span class="keyword">or</span> was <span class="keyword">not</span> closed properly.</span><br><span class="line"><span class="keyword">ROLLBACK</span><span class="comment">/*!*/</span>;</span><br><span class="line">BINLOG <span class="string">&#x27;</span></span><br><span class="line"><span class="string">3I+7ZA8BAAAAeQAAAH0AAAABAAQAOC4wLjI1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span></span><br><span class="line"><span class="string">AAAAAAAAAAAAAAAAAADcj7tkEwANAAgAAAAABAAEAAAAYQAEGggAAAAICAgCAAAACgoKKioAEjQA</span></span><br><span class="line"><span class="string">CigBZA/h+w==</span></span><br><span class="line"><span class="string">&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">125</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">20</span> server id <span class="number">1</span>  end_log_pos <span class="number">156</span> CRC32 <span class="number">0x7b4b2408</span> Previous<span class="operator">-</span>GTIDs</span><br><span class="line"># [<span class="keyword">empty</span>]</span><br><span class="line"># <span class="keyword">at</span> <span class="number">156</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">26</span> server id <span class="number">1</span>  end_log_pos <span class="number">235</span> CRC32 <span class="number">0x80f68688</span> Anonymous_GTIDlast_committed<span class="operator">=</span><span class="number">0</span>sequence_number<span class="operator">=</span><span class="number">1</span>rbr_only<span class="operator">=</span>yesoriginal_committed_timestamp<span class="operator">=</span><span class="number">1690013906305153</span>immediate_commit_timestamp<span class="operator">=</span><span class="number">1690013906305153</span>transaction_length<span class="operator">=</span><span class="number">312</span></span><br><span class="line"><span class="comment">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"># original_commit_timestamp<span class="operator">=</span><span class="number">1690013906305153</span> (<span class="number">2023</span><span class="number">-07</span><span class="number">-22</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">26.305153</span> CST)</span><br><span class="line"># immediate_commit_timestamp<span class="operator">=</span><span class="number">1690013906305153</span> (<span class="number">2023</span><span class="number">-07</span><span class="number">-22</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">26.305153</span> CST)</span><br><span class="line"><span class="comment">/*!80001 SET @@session.original_commit_timestamp=1690013906305153*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!80014 SET @@session.original_server_version=80025*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!80014 SET @@session.immediate_server_version=80025*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">235</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">26</span> server id <span class="number">1</span>  end_log_pos <span class="number">316</span> CRC32 <span class="number">0x0e6498f6</span> Querythread_id<span class="operator">=</span><span class="number">8</span>exec_time<span class="operator">=</span><span class="number">0</span>error_code<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span><span class="number">1690013906</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.pseudo_thread_id<span class="operator">=</span><span class="number">8</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.foreign_key_checks<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.sql_auto_is_null<span class="operator">=</span><span class="number">0</span>, @<span class="variable">@session</span>.unique_checks<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.autocommit<span class="operator">=</span><span class="number">1</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.sql_mode<span class="operator">=</span><span class="number">1168113696</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.auto_increment_increment<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.auto_increment_offset<span class="operator">=</span><span class="number">1</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!\C utf8mb4 */</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.character_set_client<span class="operator">=</span><span class="number">255</span>,@<span class="variable">@session</span>.collation_connection<span class="operator">=</span><span class="number">255</span>,@<span class="variable">@session</span>.collation_server<span class="operator">=</span><span class="number">255</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.lc_time_names<span class="operator">=</span><span class="number">0</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.collation_database<span class="operator">=</span><span class="keyword">DEFAULT</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!80011 SET @@session.default_collation_for_utf8mb4=255*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">316</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">26</span> server id <span class="number">1</span>  end_log_pos <span class="number">384</span> CRC32 <span class="number">0xa3ddc17f</span> Table_map: `atguigudb3`.`student` mapped <span class="keyword">to</span> number <span class="number">92</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">384</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">26</span> server id <span class="number">1</span>  end_log_pos <span class="number">437</span> CRC32 <span class="number">0x77beae88</span> Write_rows: <span class="keyword">table</span> id <span class="number">92</span> flags: STMT_END_F</span><br><span class="line"></span><br><span class="line">BINLOG <span class="string">&#x27;</span></span><br><span class="line"><span class="string">0pC7ZBMBAAAARAAAAIABAAAAAFwAAAAAAAEACmF0Z3VpZ3VkYjMAB3N0dWRlbnQAAwMPDwQ8AB4A</span></span><br><span class="line"><span class="string">BgEBAAIBIX/B3aM=</span></span><br><span class="line"><span class="string">0pC7ZB4BAAAANQAAALUBAAAAAFwAAAAAAAEAAgAD/wASAAAABUplcnJ5BuWbm+ePrYiuvnc=</span></span><br><span class="line"><span class="string">&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line">### <span class="keyword">INSERT</span> <span class="keyword">INTO</span> `atguigudb3`.`student`</span><br><span class="line">### <span class="keyword">SET</span></span><br><span class="line">###   <span class="variable">@1</span><span class="operator">=</span><span class="number">18</span></span><br><span class="line">###   <span class="variable">@2</span><span class="operator">=</span><span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line">###   <span class="variable">@3</span><span class="operator">=</span><span class="string">&#x27;四班&#x27;</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">437</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">26</span> server id <span class="number">1</span>  end_log_pos <span class="number">468</span> CRC32 <span class="number">0x0ba33a3f</span> Xid <span class="operator">=</span> <span class="number">14</span></span><br><span class="line"><span class="keyword">COMMIT</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">468</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02</span> server id <span class="number">1</span>  end_log_pos <span class="number">547</span> CRC32 <span class="number">0xcd6ec87a</span> Anonymous_GTIDlast_committed<span class="operator">=</span><span class="number">1</span>sequence_number<span class="operator">=</span><span class="number">2</span>rbr_only<span class="operator">=</span>yesoriginal_committed_timestamp<span class="operator">=</span><span class="number">1690013942336137</span>immediate_commit_timestamp<span class="operator">=</span><span class="number">1690013942336137</span>transaction_length<span class="operator">=</span><span class="number">339</span></span><br><span class="line"><span class="comment">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"># original_commit_timestamp<span class="operator">=</span><span class="number">1690013942336137</span> (<span class="number">2023</span><span class="number">-07</span><span class="number">-22</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02.336137</span> CST)</span><br><span class="line"># immediate_commit_timestamp<span class="operator">=</span><span class="number">1690013942336137</span> (<span class="number">2023</span><span class="number">-07</span><span class="number">-22</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02.336137</span> CST)</span><br><span class="line"><span class="comment">/*!80001 SET @@session.original_commit_timestamp=1690013942336137*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!80014 SET @@session.original_server_version=80025*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!80014 SET @@session.immediate_server_version=80025*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">547</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02</span> server id <span class="number">1</span>  end_log_pos <span class="number">637</span> CRC32 <span class="number">0x0e4d6052</span> Querythread_id<span class="operator">=</span><span class="number">8</span>exec_time<span class="operator">=</span><span class="number">0</span>error_code<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span><span class="number">1690013942</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">637</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02</span> server id <span class="number">1</span>  end_log_pos <span class="number">705</span> CRC32 <span class="number">0xdff84bbe</span> Table_map: `atguigudb3`.`student` mapped <span class="keyword">to</span> number <span class="number">92</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">705</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02</span> server id <span class="number">1</span>  end_log_pos <span class="number">776</span> CRC32 <span class="number">0xfbd17653</span> Update_rows: <span class="keyword">table</span> id <span class="number">92</span> flags: STMT_END_F</span><br><span class="line"></span><br><span class="line">BINLOG <span class="string">&#x27;</span></span><br><span class="line"><span class="string">9pC7ZBMBAAAARAAAAMECAAAAAFwAAAAAAAEACmF0Z3VpZ3VkYjMAB3N0dWRlbnQAAwMPDwQ8AB4A</span></span><br><span class="line"><span class="string">BgEBAAIBIb5L+N8=</span></span><br><span class="line"><span class="string">9pC7ZB8BAAAARwAAAAgDAAAAAFwAAAAAAAEAAgAD//8ADwAAAAbotbXlha0G5LqM54+tAA8AAAAD</span></span><br><span class="line"><span class="string">VG9tBuS6jOePrVN20fs=</span></span><br><span class="line"><span class="string">&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line">### <span class="keyword">UPDATE</span> `atguigudb3`.`student`</span><br><span class="line">### <span class="keyword">WHERE</span></span><br><span class="line">###   <span class="variable">@1</span><span class="operator">=</span><span class="number">15</span></span><br><span class="line">###   <span class="variable">@2</span><span class="operator">=</span><span class="string">&#x27;赵六&#x27;</span></span><br><span class="line">###   <span class="variable">@3</span><span class="operator">=</span><span class="string">&#x27;二班&#x27;</span></span><br><span class="line">### <span class="keyword">SET</span></span><br><span class="line">###   <span class="variable">@1</span><span class="operator">=</span><span class="number">15</span></span><br><span class="line">###   <span class="variable">@2</span><span class="operator">=</span><span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">###   <span class="variable">@3</span><span class="operator">=</span><span class="string">&#x27;二班&#x27;</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">776</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02</span> server id <span class="number">1</span>  end_log_pos <span class="number">807</span> CRC32 <span class="number">0x6f80cb79</span> Xid <span class="operator">=</span> <span class="number">15</span></span><br><span class="line"><span class="keyword">COMMIT</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;AUTOMATIC&#x27;</span> <span class="comment">/* added by mysqlbinlog */</span> <span class="comment">/*!*/</span>;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># <span class="keyword">End</span> <span class="keyword">of</span> log file</span><br><span class="line"><span class="comment">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/</span>;</span><br><span class="line"><span class="comment">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面的命令同时显示binlog格式的语句，使用如下命令不显示它</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@hadoop102</span> mysql]# mysqlbinlog <span class="operator">-</span>v <span class="comment">--base64-output=DECODE-ROWS &quot;/var/lib/mysql/atguigu-bin.000002&quot;</span></span><br><span class="line"><span class="comment">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/</span>;</span><br><span class="line"><span class="comment">/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/</span>;</span><br><span class="line">DELIMITER <span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">4</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">20</span> server id <span class="number">1</span>  end_log_pos <span class="number">125</span> CRC32 <span class="number">0xfbe10f64</span> <span class="keyword">Start</span>: binlog v <span class="number">4</span>, server v <span class="number">8.0</span><span class="number">.25</span> created <span class="number">230722</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">20</span> <span class="keyword">at</span> startup</span><br><span class="line"># Warning: this binlog <span class="keyword">is</span> either <span class="keyword">in</span> use <span class="keyword">or</span> was <span class="keyword">not</span> closed properly.</span><br><span class="line"><span class="keyword">ROLLBACK</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">125</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">20</span> server id <span class="number">1</span>  end_log_pos <span class="number">156</span> CRC32 <span class="number">0x7b4b2408</span> Previous<span class="operator">-</span>GTIDs</span><br><span class="line"># [<span class="keyword">empty</span>]</span><br><span class="line"># <span class="keyword">at</span> <span class="number">156</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">26</span> server id <span class="number">1</span>  end_log_pos <span class="number">235</span> CRC32 <span class="number">0x80f68688</span> Anonymous_GTIDlast_committed<span class="operator">=</span><span class="number">0</span>sequence_number<span class="operator">=</span><span class="number">1</span>rbr_only<span class="operator">=</span>yesoriginal_committed_timestamp<span class="operator">=</span><span class="number">1690013906305153</span>immediate_commit_timestamp<span class="operator">=</span><span class="number">1690013906305153</span>transaction_length<span class="operator">=</span><span class="number">312</span></span><br><span class="line"><span class="comment">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"># original_commit_timestamp<span class="operator">=</span><span class="number">1690013906305153</span> (<span class="number">2023</span><span class="number">-07</span><span class="number">-22</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">26.305153</span> CST)</span><br><span class="line"># immediate_commit_timestamp<span class="operator">=</span><span class="number">1690013906305153</span> (<span class="number">2023</span><span class="number">-07</span><span class="number">-22</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">26.305153</span> CST)</span><br><span class="line"><span class="comment">/*!80001 SET @@session.original_commit_timestamp=1690013906305153*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!80014 SET @@session.original_server_version=80025*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!80014 SET @@session.immediate_server_version=80025*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">235</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">26</span> server id <span class="number">1</span>  end_log_pos <span class="number">316</span> CRC32 <span class="number">0x0e6498f6</span> Querythread_id<span class="operator">=</span><span class="number">8</span>exec_time<span class="operator">=</span><span class="number">0</span>error_code<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span><span class="number">1690013906</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.pseudo_thread_id<span class="operator">=</span><span class="number">8</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.foreign_key_checks<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.sql_auto_is_null<span class="operator">=</span><span class="number">0</span>, @<span class="variable">@session</span>.unique_checks<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.autocommit<span class="operator">=</span><span class="number">1</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.sql_mode<span class="operator">=</span><span class="number">1168113696</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.auto_increment_increment<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.auto_increment_offset<span class="operator">=</span><span class="number">1</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!\C utf8mb4 */</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.character_set_client<span class="operator">=</span><span class="number">255</span>,@<span class="variable">@session</span>.collation_connection<span class="operator">=</span><span class="number">255</span>,@<span class="variable">@session</span>.collation_server<span class="operator">=</span><span class="number">255</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.lc_time_names<span class="operator">=</span><span class="number">0</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.collation_database<span class="operator">=</span><span class="keyword">DEFAULT</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!80011 SET @@session.default_collation_for_utf8mb4=255*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">316</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">26</span> server id <span class="number">1</span>  end_log_pos <span class="number">384</span> CRC32 <span class="number">0xa3ddc17f</span> Table_map: `atguigudb3`.`student` mapped <span class="keyword">to</span> number <span class="number">92</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">384</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">26</span> server id <span class="number">1</span>  end_log_pos <span class="number">437</span> CRC32 <span class="number">0x77beae88</span> Write_rows: <span class="keyword">table</span> id <span class="number">92</span> flags: STMT_END_F</span><br><span class="line">### <span class="keyword">INSERT</span> <span class="keyword">INTO</span> `atguigudb3`.`student`</span><br><span class="line">### <span class="keyword">SET</span></span><br><span class="line">###   <span class="variable">@1</span><span class="operator">=</span><span class="number">18</span></span><br><span class="line">###   <span class="variable">@2</span><span class="operator">=</span><span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line">###   <span class="variable">@3</span><span class="operator">=</span><span class="string">&#x27;四班&#x27;</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">437</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">26</span> server id <span class="number">1</span>  end_log_pos <span class="number">468</span> CRC32 <span class="number">0x0ba33a3f</span> Xid <span class="operator">=</span> <span class="number">14</span></span><br><span class="line"><span class="keyword">COMMIT</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">468</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02</span> server id <span class="number">1</span>  end_log_pos <span class="number">547</span> CRC32 <span class="number">0xcd6ec87a</span> Anonymous_GTIDlast_committed<span class="operator">=</span><span class="number">1</span>sequence_number<span class="operator">=</span><span class="number">2</span>rbr_only<span class="operator">=</span>yesoriginal_committed_timestamp<span class="operator">=</span><span class="number">1690013942336137</span>immediate_commit_timestamp<span class="operator">=</span><span class="number">1690013942336137</span>transaction_length<span class="operator">=</span><span class="number">339</span></span><br><span class="line"><span class="comment">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"># original_commit_timestamp<span class="operator">=</span><span class="number">1690013942336137</span> (<span class="number">2023</span><span class="number">-07</span><span class="number">-22</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02.336137</span> CST)</span><br><span class="line"># immediate_commit_timestamp<span class="operator">=</span><span class="number">1690013942336137</span> (<span class="number">2023</span><span class="number">-07</span><span class="number">-22</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02.336137</span> CST)</span><br><span class="line"><span class="comment">/*!80001 SET @@session.original_commit_timestamp=1690013942336137*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!80014 SET @@session.original_server_version=80025*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!80014 SET @@session.immediate_server_version=80025*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">547</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02</span> server id <span class="number">1</span>  end_log_pos <span class="number">637</span> CRC32 <span class="number">0x0e4d6052</span> Querythread_id<span class="operator">=</span><span class="number">8</span>exec_time<span class="operator">=</span><span class="number">0</span>error_code<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span><span class="number">1690013942</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">637</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02</span> server id <span class="number">1</span>  end_log_pos <span class="number">705</span> CRC32 <span class="number">0xdff84bbe</span> Table_map: `atguigudb3`.`student` mapped <span class="keyword">to</span> number <span class="number">92</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">705</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02</span> server id <span class="number">1</span>  end_log_pos <span class="number">776</span> CRC32 <span class="number">0xfbd17653</span> Update_rows: <span class="keyword">table</span> id <span class="number">92</span> flags: STMT_END_F</span><br><span class="line">### <span class="keyword">UPDATE</span> `atguigudb3`.`student`</span><br><span class="line">### <span class="keyword">WHERE</span></span><br><span class="line">###   <span class="variable">@1</span><span class="operator">=</span><span class="number">15</span></span><br><span class="line">###   <span class="variable">@2</span><span class="operator">=</span><span class="string">&#x27;赵六&#x27;</span></span><br><span class="line">###   <span class="variable">@3</span><span class="operator">=</span><span class="string">&#x27;二班&#x27;</span></span><br><span class="line">### <span class="keyword">SET</span></span><br><span class="line">###   <span class="variable">@1</span><span class="operator">=</span><span class="number">15</span></span><br><span class="line">###   <span class="variable">@2</span><span class="operator">=</span><span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">###   <span class="variable">@3</span><span class="operator">=</span><span class="string">&#x27;二班&#x27;</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">776</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02</span> server id <span class="number">1</span>  end_log_pos <span class="number">807</span> CRC32 <span class="number">0x6f80cb79</span> Xid <span class="operator">=</span> <span class="number">15</span></span><br><span class="line"><span class="keyword">COMMIT</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;AUTOMATIC&#x27;</span> <span class="comment">/* added by mysqlbinlog */</span> <span class="comment">/*!*/</span>;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># <span class="keyword">End</span> <span class="keyword">of</span> log file</span><br><span class="line"><span class="comment">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/</span>;</span><br><span class="line"><span class="comment">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/</span>;</span><br></pre></td></tr></table></figure><p>关于mysqlbinlog工具的使用技巧还有很多，例如只解析对某个库的操作或者某个时间段内的操作等。简单分享几个常用的语句，更多操作可以参考官方文档。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#  可查看参数帮助</span><br><span class="line">mysqlbinlog  <span class="comment">--no-defaults --help</span></span><br><span class="line">#  查看最后<span class="number">100</span>行</span><br><span class="line">mysqlbinlog <span class="comment">--no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |tail -100</span></span><br><span class="line"># 根据position查找</span><br><span class="line">mysqlbinlog  <span class="comment">--no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |grep -A 20  &#x27;4939002&#x27;</span></span><br></pre></td></tr></table></figure><p>上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> binlog events [<span class="keyword">IN</span> <span class="string">&#x27;log_name&#x27;</span>] [<span class="keyword">FROM</span> pos] [LIMIT [<span class="keyword">offset</span>,] row_count];</span><br></pre></td></tr></table></figure><ul><li><code>IN ‘log_name’</code> ：指定要查询的binlog文件名（不指定就是第一个binlog文件）</li><li><code>FROM pos</code> ：指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）</li><li><code>LIMIT [offset]</code>：偏移量(不指定就是0)</li><li><code>row_count</code> :查询总条数（不指定就是所有行）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;atguigu-bin.000002&#x27;</span>;  </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----+----------------+-----------+-------------+--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Log_name           <span class="operator">|</span> Pos <span class="operator">|</span> Event_type     <span class="operator">|</span> Server_id <span class="operator">|</span> End_log_pos <span class="operator">|</span> Info                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----+----------------+-----------+-------------+--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span>   <span class="number">4</span> <span class="operator">|</span> Format_desc    <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">125</span> <span class="operator">|</span> Server ver: <span class="number">8.0</span><span class="number">.25</span>, Binlog ver: <span class="number">4</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">125</span> <span class="operator">|</span> Previous_gtids <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">156</span> <span class="operator">|</span>                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">156</span> <span class="operator">|</span> Anonymous_Gtid <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">235</span> <span class="operator">|</span> <span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">235</span> <span class="operator">|</span> Query          <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">316</span> <span class="operator">|</span> <span class="keyword">BEGIN</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">316</span> <span class="operator">|</span> Table_map      <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">384</span> <span class="operator">|</span> table_id: <span class="number">92</span> (atguigudb3.student)    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">384</span> <span class="operator">|</span> Write_rows     <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">437</span> <span class="operator">|</span> table_id: <span class="number">92</span> flags: STMT_END_F       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">437</span> <span class="operator">|</span> Xid            <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">468</span> <span class="operator">|</span> <span class="keyword">COMMIT</span> <span class="comment">/* xid=14 */</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">468</span> <span class="operator">|</span> Anonymous_Gtid <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">547</span> <span class="operator">|</span> <span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">547</span> <span class="operator">|</span> Query          <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">637</span> <span class="operator">|</span> <span class="keyword">BEGIN</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">637</span> <span class="operator">|</span> Table_map      <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">705</span> <span class="operator">|</span> table_id: <span class="number">92</span> (atguigudb3.student)    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">705</span> <span class="operator">|</span> Update_rows    <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">776</span> <span class="operator">|</span> table_id: <span class="number">92</span> flags: STMT_END_F       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">776</span> <span class="operator">|</span> Xid            <span class="operator">|</span>         <span class="number">1</span> <span class="operator">|</span>         <span class="number">807</span> <span class="operator">|</span> <span class="keyword">COMMIT</span> <span class="comment">/* xid=15 */</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----+----------------+-----------+-------------+--------------------------------------+</span></span><br></pre></td></tr></table></figure><p>上面这条语句可以将指定的binlog日志文件，分成有效事件行的方式返回，并可使用limit指定pos点的起始偏移，查询条数。其它举例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#a、查询第一个最早的binlog日志:</span><br><span class="line">show binlog events\G ;</span><br><span class="line"></span><br><span class="line">#b、指定查询mysql-bin.088002这个文件</span><br><span class="line">show binlog events in &#x27;atguigu-bin.000002&#x27;\G;</span><br><span class="line"></span><br><span class="line">#c、指定查询mysql-bin.0888日2这个文件，从pos点:391开始查起:</span><br><span class="line">show binlog events in &#x27;atguigu-bin . 088882&#x27; from 391\G;</span><br><span class="line"></span><br><span class="line">#d、指定查询mysql-bin.000002这个文件，从pos点:391开始查起，查询5条（即5条语句</span><br><span class="line">show binlog events in &#x27;atguigu-bin.080802&#x27; from 391 limit 5\G;</span><br><span class="line"></span><br><span class="line">#e、指定查询 mysql-bin.000002这个文件，从pos点:391开始查起，偏移2行〈即中间跳过2个）查询5条（即5条语句)。</span><br><span class="line">show binlog events in &#x27;atguigu-bin.088002 &#x27; from 391 limit 2,5\G;</span><br></pre></td></tr></table></figure><p>上面我们讲了这么多都是基于binlog的默认格式，binlog格式查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;binlog_format&#x27;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> + ---------------+-------  +</span></span><br><span class="line"><span class="comment">| Variable_name | Value |</span></span><br><span class="line"><span class="comment"> + ---------------+-------  +</span></span><br><span class="line"><span class="comment">| binlog_format | ROW   |</span></span><br><span class="line"><span class="comment"> + ---------------+-------  +</span></span><br><span class="line"><span class="comment">1 行于数据集 (0.02秒)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>除此之外，binlog还有2种格式，分别是<code>Statement</code>和<code>Mixed</code></p><ul><li><p>Statement<br>每一条会修改数据的sql都会记录在binlog中。</p><p>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。</p></li><li><p>Row<br>5.1.5版本的MySQL才开始支持row level 的复制，它不记录sql语句上下文相关信息，仅保存哪条记录被修改。<br>优点：row level 的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题。</p></li><li><p>Mixed</p><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。</p></li></ul><p>详细情况，下章讲解。</p><h3 id="5-4-使用日志恢复数据"><a href="#5-4-使用日志恢复数据" class="headerlink" title="5.4 使用日志恢复数据"></a>5.4 使用日志恢复数据</h3><p>如果MySQL服务器启用了二进制日志，在数据库出现意外丢失数据时，可以使用MySQLbinlog工具从指定的时间点开始（例如，最后一次备份）直到现在或另一个指定的时间点的日志中恢复数据。</p><p>mysqlbinlog恢复数据的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [option] filename<span class="operator">|</span>mysql –uuser <span class="operator">-</span>ppass;</span><br></pre></td></tr></table></figure><p>这个命令可以这样理解：使用mysqlbinlog命令来读取filename中的内容，然后使用mysql命令将这些内容恢复到数据库中。</p><ul><li><code>filename </code>：是日志文件名。</li><li><code>option </code>：可选项，比较重要的两对option参数是–start-date、–stop-date 和–start-position、– stop-position。<ul><li>–start-date 和 –stop-date ：可以指定恢复数据库的起始时间点和结束时间点。</li><li>–start-position和–stop-position ：可以指定恢复数据的开始位置和结束位置。</li></ul></li></ul><blockquote><p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前恢复。</p></blockquote><p><strong>案例</strong></p><p>现在对student表有以下操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use atguigudb3;</span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name    <span class="operator">|</span> class  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 张三<span class="number">2</span>   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 李四<span class="number">1</span>   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> Jane    <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> 王五    <span class="operator">|</span> 二班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> Tom     <span class="operator">|</span> 二班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">18</span> <span class="operator">|</span> Jerry   <span class="operator">|</span> 四班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> 钱七    <span class="operator">|</span> 三班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#插入数据</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">21</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;No1&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">22</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;No1&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">23</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;No1&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name    <span class="operator">|</span> class  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 张三<span class="number">2</span>   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 李四<span class="number">1</span>   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> Jane    <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> 王五    <span class="operator">|</span> 二班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> Tom     <span class="operator">|</span> 二班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">18</span> <span class="operator">|</span> Jerry   <span class="operator">|</span> 四班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> 钱七    <span class="operator">|</span> 三班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">21</span> <span class="operator">|</span> aaa     <span class="operator">|</span> No1    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">22</span> <span class="operator">|</span> aaa     <span class="operator">|</span> No1    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">23</span> <span class="operator">|</span> aaa     <span class="operator">|</span> No1    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">21</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> student <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;bbb&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">22</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name    <span class="operator">|</span> class  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 张三<span class="number">2</span>   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 李四<span class="number">1</span>   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> Jane    <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> 王五    <span class="operator">|</span> 二班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> Tom     <span class="operator">|</span> 二班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">18</span> <span class="operator">|</span> Jerry   <span class="operator">|</span> 四班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> 钱七    <span class="operator">|</span> 三班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">22</span> <span class="operator">|</span> bbb     <span class="operator">|</span> No1    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">23</span> <span class="operator">|</span> aaa     <span class="operator">|</span> No1    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="number">9</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>误操作</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">21</span>;</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name    <span class="operator">|</span> class  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 张三<span class="number">2</span>   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 李四<span class="number">1</span>   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> Jane    <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> 王五    <span class="operator">|</span> 二班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> Tom     <span class="operator">|</span> 二班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">18</span> <span class="operator">|</span> Jerry   <span class="operator">|</span> 四班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> 钱七    <span class="operator">|</span> 三班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>尝试恢复</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前数据库的bin_log日志</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="type">binary</span> logs;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Log_name           <span class="operator">|</span> File_size <span class="operator">|</span> Encrypted <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span>       <span class="number">179</span> <span class="operator">|</span> <span class="keyword">No</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span>      <span class="number">2685</span> <span class="operator">|</span> <span class="keyword">No</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#新增binlog【利用日志恢复本质上依旧是对表进行增删改，仍然会产生bin_log日志。所以我们应该新增一个bin_log日志，避免对用于恢复的日志<span class="number">00002</span>产生影响】</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="type">binary</span> logs;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Log_name           <span class="operator">|</span> File_size <span class="operator">|</span> Encrypted <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span>       <span class="number">179</span> <span class="operator">|</span> <span class="keyword">No</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span>      <span class="number">2734</span> <span class="operator">|</span> <span class="keyword">No</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000003</span> <span class="operator">|</span>       <span class="number">156</span> <span class="operator">|</span> <span class="keyword">No</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;位置恢复show binlog events in&#x3D;&#x3D;</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557348.png"></p><p>查看日志发现，在备份数据后首先执行的是插入数据操作，在Info信息中xid的值分别是22、23、24 (紧邻的三项)</p><p><strong>思路：</strong>先恢复3个insert22 23 24，再恢复delete 26，最后update 27</p><p>&#x3D;&#x3D;步骤1:恢复插入的数据&#x3D;&#x3D;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#语法</span><br><span class="line">[root<span class="variable">@centos7</span><span class="operator">-</span>mysql<span class="number">-1</span> mysql]# <span class="operator">/</span>usr<span class="operator">/</span>bin<span class="operator">/</span>mysqlbinlog <span class="comment">--start-position=初位置 --stop-position=初位置 --database=数据库名 /var/lib/mysql/日志文件 | /usr/bin/mysql -uroot -p密码 -v 数据库名</span></span><br><span class="line">#实战</span><br><span class="line">[root<span class="variable">@hadoop102</span> mysql]# <span class="operator">/</span>usr<span class="operator">/</span>bin<span class="operator">/</span>mysqlbinlog <span class="comment">--start-position=886 --stop-position=1728 --database=atguigudb3 /var/lib/mysql/atguigu-bin.000002 | /usr/bin/mysql -uroot -proot -v atguigudb3;</span></span><br></pre></td></tr></table></figure><p>执行完进行查看，发现这三个插入操作已经被恢复</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557346.png" alt="image-20230722190125039"></p><p>&#x3D;&#x3D;步骤2:恢复删除的数据&#x3D;&#x3D;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@hadoop102</span> mysql]# <span class="operator">/</span>usr<span class="operator">/</span>bin<span class="operator">/</span>mysqlbinlog <span class="comment">--start-position=1807 --stop-position=2035 --database=atguigudb3 /var/lib/mysql/atguigu-bin.000002 | /usr/bin/mysql -uroot -proot -v atguigudb3;</span></span><br></pre></td></tr></table></figure><p>查看结果</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557923.png" alt="image-20230722191750190"></p><p>&#x3D;&#x3D;步骤3:恢复修改的数据的数据&#x3D;&#x3D;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@hadoop102</span> mysql]# <span class="operator">/</span>usr<span class="operator">/</span>bin<span class="operator">/</span>mysqlbinlog <span class="comment">--start-position=2114 --stop-position=2365 --database=atguigudb3 /var/lib/mysql/atguigu-bin.000002 | /usr/bin/mysql -uroot -proot -v atguigudb3;</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557951.png" alt="image-20230722205229333"></p><p>可以看到最终结果和删除数据之前的结果一样，利用binlog实现了数据恢复。</p><p>当然也可以使用日期恢复，命令格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span>usr<span class="operator">/</span>bin<span class="operator">/</span>mysqlbinlog <span class="comment">--start-datetime=&quot;2023-07-22 16:14:20” --stop-datetime=&quot;2023-07-22 16:19:02&quot;  --database=atguigudb3 /var/lib/mysql/binlog/atguigu-bin.000002 | /usr/bin/mysql -uroot root  -v atguigudb3</span></span><br></pre></td></tr></table></figure><p>另外，有时候可能出现一个事务A执行时间过短，几秒内执行完成。此时我们找到下一个事务B的开始时间和结束时间。只要恢复的时间在B结束时间之前就可以只恢复A不恢复B【只要时间不完全包含一个事务，那么此事务就不会进行恢复~】</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">at</span> <span class="number">4</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">20</span> server id <span class="number">1</span>  end_log_pos <span class="number">125</span> CRC32 <span class="number">0xfbe10f64</span> <span class="keyword">Start</span>: binlog v <span class="number">4</span>, server v <span class="number">8.0</span><span class="number">.25</span> created <span class="number">230722</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">20</span> <span class="keyword">at</span> startup</span><br><span class="line"># Warning: this binlog <span class="keyword">is</span> either <span class="keyword">in</span> use <span class="keyword">or</span> was <span class="keyword">not</span> closed properly.</span><br><span class="line"><span class="keyword">ROLLBACK</span><span class="comment">/*!*/</span>;</span><br><span class="line">BINLOG <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">547</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02</span> server id <span class="number">1</span>  end_log_pos <span class="number">637</span> CRC32 <span class="number">0x0e4d6052</span> Querythread_id<span class="operator">=</span><span class="number">8</span>exec_time<span class="operator">=</span><span class="number">0</span>error_code<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span><span class="number">1690013942</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>......</span><br><span class="line"># <span class="keyword">at</span> <span class="number">776</span></span><br><span class="line">#<span class="number">230722</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">02</span> server id <span class="number">1</span>  end_log_pos <span class="number">807</span> CRC32 <span class="number">0x6f80cb79</span> Xid <span class="operator">=</span> <span class="number">15</span></span><br><span class="line"><span class="keyword">COMMIT</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;AUTOMATIC&#x27;</span> <span class="comment">/* added by mysqlbinlog */</span> <span class="comment">/*!*/</span>;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># <span class="keyword">End</span> <span class="keyword">of</span> log file</span><br><span class="line"><span class="comment">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/</span>;</span><br></pre></td></tr></table></figure><p>mysqlbinlog命令对于意外操作非常有效，比如因操作不当误删了数据表。</p><h3 id="5-5-删除二进制日志"><a href="#5-5-删除二进制日志" class="headerlink" title="5.5 删除二进制日志"></a>5.5 删除二进制日志</h3><p>MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。PURGE MASTER LOGS只删除指定部分的二进制日志文件， RESET MASTER删除所有的二进制日志文件。具体如下：</p><ol><li><strong>PURGE MASTER LOGS：删除指定日志文件</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PURGE &#123;MASTER <span class="operator">|</span> <span class="type">BINARY</span>&#125; LOGS <span class="keyword">TO</span> <span class="string">&#x27;指定日志文件名&#x27;</span></span><br><span class="line">PURGE &#123;MASTER <span class="operator">|</span> <span class="type">BINARY</span>&#125; LOGS BEFORE <span class="string">&#x27;指定日期&#x27;</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;举例:使用PURGE MASTER LOGS语句删除创建时间比binlog.000005早的所有日志&#x3D;&#x3D;</p><p>(1）多次重新启动MySQL服务，便于生成多个日志文件。然后用SHOW语句显示二进制日志文件列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;</span><br></pre></td></tr></table></figure><p>(2）执行PURGE MASTER LOGS语句删除创建时间比binlog.oo0005早的所有日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PURGE MASTER LoGS <span class="keyword">TO</span> &quot;binlog.000005&quot;;</span><br></pre></td></tr></table></figure><p>(3）显示二进制日志文件列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS ;</span><br></pre></td></tr></table></figure><p>比binlog.000005早的所有日志文件都已经被删除了。</p><p>&#x3D;&#x3D;举例:使用PURGE MASTER LOGS语句删除2020年10月25号前创建的所有日志文件。具体步骤如下:&#x3D;&#x3D;</p><p>(1）显示二进制日志文件列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;</span><br></pre></td></tr></table></figure><p>(2）执行mysqlbinlog命令查看二进制日志文件binlog.000005的内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog <span class="comment">--no-defaults &quot;/var/lib/mysql/atguigu-bin.000005&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557981.png" alt="image-20230805163137644"></p><p>结果可以看出20230805为日志创建的时间，即2023年08月05日。</p><p>(3）使用PURGE MASTER LOGs语句删除2022年1月05日前创建的所有日志文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PURGE MASTER LoGS before &quot;20220105&quot;;</span><br></pre></td></tr></table></figure><p>(4）显示二进制日志文件列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS ;</span><br></pre></td></tr></table></figure><p>2023年08月05号之前的二进制日志文件都已经被删除，最后一个没有删除，是因为当前在用，还未记录最后的时间，所以未被删除。</p><p><strong>2.RESET MASTER:删除所有二进制日志文件</strong></p><p>使用<code>RESET MASTER</code>语句，清空所有的binlog日志。MySQL会重新创建二进制文件，新的日志文件扩展名将重新从000001开始编号。<code>慎用</code>!</p><p>举例:使用RESET MASTER语句删除所有日志文件。</p><p>(1）重启MySQL服务若干次，执行SHOW语句显示二进制日志文件列表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;</span><br></pre></td></tr></table></figure><p>(2)执行RESET MASTER语句，删除所有日志文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RESET MASTER;</span><br></pre></td></tr></table></figure><p>执行完该语句后，原来的所有二进制日志已经全部被删除。</p><h3 id="5-6-其它场景"><a href="#5-6-其它场景" class="headerlink" title="5.6 其它场景"></a>5.6 其它场景</h3><p>二进制日志可以通过数据库的<code>全量备份</code>和二进制日志中保存的<code>增量信息</code> ，完成数据库的<code>无损失恢复</code> 。但是，如果遇到数据量大、数据库和数据表很多（比如分库分表的应用）的场景，用二进制日志进行数据恢复，是很有挑战性的，因为起止位置不容易管理。</p><p>在这种情况下，一个有效的解决办法是<code>配置主从数据库服务器</code> ，甚至是一主多从 的架构，把二进制日志文件的内容通过中继日志，同步到从数据库服务器中，这样就可以有效避免数据库故障导致的数据异常等问题。</p><h2 id="6-再谈二进制日志-binlog"><a href="#6-再谈二进制日志-binlog" class="headerlink" title="6. 再谈二进制日志(binlog)"></a>6. 再谈二进制日志(binlog)</h2><h3 id="6-1-写入机制"><a href="#6-1-写入机制" class="headerlink" title="6.1 写入机制"></a>6.1 写入机制</h3><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code> ，事务提交的时候，再把binlog cache写到binlog文件中。因为&#x3D;&#x3D;一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入&#x3D;&#x3D;，所以系统会给每个线程分配一个块内存作为binlog cache。</p><p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程binlog cache大小，如果存储内容超过了这个参数，就要暂存到磁盘(Swap)。binlog日志刷盘流程如下:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557036.png" alt="image-20230806151615285"></p><p>write和fsync的时机，可以由参数<code>sync_binlog </code>控制，默认是0 。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的binglog 会丢失。如下图：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557074.png" alt="image-20230806151719545"></p><p>为了安全起见，可以设置为1 ，表示每次提交事务都会执行fsync，就如同<code>redo log 刷盘流程</code>一样。最后还有一种折中方式，可以设置为<code>N</code>(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557241.png" alt="image-20230806151910974"></p><p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p><h3 id="6-2-binlog与redolog对比"><a href="#6-2-binlog与redolog对比" class="headerlink" title="6.2 binlog与redolog对比"></a>6.2 binlog与redolog对比</h3><ul><li>redo log 它是<code>物理日志</code> ，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层产生的。</li><li>而 binlog 是<code>逻辑日志</code> ，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于 MySQL Server层。</li></ul><p>虽然它们都属于持久化的保证，但是侧重点不同：</p><ul><li>redo log让InnoDB存储引擎拥有了崩溃恢复能力</li><li>binlog 保证了MySQL集群架构的数据一致性</li></ul><h3 id="6-3-两阶段提交"><a href="#6-3-两阶段提交" class="headerlink" title="6.3 两阶段提交"></a>6.3 两阶段提交</h3><p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的 <code>写入时机</code> 不一样</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557423.png" alt="image-20230806152740528"></p><p><strong>redo log与binlog两份日志之间的逻辑不一致，会出现什么问题？</strong></p><p>以update语句为例，假设id&#x3D;2的记录，字段c值是0，把字段c值更新成1，SQL语句为update T set c&#x3D;1 where id&#x3D;2。</p><p>假设执行过程中写完redo log日志后，binlog日志写期间发生了异常，会出现什么情况呢?</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557461.png" alt="image-20230806152946955"></p><p>由于binlog没写完就异常，这时候binlog里面没有对应的修改记录。因此，之后用binlog日志恢复数据时，就会少这一次更新，恢复出来的这一行c值是0，而原库因为redo log日志恢复，这一行c值是1，最终数据不一致。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557495.png" alt="image-20230806153016005"></p><p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用两阶段提交方案。原理很简单，将redo log的写入拆成了两个步骤prepare和commit，这就是<code>两阶段提交</code>。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557543.png" alt="image-20230806153119152"></p><p>使用<code>两阶段提交</code>后，写入binlog时发生异常也不会有影响，因为MySQL根据redo log日志恢复数据时，发现redolog还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557882.png" alt="image-20230806153232003"></p><p>另一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557932.png" alt="image-20230806153253328"></p><p>并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</p><h2 id="7-中继日志-relay-log"><a href="#7-中继日志-relay-log" class="headerlink" title="7. 中继日志(relay log)"></a>7. 中继日志(relay log)</h2><h3 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h3><p>&#x3D;&#x3D;<strong>中继日志只在主从服务器架构的从服务器上存在</strong>&#x3D;&#x3D;。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入<code>本地的日志文件</code>中，这个&#x3D;&#x3D;从服务器本地的日志文件就叫中继日志&#x3D;&#x3D;。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的<code>数据同步</code>。</p><p>搭建好主从服务器之后，中继日志默认会保存在从服务器的数据目录下。</p><p>文件名的格式是：<code> 从服务器名 -relay-bin.序号</code> 。中继日志还有一个索引文件： <code>从服务器名 -relay-bin.index</code> ，用来定位当前正在使用的中继日志。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202308061557976.png"></p><h3 id="7-2-查看中继日志"><a href="#7-2-查看中继日志" class="headerlink" title="7.2 查看中继日志"></a>7.2 查看中继日志</h3><p>中继日志与二进制日志的格式相同，可以用 <code>mysqlbinlog </code>工具进行查看。下面是中继日志的一个片段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span><span class="number">1618558728</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">950</span></span><br><span class="line">#<span class="number">210416</span> <span class="number">15</span>:<span class="number">38</span>:<span class="number">48</span> server id <span class="number">1</span>  end_log_pos <span class="number">832</span> CRC32 <span class="number">0xcc16d651</span>  Table_map:</span><br><span class="line">`atguigu`.`test` mapped <span class="keyword">to</span> number <span class="number">91</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">1000</span></span><br><span class="line">#<span class="number">210416</span> <span class="number">15</span>:<span class="number">38</span>:<span class="number">48</span> server id <span class="number">1</span>  end_log_pos <span class="number">872</span> CRC32 <span class="number">0x07e4047c</span>  Delete_rows: <span class="keyword">table</span> id</span><br><span class="line"><span class="number">91</span> flags: STMT_END_F  <span class="comment">-- server id 1 是主服务器，意思是主服务器删了一行数据</span></span><br><span class="line">BINLOG <span class="string">&#x27;</span></span><br><span class="line"><span class="string">CD95YBMBAAAAMgAAAEADAAAAAFsAAAAAAAEABGRlbW8ABHRlc3QAAQMAAQEBAFHWFsw=</span></span><br><span class="line"><span class="string">CD95YCABAAAAKAAAAGgDAAAAAFsAAAAAAAEAAgAB/wABAAAAfATkBw==</span></span><br><span class="line"><span class="string">&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">1040</span></span><br><span class="line"><span class="operator">*</span><span class="operator">/</span></span><br></pre></td></tr></table></figure><p>这一段的意思是，主服务器（“server id 1”）对表 atguigu.test 进行了 2 步操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定位到表 atguigu.test 编号是 <span class="number">91</span> 的记录，日志位置是 <span class="number">832</span>;</span><br><span class="line">删除编号是 <span class="number">91</span> 的记录，日志位置是 <span class="number">872</span>。</span><br></pre></td></tr></table></figure><h3 id="7-3-恢复的典型错误"><a href="#7-3-恢复的典型错误" class="headerlink" title="7.3 恢复的典型错误"></a>7.3 恢复的典型错误</h3><p>如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能会导致你的<code>服务器名称</code>与之前<code>不同</code> 。而中继日志里是 包含从服务器名 的。在这种情况下，就可能导致你恢复从服务器的时候，无法从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。</p><p>解决的方法也很简单，把从服务器的名称改回之前的名称。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十四、多版本并发控制</title>
      <link href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC14%E7%AB%A0_%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
      <url>/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC14%E7%AB%A0_%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><hr><h2 id="1-什么是MVCC"><a href="#1-什么是MVCC" class="headerlink" title="1. 什么是MVCC"></a>1. 什么是MVCC</h2><p><code>MVCC </code>(Multiversion Concurrency Control)，多版本并发控制。顾名思义，MVCC是通过数据行的多个版本管理来实现数据库的<code>并发控制</code>。这项技术使得在InnoDB的事务隔离级别下执行<code>一致性读</code>操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p><p>MVCC没有正式的标准，在不同的DBMS中 MVCC的实现方式可能是不同的，也不是普遍使用的(大家可以参考相关的DBMS文档)。这里讲解InnoDB 中 MVCC的实现机制（MySQL其它的存储引擎并不支持它)。</p><h2 id="2-快照读与当前读"><a href="#2-快照读与当前读" class="headerlink" title="2. 快照读与当前读"></a>2. 快照读与当前读</h2><p>MVCC在MySQL InnoDB中的实现主要是为了<code>提高数据库并发性能</code>，用更好的方式去处理<code>读-写冲突</code>，做到即使有读写冲突时，也能做到<code>不加锁</code>，<code>非阻塞并发读</code>，而这个读指的就是快照读，而非当前读。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用<code>乐观锁</code>思想的一种方式。</p><h3 id="2-1-快照读"><a href="#2-1-快照读" class="headerlink" title="2.1 快照读"></a>2.1 快照读</h3><p><code>快照读</code>又叫一致性读，读取的是<code>快照数据</code>。&#x3D;&#x3D;不加锁的简单的 SELECT 都属于快照读&#x3D;&#x3D;，即不加锁的非阻塞读；比如这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure><p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于<code>MVCC</code>，它在很多情况下，避免了加锁操作，降低了开销。</p><p>既然是基于<code>多版本</code>，那么快照读&#x3D;&#x3D;可能读到的并不一定是数据的最&#x3D;&#x3D;新版本，而有可能是之前的历史版本。</p><p>快照读的前提是隔离级别不是串行级别，&#x3D;&#x3D;串行级别下的快照读会退化成当前读&#x3D;&#x3D;。</p><h3 id="2-2-当前读"><a href="#2-2-当前读" class="headerlink" title="2.2 当前读"></a>2.2 当前读</h3><p>当前读读取的&#x3D;&#x3D;是记录的最新版&#x3D;&#x3D;本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。&#x3D;&#x3D;加锁的 <code>SELECT</code>，或者对数据进行增删改都会进行当前读&#x3D;&#x3D;。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LOCK <span class="keyword">IN</span> SHARE MODE; # 共享锁</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; # 排他锁</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span> ... # 排他锁</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> ... # 排他锁</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> ... # 排他锁</span><br></pre></td></tr></table></figure><blockquote><p>注意：InnoDB增删改默认加X锁，查默认不加锁</p></blockquote><h2 id="3-复习"><a href="#3-复习" class="headerlink" title="3. 复习"></a>3. 复习</h2><h3 id="3-1-再谈隔离级别"><a href="#3-1-再谈隔离级别" class="headerlink" title="3.1 再谈隔离级别"></a>3.1 再谈隔离级别</h3><p>事务有 4 个隔离级别，可能存在三种并发问题：（准确来说是四种，还有一种：<code>脏写</code>）</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302021324260.png" alt="image-20230130164546130"></p><p>在MySQL中，默认的隔离级别是<code>可重复读</code>，可以解<strong>决脏读和不可重复</strong>读的问题，如果仅从定义的角度来看，它并不能解决幻读问题。如果想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力</p><p>&#x3D;&#x3D;MVCC可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题&#x3D;&#x3D;！它可以在大多数情况下替代行级锁，降低系统的开销。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302021324287.png" alt="image-20230130164606259"></p><blockquote><p>在面试的时候要按照第二幅图进行回答哦~ </p><p>如果采用加锁的方式，那么就是间隙锁解决幻读问题。</p></blockquote><h3 id="3-2-隐藏字段、Undo-Log版本链"><a href="#3-2-隐藏字段、Undo-Log版本链" class="headerlink" title="3.2 隐藏字段、Undo Log版本链"></a>3.2 隐藏字段、Undo Log版本链</h3><p>回顾一下undo日志的版本链，对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p><ul><li><code>trx_id </code>: 每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的<code>事务id</code>赋值给<code>trx_id</code>隐藏列</li><li><code>roll_pointer</code>:每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<code>undo日志</code>中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><p><strong>举例：</strong>student表数据如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student ;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+----+--------+--------+</span></span><br><span class="line"><span class="comment">| id | name   | class  |</span></span><br><span class="line"><span class="comment">+----+--------+--------+</span></span><br><span class="line"><span class="comment">|  1 | 张三   | 一班    |</span></span><br><span class="line"><span class="comment">+----+--------+--------+</span></span><br><span class="line"><span class="comment">1 row in set (0.07 sec)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>假设插入该记录的<code>事务id</code>为8，那么此刻该条记录的示意图如下所示:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302021324293.png" alt="image-20230130164744113"></p><blockquote><p>insert undo只在事务<code>回滚</code>时起作用，&#x3D;&#x3D;当事务提交后，该类型的undo日志就没用了&#x3D;&#x3D;，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放)。</p></blockquote><p>假设之后两个事务id分别为10、20的事务对这条记录进行UPDATE 操作，操作流程如下:</p><table><thead><tr><th>发生时间顺序</th><th>事务10</th><th>事务20</th></tr></thead><tbody><tr><td>1</td><td>BEGIN;</td><td></td></tr><tr><td>2</td><td></td><td>BEGIN;</td></tr><tr><td>3</td><td>UPDATE student SET name&#x3D;”李四”<br/>WHERE id&#x3D;1;</td><td></td></tr><tr><td>4</td><td>UPDATE student SET name&#x3D;”王五” <br/>WHERE id&#x3D;1;</td><td></td></tr><tr><td>5</td><td>COMMIT;</td><td></td></tr><tr><td>6</td><td></td><td>UPDATE student SET name&#x3D;”钱七”<br/>WHERE id&#x3D;1;</td></tr><tr><td>7</td><td></td><td>UPDATE student SET name&#x3D;”宋八”<br/>WHERE id&#x3D;1;</td></tr><tr><td>8</td><td></td><td>COMMIT;</td></tr></tbody></table><blockquote><p>能不能在两个事务中交叉更新同一条记录呢?<br>不能！这不就是一个事务修改了另一个未提交事务修改过的数据，脏写。</p><p>&#x3D;&#x3D;InnoDB使用锁来保证不会有脏写情况的发生&#x3D;&#x3D;，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。</p><p><strong><font color=red>InnoDB增删改默认加x锁，查默认不加锁</font></strong></p></blockquote><p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个<code>roll_pointer</code>属性（<code>INSERT</code>操作对应的undo日志没有该属性，因为该记录并没有更早的版本)，可以将这些<code>undo日志</code>都连起来，串成一个链表:</p><p>update写的时候是默认加了X锁的,20会等待10</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302021324295.png" alt="image-20230130165215416"></p><p>对该记录每次更新后，都会将旧值放到一条<code>undo日志</code>中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被<code>roll_pointer</code>属性连接成一个链表，把这个链表称之为<code>版本链</code>，版本链的头节点就是当前记录最新的值。</p><p>每个版本中还包含生成该版本时对应的<code>事务id</code>。</p><h2 id="4-MVCC实现原理之ReadView"><a href="#4-MVCC实现原理之ReadView" class="headerlink" title="4. MVCC实现原理之ReadView"></a>4. MVCC实现原理之ReadView</h2><p>MVCC 的实现依赖于：&#x3D;&#x3D;隐藏字段、Undo Log、Read View&#x3D;&#x3D;</p><h3 id="4-1-什么是ReadView"><a href="#4-1-什么是ReadView" class="headerlink" title="4.1 什么是ReadView"></a>4.1 什么是ReadView</h3><p>在MVCC机制中，<code>多个事务对同一个行记录进行更新会产生多个历史快照</code>，这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢？这时就需要用到<code>ReadView</code>了，它解决了&#x3D;&#x3D;行的可见性&#x3D;&#x3D;问题</p><p>ReadView就是事务A在使用MVCC机制进行快照读操作时产生的<code>读视图</code>。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前<code>活跃事务</code>的ID（“活跃”指的就是，&#x3D;&#x3D;启动了但还没提交&#x3D;&#x3D;)</p><blockquote><p>ReadView和事务是一对一的关系~ 也就是当事务中使用MVVC，且是Select时会生成一个ReadView~</p></blockquote><h3 id="4-2-设计思路"><a href="#4-2-设计思路" class="headerlink" title="4.2 设计思路"></a>4.2 设计思路</h3><p>使用<code>READ UNCONNMITTED</code>隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取的记录就是最新版本了。</p><p>使用<code>SERIALIZABLE</code>隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p><p>使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务，都必须保证读到 <code>已经提交了的</code> 事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要<code>判断一下版本链中的哪个版本是当前事务可见的</code>，这是ReadView要解决的主要问题。</p><p>这个ReadView中主要包含4个比较重要的内容，分别如下：</p><ul><li><p><code>creator_trx_id </code>，创建这个 Read View 的事务 ID。</p><blockquote><p>说明：只有在对表中的记录做改动时（执行<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>这些语句时）才会为事务分配事务id，否则在一个<code>只读事务</code>中的事务id值都默认为<code>0</code>。</p></blockquote></li><li><p><code>trx_ids </code>，表示在生成ReadView时当前系统中活跃的读写事务的 <code>事务id列表</code> 。</p></li><li><p><code>up_limit_id </code>，活跃的事务中最小的事务 ID。</p></li><li><p><code>low_limit_id </code>，表示生成ReadView时系统中应该分配给下一个事务的 id 值。low_limit_id 是系统最大的事务id值，这里要注意是<code>系统中的事务id</code>，需要区别于正在活跃的事务ID。</p><blockquote><p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p></blockquote></li></ul><p><strong>举例：</strong></p><p>trx_ids为trx2、trx3、trx5和trx8的集合，系统的最大事务ID (low_limit_id)为trx8+1(如果之前没有其他的新增事务)，活跃的最小事务ID (up_limit_id)为trx2。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302021324301.png" alt="image-20230130165359240"></p><h3 id="4-3-ReadView的规则"><a href="#4-3-ReadView的规则" class="headerlink" title="4.3 ReadView的规则"></a>4.3 ReadView的规则</h3><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p><ul><li>如果被访问版本的trx_id属性值与ReadView中的<code>creator_trx_id </code>值相同，意味着&#x3D;&#x3D;当前事务在访问它自己修改过的记录&#x3D;&#x3D;，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值小于ReadView中的<code>up_limit_id</code>值，表明&#x3D;&#x3D;生成该版本的事务在当前事务生成ReadView前已经提交&#x3D;&#x3D;，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值大于或等于ReadView中的<code>low_limit_id</code>值，表明&#x3D;&#x3D;生成该版本的事务在当前事务生成ReadView后才开启&#x3D;&#x3D;，所以该版本不可以被当前事务访问。(不然会出现脏读)</li><li>如果被访问版本的trx_id属性值在ReadView的<code>up_limit_id </code>和<code>low_limit_id</code>之间，那就需要判断一下<code>trx_id</code>属性值是不是在<code>trx_ids </code>列表中。<ul><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问</li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ul></li></ul><h3 id="4-4-MVCC整体操作流程"><a href="#4-4-MVCC整体操作流程" class="headerlink" title="4.4 MVCC整体操作流程"></a>4.4 MVCC整体操作流程</h3><p>了解了这些概念之后，来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p><ol><li>首先获取事务自己的版本号，也就是事务 ID；</li><li>获取(生成) ReadView；</li><li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li><li>如果不符合 ReadView 规则（当前版本不能被访问），就需要从 <code>Undo Log</code> 中获取历史快照；</li><li>最后返回符合规则的数据。</li></ol><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p><blockquote><p>InnoDB中，MVCC是通过<code>Undo Log + Read View</code>进行数据读取，Undo Log保存了历史快照，而Read View规则帮我们判断当前版本的数据是否可见。</p><p>Read View和事务是一对一对应的，而且Read View也是一个动态，不断变化的~</p></blockquote><p>在隔离级别为<code>读已提交</code>（Read Committed）时，&#x3D;&#x3D;一个事务中的每一次 SELECT 查询都会重新获取一次Read View&#x3D;&#x3D;。</p><table><thead><tr><th>事务</th><th>说明</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from student where id &gt;2;</td><td>获取一次Read View</td></tr><tr><td>…</td><td></td></tr><tr><td>select * from student where id &gt;2;</td><td>获取一次Read View</td></tr><tr><td>commit;</td><td></td></tr></tbody></table><blockquote><p>注意，此时同样的查询语句都会重新获取一次Read View，这时如果Read View 不同，就可能产生不可重复读或者幻读的情况。这样符合Read Committed的规则特点~</p></blockquote><p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为&#x3D;&#x3D;一个事务只在第一次SELECT的时候会获取一次Read View&#x3D;&#x3D;，而后面所有的SELECT都会复用这个Read View，如下表所示:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302021324310.png" alt="image-20230131160657468"></p><h2 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5. 举例说明"></a>5. 举例说明</h2><p>假设现在student表中只有一条由<code>事务id</code>为<code>8</code>的事务插入的一条记录:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student ;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+----+--------+--------+</span></span><br><span class="line"><span class="comment">| id | name   | class  |</span></span><br><span class="line"><span class="comment">+----+--------+--------+</span></span><br><span class="line"><span class="comment">|  1 | 张三   | 一班    |</span></span><br><span class="line"><span class="comment">+----+--------+--------+</span></span><br><span class="line"><span class="comment">1 row in set (0.07 sec)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>MVCC只能在<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>两个隔离级别下工作。接下来看一下READ COMMITTED和REPEATABLE READ所谓的生成ReadView的时机不同到底不同在哪里</p><h3 id="5-1-READ-COMMITTED隔离级别下"><a href="#5-1-READ-COMMITTED隔离级别下" class="headerlink" title="5.1 READ COMMITTED隔离级别下"></a>5.1 READ COMMITTED隔离级别下</h3><p><strong><font color=red>READ COMMITTED ：每次读取数据前都生成一个ReadView</font></strong></p><p>现在有两个 事务id 分别为 10 、 20 的事务在执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录(为了分配事务id)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>说明:事务执行过程中，只有在第一次真正修改记录时(比如使用INSERT、DELETE、UPDATE语句)，才会被分配一个单独的事务id，这个事务id是递增的。所以我们才在事务2中更新一些别的表的记录，目的是让它分配事务id。</p></blockquote><p>此刻，表student 中id为1的记录得到的<code>版本链表</code>如下所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302021324986.png" alt="image-20230131170029928"></p><p>假设现在有一个使用 <code>READ COMMITTED</code> 隔离级别的事务开始执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>这个 SELECT1 的执行过程如下：</strong></p><p>步骤1∶在执行<code>SELECT</code>语句时会先生成一个<code>ReadView </code>，ReadView的<code>trx_ids</code>列表的内容就是<code>[10，20]</code>,<code>up_limit_id</code>为<code>10</code>, <code>low_limit_id</code>为<code>21</code>, <code>creator_trx_id</code>为<code>0</code>。</p><p>步骤2：从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是’王五’，该版本的<code>trx_id</code>值为<code>10</code>，在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本</p><p>步骤3：下一个版本的列name的内容是’李四’，该版本的trx_id值也为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本</p><p>步骤4：下一个版本的列name的内容是’张三’，该版本的trx_id值为8，小于ReadView中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘张三’的记录。</p><p>之后，把 事务id 为 10 的事务提交一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>然后再到 <code>事务id</code> 为 20 的事务中更新一下表 <code>student </code>中 <code>id </code>为 <code>1 </code>的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;钱七&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;宋八&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>此刻，表student中 <code>id </code>为 <code>1 </code>的记录的版本链就长这样：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302021324019.png" alt="image-20230131170300061"></p><p>然后再到刚才使用 <code>READ COMMITTED</code> 隔离级别的事务中继续查找这个 <code>id</code>为 <code>1</code> 的记录，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span> 均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction <span class="number">10</span>提交，Transaction <span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;王五&#x27;</span></span><br></pre></td></tr></table></figure><p>这个<code>SELECT2</code>的执行过程如下:</p><p>步骤1：在执行<code>SELECT</code>语句时会又会<code>单独生成</code>一个<code>ReadView</code>，该ReadView的<code>trx_ids</code>列表的内容就是<code>[20]</code>，<code>up_limit_id</code>为<code>20</code>，<code>low_limit_id</code>为<code>21</code>, <code>creator_trx_id</code>为<code>0</code>。</p><p>步骤2：从版本链中挑选可见的记录，从图中看出，最新版本的列<code>name</code>的内容是<code>’宋八’</code>，该版本的<code>trx_id</code>值为<code>20</code>，在trx_ids列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</p><p>步骤3∶下一个版本的列<code>name</code>的内容是‘<code>钱七</code>’，该版本的<code>trx_id</code>值为<code>20</code>，也在<code>trx_ids</code>列表内，所以也不符合要求，继续跳到下一个版本</p><p>步骤4∶下一个版本的列<code>name</code>的内容是’<code>王五</code>’，该版本的<code>trx_id</code>值为<code>10</code>，小于<code>ReadView</code>中的<code>up_limit_id</code>值<code>20</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为’<code>王五</code>’的记录。</p><p>以此类推，如果之后<code>事务id</code>为<code>20</code>的记录也提交了，再次在使用<code>READ COMMITED</code> 隔离级别的事务查询表<code>student</code>中<code>id</code>值为<code>1</code>的记录时，得到的结果就是’<code>宋八</code>‘了，具体流程我们就不分析了。</p><blockquote><p><strong>强调：</strong>使用<code>READ COMMITTED</code>隔离级别的事务在每次查询开始时都会生成一个独立的ReadView</p></blockquote><h3 id="5-2-REPEATABLE-READ隔离级别下"><a href="#5-2-REPEATABLE-READ隔离级别下" class="headerlink" title="5.2 REPEATABLE READ隔离级别下"></a>5.2 REPEATABLE READ隔离级别下</h3><p>使用 <code>REPEATABLE READ</code> 隔离级别的事务来说，只会在第一次执行查询语句时生成一个 <code>ReadView </code>，之后的查询就不会重复生成了。</p><p>比如，系统里有两个 <code>事务id</code> 分别为 <code>10 </code>、 <code>20 </code>的事务在执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此刻，表student 中 <code>id </code>为 <code>1 </code>的记录得到的版本链表如下所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302021324050.png" alt="image-20230131170424180"></p><p>假设现在有一个使用 <code>REPEATABLE READ</code> 隔离级别的事务开始执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure><p>这个<code>SELECT1</code>的执行过程如下:</p><p>步骤1：在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，<code>ReadView</code>的<code>trx_ids</code>列表的内容就是<code>[10，20]</code>，<code>up_limit_id</code>为<code>10</code>, <code>low_limit_id</code>为<code>21</code>, <code>creator_trx_id</code>为<code>0</code>。</p><p>步骤2：然后从版本链中挑选可见的记录，从图中看出，最新版本的列<code>name</code>的内容是’<code>王五</code>’，该版本的<code>trx_id</code>值为<code>10</code>，在<code>trx_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</p><p>步骤3：下一个版本的列<code>name</code>的内容是’<code>李四</code>’，该版本的trx_id值也为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</p><p>步骤4：下一个版本的列name的内容是’<code>张三</code>’，该版本的<code>trx_id</code>值为<code>8</code>，小于<code>ReadView</code>中的<code>up_limit_id</code>值<code>10</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>name</code>为’<code>张三</code> ’的记录</p><p>之后，我们把<code>事务id</code>为<code>10</code>的事务提交一下，就像这样:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>然后再到 <code>事务id</code> 为 <code>20 </code>的事务中更新一下表 student 中 id 为 1 的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;钱七&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;宋八&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>此刻，表student 中 <code>id </code>为 <code>1 </code>的记录的版本链长这样：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302021324080.png" alt="image-20230131170550677"></p><p>然后再到刚才使用 <code>REPEATABLE READ</code> 隔离级别的事务中继续查找这个<code>id </code>为 <code>1 </code>的记录，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction <span class="number">10</span>提交，Transaction <span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值仍为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure><p><code>SELECT2</code>的执行过程如下:</p><p>步骤1：因为当前事务的隔离级别为<code>REPEATABLE READ</code>，而之前在执行<code>SELECT1</code>时已经生成过<code>ReadView</code>了，所以此时直接复用之前的ReadView，之前的<code>ReadView</code>的<code>trx_ids</code>列表的内容就是<code>[10，20]</code>，<code>up_limit_id</code>为<code>10</code>，<code>low_limit_id</code>为<code>21</code>, <code>creator_trx_id</code>为<code>0</code>。</p><p>步骤2：然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>name</code>的内容是’<code>宋八</code>’，该版本的<code>trx_id</code>值为<code>20</code>，在<code>trx_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本</p><p>步骤3：下一个版本的列<code>name</code>的内容是’<code>钱七</code>’，该版本的<code>trx_id</code>值为<code>20</code>，也在<code>trx_ids</code>列表内，所以也不符合要求，继续跳到下一个版本</p><p>步骤4：下一个版本的列<code>name</code>的内容是’<code>王五</code>’，该版本的<code>trx_id</code>值为<code>10</code>，而trx_ids列表中是包含值为10的事务id的，所以该版本也不符合要求，同理下一个列<code>name</code>的内容是‘<code>李四</code>’的版本也不符合要求。继续跳到下一个版本</p><p>步骤5：下一个版本的列<code>name</code>的内容是’<code>张三</code>’，该版本的<code>trx_id</code>值为<code>8</code>，小于<code>ReadView</code>中的<code>up_limit_id</code>值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为‘<code>张三</code>’的记录。</p><p>两次<code>SELECT</code>查询得到的结果是重复的，记录的列<code>c</code>值都是‘<code>张三</code>‘，这就是<code>可重复读</code>的含义。如果我们之后再把<code>事务id</code>为<code>20</code>的记录提交了，然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个<code>id</code>为<code>1</code>的记得到的结果还是‘<code>张三</code>‘，具体执行过程大家可以自己分析一下。</p><h3 id="5-3-如何解决幻读"><a href="#5-3-如何解决幻读" class="headerlink" title="5.3 如何解决幻读"></a>5.3 如何解决幻读</h3><p>接下来说明InnoDB 是如何解决幻读的。</p><p>假设现在表 student 中只有一条数据，数据内容中，主键 <code>id=1</code>，隐藏的 <code>trx_id=10</code>，它的 undo log 如下图所示。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302021324108.png" alt="image-20230131170636804"></p><p>假设现在有事务 A 和事务 B 并发执行， <code>事务 A</code> 的事务 id 为 <code>20 </code>， <code>事务 B</code> 的事务 id 为 <code>30 </code>。</p><p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下： <code>trx_ids=[20,30]</code> ，<code>up_limit_id=20</code> ，<code> low_limit_id=31</code> ， <code>creator_trx_id=20</code> 。</p><p>由于此时表 student 中只有一条数据，且符合 where id&gt;&#x3D;1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id&#x3D;10，<code>小于</code>事务 A 的 ReadView 里 <code>up_limit_id</code>，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p><p>结论：事务 A 的第一次查询，能读取到一条数据，id&#x3D;1。</p><p>步骤2：接着事务 B(trx_id&#x3D;30)，往表 student 中新插入两条数据，并<code>提交</code>事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>);</span><br></pre></td></tr></table></figure><p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302021324138.png" alt="image-20230131170730357"></p><p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并<code>不会再重新生成ReadView</code>。此时表 student 中的 3 条数据都满足 where id&gt;&#x3D;1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p><p>1）首先 id&#x3D;1 的这条数据，前面已经说过了，可以被事务 A 看到。</p><p>2）然后是 id&#x3D;2 的数据，它的 trx_id&#x3D;30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids&#x3D;[20,30]，因此在数组内，这表示 id&#x3D;2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到</p><p>3）同理，id&#x3D;3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202302021324508.png" alt="image-20230131170811967"></p><p>结论：最终事务 A 的第二次查询，只能查询出 id&#x3D;1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>这里介绍了 <code>MVCC </code>在 <code>READ COMMITTD</code> 、 <code>REPEATABLE READ</code> 这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的 <code>读-写</code> 、 <code>写-读</code> 操作并发执行，从而提升系统性能</p><p>核心点在于 <code>ReadView </code>的原理， <code>READ COMMITTD 、 REPEATABLE READ</code> 这两个隔离级别的一个很大不同就是生成ReadView的时机不同：</p><ul><li><p>READ COMMITTD 在每一次进行普通SELECT操作前都会生成一个ReadView</p></li><li><p>REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了</p></li></ul><blockquote><p>说明：之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除，而是执行一个所谓的<code>delete mark</code>操作(标记0-&gt;1)，相当于只是对记录打上了一个删除标志位，这主要就是为MVCC服务的。另外后面回滚也可能用到这个delete mark~</p></blockquote><p>通过 MVCC 可以解决:</p><ul><li><p><code>读写之间阻塞的问题</code>。通过MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力</p></li><li><p><code>降低了死锁的概率</code>。这是因为MVCC采用了<code>乐观锁</code>的方式，读取数据时并不需要加锁，对于写操作，也只锁 定必要的行</p></li><li><p><code>解决快照读的问题</code>。当查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十三、锁</title>
      <link href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC13%E7%AB%A0_%E9%94%81/"/>
      <url>/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC13%E7%AB%A0_%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><hr><p>事务的<code>隔离性</code>由这章讲述的<code>锁</code>来实现</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>锁</code>是计算机协调多个进程或线程<code>并发访问某一资源</code>的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等)，就需要保证这个数据在任何时刻<code>最多只有一个线程</code>在访问，保证数据的<code>完整性</code>和<code>一致性</code>。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。</p><p>在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对<code>并发操作进行控制</code>，因此产生了<code>锁</code>。同时<code>锁机制</code>也为实现MySQL的各个隔离级别提供了保证。<code>锁冲突</code>也是影响数据库<code>并发访问性能</code>的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p><h2 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2. MySQL并发事务访问相同记录"></a>2. MySQL并发事务访问相同记录</h2><p>并发事务访问相同记录的情况大致可以划分为3种：</p><h3 id="2-1-读-读情况"><a href="#2-1-读-读情况" class="headerlink" title="2.1 读-读情况"></a>2.1 读-读情况</h3><p><code>读-读</code> 情况，即并发事务相继 <code>读取相同的记录</code> 。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p><h3 id="2-2-写-写情况"><a href="#2-2-写-写情况" class="headerlink" title="2.2 写-写情况"></a>2.2 写-写情况</h3><p><code>写-写</code> 情况，即并发事务相继对相同的记录做出改动。</p><p>在这种情况下会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们 <code>排队执行</code> ，这个排队的过程其实是通过 <code>锁</code> 来实现的。这个所谓的锁其实是一个 <code>内存中的结构</code> ，在事务执行前本来是没有锁的，也就是说一开始是没有 <code>锁结构</code> 和记录进行关联的,如图所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335827.png" alt="image-20230123203920264"></p><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 锁结构 ，当没有的时候就会在内存中生成一个 <code>锁结构</code> 与之关联。比如，事务 <code>T1</code>要对这条记录做改动，就需要生成一个 <code>锁结构</code> 与之关联：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335836.png" alt="image-20230123203950048"></p><p>在 <code>锁结构</code> 里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来:</p><ul><li><code>trx信息</code>:代表这个锁结构是哪个事务生成的。</li><li><code>is_waiting </code>:代表当前事务是否在等待。</li></ul><p>当事务<code>T1</code>改动了这条记录后，就生成了一个<code>锁结构</code>与该记录关联，因为之前没有别的事务为这条记录加锁，所以<code>is_waiting</code>属性就是<code>false</code>，把这个场景就称之为<code>获取锁成功</code>，或者<code>加锁成功</code>，然后就可以继续执行操作了</p><p>在事务T1提交之前，另一个事务<code>T2</code>也想对该记录做改动，那么先看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个<code>锁结构</code>与这条记录关联，不过锁结构的<code>is_waiting</code>属性值为<code>true</code>，表示当前事务需要等待，把这个场景就称之为<code>获取锁失败</code>，或者<code>加锁失败</code>，图示:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335830.png" alt="image-20230123204057637"></p><p>在事务T1提交之后，就会把该事务生成的<code>锁结构释放</code>掉，然后看看还有没有别的事务在等待获取锁，发现了事务<code>T2</code>还在等待获取锁，所以把事务T2对应的锁结构的<code>is_waiting</code>属性设置为<code>false</code>，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。效果图就是这样:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335839.png" alt="image-20230123204129603"></p><p><strong>小结几种说法:</strong></p><ul><li><p>不加锁<br>意思就是不需要在内存中生成对应的<code>锁结构</code>，可以直接执行操作。</p></li><li><p>获取锁成功，或者加锁成功<br>意思就是在内存中生成了对应的<code>锁结构</code>，而且锁结构的<code>is_waiting</code>属性为<code>false</code>，也就是事务可以继续执行操作。</p></li><li><p>获取锁失败，或者加锁失败，或者没有获取到锁</p><p>意思就是在内存中生成了对应的<code>锁结构</code>，不过锁结构的<code>is_waiting</code>属性为<code>true</code>，也就是事务需要等待，不可以继续执行操作。</p></li></ul><h3 id="2-3-读-写或写-读情况"><a href="#2-3-读-写或写-读情况" class="headerlink" title="2.3 读-写或写-读情况"></a>2.3 读-写或写-读情况</h3><p><code>读-写</code> 或 <code>写-读</code> ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 <code>脏读</code>、 <code>不可重复读</code> 、 <code>幻读</code> 的问题。</p><p>各个数据库厂商对 <code>SQL标准</code> 的支持都可能不一样。比如<font color=red>MySQL在 <code>REPEATABLE READ</code> 隔离级别上就已经解决了 <code>幻读</code> 问题</font>。</p><h3 id="2-4-并发问题的解决方案"><a href="#2-4-并发问题的解决方案" class="headerlink" title="2.4 并发问题的解决方案"></a>2.4 并发问题的解决方案</h3><p>**<font color=orange>怎么解决 <code>脏读</code> 、 <code>不可重复读</code> 、 <code>幻读</code> 这些问题呢？</font>**其实有两种可选的解决方案：</p><ul><li><font color=red>方案一：读操作利用多版本并发控制（<code>MVCC </code>，下章讲解），写操作进行<code>加锁</code> 。</font></li></ul><p>所谓的<code>MVCC</code>，就是生成一个<code>ReadView</code>，通过ReadView找到符合条件的记录版本（(历史版本由<code>undo</code>日志构建)。查询语句只能读到在生成ReadView之前<code>已提交事务所做的更改</code>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<code>写操作</code>肯定针对的是<code>最新版本的记录</code>，&#x3D;&#x3D;读记录的历史版本和改动记录的最新版本本身并不冲突&#x3D;&#x3D;，也就是采用MVCC时，<code>读-写</code>操作并不冲突</p><blockquote><p>普通的SELECT语句在<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别下会使用到MVCC读取记录。</p><ul><li>在<code>READ COMMITTED</code> 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了<code>事务不可以读取到未提交的事务所做的更改</code> ，也就是避免了脏读现象；</li><li>在<code>REPEATABLE READ</code> 隔离级别下，一个事务在执行过程中只有<code>第一次执行SELECT操作</code> 才会生成一个ReadView，之后的SELECT操作都 <code>复用</code> 这个ReadView，这样也就避免了不可重复读 和幻读的问题</li></ul></blockquote><ul><li><font color=red>方案二：读、写操作都采用加锁的方式</font></li></ul><p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去<code>读取记录的最新版本</code>。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行<code>加锁</code>操作，这样也就意味着<code>读</code>操作和<code>写</code>操作也像<code>写-写</code>操作那样排队执行。</p><p><code>脏读</code>的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p><p><code>不可重复读</code>的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就<code>无法修改</code>该记录，自然也不会发生不可重复读了</p><p><code>幻读</code>问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬（因为你并不知道给谁加锁~)</p><p><strong>小结对比发现：</strong></p><ul><li>采用 <code>MVCC </code>方式的话，<code>读-写</code> 操作彼此并不冲突，<code>性能更高</code> 。</li><li>采用 <code>加锁</code> 方式的话， 读-写 操作彼此需要 <code>排队执行</code> ，影响性能。</li></ul><p>一般情况下当然愿意采用<code>MVCC</code>来解决 读-写 操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用 <code>加锁</code> 的方式执行。下面就讲解下MySQL中不同类别的锁。</p><h2 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3. 锁的不同角度分类"></a>3. 锁的不同角度分类</h2><p>锁的分类图，如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335845.png" alt="image-20230123212838138"></p><h3 id="3-1从数据操作的类型划分-读锁、写锁"><a href="#3-1从数据操作的类型划分-读锁、写锁" class="headerlink" title="3.1从数据操作的类型划分:读锁、写锁"></a>3.1从数据操作的类型划分:读锁、写锁</h3><p>对于数据库中并发事务的<code>读-读</code>情况并不会引起什么问题。对于<code>写-写</code>、<code>读-写</code>或<code>写-读</code>这些情况可能会引起一些问题，需要使用<code>MVCC</code>或者<code>加锁</code>的方式来解决它们。在使用<code>加锁</code>的方式解决问题时，由于既要允许<code>读-读</code>情况不受影响，又要使<code>写-写</code>、<code>读-写</code>或<code>写-读</code>情况中的操作相互阻塞，所以MySQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为&#x3D;&#x3D;共享锁(Shared Lock，S Lock)&#x3D;&#x3D;和&#x3D;&#x3D;排他锁(Exclusive Lock，X Lock)&#x3D;&#x3D;，也叫&#x3D;&#x3D;读锁(readlock)&#x3D;&#x3D;和&#x3D;&#x3D;写锁(write lock)&#x3D;&#x3D;</p><ul><li><code>读锁</code>:也称为<code>共享锁</code>、英文用<code>S</code>表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</li><li><code>写锁</code>:也称为<code>排他锁</code>、英文用<code>X</code>表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源</li></ul><blockquote><p>需要注意的是对于InnoDB引擎来说，读锁和写锁可以加在表上，也可以加在行上。</p></blockquote><p><strong>举例（行级读写锁)︰</strong>如果一个事务T1已经获得了某个行r的读锁，那么此时另外的一个事务T2是可以去获得这个行r的读锁的，因为读取操作并没有改变行r的数据;但是，如果某个事务T3想获得行r的写锁，则它必须等待事务T1、T2释放掉行r上的读锁才行。</p><blockquote><p>总结:这里的兼容是指对同一张表或记录的锁的兼容性情况</p></blockquote><table><thead><tr><th>兼容情况</th><th>X锁</th><th>S锁</th></tr></thead><tbody><tr><td>X锁</td><td>不兼容</td><td>不兼容</td></tr><tr><td>S锁</td><td>不兼容</td><td>兼容</td></tr></tbody></table><h4 id="1-锁定读"><a href="#1-锁定读" class="headerlink" title="1. 锁定读"></a>1. 锁定读</h4><p>在采用<code>加锁</code>方式解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题时，读取一条记录时需要获取该记录的<code>S锁</code>，其实是不严谨的，有时候需要在读取记录时就获取记录的<code>X锁</code> ，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的<code>SELECT</code>语句格式:</p><ul><li>对读取的记录加S锁∶</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE; </span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> SHARE;#(<span class="number">8.0</span>新增语法)</span><br></pre></td></tr></table></figure><p>在普通的SELECT语句后边加<code>LOCK IN SHARE MODE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加<code>S锁</code>，这样允许别的事务继续获取这些记录的<code>S锁</code>（比方说别的事务也使用<code>SELECT …LOCK IN SHARE MODE</code>语句来读取这些记录)，但是不能获取这些记录的<code>X锁</code>(比如使用<code>SELECT … FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的<code>X锁</code>，那么它们会阻塞，直到当前事务提交之后将这些记录上的<code>S锁</code>释放掉</p><ul><li>对读取的记录加<code>X锁</code>:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>在普通的SELECT语句后边加<code>FOR UPDATE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加<code>X锁</code>，这样既不允许别的事务获取这些记录的<code>S锁</code>(比方说别的事务使用<code>SELECT … LOCK IN SHARE MODE</code>语句来读取这些记录)，也不允许获取这些记录的<code>X锁</code>(比如使用<code>SELECT … FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的<code>S锁</code>或者<code>X锁</code>，那么它们会阻塞，直到当前事务提交之后将这些记录上的<code>X锁</code>释放掉</p><p><strong><font color=blue>案例演示</font></strong></p><ul><li>S-&gt;S</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335867.png"></p><ul><li>S-&gt;X</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335594.png"></p><ul><li>X-&gt;S</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335638.png"></p><ul><li>X-&gt;X</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335738.png"></p><p><strong>MySQL8.0新特性:</strong></p><p>在5.7及之前的版本，<code>SELECT … FOR UPDATE</code>，如果获取不到锁，会一直等待，直到<br><code>innodb_lock_wait_timeout</code>超时。在8.0版本中，在SELECT …FOR UPDATE，SELECT …FOR SHARE后添加<code>NOWAIT</code>、<code>SKIP LOCKED</code>语法，跳过锁等待，或者跳过锁定。</p><p>如果查询的行已经加锁：</p><ul><li>那么NOWAIT会立即报错返回</li><li>而SKIP LOCKED也会立即返回，只是返回的结果中不包含被锁定的行。</li></ul><p><strong><font color=blue>演示</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#事务A</span><br><span class="line"><span class="keyword">begin</span> ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+-- --+--------+- ------ +</span></span><br><span class="line"><span class="comment">| id  |    NAME|  balance|</span></span><br><span class="line"><span class="comment">|   1 │     张三|    40.00|</span></span><br><span class="line"><span class="comment">|   2 |     李四|    0.00 |</span></span><br><span class="line"><span class="comment">|   3 |     王五|   100.00|</span></span><br><span class="line"><span class="comment">+--- -+--------+- ------ +</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#事务B</span><br><span class="line"><span class="keyword">begin</span> ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">for</span> <span class="keyword">update</span> nowait;</span><br><span class="line">#报错返回</span><br><span class="line">#ERROR <span class="number">3572</span> (HYO00): Statement aborted because lock(s) could <span class="keyword">not</span> be acquired immediately <span class="keyword">and</span> NOMAIT <span class="keyword">is</span> set.</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">skip</span> locked;</span><br><span class="line"># 因为事务A获得X锁，所以查到的记录是空的<span class="operator">~</span></span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (o<span class="number">.00</span> sec)</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line">#Query Ok,o <span class="keyword">rows</span> affected ( sec)</span><br></pre></td></tr></table></figure><h4 id="2-写操作"><a href="#2-写操作" class="headerlink" title="2. 写操作"></a>2. 写操作</h4><p>平常所用到的写操作无非是 <code>DELETE</code>、<code>UPDATE</code>、<code>INSERT </code>这三种:</p><ul><li><code>DELETE</code>：对一条记录做DELETE操作的过程其实是先在<code>B+</code>树中定位到这条记录的位置，然后获取这条记录的<code>X锁</code>，再执行<code>delete mark</code>操作。也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</li><li><code>UPDATE</code>︰在对一条记录做UPDATE操作时分为三种情况:<ul><li>情况1: 未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。<br>则先在<code>B+</code>树中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原记录的位置进行修改操作。也可以把这个定位待修改记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</li><li>情况2∶未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。<br>则先在<code>B+</code>树中定位到这条记录的位置，然后获取一下记录的<code>X锁</code>，将该记录<code>彻底删除掉</code>（就是把记录彻底移入垃圾链表)，最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个<code>获取X锁的锁定读</code>，新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</li><li>情况3∶ 修改了该记录的键值，则相当于在原记录上做<code>DELETE</code>操作之后再来一次<code>INSERT</code>操作，加锁操作就需要按照<code>DELETE</code>和<code>INSERT</code>的规则进行了。（同情况2）</li></ul></li><li><code>INSERT </code>：&#x3D;&#x3D;一般情况下，新插入一条记录的操作并不加锁&#x3D;&#x3D;，通过一种称之为<code>隐式锁</code>的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</li></ul><blockquote><p>分析：因为插入之前就没有要锁的记录，所以也就不需要加X锁了</p></blockquote><h3 id="3-2-从数据操作的粒度划分-表级锁、页级锁、行锁"><a href="#3-2-从数据操作的粒度划分-表级锁、页级锁、行锁" class="headerlink" title="3.2 从数据操作的粒度划分:表级锁、页级锁、行锁"></a>3.2 从数据操作的粒度划分:表级锁、页级锁、行锁</h3><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很<code>耗资源</code>的事情（涉及获取、检查、释放锁等动作)。因此数据库系统需要在<code>高并发响应</code>和<code>系统性能</code>两方面进行平衡，这样就产生了“<code>锁粒度</code>(Lock granularity)”的概念。</p><p>对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细；其实一个事务也可以在<code>表级别</code>进行加锁，自然就被称之为<code>表级锁</code>或者<code>表锁</code>，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。锁的粒度主要分为<code>表级锁</code>、<code>页级锁</code>和<code>行锁</code>。</p><h4 id="1-表锁-Table-Lock"><a href="#1-表锁-Table-Lock" class="headerlink" title="1. 表锁(Table Lock)"></a>1. 表锁(Table Lock)</h4><p>该锁会锁定整张表，它是MySQL中最基本的锁策略，并<code>不依赖于存储引擎</code>（不管你是MySQL的什么存储引擎，对于表锁的策略都是一样的)，并且表锁是<code>开销最小</code>的策略(因为粒度比较大)。由于表级锁一次会将整个表锁定，所以可以很好的<code>避免死锁</code>问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致<code>并发率大打折扣</code>。</p><h5 id="①-表级别的S锁、X锁"><a href="#①-表级别的S锁、X锁" class="headerlink" title="① 表级别的S锁、X锁"></a><font color=orange>① 表级别的S锁、X锁</font></h5><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的<code>S锁</code>或者<code>X锁</code>的。在对某个表执行一些诸如<code>ALTER TABLE</code>、<code>DROP TABLE</code>这类的<code>DDL</code>语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行DDL语句也会发生阻塞。这个过程其实是通过在<code>server层</code>使用一种称之为<code>元数据锁</code>(英文名: <code>Metadata Locks</code>，简称<code>MDL</code>）结构来实现的。</p><p>&#x3D;&#x3D;一般情况下，不会使用InnoDB存储引擎提供的表级别的 <code>S锁</code> 和 <code>X锁</code>&#x3D;&#x3D;  (因为InnoDB支持更小粒度的行锁~)。只会在一些特殊情况下，比方说 <code>崩溃恢复</code> 过程中用到。比如，在系统变量 <code>autocommit=0</code>，<code>innodb_table_locks = 1</code> 时， <code>手动</code> 获取InnoDB存储引擎提供的表t 的 <code>S锁</code> 或者 <code>X锁</code> 可以这么写：</p><ul><li><code>LOCK TABLES t READ</code> ：InnoDB存储引擎会对表 t 加表级别的<code>S锁</code> 。</li><li><code>LOCK TABLES t WRITE</code> ：InnoDB存储引擎会对表 t 加表级别的<code>X锁</code> 。</li></ul><p>不过尽量避免在使用InnoDB存储引擎的表上使用 <code>LOCK TABLES</code> 这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的 <code>行锁</code> ，关于InnoDB表级别的 S锁 和 X锁 大家了解一下就可以了</p><p><strong>举例：</strong> 下面我们讲解MylSAM引擎下的表锁。</p><ul><li>步骤1：创建表并添加数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mylock(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY auto_increment,NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">)ENGINE myisam;#存储引擎使用InnoDB也可以，只是不建议</span><br><span class="line"></span><br><span class="line">#插入一条数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mylock(NAME) <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#查询表中所有的数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mylock;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+----+------+</span></span><br><span class="line"><span class="comment">| id | NAME |</span></span><br><span class="line"><span class="comment">+----+------+</span></span><br><span class="line"><span class="comment">|  1 | a    |</span></span><br><span class="line"><span class="comment">+----+------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>步骤2：查看表上加过的锁</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> TABLES <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> TABLES;#主要关注In_use字段的值 <span class="operator">&gt;</span><span class="number">0</span></span><br><span class="line"><span class="comment">/*部分输出</span></span><br><span class="line"><span class="comment">SHOW OPEN TABLES;</span></span><br><span class="line"><span class="comment">+--------------------+---------------------------+--------+-------------+</span></span><br><span class="line"><span class="comment">| Database           | Table                     | In_use | Name_locked |</span></span><br><span class="line"><span class="comment">+--------------------+---------------------------+--------+-------------+</span></span><br><span class="line"><span class="comment">| atguigudb3         | user1                     |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | tablespace_files          |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | column_statistics         |      0 |           0 |</span></span><br><span class="line"><span class="comment">| atguigudb3         | account                   |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | table_stats               |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | check_constraints         |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | view_table_usage          |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | tables_priv               |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | column_type_elements      |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | foreign_key_column_usage  |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | time_zone_name            |      0 |           0 |</span></span><br><span class="line"><span class="comment">.........................................................................</span></span><br><span class="line"><span class="comment">| information_schema | TABLES                    |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | time_zone_transition_type |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | tablespaces               |      0 |           0 |</span></span><br><span class="line"><span class="comment">+--------------------+---------------------------+--------+-------------+</span></span><br><span class="line"><span class="comment">61 rows in set (0.01 sec)                </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的结果表明，当前数据库中没有被锁定的表。</p></blockquote><ul><li>步骤3：手动增加表锁命令</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES t READ:#存储引擎会对表t加表级别的共享锁。共享锁也叫读锁或S锁(Share的缩写)</span><br><span class="line">LOCK TABLES t WRITE:#存储引擎会对表t加表级别的排他锁。排它锁也叫独占锁、写锁或X锁(是eXclusive的缩写)</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> lock tables mylock write;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">OPEN</span> TABLES <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> Database   <span class="operator">|</span> <span class="keyword">Table</span>  <span class="operator">|</span> In_use <span class="operator">|</span> Name_locked <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> atguigudb3 <span class="operator">|</span> mylock <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------+--------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>步骤4：释放锁</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#释放锁</span><br><span class="line">unlock tables;#释放当前加锁的表</span><br></pre></td></tr></table></figure><ul><li>步骤5：加读锁</li></ul><p>为mylock表加read锁(读阻塞写)，观察阻塞的情况，流程如下:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335780.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#######################SessonA中########################################</span></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">begin;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">lock tables mylock <span class="built_in">read</span>;<span class="comment">#为表加上读锁</span></span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from mylock;<span class="comment">#自己可读</span></span></span><br><span class="line">+----+------+</span><br><span class="line">| id | NAME |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | a    |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">update mylock <span class="built_in">set</span> name = <span class="string">&#x27;a1&#x27;</span> <span class="built_in">where</span> <span class="built_in">id</span> = 1; <span class="comment">#自己不可写</span></span></span><br><span class="line">ERROR 1099 (HY000): Table &#x27;mylock&#x27; was locked with a READ lock and can&#x27;t be updated</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from account; <span class="comment"># 不可操作其他表</span></span></span><br><span class="line">ERROR 1100 (HY000): Table &#x27;account&#x27; was not locked with LOCK TABLES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################sessionB###############################</span></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from mylock;<span class="comment">#其他人可以读</span></span></span><br><span class="line">+----+------+</span><br><span class="line">| id | NAME |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | a    |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">update mylock <span class="built_in">set</span> name = <span class="string">&#x27;a2&#x27;</span> <span class="built_in">where</span> <span class="built_in">id</span> = 1; <span class="comment">#其他人不可写，需要等待</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">阻塞....</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#######################SessionA##########################</span></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">unlock tables; <span class="comment">#释放锁</span></span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#######################SessionB#########################</span></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">update mylock <span class="built_in">set</span> name = <span class="string">&#x27;a2&#x27;</span> <span class="built_in">where</span> <span class="built_in">id</span> = 1;<span class="comment">#获取到锁，进行写操作</span></span></span><br><span class="line">Query OK, 1 row affected (13.41 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from mylock;<span class="comment"># 数据已经变更</span></span></span><br><span class="line">+----+------+</span><br><span class="line">| id | NAME |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | a2   |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>步骤6∶加写锁</li></ul><p>为mylock表加write锁，观察阻塞的情况，流程如下:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335828.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#######################SessionA########################################</span></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">lock tables mylock write; <span class="comment">#为表上加写锁</span></span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from mylock; <span class="comment">#自己可用读</span></span></span><br><span class="line">+----+------+</span><br><span class="line">| id | NAME |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | a1   |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">update mylock <span class="built_in">set</span> name = <span class="string">&#x27;a2&#x27;</span> <span class="built_in">where</span> <span class="built_in">id</span> = 1; <span class="comment">#自己可以写</span></span></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from account; <span class="comment">#自己无法操作其他表</span></span></span><br><span class="line">ERROR 1100 (HY000): Table &#x27;account&#x27; was not locked with LOCK TABLES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###########################SessionB##################################</span></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from mylock; <span class="comment">#其他人不可以读</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">阻塞...</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">update mylock <span class="built_in">set</span> name = <span class="string">&#x27;a3&#x27;</span> <span class="built_in">where</span> <span class="built_in">id</span> = 1; <span class="comment">#其他人不可以写</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">阻塞...</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from account; <span class="comment">#可以操作其他表</span></span></span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | abc    |      40 |</span><br><span class="line">|  2 | 李四   |       0 |</span><br><span class="line">|  3 | 王五   |     100 |</span><br><span class="line">|  4 | 马六   |    1000 |</span><br><span class="line">|  5 | 张三   |    6666 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p><strong>总结：</strong><br><font color=red>MylSAM在执行查询语句(SELECT)前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁</font>。InnoDB存储引擎是不会为这个表添加表级别的读锁或者写锁的。</p><p>MySQL的表级锁有两种模式：(以MyISAM表进行操作的演示)</p><ul><li>表共享读锁(Table Read Lock)</li><li>表独占写锁(Table Write Lock)</li></ul><table><thead><tr><th align="center">锁类型</th><th align="center">自己可读</th><th align="center">自己可写</th><th align="center">自己可操作其他表</th><th align="center">他人可读</th><th align="center">他人可写</th></tr></thead><tbody><tr><td align="center">读锁</td><td align="center">是</td><td align="center">否</td><td align="center">否</td><td align="center">是</td><td align="center">否，需等待</td></tr><tr><td align="center">写锁</td><td align="center">是</td><td align="center">是</td><td align="center">否</td><td align="center">否，需等待</td><td align="center">否，需等待</td></tr></tbody></table><h5 id="②-意向锁-（intention-lock）"><a href="#②-意向锁-（intention-lock）" class="headerlink" title="② 意向锁 （intention lock）"></a><font color=orange>② 意向锁 （intention lock）</font></h5><p>InnoDB 支持 <code>多粒度锁</code>（multiple granularity locking） ，它允许 <code>行级锁</code> 与 <code>表级锁</code> 共存，而<code>意向锁</code>就是其中的一种 <code>表锁</code> 。</p><ul><li>意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。</li><li>意向锁是一种&#x3D;&#x3D;不与行级锁冲突的表级锁&#x3D;&#x3D;，这一点非常重要。</li><li>表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</li></ul><p>意向锁分为两种：</p><ul><li><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<code>共享锁</code>（S锁）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure><ul><li><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<code>排他锁</code>（X锁）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>即：&#x3D;&#x3D;意向锁是由存储引擎 <code>自己维护的</code> ，用户无法手动操作意向锁&#x3D;&#x3D;，在为数据行加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据行 <code>所在数据表的对应意向锁</code> 。</p><p><strong><font color=blue>1、意向锁要解决的问题</font></strong></p><p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁；如果存在意向锁，那么此时就会受到由T1控制的<code>表级别意向锁的阻塞</code>。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说就是<code>给更大一级别的空间示意里面是否已经上过锁</code>。</p><p>在数据表的场景中，<font color=red>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</font>，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p><ul><li>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁。</li><li>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排他锁</li></ul><p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录</p><p>举例：事务的隔离级别默认为Repeatable-Read，如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 创建表teacher，插入<span class="number">6</span>条数据</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `teacher`(</span><br><span class="line">  id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `teacher` <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;zhangsan&#x27;</span>),</span><br><span class="line">(<span class="number">2</span> , <span class="string">&#x27;lisi&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;wangwu&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;zhaoliu&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;songhongkang&#x27;</span>),</span><br><span class="line">(<span class="number">6</span> , <span class="string">&#x27;leifengyang&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 查看数据</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> zhangsan     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> lisi         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> wangwu       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> zhaoliu      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> songhongkang <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> leifengyang  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># 假设事务A获取了某一行的排他锁，并未提交</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"># 事务B想要获取teacher表的表读锁，语句如下。</span><br><span class="line"><span class="keyword">begin</span> ;</span><br><span class="line">LOCK TABLES teacher READ;</span><br><span class="line">#阻塞...</span><br></pre></td></tr></table></figure><p>因为共享锁与排他锁互斥，所以事务B在试图对teacher表加共享锁的时候，必须保证两个条件</p><p>（1）当前没有其他事务持有teacher表的排他锁</p><p>（2）当前没有其他事务持有teacher 表中任意一行的排他锁。</p><p>为了检测是否满足第二个条件，事务B必须在确保teacher表不存在任何排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了意向锁之后，情况就不一样了。</p><p>意向锁是怎么解决这个问题的呢？首先需要知道意向锁之间的兼容互斥性，如下所示：</p><table><thead><tr><th>兼容性</th><th>意向共享锁(lS)</th><th>意向排他锁(IX)</th></tr></thead><tbody><tr><td>意向共享锁(IS)</td><td>兼容</td><td>兼容</td></tr><tr><td>意向排他锁(IX)</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>即意向锁之间是互相兼容的，虽然意向锁和自家兄弟互相兼容，但是它会与普通的排他&#x2F;共享锁互斥。</p><table><thead><tr><th>兼容性</th><th>意向共享锁(lS)</th><th>意向排他锁(IX)</th></tr></thead><tbody><tr><td>共享锁(S)</td><td>兼容</td><td>互斥</td></tr><tr><td>排他锁(X)</td><td>互斥</td><td>互斥</td></tr></tbody></table><blockquote><p>注意这里的排他&#x2F;共享锁指的都是表锁，&#x3D;&#x3D;意向锁不会与行级的共享&#x2F;排他锁互斥&#x3D;&#x3D;。 可以把意向锁看做是一种行级锁的标记</p></blockquote><p>回到刚才teacher表的例子。事务A获取了某一行的排他锁，并未提交:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>此时 teacher表存在两把锁： teacher表上的意向排他锁与id为6的数据行上的排他锁。事务B想要获取teacher表的共享锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">LOCK TABLES teacher READ;</span><br></pre></td></tr></table></figure><p>此时事务B检测事务A持有teacher 表的意向排他锁，就可以得知事务A必然持有该表中某些数据行的排他锁，那么事务B对teacher表的加锁请求就会被<code>排斥</code>(<code>阻塞</code>)，而<code>无需去检测</code>表中的每一行数据是否存在排他锁。  </p><p><strong><font color=blue>2、意向锁的并发性</font></strong><br><font color=red>意向锁不会与行级的共享&#x2F;排他锁互斥！</font>正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。(如果互斥，那么行级锁直接就退化成表锁了，就没有什么优势了~)</p><p>我们扩展一下上面teacher表的例子来概括一下意向锁的作用（一条数据从被锁定到被释放的过程中，可能存在多种不同锁，但是这里只着重表现意向锁)</p><p>**<font color=green>① </font>**事务A先获取了某一行的排他锁，并未提交:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>**<font color=green>② </font>**事务A获取了teacher表上的意向排他锁，事务A获取了id为6的数据行上的排他锁。之后事务B想要获取teacher表的共享锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">LOCK TABLES teacher READ ;</span><br></pre></td></tr></table></figure><p>③ 事务B<code>检测到</code>事务A持有teacher表的<code>意向排他锁</code>。事务B对teacher表的加锁请求被<code>阻塞</code>(排斥)。最后事务C也想获取teacher表中某一行的排他锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>事务C申请teacher表的意向排他锁。事务C检测到事务A持有teacher表的意向排他锁。<code>因为意向锁之间并不互斥</code>，所以事务C获取到了teacher表的意向排他锁。因为id为5的数据行上不存在任何排他锁，最终事务C成功获取到了该数据行上的<code>排他锁</code>。</p><p><strong>从上面的案例可以得到如下结论：</strong></p><ol><li>InnoDB支持<code>多粒度锁</code>，特定场景下，&#x3D;&#x3D;行级锁可以与表级锁共存&#x3D;&#x3D;。</li><li>意向锁之间互不排斥，但除了IS与S兼容外，<code>意向锁会与共享锁 / 排他锁互斥</code>。</li><li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li><li>意向锁在保证并发性的前提下，实现了<code>行锁和表锁共存</code>且<code>满足事务隔离性</code>的要求。</li></ol><h5 id="③-自增锁（AUTO-INC锁）"><a href="#③-自增锁（AUTO-INC锁）" class="headerlink" title="③ 自增锁（AUTO-INC锁）"></a><font color=orange>③ 自增锁（AUTO-INC锁）</font></h5><p>在使用MySQL过程中，我们可以为表的某个列添加 <code>AUTO_INCREMENT </code>属性。举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `teacher` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改如下所示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `teacher` (name) <span class="keyword">VALUES</span> (<span class="string">&#x27;zhangsan&#x27;</span>), (<span class="string">&#x27;lisi&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值，结果如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+----+----------+</span></span><br><span class="line"><span class="comment">| id | name |</span></span><br><span class="line"><span class="comment">+----+----------+</span></span><br><span class="line"><span class="comment">| 1 | zhangsan |</span></span><br><span class="line"><span class="comment">| 2 | lisi |</span></span><br><span class="line"><span class="comment">+----+----------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>现在看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是“ <code>Simple inserts</code> ”，“ <code>Bulk inserts</code> ”和“ <code>Mixed-mode inserts</code> ”。</p><p><strong>1. “Simple inserts” （简单插入）</strong><br>可以 <code>预先确定要插入的行数</code> （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<code>INSERT…VALUES()</code> 和 <code>REPLACE</code> 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行数。</p><p><strong>2. “Bulk inserts” （批量插入）</strong><br><code>事先不知道要插入的行数</code> （和所需自动递增值的数量）的语句。比如 <code>INSERT … SELECT</code> ， <code>REPLACE … SELECT</code> 和<code>LOAD DATA</code>语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。</p><p><strong>3. “Mixed-mode inserts” （混合模式插入）</strong><br>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 <code>INSERT INTO teacher (id,name) VALUES (1,‘a’), (NULL,‘b’), (5,‘c’), (NULL,‘d’); </code>只是指定了部分id的值。另一种类型的“混合模式插入”是 <code>INSERT … ON DUPLICATE KEY UPDATE</code> 。</p><p>对于上面数据插入的案例，MySQL中采用了<code>自增锁</code>的方式来实现，&#x3D;&#x3D;AUTO-INC锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁&#x3D;&#x3D;，在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC锁释放掉。&#x3D;&#x3D;一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞&#x3D;&#x3D;，可以保证一个语句中分配的递增值是连续的。也正因为此，其<code>并发性显然并不高</code>，&#x3D;&#x3D;当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争&#x3D;&#x3D;，这样的并发潜力其实是很低下的，所以InnoDB通过<code>innodb_autoinc_lock_mode</code>的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。</p><p><strong><font color=blue>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：（了解）</font></strong></p><p><code>(1) innodb_autoinc_lock_mode = 0(“传统&quot;锁定模式)</code> 在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会 <code>限制并发</code> 能力。</p><p><code>（2) innodb_autoinc_lock_mode = 1(“连续”锁定模式)</code> 在 MySQL 8.0 之前，连续锁定模式是 默认 的。</p><p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT …SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p><p>对于“Simple inserts”（要插入的行数事先已知），则通过在<code> mutex（轻量锁）</code> 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。</p><p><code>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式)</code></p><p>从 MySQL 8.0 开始，交错锁定模式是 <code>默认</code> 的。</p><p>在这种锁定模式下，所有类INSERT语句都不会使用表级AUTO-INC锁，并且可以同时执行多个语句。这是最快和最可扩展的锁定模式，但是当使用基于语句的复制或恢复方案时，<code>从二进制日志重播SQL语句时，这是不安全的</code>。</p><p>在此锁定模式下，自动递增值保证在所有并发执行的所有类型的insert语句中是<code>唯一</code>且<code>单调递增</code>的。但是，由于多个语句可以同时生成数字(即，跨语句交叉编号），<code>为任何给定语句插入的行生成的值可能不是连续的</code>。</p><p>如果执行的语句是”simple inserts”，其中要插入的行数已提前知道，除了“Mixed-mode inserts”之外，为单个语句生成的数字不会有间隙。然而，当执行“bulk inserts”时，在由任何给定语句分配的自动递增值中可能存在间隙。</p><h5 id="④-元数据锁（MDL锁）"><a href="#④-元数据锁（MDL锁）" class="headerlink" title="④ 元数据锁（MDL锁）"></a><font color=orange>④ 元数据锁（MDL锁）</font></h5><p>MySQL5.5引入了<code>meta data lock</code>，简称<code>MDL</code>锁，属于表锁范畴。MDL的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个<code>表结构做变更</code>，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的</p><p>因此，&#x3D;&#x3D;当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁&#x3D;&#x3D;。</p><p>读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。&#x3D;&#x3D;不需要显式使用&#x3D;&#x3D;，在访问一个表的时候会被自动加上。</p><p><strong>举例：元数据锁的使用场景模拟</strong></p><ul><li>会话A：从表中查询数据</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335043.png" alt="image-20230125165020157"></p><ul><li>会话B：修改表结构，增加新列</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335170.png" alt="image-20230125165055077"></p><ul><li>会话C：查看当前MySQL的进程，可以得出B中的阻塞就是因为A为teacher加了MDL锁</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335683.png" alt="image-20230125163142559"></p><ul><li>在会话B中结束修改，进行读操作</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335772.png" alt="image-20230125163856580"></p><ul><li>B中之前的所有进行提交，重新开启事务尽心修改，同时C中也开启一个事务进行查询~</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335815.png"></p><p>可以看出会话B被阻塞，这是由于会话A拿到了teacher表的<code>元数据读锁</code>，会话B想申请teacher表的<code>元数据写锁</code>，由于&#x3D;&#x3D;读写锁互斥&#x3D;&#x3D;，会话B需要等待会话A释放元数据锁才能执行。而会话C要在表teacher上新申请MDL读锁的请求也会被<code>会话B</code> 阻塞。</p><p>前面说了，所有对表的增删改查操作都需要先申请MDL读锁，现在就都被阻塞了，等于这个表现在完全不可读写了，&#x3D;&#x3D;并发性大大降低&#x3D;&#x3D;！！！这也就是元数据锁可能带来的问题~</p><h4 id="2-InnoDB中的行锁"><a href="#2-InnoDB中的行锁" class="headerlink" title="2. InnoDB中的行锁"></a>2. InnoDB中的行锁</h4><p>行锁(Row Lock)也称为记录锁，顾名思义，就是锁住某一行（某条记录row)。需要的注意的是，MySQL服务器层并没有实现行锁机制，&#x3D;&#x3D;行级锁只在存储引擎层实现&#x3D;&#x3D;。</p><p><strong>优点：</strong> 锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code>。<br><strong>缺点：</strong> 对于<code>锁的开销比较大</code>，加锁会比较慢，容易出现<code>死锁</code>情况。</p><p><font color=red>InnoDB与MylSAM的最大不同有两点：一是支持事务(TRANSACTION)；二是采用了行级锁。</font></p><p><font color=blue>演示环境搭建</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">  id <span class="type">INT</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  class <span class="type">varchar</span> (<span class="number">10</span>) ,<span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">)Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"># 插入几条记录</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span> ,<span class="string">&#x27;一班&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;李四&#x27;</span> ,<span class="string">&#x27;一班&#x27;</span>),</span><br><span class="line">( <span class="number">8</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;二班&#x27;</span>),</span><br><span class="line">( <span class="number">15</span>,<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;二班&#x27;</span>),</span><br><span class="line">(<span class="number">20</span>, <span class="string">&#x27;钱七&#x27;</span>,<span class="string">&#x27;三班&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> student;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+----+--------+--------+</span></span><br><span class="line"><span class="comment">| id | name   | class  |</span></span><br><span class="line"><span class="comment">+----+--------+--------+</span></span><br><span class="line"><span class="comment">|  1 | 张三   | 一班   |</span></span><br><span class="line"><span class="comment">|  3 | 李四   | 一班   |</span></span><br><span class="line"><span class="comment">|  8 | 王五   | 二班   |</span></span><br><span class="line"><span class="comment">| 15 | 赵六   | 二班   |</span></span><br><span class="line"><span class="comment">| 20 | 钱七   | 三班   |</span></span><br><span class="line"><span class="comment">+----+--------+--------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>student表中的聚簇索引的简图如下所示</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335858.png" alt="image-20230125202318828"></p><p>这里把B+树的索引结构做了一个超级简化，只把索引中的记录给拿了出来，下面看看都有哪些常用的行锁类型。</p><h5 id="①-记录锁（Record-Locks）"><a href="#①-记录锁（Record-Locks）" class="headerlink" title="① 记录锁（Record Locks）"></a><font color=orange>① 记录锁（Record Locks）</font></h5><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为： <code>LOCK_REC_NOT_GAP</code>。比如把id值为8的那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335945.png" alt="image-20230125202950342"></p><p>举例如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335991.png" alt="image-20230125203029242"></p><p>代码演示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">###############################SessionA###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> student <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;张三1&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; #为id<span class="operator">=</span><span class="number">1</span>的记录加X型的行锁</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">###############################SessionB###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> class  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 李四   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> lock <span class="keyword">in</span> share mode; </span><br><span class="line">#阻塞...因为sessonA中的事务对该记录了X锁</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; #执行超时</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> student <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;李四1&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>; #为id<span class="operator">=</span><span class="number">3</span>的记录加X型的锁</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> student <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;张三2&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">#阻塞...</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; #执行超时</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###############################SessionA###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>; #提交</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">###############################SessionB###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> student <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;张三2&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; #再次尝试获取X锁，执行成功</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">5.74</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name    <span class="operator">|</span> class  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 张三<span class="number">2</span>   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 李四<span class="number">1</span>   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> 王五    <span class="operator">|</span> 二班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> 赵六    <span class="operator">|</span> 二班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> 钱七    <span class="operator">|</span> 三班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>记录锁是有S锁和X锁之分的，称之为 <code>S型记录锁</code> 和 <code>X型记录锁</code> 。</p><ul><li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li><li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li></ul><h5 id="②-间隙锁（Gap-Locks）"><a href="#②-间隙锁（Gap-Locks）" class="headerlink" title="② 间隙锁（Gap Locks）"></a><font color=orange>② 间隙锁（Gap Locks）</font></h5><blockquote><p>对于repeatable read，sql标准没解决幻读，MySQL中解决了幻读</p></blockquote><p>MySQL在 <code>REPEATABLE READ</code> 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 <code>MVCC</code>方案解决，也可以采用 <code>加锁</code> 方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些 <code>幻影记录</code> 加上 <code>记录锁</code> 。InnoDB提出了一种称之为<code>Gap Locks</code> 的锁，官方的类型名称为： <code>LOCK_GAP</code>，我们可以简称为 <code>gap锁</code> 。</p><p>比如，把id值为5的那条记录加一个gap锁的示意图如下。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335196.png"></p><p>图中id值为5的记录加了gap锁，意味着 <code>不允许别的事务在id值为5的记录所在的间隙插入新记录</code> ，其实就是id列的值<code>(3, 8)</code>这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新记录，它定位到该条新记录在id为5的间隙锁的范围内，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。</p><p><font color=red>gap锁的提出仅仅是为了防止插入幻影记录而提出的</font>。虽然有共享gap锁和独占gap锁这样的说法，但是它们起到的作用是相同的。而且&#x3D;&#x3D;如果对一条记录加了gap锁&#x3D;&#x3D;〈不论是共享gap锁还是独占gap锁)，&#x3D;&#x3D;并不会限制其他事务对这条记录加记录锁或者继续加gap锁&#x3D;&#x3D;。</p><p><strong>举例：</strong></p><table><thead><tr><th>Session1</th><th>Session2</th></tr></thead><tbody><tr><td>select * from student where id &#x3D; 5 lock in share mode;</td><td></td></tr><tr><td></td><td>select * from student where id &#x3D; 5 for update;</td></tr></tbody></table><p>这里session 2并不会被堵住。因为表里并没有id&#x3D;5这个记录，因此 session 1加的是间隙锁（3,8)。而session 2也是在这个间隙加的间隙锁。它们有共同的目标，即:保护这个间隙，不允许插入值。但，它们之间是不冲突的。</p><p><strong>注意，</strong>给一条记录加了<code>gap锁</code>只是<code>不允许</code>其他事务往这条记录前边的间隙<code>插入新记录</code>，那对于最后一条记录之后的间隙，也就是student 表中id值为<code>20</code>的记录之后的间隙该咋办呢？也就是说给哪条记录加<code>gap锁</code>才能阻止其他事务插入<code>id值</code>在<code>(20，正无穷)</code>这个区间的新记录呢？这时候我们在讲数据页时介绍的两条伪记录派上用场了：</p><ul><li><code>Infimum</code>记录，表示该页面中最小的记录。</li><li><code>Supremum</code>记录，表示该页面中最大的记录。</li></ul><p>为了实现阻止其他事务插入id值在(20, 正无穷)这个区间的新记录，可以给索引中的最后一条记录，也就是id值为20的那条记录所在页面的<code>Supremum</code>记录加上一个gap锁，如图所示</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335240.png" alt="image-20230125210502347"></p><p><strong><font color=bule>代码演示：</font></strong></p><ul><li>关于X和S锁互斥的知识回顾</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">###############################SessionA###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">8</span> lock <span class="keyword">in</span> share mode; #为id<span class="operator">=</span><span class="number">8</span>的记录加S锁</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> class  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> 王五   <span class="operator">|</span> 二班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">###############################SessionB####################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>; # A已经为id<span class="operator">=</span><span class="number">8</span>的加了S锁，B就不能加X锁了</span><br><span class="line"><span class="operator">^</span>C<span class="operator">^</span>C <span class="comment">-- query aborted</span></span><br><span class="line">ERROR <span class="number">1317</span> (<span class="number">70100</span>): Query execution was interrupted</span><br><span class="line"></span><br><span class="line">#################SessionA<span class="operator">&amp;</span>SessionB########################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>间隙锁</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#############################SessionA#####################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># id<span class="operator">=</span><span class="number">5</span>的记录不存在，所以无法加上记录锁<span class="operator">~</span> 对于不存在的记录，加的是间隙锁。（<span class="number">3</span><span class="number">-8</span>）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span> lock <span class="keyword">in</span> share mode; </span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">############################SessionB####################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># 依旧加的是间隙锁。可以看出共享gap锁和独占gap锁作用相同，而且可以重复加<span class="operator">~</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">##########################SessionC######################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;三班&#x27;</span>); #在间隙锁范围内，无法插入</span><br><span class="line">#阻塞...</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><ul><li>可以这样实现加 id &gt; 20的间隙锁：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">25</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果记录存在，则使用<code>for update</code> 或 <code>lock in share mode</code> 加的就是记录锁，如果记录不存在加的就是间隙锁~</p></blockquote><p>&#x3D;&#x3D;间隙锁的引入，可能会导致&#x3D;&#x3D;同样的语句锁住更大的范围，这其实是影响了并发度的。下面的例子会产生&#x3D;&#x3D;死锁&#x3D;&#x3D;。</p><table><thead><tr><th>Session1</th><th>Session2</th></tr></thead><tbody><tr><td>begin; select *from student where id &#x3D; 5 for update;</td><td>begin;select * from student where id &#x3D; 5 for update;</td></tr><tr><td></td><td>INSERT INTO student VALUES(5,’宋红康,‘二班’);阻塞</td></tr><tr><td>INSERT INTO student VALUES(5,‘宋红康’,‘二班’);(ERROR 1213(40001):Deadlock found when trying to get lock; try restarting transaction)</td><td></td></tr></tbody></table><p>① session 1执行select …for update语句，由于id &#x3D; 5这一行并不存在，因此会<code>加上间隙锁(3，8)</code>;<br>② session2执行select … for update语句，同样会<code>加上间隙锁（3，8)</code>，间隙锁之间不会冲突，因此这个语句可以执行成功;<br>③ session 2试图插入一行(5, ‘宋红康’, ‘二班’)，被session 1的间隙锁挡住了，只好<code>进入等待</code>；</p><p>④ session 1试图插入一行(5. 宋红康’二班)，被session2的间隙锁挡住了。至此，两个session陷入<code>死锁</code>。</p><p><strong><font color=bule>代码演示：</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#############################SessionA####################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span> lock <span class="keyword">in</span> share mode; #为id<span class="operator">=</span><span class="number">5</span>加间隙锁</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#############################SessionB####################################</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; #为id<span class="operator">=</span><span class="number">5</span>加间隙锁</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>); #id<span class="operator">=</span><span class="number">7</span>在间隙区间</span><br><span class="line">#阻塞...</span><br><span class="line"></span><br><span class="line">###########################SessionA######################################</span><br><span class="line">#出现了死锁，也可能在B中出现</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;Jane&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>); </span><br><span class="line">ERROR <span class="number">1213</span> (<span class="number">40001</span>): Deadlock found <span class="keyword">when</span> trying <span class="keyword">to</span> <span class="keyword">get</span> lock; try restarting transaction</span><br><span class="line"></span><br><span class="line">##########################SessionB##################################</span><br><span class="line">#出现死锁后，按照策略，让A回滚，从而B中的<span class="keyword">Insert</span>执行成功<span class="operator">~</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>); </span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><font color=red>分析：为什么会出现 死锁呢？</font></p><p>当SessionA中执行Insert，就会造成：B中Insert在等A中的间隙锁的释放~ A中的Insert在等B中间隙锁的释放~ （因为只有释放后，这俩各自的Insert才会继续执行）。从而A和B相互等待，就产生了<code>死锁</code></p><p>那为啥发生死锁后，A执行失败，B又成功执行了呢？(参见 3.6其它锁之:死锁)</p><p>这涉及MySQL的处理死锁机制。当MySQL发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务（将持有最少行级排他锁的事务进行回滚），让其他事务得以继续执行！</p><h5 id="③-临键锁（Next-Key-Locks）"><a href="#③-临键锁（Next-Key-Locks）" class="headerlink" title="③ 临键锁（Next-Key Locks）"></a><font color=orange>③ 临键锁（Next-Key Locks）</font></h5><p>有时候既想 <code>锁住某条记录</code> ，又想 <code>阻止 </code>其他事务在该记录前边的 <code>间隙插入新记录</code> ，所以InnoDB就提出了一种称之为 <code>Next-Key Locks</code> 的锁，官方的类型名称为： <code>LOCK_ORDINARY</code> ，我们也可以简称为<code>next-key锁</code> 。Next-Key Locks是在存储引擎 <code>innodb</code>、事务级别在 <code>可重复读</code> 的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。</p><p>比如，把id值为8的那条记录加一个next-key锁的示意图如下:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335320.png"></p><p><code>next-key</code>锁的本质就是一个<code>记录锁</code>和一个<code>gap锁</code>的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的<code>间隙</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">8</span> <span class="keyword">and</span> id <span class="operator">&gt;</span> <span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p><font color=blue>代码演示</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#############################SessionA####################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># 为(<span class="number">8</span>，,<span class="number">15</span>]加邻键锁（<span class="number">8</span><span class="number">-15</span>是间隙 <span class="operator">+</span> <span class="number">15</span>记录锁）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">15</span> <span class="keyword">and</span> id <span class="operator">&gt;</span> <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> class  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> 赵六   <span class="operator">|</span> 二班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#############################SessionB####################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">15</span> lock <span class="keyword">in</span> share mode; #无法获取S锁</span><br><span class="line"><span class="operator">^</span>C<span class="operator">^</span>C <span class="comment">-- query aborted</span></span><br><span class="line">ERROR <span class="number">1317</span> (<span class="number">70100</span>): Query execution was interrupted</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">15</span> <span class="keyword">for</span> <span class="keyword">update</span>; #无法获取X锁</span><br><span class="line"><span class="operator">^</span>C<span class="operator">^</span>C <span class="comment">-- query aborted</span></span><br><span class="line">ERROR <span class="number">1317</span> (<span class="number">70100</span>): Query execution was interrupted</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">12</span>,<span class="string">&#x27;Tim&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>); #无法在间隙内插入数据</span><br><span class="line"><span class="operator">^</span>C<span class="operator">^</span>C <span class="comment">-- query aborted</span></span><br><span class="line">ERROR <span class="number">1317</span> (<span class="number">70100</span>): Query execution was interrupted</span><br><span class="line">    </span><br><span class="line">###############################SessionA<span class="operator">&amp;</span>SessionB#######################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h5 id="④-插入意向锁（Insert-Intention-Locks）"><a href="#④-插入意向锁（Insert-Intention-Locks）" class="headerlink" title="④ 插入意向锁（Insert Intention Locks）"></a><font color=orange>④ 插入意向锁（Insert Intention Locks）</font></h5><p>我们说一个事务在 <code>插入</code> 一条记录时需要判断一下插入位置是不是被别的事务加了 <code>gap锁</code> （ <code>next-key</code>锁也包含 <code>gap锁</code> ），如果有的话，插入操作需要等待，直到拥有 <code>gap锁</code> 的那个事务提交。但是InnoDB &#x3D;&#x3D;规定事务在等待的时候也需要在内存中生成一个锁结构&#x3D;&#x3D;，表明有事务想在某个 <code>间隙</code> 中 插入 <code>新记录</code>，但是现在在等待。InnoDB就把这种类型的锁命名为 <code>Insert Intention Locks</code> ，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们称为 <code>插入意向锁</code> 。&#x3D;&#x3D;插入意向锁是一种 <code>Gap锁</code> ，不是意向锁&#x3D;&#x3D;，在insert操作时产生。</p><blockquote><p>插入意向锁是在插入一条记录行前，由 INSERT 操作产生的一种间隙锁<br>事实上插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</p></blockquote><p>插入意向锁是在插入一条记录行前，由&#x3D;&#x3D;INSERT 操作产生的一种间隙锁&#x3D;&#x3D;。该锁用以表示<code>插入意向</code>，当多个事务在同一区间(gap）插入<code>位置不同</code>的多条数据时，事务之间<code>不需要互相等待</code>。假设存在两条值分别为8和15的记录，两个不同的事务分别试图插入值为11和12的两条记录，每个事务在获取插入行上独占的(排他）锁前，都会获取(8，15）之间的间隙锁，但是因为数据行之间并<code>不冲突</code>，所以两个事务之间并不会产生冲突（<code>阻塞等待</code>)。总结来说，插入意向锁的特性可以分成两部分：</p><p>(1）&#x3D;&#x3D;插入意向锁是一种特殊的间隙锁&#x3D;&#x3D;―—间隙锁可以锁定开区间内的部分记录。<br>(2）&#x3D;&#x3D;插入意向锁之间互不排斥&#x3D;&#x3D;，所以即使多个事务在同一区间插入多条记录，只要记录本身(主键、唯一索引)<code>不冲突</code>，那么事务之间就不会出现冲突等待</p><p>注意，虽然插入意向锁中含有意向锁三个字，但是它并不属于意向锁而属于间隙锁，因为意向锁是表锁而插入意向锁是行锁</p><p>比如，把id值为8的那条记录加一个插入意向锁的示意图如下:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335409.png" alt="image-20230126151811673"></p><p>比如，现在T1为id值为8的记录加了一个gap锁，然后T2和T3分别想向student表中插入id值分别为4、5的两条记录，所以现在为id值为8的记录加的锁的示意图就如下所示:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335546.png" alt="image-20230126151840355"></p><p>从图中可以看到，由于<code>T1持有gap锁</code>，所以<code>T2和T3</code>需要<code>生成一个插入意向锁</code>的锁结构并且处于<code>等待</code>状态。当T1提交后会把它获取到的锁都释放掉，这样T2和T3就能<code>获取</code>到对应的插入意向锁了(本质上就是把插入意向锁对应锁结构的is_waiting属性改为false)，T2和T3之间也并不会相互阻塞，它们可以<code>同时</code>获取到id值为8的插入意向锁，然后执行插入操作。事实上&#x3D;&#x3D;插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。&#x3D;&#x3D;</p><p><strong><font color=blue>演示-插入意向锁</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">###############################SessionA####################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">12</span> <span class="keyword">for</span> <span class="keyword">update</span>; #加间隙锁</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">###############################SessionB####################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">12</span>,<span class="string">&#x27;Tim&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>); </span><br><span class="line">#阻塞..同时会加插入意向锁</span><br><span class="line"></span><br><span class="line">##############################SessionC###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">11</span>,<span class="string">&#x27;Tim&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>);</span><br><span class="line">#阻塞..同时会加插入意向锁。 可以看出插入意向锁是相互兼容的，毕竟id都不同嘛</span><br><span class="line"></span><br><span class="line">##############################SessionA#################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>; #提交</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#############################SessionB###############################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">12</span>,<span class="string">&#x27;Tim&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>); #插入成功</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">45.43</span> sec)</span><br><span class="line">##############################SessionC#################################</span><br><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">11</span>,<span class="string">&#x27;Tim&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>); #插入成功</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="3-页锁"><a href="#3-页锁" class="headerlink" title="3. 页锁"></a>3. 页锁</h4><p>页锁就是在 <code>页的粒度</code> 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。&#x3D;&#x3D;页锁的开销介于表锁和行锁之间，会出现<code>死锁</code>。锁定粒度介于表锁和行锁之间，并发度一般&#x3D;&#x3D;。</p><p>每个层级的锁数量是有限制的，因为锁会占用内存空间， <code>锁空间的大小是有限的</code> 。当某个层级的锁数量超过了这个层级的阈值时，就会进行 <code>锁升级</code> 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中<code>行锁升级为表锁</code>，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p><p><font color=blue>死锁演示：</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">事务A目前锁定了页A，想要锁定页B才可以执行完。</span><br><span class="line">事务B目前锁定了页B，想要锁定页A才可以执行完。</span><br><span class="line">### 死锁</span><br></pre></td></tr></table></figure><h3 id="3-3-从对待锁的态度划分-乐观锁、悲观锁"><a href="#3-3-从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="3.3 从对待锁的态度划分:乐观锁、悲观锁"></a>3.3 从对待锁的态度划分:乐观锁、悲观锁</h3><p>从对待锁的态度来看锁的话，可以将锁分成<code>乐观锁</code>和<code>悲观锁</code>，从名字中也可以看出这两种锁是两种看待<code>数据并发的思维方式</code> 。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的 <code>设计思想</code> 。</p><h4 id="1-悲观锁（Pessimistic-Locking）"><a href="#1-悲观锁（Pessimistic-Locking）" class="headerlink" title="1. 悲观锁（Pessimistic Locking）"></a>1. 悲观锁（Pessimistic Locking）</h4><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的<code>锁机制</code>来实现，从而保证数据操作的排它性。</p><p>悲观锁总是假设<code>最坏</code>的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 <code>阻塞</code> 直到它拿到锁（&#x3D;&#x3D;共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程&#x3D;&#x3D;）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中 <code>synchronized</code>和 <code>ReentrantLock </code>等独占锁就是悲观锁思想的实现。</p><p><strong><font color=blue>秒杀案例1：</font></strong><br>商品秒杀过程中，库存数量的减少，避免出现<code>超卖</code>的情况。比如，商品表中有一个字段为quantity表示当前该商品的库存量。假设商品为华为mate40，id为1001，quantity&#x3D;100个。如果不使用锁的情况下，操作方法如下所示:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#第<span class="number">1</span>步:查出商品库存</span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1001</span> ;</span><br><span class="line">#第<span class="number">2</span>步:如果库存大于<span class="number">0</span>，则根据商品信息生产订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders (item_id）<span class="keyword">values</span> ( <span class="number">1001</span> ) ;</span><br><span class="line">#第<span class="number">3</span>步:修改商品的库存，num表示购买数量</span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity <span class="operator">=</span> quantity<span class="operator">-</span>num <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1001</span> ;</span><br></pre></td></tr></table></figure><p>这样写的话，在并发量小的公司没有大的问题，但是如果在 <code>高并发环境</code> 下可能出现以下问题</p><table><thead><tr><th></th><th>线程A</th><th>线程B</th></tr></thead><tbody><tr><td>1</td><td>step1(查询还有100部手机)</td><td>step1(查询还有100部手机)</td></tr><tr><td>2</td><td></td><td>step2(生成订单)</td></tr><tr><td>3</td><td>step2(生成订单)</td><td></td></tr><tr><td>4</td><td></td><td>step3(减库存1)</td></tr><tr><td>5</td><td>step3(减库存2)</td><td></td></tr></tbody></table><p>其中线程B此时已经下单并且减完库存，这个时候线程A依然去执行step3，就可能会造成<code>超卖</code>。</p><p>我们使用悲观锁可以解决这个问题，商品信息从查询出来到修改，中间有一个生成订单的过程，使用悲观锁的原理就是，&#x3D;&#x3D;在查询items信息后就把当前的数据锁定，直到修改完毕后再解锁&#x3D;&#x3D;。那么整个过程中，因为数据被锁定了，就不会出现有第三者来对其进行修改了。而这样做的前提是<code>需要将要执行的SQL语句放在同一个事务中</code>，否则达不到锁定数据行的目的。</p><p><strong>修改如下:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#第<span class="number">1</span>步:查出商品库存</span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1001</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">#第<span class="number">2</span>步:如果库存大于<span class="number">0</span>，则根据商品信息生产订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders (item_id)<span class="keyword">values</span>(<span class="number">1001</span>);</span><br><span class="line">#第<span class="number">3</span>步:修改商品的库存，num表示购买数量</span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity <span class="operator">=</span> quantity<span class="operator">-</span>num <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1001</span> ;</span><br></pre></td></tr></table></figure><p><code>select … for update</code> 是MySQL中悲观锁。 此时在items表中，id为1001的那条数据就被锁定了，其他的要执行<code>select quantity from items where id = 1001 for update;</code>语句的事务必须等本次事务提交之后才能执行。这样可以保证当前的数据不会被其它事务修改。</p><blockquote><p>注意，当执行select quantity from items where id &#x3D; 1001 for update;语句之后，如果在其他事务中执行select quantity from items where id &#x3D; 1001;语句，并不会受第一个事务的影响，仍然可以正常查询出数据。</p></blockquote><p>另外，<font color=red>select … for update语句执行过程中所有扫描的行都会被锁上，因此在MySQL中用悲观锁必须确定使用了索引，而不是全表扫描，否则将会把整个表锁住（表锁）</font>。</p><blockquote><p>InnoDB 行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据 InnoDB 才使用行级锁，否则 InnoDB 将使用表锁~</p></blockquote><p>悲观锁不适用的场景较多，它存在一些不足，因为悲观锁大多数情况下依靠数据库的锁机制来实现，以保证程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是 <code>长事务</code> 而言，这样的 <code>开销往往无法承受</code>，这时就需要乐观锁。</p><h4 id="2-乐观锁（Optimistic-Locking）"><a href="#2-乐观锁（Optimistic-Locking）" class="headerlink" title="2. 乐观锁（Optimistic Locking）"></a>2. 乐观锁（Optimistic Locking）</h4><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是&#x3D;&#x3D;不采用数据库自身的锁机制，而是通过程序来实现&#x3D;&#x3D;。在程序上，可以采用 <code>版本号机制</code> 或者 <code>CAS机制</code> 实现。&#x3D;&#x3D;乐观锁适用于<code>多读</code>的应用类型，这样可以提高吞吐量&#x3D;&#x3D;。在Java中<code>java.util.concurrent.atomic</code> 包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p><p><strong><font color=orange>1. 乐观锁的版本号机制</font></strong></p><p>在表中设计一个 <code>版本字段 version</code> ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行 <code>UPDATE ... SET version = version + 1 WHERE version=version</code> 。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p><p>这种方式类似我们熟悉的SVN、CVS版本管理系统，当修改了代码进行提交时，首先会检查当前版本号与服务器上的版本号是否一致，如果一致就可以直接提交，如果不一致就需要更新服务器上的最新代码，然后再进行提交。</p><p><strong><font color=orange>2. 乐观锁的时间戳机制</font></strong></p><p>时间戳和版本号机制一样，也是在更新提交的时候，将<code>当前数据的时间戳和更新之前取得的时间戳</code>进行比较，如果两者一致则更新成功，否则就是版本冲突。</p><p>能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳(版本号或者时间戳)，从而证明当前拿到的数据是否最新。</p><p><font color=blue>秒杀案例2</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#第<span class="number">1</span>步:查出商品库存</span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line">#第<span class="number">2</span>步:如果库存大于<span class="number">0</span>，则根据商品信息生产订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders (item_id）<span class="keyword">values</span> (<span class="number">1001</span>);</span><br><span class="line"></span><br><span class="line">#第<span class="number">3</span>步:修改商品的库存,num表示购买数量</span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity <span class="operator">=</span> quantity<span class="operator">-</span>num , version <span class="operator">=</span> version<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1001</span> <span class="keyword">and</span> version <span class="operator">=</span> #&#123;version&#125; ;</span><br></pre></td></tr></table></figure><p>注意，如果数据表是 <code>读写分离</code> (主写从读)的表，当matser表中写入的数据没有及时同步到slave表中时，会造成更新一直失败的问题。此时需要<code>强制读取master表</code>中的数据（即将select语句放到事务中即可，这时候查询的就是master主库了)</p><p>如果对同一条数据进行 <code>频繁的修改</code> 的话，那么就会出现这么一种场景，每次修改都只有一个事务能更新成功，在业务感知上面就有大量的失败操作。我们把代码修改如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#第<span class="number">1</span>步:查出商品库存</span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line">#第<span class="number">2</span>步:如果库存大于<span class="number">0</span>，则根据商品信息生产订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders (item_id)<span class="keyword">values</span>(<span class="number">1001</span>);</span><br><span class="line"></span><br><span class="line">#第<span class="number">3</span>步:修改商品的库存，num表示购买数量</span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity <span class="operator">=</span> quantity<span class="operator">-</span>num <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1001</span> <span class="keyword">and</span> quantity<span class="operator">-</span>num <span class="operator">&gt;</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>这样就会使每次修改都能成功，而且不会出现超卖的现象。</p><p><strong><font color=orange>3. 两种锁的适用场景</font></strong></p><p>从这两种锁的设计思想中，总结一下乐观锁和悲观锁的适用场景：</p><ol><li><p><code>乐观锁</code> 适合 <code>读操作多</code> 的场景，相对来说写的操作比较少。它的优点在于<code>程序实现</code> ，<code>不存在死锁</code> 问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</p></li><li><p><code>悲观锁</code> 适合 <code>写操作多</code> 的场景，因为写的操作具有 <code>排它性</code> 。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止 <code>读 - 写</code> 和 <code>写 - 写</code> 的冲突。</p></li></ol><p>把乐观锁和悲观锁总结如下图所示</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335691.png" alt="image-20230127145003149"></p><h3 id="3-4-按加锁的方式划分-显式锁、隐式锁"><a href="#3-4-按加锁的方式划分-显式锁、隐式锁" class="headerlink" title="3.4 按加锁的方式划分:显式锁、隐式锁"></a>3.4 按加锁的方式划分:显式锁、隐式锁</h3><h4 id="1-隐式锁"><a href="#1-隐式锁" class="headerlink" title="1. 隐式锁"></a>1. 隐式锁</h4><blockquote><p><strong>回顾</strong></p><p>一个事务在执行<code>INSERT</code>操作时，如果即将插入的<code>间隙</code>已经被其他事务加了<code>gap锁</code>，那么本次<code>INSERT</code>操作会阻塞，并且当前事务会在该间隙上加一个<code>插入意向锁</code>。【被动加锁】</p><p>否则，一般情况下，新插入一条记录的操作并不加锁（后面会推翻这个结论，<font color=red>严格来说是加锁的，隐式锁</font>）【主动加锁】</p></blockquote><p>那如果一个事务首先插入了一条记录（此时并没有在内存生产与该记录关联的锁结构)，然后另一个事务:</p><ul><li>立即使用<code>SELECT … LOCK IN SHARE MODE</code>语句读取这条记录，也就是要获取这条记录的<code>S锁</code>，或者使用<code>SELECT… FOR UPDATE</code>语句读取这条记录，也就是要获取这条记录的<code>X锁</code>，怎么办?<br>如果允许这种情况的发生，那么可能产生<code>脏读</code>问题。</li><li>立即修改这条记录，也就是要获取这条记录的<code>X锁</code>，怎么办?<br>如果允许这种情况的发生，那么可能产生<code>脏写</code>问题。</li></ul><p>这时候前边提过的<code>事务id</code>又要起作用了。把聚簇索引和二级索引中的记录分开看一下：（原理了解即可）</p><p><strong>情景一：</strong>对于聚簇索引记录来说，有一个<code>trx_id </code>隐藏列，该隐藏列记录着最后改动该记录的 <code>事务id</code> 。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 <code>trx_id</code> 隐藏列代表的的就是当前事务的 <code>事务id</code> ，如果其他事务此时想对该记录添加 <code>S锁</code> 或者 <code>X锁</code> 时，首先会看一下该记录的<code>trx_id</code> 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就<code>帮助</code>当前事务创建一个 <code>X锁</code> （也就是为当前事务创建一个锁结构， <code>is_waiting</code> 属性是 <code>false</code>），然后自己进入阻塞状态（也就是为自己也创建一个锁结构， <code>is_waiting</code>属性是 <code>true </code>）。<br><strong>情景二：</strong>对于二级索引记录来说，本身并没有<code>trx_id</code> 隐藏列，但是在二级索引页面的 Page Header 部分有一个 <code>PAGE_MAX_TRX_ID</code> 属性，该属性代表对该页面做改动的最大的 <code>事务id</code> ，如果 <code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活跃 <code>事务id</code> ，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复 <code>情景一</code> 的做法。<br>即：&#x3D;&#x3D;一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于<code>事务id</code>的存在，相当于加了一个隐式锁&#x3D;&#x3D;。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种<code>延迟加锁</code>的机制，从而来减少加锁的数量。</p><p>隐式锁在实际内存对象中并不含有这个锁信息。&#x3D;&#x3D;只有当产生锁等待时，隐式锁转化为显式锁&#x3D;&#x3D;。</p><p>InnoDB的insert操作，对插入的记录不加锁，但是此时如果另一个线程进行当前读，类似以下的用例，整个过程会发生什么呢 ?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">############################SessionA#########################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">12</span>,<span class="string">&#x27;关羽&#x27;</span>,<span class="string">&#x27;三班&#x27;</span>); #此时相当于会加个隐式锁</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">###########################SessionC###############################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> performance_schema.data_lock_waits\G; #隐式锁是查不到的</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">##########################SessionB################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student lock <span class="keyword">in</span> share mode;  #可以侧面得出结论，隐式锁是存在的<span class="operator">~</span></span><br><span class="line">#阻塞... #阻塞也会导致A中的隐式锁转为显示锁</span><br><span class="line"></span><br><span class="line">##########################SessionC###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> performance_schema.data_lock_waits\G; #查到由隐式锁转的显示锁</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">                          ENGINE: INNODB</span><br><span class="line">       REQUESTING_ENGINE_LOCK_ID: <span class="number">140078105288944</span>:<span class="number">47</span>:<span class="number">4</span>:<span class="number">10</span>:<span class="number">140078009627240</span></span><br><span class="line">REQUESTING_ENGINE_TRANSACTION_ID: <span class="number">421553081999600</span></span><br><span class="line">            REQUESTING_THREAD_ID: <span class="number">49</span></span><br><span class="line">             REQUESTING_EVENT_ID: <span class="number">25</span></span><br><span class="line">REQUESTING_OBJECT_INSTANCE_BEGIN: <span class="number">140078009627240</span></span><br><span class="line">         BLOCKING_ENGINE_LOCK_ID: <span class="number">140078105288088</span>:<span class="number">47</span>:<span class="number">4</span>:<span class="number">10</span>:<span class="number">140078009620736</span></span><br><span class="line">  BLOCKING_ENGINE_TRANSACTION_ID: <span class="number">17430</span></span><br><span class="line">              BLOCKING_THREAD_ID: <span class="number">49</span></span><br><span class="line">               BLOCKING_EVENT_ID: <span class="number">25</span></span><br><span class="line">  BLOCKING_OBJECT_INSTANCE_BEGIN: <span class="number">140078009620736</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>隐式锁的逻辑过程如下：</strong></p><p>A. InnoDB的每条记录中都一个隐含的<code>trx_id</code>字段，这个字段存在于聚簇索引的B+Tree中。<br>B. 在操作一条记录前，首先根据记录中的<code>trx_id</code>检查该事务是否是活动的事务(未提交或回滚)。如果是活动的事务，首先将 &#x3D;&#x3D;隐式锁 转换为 显式锁&#x3D;&#x3D; (就是为该事务添加一个锁)。<br>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为<code>waiting</code>状态。如果没有冲突不加锁，跳到E。<br>D. 等待加锁成功，被唤醒，或者超时。<br>E. 写数据，并将自己的 <code>事务id</code> 写入trx_id字段。</p><h4 id="2-显式锁"><a href="#2-显式锁" class="headerlink" title="2. 显式锁"></a>2. 显式锁</h4><p>通过特定的语句进行加锁，一般称之为显示加锁，例如:</p><ul><li>显示加共享锁：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ....lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure><ul><li>显示加排它锁：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ....<span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><h3 id="3-5-其它锁之：全局锁"><a href="#3-5-其它锁之：全局锁" class="headerlink" title="3.5 其它锁之：全局锁"></a>3.5 其它锁之：全局锁</h3><p>全局锁就是对<code>整个数据库实例</code>加锁。当你需要让整个库处于<code>只读状态</code>的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句(数据的增删改)、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用<code>场景</code>是：做<code>全库逻辑备份</code>。</p><p>全局锁的命令:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></table></figure><h3 id="3-6-其它锁之：死锁"><a href="#3-6-其它锁之：死锁" class="headerlink" title="3.6 其它锁之：死锁"></a>3.6 其它锁之：死锁</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性<code>循环</code>。死锁举例如下：</p><p><strong>举例一：</strong></p><table><thead><tr><th></th><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td>1</td><td>start transaction;<br/>update account set money&#x3D;10 where id&#x3D;1;</td><td>start transaction;</td></tr><tr><td>2</td><td></td><td>update account set money&#x3D;10 where id&#x3D;2:</td></tr><tr><td>3</td><td>update account set money&#x3D;20 where id&#x3D;2:</td><td></td></tr><tr><td>4</td><td></td><td>update account set money&#x3D;20 where id&#x3D;1;</td></tr></tbody></table><p>这时候，事务1在等待事务2释放id&#x3D;2的行锁，而事务2在等待事务1释放id&#x3D;1的行锁。 事务1和事务2在<code>互相等待</code>对方的资源释放，就是进入了<code>死锁</code>状态。当出现死锁以后，有两种策略 ：</p><ul><li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数<code>innodb_lock_wait_timeout </code>来设置。</li><li>另一种策略是，发起<code>死锁检测</code>，发现死锁后，主动回滚死锁链条中的某一个事务（<code>将持有最少行级排他锁的事务进行回滚</code>），让其他事务得以继续执行。将参数<code>innodb_deadlock_detect </code>设置为<code>on </code>，表示开启这个逻辑。</li></ul><p>在InnoDB中，innodb_lock_wait_timeout的默认值是<code>50s</code>，意味着如果采用第一个策略，当出现死锁以后,第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p><p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p><p><strong>举例二：</strong></p><p>用户A给用户B转账100，在此同时，用户B也给用户A转账100。这个过程，可能导致死锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#事务<span class="number">1</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">108</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;#操作<span class="number">1</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>);#操作<span class="number">3</span></span><br><span class="line"></span><br><span class="line">#事务<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;#操作<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;#操作<span class="number">4</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335741.png" alt="image-20230127162458138"></p><h4 id="2-产生死锁的必要条件"><a href="#2-产生死锁的必要条件" class="headerlink" title="2. 产生死锁的必要条件"></a>2. 产生死锁的必要条件</h4><ol><li>两个或者两个以上事务</li><li>每个事务都已经持有锁并且申请新的锁</li><li>锁资源同时只能被同一个事务持有或者不兼容</li><li>事务之间因为持有锁和申请锁导致彼此循环等待</li></ol><blockquote><p>死锁的关键在于:两个(或以上)的Session加锁的顺序不一致。</p></blockquote><p><strong><font color=blue>演示—死锁</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#####################################SessionA########################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; #为<span class="number">1</span>d<span class="operator">=</span><span class="number">1</span>的加X锁</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">###################################SessionB########################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>; #为id<span class="operator">=</span><span class="number">3</span>的加X锁</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">######################################SessionA###########################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>; #想要获取id为<span class="number">3</span>的X锁</span><br><span class="line">#阻塞...</span><br><span class="line"></span><br><span class="line">#####################################SessionB####################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; #想要获取id为<span class="number">1</span>的X锁</span><br><span class="line">ERROR <span class="number">1213</span> (<span class="number">40001</span>): Deadlock found <span class="keyword">when</span> trying <span class="keyword">to</span> <span class="keyword">get</span> lock; #出现死锁</span><br><span class="line"></span><br><span class="line">#################################SessionA############################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>; #阻塞解开，继续执行</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">18.39</span> sec) # 具体死锁为啥会被解开，下面会讲哦<span class="operator">~</span></span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="3-如何处理死锁"><a href="#3-如何处理死锁" class="headerlink" title="3. 如何处理死锁"></a>3. 如何处理死锁</h4><p><font color=orange><strong>方式1：</strong>等待，直到超时( innodb_lock_wait_timeout&#x3D;50s)</font></p><p>即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其<code>回滚</code>，另外事务继续进行。这种方法简单有效，在innodb中，参数<code>innodb_lock_wait_timeout</code>用来设置超时时间。</p><p>缺点：对于在线服务来说，这个等待时间往往是无法接受的。</p><p>那将此值修改短一些，比如1s，0.1s是否合适？不合适，容易误伤到普通的锁等待。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_lock_wait_timeout&#x27;</span>;;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name            <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_lock_wait_timeout <span class="operator">|</span> <span class="number">50</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p><font color=orange><strong>方式2：</strong>使用死锁检测进行死锁处理</font></p><p>方式1检测死锁太过被动，innodb还提供了<code>wait-for graph</code>算法来主动进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。</p><p>这是一种较为<code>主动的死锁检测机制</code>，要求数据库<code>保存锁的信息链表</code>和<code>事务等待链表</code>两部分信息。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335843.png" alt="image-20230127163322402"></p><p>基于这两个信息，可以绘制wait-for graph 等待图</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335890.png" alt="image-20230127163339663"></p><blockquote><p>死锁检测的原理是构建一个以<code>事务为顶点、锁为边的有向图</code>，判断有向图是否存在<code>环</code>，存在即有死锁</p></blockquote><p>一旦检测到<code>回路</code>、有死锁，这时候InnoDB存储引擎会选择<code>回滚undo量最小的事务</code>，让其他事务继续执行( <code>innodb_deadlock_detect=on</code>表示开启这个逻辑)。</p><p>缺点：每个新的被阻塞的线程，都要判断是不是由于自己的加入导致了死锁，这个操作时间复杂度是O(n)。如果100个并发线程同时更新同一行，意味着要检测100*100&#x3D; 1万次，1万个线程就会有1千万次检测。</p><p><strong>如何解决？</strong></p><ul><li>方式1：关闭死锁检测，但意味着可能会出现大量的超时，会导致业务有损。</li><li>方式2：控制并发访问的数量。比如在中间件中实现对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作</li></ul><blockquote><p>进一步的思路：可以考虑通过<code>将一行改成逻辑上的多行</code>来减少锁冲突。比如，连锁超市账户总额的记录，可以考虑放到多条记录上。账户总额等于这多个记录的值的总和。</p></blockquote><h4 id="4-如何避免死锁"><a href="#4-如何避免死锁" class="headerlink" title="4. 如何避免死锁"></a>4. 如何避免死锁</h4><ul><li><code>合理设计索引</code>，使业务SQL尽可能通过索引定位更少的行，减少锁竞争。</li><li><code>调整业务逻辑SQL执行顺序</code>，避免update&#x2F;delete长时间持有锁的SQL在事务前面。</li><li>避免大事务，<code>尽量将大事务拆成多个小事务来处理</code>，小事务缩短锁定资源的时间，发生锁冲突的几率也更小</li><li><code>在并发比较高的系统中，不要显式加锁</code>，特别是是在事务里显式加锁。如select … for<br>update语句，如果是在事务里运行了start transaction或设置了autocommit等于0，那么就会锁定所查找到的记录</li><li><code>降低隔离级别</code>。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。</li></ul><h2 id="4-锁的内存结构"><a href="#4-锁的内存结构" class="headerlink" title="4. 锁的内存结构"></a>4. 锁的内存结构</h2><p>前边说对一条记录加锁的本质就是在内存中创建一个<code>锁结构</code>与之关联，那么是不是一个事务对多条记录加锁，就要创建多个<code>锁结构</code>呢?比如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#事务T1</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure><p>理论上创建多个<code>锁结构</code>没问题，但是如果一个事务要获取10000条记录的锁，生成10000个锁结构也太崩溃了! 所以决定在对不同记录加锁时，如果符合下边这些条件的记录会放到一个<code>锁结构</code>中。</p><ul><li>在同一个事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样的</li><li>等待状态是一样的</li></ul><p><code>InnoDB</code>存储引擎中的<code>锁结构</code>如下:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335999.png" alt="image-20230127222432726"></p><p>结构解析：</p><ol><li><code>锁所在的事务信息 ：</code></li></ol><p>不论是 <code>表锁</code> 还是 <code>行锁</code> ，都是在事务执行过程中生成的，哪个事务生成了这个 <code>锁结构</code> ，这里就记录这个事务的信息。</p><p>此锁所在的事务信息 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p><ol start="2"><li><code>索引信息 ：</code></li></ol><p>对于 <code>行锁</code> 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p><ol start="3"><li><code>表锁／行锁信息 ：</code></li></ol><p><code>表锁结构</code> 和 <code>行锁结构</code> 在这个位置的内容是不同的：</p><ul><li>表锁：记载着是对哪个表加的锁，还有其他的一些信息。</li><li>行锁：记载了三个重要的信息：<ul><li><code>Space ID</code> ：记录所在表空间。</li><li><code>Page Number</code> ：记录所在页号。</li><li><code>n_bits</code> ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，<code>这个n_bits 属性代表使用了多少比特位</code></li></ul></li></ul><blockquote><p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后也不至于重新分配锁结构</p></blockquote><ol start="4"><li><code>type_mode ：</code></li></ol><p>这是一个32位的数，被分成了 <code>lock_mode </code>、 <code>lock_type </code>和 <code>rec_lock_type </code>三个部分，如图所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335161.png" alt="image-20230127222846678"></p><ul><li>锁的模式（<code>lock_mode </code>），占用低4位，可选的值如下：<ul><li><code>LOCK_IS </code>（十进制的<code>0</code> ）：表示共享意向锁，也就是<code>IS锁</code></li><li><code>LOCK_IX </code>（十进制的<code>1</code> ）：表示独占意向锁，也就是<code>IX锁</code> 。</li><li><code>LOCK_S </code>（十进制的<code>2</code> ）：表示共享锁，也就是<code>S锁</code> 。</li><li><code>LOCK_X </code>（十进制的<code>3</code> ）：表示独占锁，也就是<code>X锁</code> 。</li><li><code>LOCK_AUTO_INC </code>（十进制的<code>4</code> ）：表示AUTO-INC锁 。</li></ul></li></ul><blockquote><p>在InnoDB存储引擎中，LOCK_IS,LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式</p></blockquote><ul><li>锁的类型（<code>lock_type </code>），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul><li><code>LOCK_TABLE </code>（十进制的16 ），也就是当第5个比特位置为1时，表示表级锁。</li><li><code>LOCK_REC </code>（十进制的32 ），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li>行锁的具体类型（<code>rec_lock_type </code>），使用其余的位来表示。只有在<code>lock_type </code>的值为<code>LOCK_REC </code>时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul><li><code>LOCK_ORDINARY </code>（十进制的<code>0 </code>）：表示<code>next-key</code>锁 。</li><li><code>LOCK_GAP </code>（十进制的<code>512 </code>）：也就是当第10个比特位置为1时，表示<code>gap锁</code> </li><li><code>LOCK_REC_NOT_GAP </code>（十进制的<code>1024 </code>）：也就是当第11个比特位置为<code>1</code>时，表示<code>正经记录锁</code> </li><li><code>LOCK_INSERT_INTENTION </code>（十进制的<code>2048</code>）：也就是当第12个比特位置为1时，表示<code>插入意向锁</code>。其他的类型：还有一些不常用的类型我们就不多说了。</li></ul></li><li><code>is_waiting </code>属性呢？基于内存空间的节省，所以把<code>is_waiting </code>属性放到了<code>type_mode </code>这个32位的数字中：<ul><li><code>LOCK_WAIT </code>（十进制的<code>256 </code>） ：当第9个比特位置为 1 时，表示<code>is_waiting </code>为<code>true </code>，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示<code>is_waiting </code>为<code>false </code>，也就是当前事务获取锁成功。</li></ul></li></ul><ol start="5"><li><p><code>其他信息</code> ：为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p></li><li><p><code>一堆比特位</code> ：</p></li></ol><p>如果是 <code>行锁结构</code> 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 <code>n_bits </code>属性表示的。InnoDB数据页中的每条记录在 <code>记录头信息</code> 中都包含一个 <code>heap_no </code>属性，伪记录 <code>Infimum </code>的<code>heap_no </code>值为<code>0 </code>， <code>Supremum </code>的 <code>heap_no </code>值为 <code>1 </code>，之后每插入一条记录， <code>heap_no </code>值就增1。 <code>锁结构</code> 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 <code>heap_no </code>，即一个比特位映射到页内的一条记录。</p><h2 id="5-锁监控"><a href="#5-锁监控" class="headerlink" title="5. 锁监控"></a>5. 锁监控</h2><p>关于MySQL锁的监控，我们一般可以通过检查 InnoDB_row_lock 等状态变量来分析系统上的行锁的争夺情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                 <span class="operator">|</span> <span class="keyword">Value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_current_waits <span class="operator">|</span> <span class="number">0</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time          <span class="operator">|</span> <span class="number">129831</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time_avg      <span class="operator">|</span> <span class="number">18547</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time_max      <span class="operator">|</span> <span class="number">51095</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_waits         <span class="operator">|</span> <span class="number">7</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+--------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>对各个状态量的说明如下：</p><ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li><li><code>Innodb_row_lock_time </code>：从系统启动到现在锁定总时间长度；（等待总时长）</li><li><code>Innodb_row_lock_time_avg </code>：每次等待所花平均时间；（等待平均时长）</li><li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li><li><code>Innodb_row_lock_waits </code>：系统启动后到现在总共等待的次数；（等待总次数）</li></ul><p>对于这5个状态变量，比较重要的3个见上面（橙色）</p><p><strong>其他监控方法：</strong></p><p>MySQL把事务和锁的信息记录在了 <code>information_schema </code>库中，涉及到的三张表分别是<code>INNODB_TRX </code>、 <code>INNODB_LOCKS </code>和 <code>INNODB_LOCK_WAITS </code>。</p><p><code>MySQL5.7及之前</code> ，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况</p><p>MySQL8.0删除了<code>information_schema.INNODB_LOCKS</code>，添加了 performance_schema.data_locks ，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p><p>同时,information_schema.INNODB_LOCK_WAITS也被 <code>performance_schema.data_lock_waits</code> 所代替。</p><h2 id="6-附录"><a href="#6-附录" class="headerlink" title="6. 附录"></a>6. 附录</h2><blockquote><p>主要补充间隙锁加锁规则，共11个案例~ 感兴趣的小伙伴可以参考老师讲课的课件，这部分很全</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十二、MySQL事务日志</title>
      <link href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC12%E7%AB%A0_MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/"/>
      <url>/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC12%E7%AB%A0_MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>事务有4种特性<code>:原子性</code>、<code>一致性</code>、<code>隔离性</code>和<code>持久性</code>。那么事务的四种特性到底是基于什么机制实现呢?</p><ul><li>事务的隔离性由<code>锁机制</code>实现</li><li>而事务的原子性、一致性和持久性由事务的<code>redo</code>日志和<code>undo</code>日志来保证。<ul><li>REDO LOG称为<code>重做日志</code>，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的特久性。</li><li>UNDO LOG称为<code>回滚日志</code>，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li></ul></li></ul><p>有的DBA或许会认为UNDO是REDO的逆过程，其实不然。REDO和UNDO都可以视为是一种<code>恢复操作</code>。但是:：</p><ul><li><p>redo log：是存储引擎层(innodb)生成的日志，记录的是”<code>物理级别</code>“上的页修改操作，比如页号xxx、偏移量yyy写入了’zzz’数据。&#x3D;&#x3D;主要为了保证数据的可靠性&#x3D;&#x3D;</p></li><li><p>undo log:是存储引擎层(innodb)生成的日志，记录的是<code>逻辑操作</code>日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。&#x3D;&#x3D;主要用于事务的回滚&#x3D;&#x3D;(undo log 记录的是每个修改操作的<code>逆操作</code>)和<code>一致性非锁定读</code>(undo log回滚行记录到某种特定的版本–MVCC，即多版本并发控制）</p></li></ul><h2 id="1-redo日志"><a href="#1-redo日志" class="headerlink" title="1. redo日志"></a>1. redo日志</h2><p>InnoDB存储引擎是以<code>页为单位</code>来管理存储空间的。在真正访问页面之前，需要把在<code>磁盘上</code>的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。&#x3D;&#x3D;所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以一定的频率被刷入磁盘&#x3D;&#x3D;（ <code>checkPoint机制</code>），通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p><h3 id="1-1-为什么需要REDO日志"><a href="#1-1-为什么需要REDO日志" class="headerlink" title="1.1 为什么需要REDO日志"></a>1.1 为什么需要REDO日志</h3><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint <code>并不是每次变更的时候就触发 的</code>，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p><p>另一方面，事务包含 <code>持久性</code> 的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p><p>那么如何保证这个持久性呢？<code> 一个简单的做法</code> ：&#x3D;&#x3D;在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘&#x3D;&#x3D;，但是这个简单粗暴的做法有些问题：</p><ul><li><strong><font color=blue>修改量与刷新磁盘工作量严重不成比例</font></strong><br>有时候仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是以页为单位来进行磁盘IO的，也就是说在该事务提交时不得不将一个完整的页面从内存中刷新到慈盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太小题大做了。</li><li><strong><font color=blue>随机IO刷新较慢</font></strong><br>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</li></ul><p><code>另一个解决的思路</code>∶我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，&#x3D;&#x3D;只需要把修改了哪些东西记录一下就好&#x3D;&#x3D;。比如，某个事务将0号系统表空间中<code>第10号</code>页面中偏移量为<code>100</code>处的值<code>1</code>改成<code>2 </code>。我们只需记录一下：将第0号表空间的<code>第10号</code>页面中偏移量为100处的值更新为2。</p><p>InnoDB引擎的事务采用了WAL技术（<code>Write-Ahead Logging</code> )，这种技术的思想就是<code>先写日志，再写磁盘</code>，&#x3D;&#x3D;只有日志写入成功，才算事务提交成功&#x3D;&#x3D;，这里的日志就是redo log。<font color=red>当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D</font>，这就是redo log的作用。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035296.png" alt="image-20230118213029209"></p><h3 id="1-2-REDO日志的好处、特点"><a href="#1-2-REDO日志的好处、特点" class="headerlink" title="1.2 REDO日志的好处、特点"></a>1.2 REDO日志的好处、特点</h3><h4 id="1-好处"><a href="#1-好处" class="headerlink" title="1. 好处"></a>1. 好处</h4><ul><li>redo日志降低了刷盘频率</li><li>redo日志占用的空间非常小</li></ul><p>存储<code>表空间ID</code>、<code>页号</code>、<code>偏移量</code>以及<code>需要更新的值</code>，所需的存储空间是很小的，刷盘快。</p><h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul><li>redo日志是顺序写入磁盘的</li></ul><p>在执行事务的过程中，&#x3D;&#x3D;每执行一条语句，就可能产生若干条redo日志&#x3D;&#x3D;，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO，效率比随机lO快。</p><ul><li>事务执行过程中，redo log不断记录</li></ul><p>redo log跟bin log的区别，redo log是<code>存储引擎层</code>产生的，而bin log是<code>数据库层</code>产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中（bin log是记录主从复制的~）</p><h3 id="1-3-redo的组成"><a href="#1-3-redo的组成" class="headerlink" title="1.3 redo的组成"></a>1.3 redo的组成</h3><p>Redo log可以简单分为以下两个部分：</p><ul><li><code>重做日志的缓冲 (redo log buffer)</code> ，保存在内存中，是易失的。</li></ul><p>在服务器启动时就向操作系统申请了一大片称之为redo log buffer的<code>连续内存</code>空间，翻译成中文就是redo日志缓冲区。这片内存空间被划分成若干个连续的<code>redo log block</code>。一个redo log block占用<code>512字节</code>大小</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035315.png" alt="image-20230119125711415"></p><p><strong>参数设置：innodb_log_buffer_size：</strong><br>redo log buffer 大小，默认 16M ，最大值是4096M，最小值为1M。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_log_buffer_size%&#x27;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+------------------------+----------+</span></span><br><span class="line"><span class="comment">| Variable_name | Value |</span></span><br><span class="line"><span class="comment">+------------------------+----------+</span></span><br><span class="line"><span class="comment">| innodb_log_buffer_size | 16777216 |</span></span><br><span class="line"><span class="comment">+------------------------+----------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>重做日志文件 (redo log file) ，保存在硬盘中，是持久的。</li></ul><p>REDO日志文件如图所示，其中的<code>ib_logfile0</code>和<code>ib_logfile1</code>即为REDO日志</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035312.png" alt="image-20230119130410801"></p><h3 id="1-4-redo的整体流程"><a href="#1-4-redo的整体流程" class="headerlink" title="1.4 redo的整体流程"></a>1.4 redo的整体流程</h3><p>以一个更新事务为例，redo log 流转过程，如下图所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035373.png" alt="image-20230119143720695"></p><p><code>第1步</code>：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝<br><code>第2步</code>：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值<br><code>第3步</code>：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式<br><code>第4步</code>：定期将内存中修改的数据刷新到磁盘中</p><blockquote><p><strong>体会：</strong><code>Write-Ahead Log</code>(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。</p></blockquote><h3 id="1-5-redo-log的刷盘策略"><a href="#1-5-redo-log的刷盘策略" class="headerlink" title="1.5 redo log的刷盘策略"></a>1.5 redo log的刷盘策略</h3><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以 <code>一定的频率</code>刷到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035317.png" alt="image-20230119144112435"></p><p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 <code>文件系统缓存</code>（<code>page cache</code>）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给<code>系统自己来决定</code>（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p><p>针对这种情况，InnoDB给出<code>innodb_flush_log_at_trx_commit </code>参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p><ul><li><code>设置为0</code> ：表示每次事务提交时不进行刷盘操作。（系统默认master thread(后台线程)每隔1s进行一次重做日 志的同步）</li><li><code>设置为1</code> ：表示每次事务提交时都将进行同步，刷盘操作（<code>默认值</code> ）</li><li><code>设置为2</code> ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_flush_log_at_trx_commit&#x27;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+--------------------------------+-------+</span></span><br><span class="line"><span class="comment">| Variable_name                  | Value |</span></span><br><span class="line"><span class="comment">+--------------------------------+-------+</span></span><br><span class="line"><span class="comment">| innodb_flush_log_at_trx_commit | 1     |</span></span><br><span class="line"><span class="comment">+--------------------------------+-------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>另外，InnoDB存储引擎有一个后台线程，每隔<code>1秒</code>，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存( <code>page cache</code> ) ，然后调用刷盘操作。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035376.png" alt="image-20230119145340527"></p><p>也就是说，一个没有提交事务的<code>redo log</code> 记录，也可能会刷盘。因为在事务执行过程redo log记录是会写入redo log buffer中，这些redo log记录会被后台线程刷盘</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035186.png" alt="image-20230119145412718"></p><p>除了后台线程每秒<code>1次</code>的轮询操作，还有一种情况，当<code>redo log buffer</code>占用的空间即将达到<code>innodb_log_buffer_size</code>(这个参数默认是16M）的一半的时候，后台线程会主动刷盘。</p><h3 id="1-6-不同刷盘策略演示"><a href="#1-6-不同刷盘策略演示" class="headerlink" title="1.6 不同刷盘策略演示"></a>1.6 不同刷盘策略演示</h3><h4 id="1-刷盘策略分析"><a href="#1-刷盘策略分析" class="headerlink" title="1. 刷盘策略分析"></a>1. 刷盘策略分析</h4><p><font color=orange>1、innodb_flush_log_at_trx_commit&#x3D;1</font></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035192.png" alt="image-20230119151403112"></p><blockquote><p><strong>总结</strong></p><p>innodb_flush_log_at_trx_commit&#x3D;1时，&#x3D;&#x3D;只要事务提交成功，（都会主动同步刷盘，这个速度是很快的），最终redo log记录就一定在硬盘里&#x3D;&#x3D;，不会有任何数据丢失。</p><p>如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。&#x3D;&#x3D;可以保证ACID的D，数据绝对不会丢失&#x3D;&#x3D;，但是这种&#x3D;&#x3D;效率是最差的&#x3D;&#x3D;。</p><p><font color=red>建议使用默认值</font>，虽然操作系统宕机的概率理论小于数据库宕机的概率，但是一般既然使用了事务，那么数据的安全相对来说更重要些</p></blockquote><p><font color=orange>2、innodb_flush_log_at_trx_commit&#x3D;2</font></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035219.png"></p><blockquote><p><strong>总结</strong></p><p>innodb_flush_log_at_trx_commit&#x3D;2时，&#x3D;&#x3D;只要事务提交成功&#x3D;&#x3D;，&#x3D;&#x3D;redo log buffer中的内容就会写入文件系统缓存&#x3D;&#x3D;（page cache）</p><p>如果仅仅只是<code>MySQL挂了不会有任何数据丢失</code>，但是<code>操作系统宕机</code>可能会有1秒数据的丢失，这种情况下无法满足ACID中的D。</p><p>但是数值2是一种折中的做法，它的IO效率理论是高于1的，低于0的</p><p>当进行调优时，为了降低CPU的使用率，可以从1降成2。因为OS出现故障的概率很小~</p></blockquote><p><font color=orange>3、innodb_flush_log_at_trx_commit&#x3D;0</font></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035225.png"></p><blockquote><p><strong>总结</strong></p><p> innodb_flush_log_at_trx_commit&#x3D;0时,master thread中每1秒进行一次重做日志的fsync操作，因此实例crash<code>最多丢失1秒钟内的事务</code>。( master thread是负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性)</p><p>数值0话，是一种效率最高的做法，这种策略也有丢失数据的风险，也无法保证D。</p></blockquote><p><strong><font color=red>一句话就是：<code>0：延迟写，延迟刷</code>，<code>1：实时写，实时刷</code>，<code>2：实时写，延迟刷</code></font></strong></p><h4 id="2-举例"><a href="#2-举例" class="headerlink" title="2. 举例"></a>2. 举例</h4><p>比较innodb_flush_log_at_trx_commit对事务的影响。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#################################数据准备####################################</span><br><span class="line">USE atguigudb3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_load(</span><br><span class="line">a <span class="type">INT</span>,</span><br><span class="line">b <span class="type">CHAR</span>(<span class="number">80</span>)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"></span><br><span class="line">#创建存储过程，用于向test_load中添加数据</span><br><span class="line">DELIMITER<span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p_load(COUNT <span class="type">INT</span> UNSIGNED)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> s <span class="type">INT</span> UNSIGNED <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> c <span class="type">CHAR</span>(<span class="number">80</span>)<span class="keyword">DEFAULT</span> REPEAT(<span class="string">&#x27;a&#x27;</span>,<span class="number">80</span>);</span><br><span class="line">WHILE s<span class="operator">&lt;=</span>COUNT DO</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_load <span class="keyword">SELECT</span> <span class="keyword">NULL</span>,c;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">SET</span> s<span class="operator">=</span>s<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER;</span><br><span class="line"></span><br><span class="line">###########################测试<span class="number">1</span>：###########################################</span><br><span class="line">#设置并查看：innodb_flush_log_at_trx_commit</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_flush_log_at_trx_commit&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">set</span> <span class="keyword">GLOBAL</span> innodb_flush_log_at_trx_commit <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">#调用存储过程</span><br><span class="line"><span class="keyword">CALL</span> p_load(<span class="number">30000</span>); #<span class="number">1</span>min <span class="number">28</span>sec</span><br><span class="line"></span><br><span class="line">############################测试<span class="number">2</span>：#########################################</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> test_load;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> test_load;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_flush_log_at_trx_commit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_flush_log_at_trx_commit&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#调用存储过程</span><br><span class="line"><span class="keyword">CALL</span> p_load(<span class="number">30000</span>); #<span class="number">37.945</span> sec</span><br><span class="line"></span><br><span class="line">##########################测试<span class="number">3</span>：###########################################</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> test_load;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> test_load;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_flush_log_at_trx_commit <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_flush_log_at_trx_commit&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#调用存储过程</span><br><span class="line"><span class="keyword">CALL</span> p_load(<span class="number">30000</span>); #<span class="number">45.173</span> sec</span><br></pre></td></tr></table></figure><table><thead><tr><th>innodb_flush_logat_trx_commit</th><th>执行所用的时间</th></tr></thead><tbody><tr><td>0</td><td>37.945 sec</td></tr><tr><td>1</td><td>1min 28sec</td></tr><tr><td>2</td><td>45.173 sec</td></tr></tbody></table><p>而针对上述存储过程，为了提高事务的提交性能，应该在将3万行记录插入表后进行一次的COMMIT操作，而不是每插入一条记录后进行一次COMMIT操作。这样做的好处是可以使事务方法在rollback时回滚到事务最开始的确定状态。</p><blockquote><p>虽然用户可以通过设置参数innodb_flush_log_at_trx_commit为0或2来提高事务提交的性能，但需清楚，这种设置方法丧失了事务的ACID特性。</p></blockquote><h3 id="1-7-写入redo-log-buffer-过程"><a href="#1-7-写入redo-log-buffer-过程" class="headerlink" title="1.7 写入redo log buffer 过程"></a>1.7 写入redo log buffer 过程</h3><h4 id="1-补充概念-Mini-Transaction"><a href="#1-补充概念-Mini-Transaction" class="headerlink" title="1. 补充概念:Mini-Transaction"></a>1. 补充概念:Mini-Transaction</h4><p>MySQL把对底层页面中的一次原子访问的过程称之为一个<code>Mini-Transaction</code>，简称mtr，比如，向某个索引对应的B+树中插入一条记录的过程就是一个<code>Mini-Transaction</code>。<code>一个所谓的mtr可以包含一组redo日志</code>，在进行崩溃恢复时这一组<code>redo</code>日志作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条redo日志，画个图表示它们的关系就是这样:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035234.png"></p><blockquote><p>分析：一个事务有多条SQL语句组成~ 一个SQL语句包含多个mtr：因为一个SQL可能改变多条记录；一个mtr对应多条redo日志，因为redo存放的是物理级别的修改，当插入语句且页分裂时，会大量出现比如A页xxx、偏移量yy写入了’zzz’数据，B页面aaa、偏移量bb写入了‘ccc’数据…</p></blockquote><h4 id="2-redo-日志写入log-buffer"><a href="#2-redo-日志写入log-buffer" class="headerlink" title="2. redo 日志写入log buffer"></a>2. redo 日志写入log buffer</h4><p>向<code>log buffer</code>中写入redo日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当想往log buffer中写入redo日志时，第一个遇到的问题就是应该写在哪个<code>block</code>的哪个偏移量处，所以<code>InnoDB</code>的设计者特意提供了一个称之为<code>buf_free</code>的全局变量，该变量指明后续写入的redo日志应该写入到 log buffer中的哪个位置，如图所示</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035242.png"></p><p>一个mtr执行过程中可能产生若干条redo日志，<code>这些redo日志是一个不可分割的组</code>，所以其实并不是每生成一条redo日志，就将其插入到log buffer中，而是每个mtr运行过程中产生的日志先暂时存到一个地方，当该mtr结束的时候，将过程中产生的一组redo日志再全部复制到log bulffer中。假设有两个名为<code>T1、T2</code>的事务，每个事务都包含2个mtr，我们给这几个mtr命名一下;</p><ul><li>事务T1的两个<code>mtr</code>分别称为<code>mtr_T1_1</code>和<code>mtr_T1_2</code></li><li>事务T2的两个<code>mtr</code>分别称为<code>mtr_T2_1</code>和<code>mtr_T2_2</code></li></ul><p>每个mtr都会产生一组redo日志，用示意图来描述一下这些mtr产生的日志情况:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035256.png"></p><p>不同的事务可能是<code>并发</code>执行的，所以<code>T1</code>、<code>T2</code>之间的<code>mtr</code>可能是<code>交替执行</code>的。每当一个mtr执行完成时，伴随该mtr生成的一组redo日志就需要被复制到log buffer中，也就是说<code>不同事务的mtr可能是交替写入log buffer的</code>，我们画个示意图(为了美观，把一个mtr中产生的所有的redo日志当作一个整体来画):</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035263.png"></p><p>有的mtr产生的redo日志量非常大，比如<code>mtr_t1_2</code>产生的redo日志占用空间比较大，占用了3个block来存储。</p><h4 id="3-redo-log-block的结构图"><a href="#3-redo-log-block的结构图" class="headerlink" title="3. redo log block的结构图"></a>3. redo log block的结构图</h4><p>一个redo log block是由<code>日志头</code>、<code>日志体</code>、<code>日志尾</code>组成。日志头占用12字节，日志尾占用8字节，所以一个block真正能存储的数据就是512-12-8&#x3D;492字节。</p><blockquote><p><strong>为什么一个block设计成512字节?</strong></p><p>这个和磁盘的扇区有关，机械磁盘默认的扇区就是512字节，如果要写入的数据大于512字节，那么要写入的扇区肯定不止一个，这时就要涉及到盘片的转动，找到下一个扇区，假设现在需要写入两个扇区A和B，如果扇区A写入成功，而扇区B写入失败，那么就会出现<code>非原子性</code>的写入，而如果每次只写入和扇区的大小一样的512字节,那么每次的写入都是原子性的</p></blockquote><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035269.png"></p><p>真正的&#x3D;&#x3D;redo日志都是存储到占用496字节大小的log block body中&#x3D;&#x3D;，图中的log block header和log block trailer存储的是一些管理信息。我们来看看这些所谓的管理信息都有什么</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035282.png"></p><ul><li><code>log block header</code>的属性分别如下:<ul><li><code>LOG_BLOCK_HDR_NO </code>: log buffer是由log block组成，在内部log buff er就好似一个数组，因此LOG_BLOCK_HDR_NO用来标记这个数组中的位置。其是递增并且循环使用的，占用4个字节，但是由于第—位用来判新是否是flush bit，所以最大的值为2G。</li><li><code>LOG_BLOCK_HDR_DATA_LEN</code>∶表示block中已经使用了多少字节，初始值为<code>12</code>(因为<code>log block body</code>从第12个字节处开始)。随着往block中写入的redo日志越来也多，本属性值也跟着增长。如果<code>log block body</code>已经被全部写满,那么本属性的值被设置为<code>512</code></li><li><code>LOG_BLOCK_FIRST_REC_GROUP </code>:一条redo日志也可以称之为一条redo日志记录（redo log record)，一个mtr会生产多条redo日志记录，这些redo日志记录被称之为一个redo日志记录组(redo log record group)。LOG_BLOCK_FIRST_REC_GROUP就代表该block中第一个mtr生成的redo日志记录组的偏移量(其实也就是这个block里第一个mtr生成的第一条redo日志的偏移量)。如果该值的大小</li><li><code>LOG_BLOCK_HDR_DATA_LEN</code>相同，则表示当前log block不包含新的日志。</li><li><code>LOG_BLOCK_CHECKPOINT_NO</code>:占用4字节，表示该log block最后被写入时的<code>checkpoint</code>。</li></ul></li><li><code>log block trailer</code>中属性的意思如下:<ul><li><code>LOG_BLOCK_CHECKSUN</code>:表示block的校验值，用于正确性校验（其值和LOG_BLOCK_HDR_NO相同)，暂时不关心它。</li></ul></li></ul><h3 id="1-8-redo-log-file"><a href="#1-8-redo-log-file" class="headerlink" title="1.8 redo log file"></a>1.8 redo log file</h3><h4 id="1-相关参数设置"><a href="#1-相关参数设置" class="headerlink" title="1. 相关参数设置"></a>1. 相关参数设置</h4><ul><li><code>innodb_log_group_home_dir </code>：指定 redo log 文件组所在的路径，默认值为<code>./</code> ，表示在数据库的数据目录下。MySQL的默认数据目录（<code>var/lib/mysql</code> ）下默认有两个名为<code>ib_logfile0 </code>和<code>ib_logfile1 </code>的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_log_group_home_dir&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name             <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_group_home_dir <span class="operator">|</span> .<span class="operator">/</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li><code>innodb_log_files_in_group</code>：指明redo log file的个数，命名方式如：ib_logfile0，iblogfile1…iblogfilen。默认2个，最大100个。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_log_files_in_group&#x27;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+---------------------------+-------+</span></span><br><span class="line"><span class="comment">| Variable_name             | Value |</span></span><br><span class="line"><span class="comment">+---------------------------+-------+</span></span><br><span class="line"><span class="comment">| innodb_log_files_in_group | 2     |</span></span><br><span class="line"><span class="comment">+---------------------------+-------+</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#ib_logfile0</span><br><span class="line">#ib_logfile1</span><br></pre></td></tr></table></figure><ul><li><p><code>innodb_flush_log_at_trx_commit</code>：控制 redo log 刷新到磁盘的策略，默认为<code>1</code>。</p></li><li><p><code>innodb_log_file_size</code>：单个 redo log 文件设置大小，默认值为<code>48M </code>。最大值为512G，注意最大值指的是整个redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size）不能大于最大值512G。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_log_file_size&#x27;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+----------------------+----------+</span></span><br><span class="line"><span class="comment">| Variable_name | Value |</span></span><br><span class="line"><span class="comment">+----------------------+----------+</span></span><br><span class="line"><span class="comment">| innodb_log_file_size | 50331648 |</span></span><br><span class="line"><span class="comment">+----------------------+----------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>根据业务修改其大小，以便容纳较大的事务。编辑my.cnf文件并重启数据库生效，如下所示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@centos7</span><span class="operator">-</span>mysql<span class="number">-1</span> mysql]#vim <span class="operator">/</span>etc<span class="operator">/</span>my.cnf</span><br><span class="line">innodb_log_file_size<span class="operator">=</span><span class="number">200</span>M</span><br></pre></td></tr></table></figure><blockquote><p>在数据库实例更新比较频繁的情况下，可以适当加大 redo log组数和大小。但也不推荐redo log设置过大，在MySQL前溃恢复时会重新执行REDO日志中的记录。</p></blockquote><h4 id="2-日志文件组"><a href="#2-日志文件组" class="headerlink" title="2. 日志文件组"></a>2. 日志文件组</h4><p>从上边的描述中可以看到，磁盘上的<code>redo</code>日志文件不只一个，而是以一个<code>日志文件组</code>的形式出现的。这些文件以<code>ib_logfile[数字]</code>（<code>数字</code>可以是<code>0、1、2…</code>）)的形式进行命名，每个的redo日志文件大小都是一样的。</p><p>在将redo日志写入日志文件组时，是从<code>ib_logfile0</code>开始写，如果<code>ib_logfile0</code>写满了，就接着<code>ib_logfile1</code>写。同理, <code>ib_logf1le1</code>写满了就去写<code>ib_logfile2</code>，依此类准。如果写到最后一个文件该咋办?那就<code>重新转到ib_logfile0继续写</code>，所以整个过程如下图所示:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035304.png" alt="image-20230119212532135"></p><p>总共的redo日志文件大小其实就是: <code>innodb_log_file_size * innodb_log_files_in_group</code></p><p>采用循环使用的方式向redo日志文件组里写数据的话，会导致后写入的redo日志在盖掉前边写的redo日志?当然!所以InnoDB的设计者提出了checkpoint的概念。</p><h4 id="3-checkpoint"><a href="#3-checkpoint" class="headerlink" title="3. checkpoint"></a>3. checkpoint</h4><p>在整个日志文件组中还有两个重要的属性，分别是<code>write pos</code>、<code>checkpoint</code></p><ul><li>write pos是当前记录的位置，一边写一边后移</li><li>checkpoint是当前要擦除的位置，也是往后推移</li></ul><p>每次<code>刷盘 redo log记录到日志文件组</code>中，<code>write pos</code>位置就会<code>后移</code>更新。每次MySQL<code>加载日志文件组恢复数据</code>时，会清空加载过的redo log记录，并把 <code>checkpoint后移</code>更新。write pos和checkpoint之间的还空着的部分可以用来写入新的redo log记录。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035306.png" alt="image-20230119212607110"></p><p>如果 write pos 追上 checkpoint ，表示<code>日志文件组</code>满了，这时候不能再写入新的 redo log记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035944.png" alt="image-20230119212622535"></p><h3 id="1-9-redo-log小结"><a href="#1-9-redo-log小结" class="headerlink" title="1.9 redo log小结"></a>1.9 redo log小结</h3><p>相信大家都知道redo log的作用和它的刷盘时机、存储形式:</p><p><font color=red>InnoDB 的更新操作采用的是Write Ahead Log (预先日志持久化)策略，即先写日志，再写入磁盘</font></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035955.png" alt="image-20230119212716151"></p><h2 id="2-Undo日志"><a href="#2-Undo日志" class="headerlink" title="2. Undo日志"></a>2. Undo日志</h2><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 <code>更新数据</code> 的 <code>前置操作 </code>其实是要先写入一个 <code>undo log</code> 。</p><h3 id="2-1-如何理解Undo日志"><a href="#2-1-如何理解Undo日志" class="headerlink" title="2.1 如何理解Undo日志"></a>2.1 如何理解Undo日志</h3><p>事务需要保证 <code>原子性</code> ，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如<code>服务器本身的错误</code> ，<code>操作系统错误 </code>，甚至是突然<code>断电</code> 导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入<code>ROLLBACK </code>语句结束当前事务的执行。</li></ul><p>以上情况出现，需要把数据改回原先的样子，这个过程称之为<code>回滚</code> ，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。</p><p>每当我们要对一条记录做改动时(这里的<code>改动</code>可以指<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE </code>），都需要”留一手”—&gt;把回滚时所需的东西记下来。比如:</p><ul><li>你<code>插入一条记录</code>时，至少要把这条记录的<code>主键值</code>记下来，之后回滚的时候只需要把这个主键值对应的记录<code>删除</code>就好了（对于每个INSERT，InnoDB存储引擎会完成一个DELETE)</li><li>你<code>删除了一条记录</code>，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<code>插入</code>到表中就好了。(对于每个DELETE，InnoDB存储引擎会执行一个INSERT)</li><li>你<code>修改了一条记录</code>，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录<code>更新为旧值</code>就好了。(对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改前的行放回去)</li></ul><p>MySQL把这些为了回滚而记录的这些内容称之为<code>撤销日志</code>或者<code>回滚日志</code>(即undo log)。</p><blockquote><p><strong>注意</strong></p><ul><li><p>由于查询操作( <code>SELECT</code>）并不会修改任何用户记录，所以在查询操作执行时，<code>并不需要记录</code>相应的undo日志</p></li><li><p>此外，undo log 会产生<code>redo log</code>，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护</p></li></ul></blockquote><h3 id="2-2-Undo日志的作用"><a href="#2-2-Undo日志的作用" class="headerlink" title="2.2 Undo日志的作用"></a>2.2 Undo日志的作用</h3><p><strong><font color=orange>作用1：回滚数据</font></strong></p><p>用户对undo日志可能<code>有误解</code>：undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此。undo是<code>逻辑日志</code>，因此只是将数据库逻辑地恢复到原来的样子。&#x3D;&#x3D;所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同&#x3D;&#x3D;。(比如新增的页不会逻辑的进行删除~)</p><p>这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是<code>协调对数据记录的并发访问</code>。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p><p><strong><font color=orange>作用2：MVCC</font></strong><br>undo的另一个作用是<code>MVCC</code>，即在InnoDB存储引擎中<code>MVCC的实现是通过undo来完成</code>。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现<code>非锁定读取</code></p><h3 id="2-3-undo的存储结构"><a href="#2-3-undo的存储结构" class="headerlink" title="2.3 undo的存储结构"></a>2.3 undo的存储结构</h3><h4 id="1-回滚段与undo页"><a href="#1-回滚段与undo页" class="headerlink" title="1. 回滚段与undo页"></a>1. 回滚段与undo页</h4><p>InnoDB对undo log的管理采用段的方式，也就是 <code>回滚段（rollback segment）</code> 。每个回滚段记录了<code>1024 </code>个<code> undo log segment</code> ，而在每个undo log segment段中进行<code>undo页</code>的申请。</p><ul><li><p>在<code>InnoDB1.1版本之前</code>（不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为<code>1024</code>。虽然对绝大多数的应用来说都已经够用。</p></li><li><p>从1.1版本开始InnoDB支持最大<code>128个rollback segment </code> ，故其支持同时在线的事务限制提高到 了<code>128*1024</code></p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_undo_logs&#x27;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+------------------+-------+</span></span><br><span class="line"><span class="comment">| Variable_name | Value |</span></span><br><span class="line"><span class="comment">+------------------+-------+</span></span><br><span class="line"><span class="comment">| innodb_undo_logs | 128 |</span></span><br><span class="line"><span class="comment">+------------------+-------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>虽然InnoDB1.1版本支持了128个rollback segment，但是这些rollback segment都存储于共享表空间<code>ibdata</code>中。从InnoDB1.2版本开始，可通过参数对rollback segment做进一步的设置。这些参数包括:</p><ul><li><code>innodb_undo_directory</code>:设置rollback segment文件所在的路径。这意味若rollback segment可以存放在共享表空间以外的位置，即可以设置为独立表空间。该参数的默认值为“.&#x2F;”，表示当前InnoDB存储引擎的目录</li><li><code>innodb_undo_logs</code>:设置rollback segment的个数，默认值为<code>128</code>。在InnoDB1.2版本中，该参数用来替换之前版本的参数innodb_rollback_segments。</li><li><code>innodb_undo_tablespaces</code>:设置构成rollback segment文件的数目，<code>默认值为2</code>，这样rollback segment可以较为平均地分布在多个文件中。设置该参数后，会在路径innodb_undo_directory看到undo为前缀的文件，该文件就代表rollback segment文件</li></ul><p>undo log相关参数一般很少改动。</p><p><strong><font color=blue>补充：undo页的重用</font></strong></p><p>当开启一个事务需要写undo log的时候，就得先去undo log segment中去找到一个空闲的位置，当有空位的时候，就去申请undo页，在这个申请到的undo页中进行undo log的写入。我们知道mysql默认一页的大小是<code>16k</code>。</p><p>为每一个事务分配一个页，是非常浪费的（除非你的事务非常长)，假设你的应用的TPS(每秒处理的事务数目)为1000，那么1s就需要1000个页大概需要16M的存储，1分钟大概需要1G的存储。如果照这样下去除非MySQL清理的非常勤快，否则随着时间的推移，磁盘空间会增长的非常快，而且很多空间都是浪费的。</p><p>于是undo页就被设计的可以<code>重用</code>了，当事务提交时，并<code>不会立刻删除undo页</code>。因为重用，所以这个undo页可能混杂着其他事务的undo log。undo log在commit后，会被放到一个链表中，然后判断undo页的使用空间是否小于3 &#x2F;4，如果<code>小于3/4</code>的话，则表示当前的undo页可以被重用，那么它就不会被回收，其他事务的undo log可以记录在当前undo页的后面。由于undo log是<code>离散的</code>，所以清理对应的磁盘空间时，效率不高。</p><blockquote><p>因为每一个事务分配一个页，造成非常浪费，所以要重用—&gt;因为重用，所以当前日志的undo页可能会有其他事务的undo log—&gt;所以当前事务提交后，不能立即删除undo页。而是log放到链表中，尝试重用undo页面~</p></blockquote><h4 id="2-回滚段与事务"><a href="#2-回滚段与事务" class="headerlink" title="2. 回滚段与事务"></a>2. 回滚段与事务</h4><ol><li>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</li><li>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</li><li>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用</li><li>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_undo_tablespaces&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_undo_tablespaces <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#undo log的数量，最少是<span class="number">2</span></span><br><span class="line">#undo log的<span class="keyword">truncate</span>操作有purge协调线程发起。在<span class="keyword">truncate</span>某个undo log表空间的过程中，保证有一个可用的undo1og可用。</span><br></pre></td></tr></table></figure><ol start="5"><li>当事务提交时， lnnoDB存储引擎会做以下两件事情：<ul><li>将undo log放入列表中，以供之后的purge操作</li><li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li></ul></li></ol><h4 id="3-回滚段中的数据分类"><a href="#3-回滚段中的数据分类" class="headerlink" title="3. 回滚段中的数据分类"></a>3. 回滚段中的数据分类</h4><ul><li><code>未提交的回滚数据(uncommitted undo information)</code>:该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖</li><li><code>已经提交但未过期的回滚数据(committed undo information)</code>:该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响</li><li><code>事务已经提交并过期的数据(expired undo information)</code>:事务已经提交，而且数据保存时间已经超过undo retention参数指定的时间，属于已经过期的数据。当回滚段满了之后，会优先覆盖”事务已经提交并过期的数据”</li></ul><p>事务提交后并不能马上删除undo log及undo log所在的页。这是因为&#x3D;&#x3D;可能还有其他事务需要通过undo log来得到行记录之前的版本&#x3D;&#x3D;。故事务提交时将undo log放入一个<code>链表</code>中，是否可以最终删除undo log及undo log所在页由<code>purge</code>线程来判断</p><h3 id="2-4-undo的类型"><a href="#2-4-undo的类型" class="headerlink" title="2.4 undo的类型"></a>2.4 undo的类型</h3><p>在InnoDB存储引擎中，undo log分为：</p><ul><li><code>insert undo log</code><br>insert undo log是指在<code>insert</code>操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见(这是事务隔离性的要求)，故该undo log可以在事务提交后直接删除。不需要进行purge操作</li><li><code>update undo log</code><br>update undo log记录的是对<code>delete</code>和<code>update</code>操作产生的undo log，该undo log可能需要提供<code>MVCC</code>机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除</li></ul><h3 id="2-5-undo-log的生命周期"><a href="#2-5-undo-log的生命周期" class="headerlink" title="2.5 undo log的生命周期"></a>2.5 undo log的生命周期</h3><h4 id="1-简要生成过程"><a href="#1-简要生成过程" class="headerlink" title="1. 简要生成过程"></a>1. 简要生成过程</h4><p>以下是undo+redo事务的简化i过程</p><p>假设有2个数值，分别为A&#x3D;1和B&#x3D;2，然后将A修改为3,B修改为4</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="operator">-</span> <span class="keyword">start</span> transaction ;</span><br><span class="line"><span class="number">2</span>．记录A<span class="operator">=</span><span class="number">1</span>到undo log;</span><br><span class="line"><span class="number">3</span> <span class="operator">-</span> <span class="keyword">update</span> A <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="number">4.</span>记录A<span class="operator">=</span><span class="number">3</span> 到redo log;</span><br><span class="line"><span class="number">5</span>．记录B<span class="operator">=</span><span class="number">2</span>到undo log;</span><br><span class="line"><span class="number">6</span> <span class="operator">-</span> <span class="keyword">update</span> B <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="number">7.</span>记录B <span class="operator">=</span><span class="number">4</span>到redo log;</span><br><span class="line"><span class="number">8</span>．将redo log刷新到磁盘</span><br><span class="line"><span class="number">9</span> <span class="operator">-</span> <span class="keyword">commit</span></span><br></pre></td></tr></table></figure><ul><li>在1-8步骤的任意一步系统宕机，事务未提交，该事务就不会对磁盘上的数据做任何影响</li><li>如果在8-9之间宕机，恢复之后可以选择回滚，也可以选择继续完成事务提交，因为此时redo log已经持久化</li><li>若在9之后系统宕机，内存映射中变更的数据还来不及刷回磁盘，那么系统恢复之后，可以根据redo log把数据刷回磁盘</li></ul><p>&#x3D;&#x3D;只有Buffer Pool的流程：&#x3D;&#x3D;</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035954.png" alt="image-20230119233302216"></p><p>&#x3D;&#x3D;有了Redo Log和Undo Log之后：&#x3D;&#x3D;</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035981.png" alt="image-20230119233316969"></p><p>在更新Buffer Pool中的数据之前，需要先将该数据事务开始之前的状态写入Undo Log中。假设更新到一半出错了，就可以通过Undo Log来回滚到事务开始前。</p><h4 id="2-详细生成过程"><a href="#2-详细生成过程" class="headerlink" title="2. 详细生成过程"></a>2. 详细生成过程</h4><p>对于InnoDB引擎来说，每个行记录除了记录本身的数据之外，还有几个隐藏的列:</p><ul><li><code>DB_ROW_ID</code>:如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么InnoDB会自动为表添加一个row_id的<code>隐藏</code>列作为<code>主键</code></li><li><code>DB_TRX_ID</code>:每个事务都会分配一个事务ID，当对某条记录发生变更时，就会将这个事务的事务ID写入trx_id中</li><li><code>DB_ROLL_PTR</code>;回滚指针，本质上就是指句undo log的指针</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035986.png" alt="image-20230119233335524"></p><p><strong>当我们执行INSERT时：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name) <span class="keyword">VALUES</span> (&quot;tom&quot;);</span><br></pre></td></tr></table></figure><p>插入的数据都会生成一条<code>insert undo log</code>，并且数据的回滚指针会指向它。undo log会记录undo log的序号、插入主键的列和值…。那么在进行rollback的时候，通过主键直接把对应的数据删除即可。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035990.png" alt="image-20230119233405641"></p><p><strong>当我们执行UPDATE时：</strong><br>对于更新的操作会产生<code>update undo log</code>，并且会分更新主键的和不更新主键的，假设现在执行:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name<span class="operator">=</span> &quot;Sun&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035553.png" alt="image-20230119233420923"></p><p>这时会把老的记录写入新的undo log，让回滚指针指向新的undo log，它的undo no是1，并且新的undo log会指向老的undo log (undo no&#x3D;0) .</p><p>假设现在执行:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> id<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035560.png" alt="image-20230119233454289"></p><p>对于更新主键的操作，会先把原来的数据deletemark标识打开，这时并没有真正的删除数据，<code>真正的删除会交给清理线程去判断</code>，然后在后面插入一条新的数据，新的数据也会产生undo log，并且undo log的序号会递增</p><p>&#x3D;&#x3D;可以发现每次对数据的变更都会产生一个undo log&#x3D;&#x3D;，当一条记录被变更多次时，那么就会产生多条undo log,undo log记录的是变更前的日志，并且每个undo log的序号是<code>递增</code>的，那么当要回滚的时候，按照序号<code>依次向前推</code>，就可以找到原始数据</p><h4 id="3-undo-log是如何回滚的"><a href="#3-undo-log是如何回滚的" class="headerlink" title="3. undo log是如何回滚的"></a>3. undo log是如何回滚的</h4><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p><ul><li><p>①通过undo no&#x3D;3的日志把id&#x3D;2的数据删除</p></li><li><p>②通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0</p></li><li><p>③通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom</p></li><li><p>④通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</p></li></ul><h4 id="4-undo-log的删除"><a href="#4-undo-log的删除" class="headerlink" title="4. undo log的删除"></a>4. undo log的删除</h4><ul><li>针对于<code>insert undo log</code><br>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</li><li>针对于<code>update undo log</code><br>该undo log可能需要提供<code>MVCC</code>机制，因此不能在事务提交时就进行删除。提交时放入undo log<code>链表</code>，等待<code>purge</code>线程进行最后的删除。</li></ul><hr><blockquote><p>补充:<br>purge线程两个主要作用是:<code>清理undo页和清除page里面带有Delete_Bit标识的数据行</code>。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识Delete_Bit，而不删除记录。这是一种”假删除”，只是做了个标记，真正的删除工作需要后台purge线程去完成</p></blockquote><h3 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301200035955.png" alt="image-20230119212716151"></p><ul><li>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子</li><li>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十一、事务基础知识</title>
      <link href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC11%E7%AB%A0%20%20%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC11%E7%AB%A0%20%20%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><hr><h2 id="1-数据库事务概述"><a href="#1-数据库事务概述" class="headerlink" title="1. 数据库事务概述"></a>1. 数据库事务概述</h2><p>事务是数据库区别于文件系统的重要特性之一，当有了事务就会让数据库始终保持<code>一致性</code>，同时还能通过事务的机制<code>恢复到某个时间点</code>，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失</p><h3 id="1-1-存储引擎支持情况"><a href="#1-1-存储引擎支持情况" class="headerlink" title="1.1 存储引擎支持情况"></a>1.1 存储引擎支持情况</h3><p><code>SHOW ENGINES </code>命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301162312842.png" alt="image-20230111230307559"></p><p>能看出在MysQL中，只有InnoDB是支持事务的</p><h3 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2 基本概念"></a>1.2 基本概念</h3><p><strong>事务：</strong>一组逻辑操作单元（一组SQL），使数据从一种状态变换到另一种状态。比如下面的转账的两条SQL~</p><p><strong>事务处理的原则</strong>：保证所有事务都作为 <code>一个工作单元</code> 来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交( <code>commit </code>)，那么这些修改就 <code>永久 </code>地保存下来；要么数据库管理系统将 放弃 所作的所有 <code>修改 </code>，整个事务回滚( <code>rollback </code>)到最初状态。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#案例: AA用户给BB用户转账<span class="number">100</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;AA&#x27;</span>;</span><br><span class="line">#服务器宕机</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="1-3-事务的ACID特性"><a href="#1-3-事务的ACID特性" class="headerlink" title="1.3 事务的ACID特性"></a>1.3 事务的ACID特性</h3><ul><li><font color=orange>原子性(atomicity)</font></li></ul><p>原子性是指&#x3D;&#x3D;事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚&#x3D;&#x3D;。即要么转账成功，要么转账失败，是不存在中间的状态。如果无法保证原子性会怎么样?就会出现数据不一致的情形，A账户减去100元，而B账户增加100元操作失败，系统将无故丢失100元。</p><ul><li><font color=orange>一致性(consistency)</font></li></ul><p>(国内很多网站上对一致性的阐述有误，具体你可以参考wikipedia对Consistency的阐述)</p><p>根据定义，一致性是指&#x3D;&#x3D;事务执行前后，数据从一个合法性状态变换到另外一个合法性状态&#x3D;&#x3D;。这种状态是<code>语义上的</code>而不是语法上的，跟具体的业务有关。</p><p>那什么是合法的数据状态呢?&#x3D;&#x3D;满足预定的约束的状态&#x3D;&#x3D;就叫做合法的状态。通俗一点，这状态是由你自己来定义的(比如满足现实世界中的约束)。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的!如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。</p><p>**举例1:**A账户有200元，转账300元出去，此时A账户余额为-100元。你自然就发现了此时数据是不一致的，为什么呢?因为你定义了一个状态，余额这列必须&gt;&#x3D;0。</p><p>**举例2:**A账户200元。转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。你也知道此时数据是不一致的，为什么呢?因为你定义了一个状态，要求A+B的总余额必须不变。</p><p>**举例3:**在数据表中将姓名字段设置为唯一性约束，这时当事务进行提交或者事务发生回滚的时候，如果数据表中的姓名不唯一，就破坏了事务的一致性要求。</p><ul><li><font color=orange>隔离型(isolation)</font></li></ul><p>(可以联系JUC中的临界区的概念，为了避免各个线程都执行临界区的代码，必须加<code>synchronized</code>)</p><p>&#x3D;&#x3D;事务的隔离性是指一个事务的执行不能被其他事务干扰&#x3D;&#x3D; ，即&#x3D;&#x3D;一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰&#x3D;&#x3D;。</p><p>如果无法保证隔离性会怎么样？假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;AA&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>根据图解，发现出现了线程安全的问题，从而导致转账前后总金额不一致的情况~</p></blockquote><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301162312447.png"></p><ul><li><font color=orange>持久性（durability）</font></li></ul><p>持久性是指&#x3D;&#x3D;一个事务一旦被提交，它对数据库中数据的改变就是 永久性的 ，接下来的其他操作和数据库故障不应该对其有任何影响&#x3D;&#x3D;。</p><p>持久性是通过 <code>事务日志</code> 来保证的。日志包括了 <code>重做日志</code> 和 <code>回滚日志</code> 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p><blockquote><p>总结<br>ACID是事务的四大特性，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，而持久性是目的。</p><p>数据库事务，其实就是数据库设计者为了方便起见，把需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称为一个事务。一句话，事务就是ACID~</p></blockquote><h3 id="1-4-事务的状态"><a href="#1-4-事务的状态" class="headerlink" title="1.4 事务的状态"></a>1.4 事务的状态</h3><p>我们现在知道 <code>事务</code> 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执行的不同阶段把 <code>事务</code> 大致划分成几个状态：</p><ul><li><font color=orange>活动的（active）</font></li></ul><p>事务对应的数据库操作正在执行过程中时，就说该事务处在 <code>活动的</code> 状态。比如转账的事务（两条DML）在执行~</p><ul><li><font color=orange>部分提交的（partially committed）</font></li></ul><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 <code>没有刷新到磁盘</code>时，我们就说该事务处在 <code>部分提交的</code> 状态。比如转账的事务执行完成，但是还没有进行提交</p><ul><li><font color=orange>失败的（failed）</font></li></ul><p>当事务处在 <code>活动的</code> 或者 <code>部分提交的</code> 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，就说该事务处在<code>失败的</code>状态。 比如正在转账时，银行突然断电了，事务就会被停止。</p><ul><li><font color=orange>中止的（aborted）</font></li></ul><p>如果事务执行了一部分而变为 <code>失败的</code> 状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。把这个撤销的过程称之为 <code>回滚</code> 。当 <code>回滚</code> 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，就说该事务处在了 <code>中止的</code> 状态。比如当事务执行失败后，需要进行回滚，回滚完毕后的状态就是中止态</p><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;AA&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><font color=orange>提交的（committed）</font></li></ul><p>当一个处在 <code>部分提交的</code>状态的事务将修改过的数据都 <code>同步到磁盘</code> 上之后，就可以说该事务处在了 <code>提交的</code> 状态。</p><p>一个基本的状态转换图如下所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301162312453.png" alt="22_1_13_02"></p><p>图中可见，只有当事务处于 <code>提交的 </code>或者 <code>中止的</code> 状态时，一个事务的生命周期才算是结束了。对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，对于处于中止状态的事务，该事务对数据库所做的所有修改被回滚到没执行该事务之前的状态。</p><h2 id="2-如何使用事务"><a href="#2-如何使用事务" class="headerlink" title="2. 如何使用事务"></a>2. 如何使用事务</h2><p>使用事务有两种方式，分别为<code>显式事务</code>和<code>隐式事务</code></p><h3 id="2-1-显式事务"><a href="#2-1-显式事务" class="headerlink" title="2.1 显式事务"></a>2.1 显式事务</h3><p><font color=red><strong>事务的完成过程</strong></font></p><ul><li>步骤1：开启事务：</li><li>步骤2：一系列的DML操作</li><li>…</li><li>步骤3：结束的状态：提交的状态（COMMIT）、中止的状态（ROLLBACK）</li></ul><p><strong><font color=orange>步骤1：<code> START TRANSACTION</code> 或者 <code>BEGIN </code>，作用是显式开启一个事务。</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br></pre></td></tr></table></figure><p><code>START TRANSACTION</code> 语句相较于 <code>BEGIN </code>特别之处在于，后边能跟随几个 <code>修饰符</code> ：</p><p>① <code>READ ONLY</code> ：标识当前事务是一个 <code>只读事务</code> ，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p><blockquote><p>补充:只读事务中只是不允许修改那些其他事务也能访问到的表中的数据，对于临时表来说(使用CREATE TMEPORARY TABLE创建的表)，由于它们只能在当前会话中可见，所以只读事务其实也是可以对临时表进行增、删、改操作的</p></blockquote><p>② <code>READ WRITE</code> ：标识当前事务是一个<code>读写事务</code> ，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p><p>③ <code>WITH CONSISTENT SNAPSHOT</code> ：启动一致性读。</p><p><strong>举例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION READ <span class="keyword">ONLY</span>;#开启一个只读事务</span><br><span class="line"><span class="keyword">START</span> TRANSACTION READ <span class="keyword">ONLY</span>,<span class="keyword">WITH</span> CONSISTENT SNAPSHOT;#开启只读事多和一致性读</span><br><span class="line"><span class="keyword">START</span> TRANSACTION READ WRITE,<span class="keyword">WITH</span> CONSISTENT SNAPSHOT;#开启读写事务和一致性读</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p><code>READ ONLY</code>和<code>READ WRITE</code>是用来设置所谓的事务<code>访问模式</code>的，就是以只读还是读写的方式来访问数据库中的数据，一个事务的访问模式不能同时既设置为只读的又设置为读写的，所以不能同时把<code>READ ONLY</code>和<code>READ WRITE</code>放到<code>START TRANSACTION</code>语句后边</p><p>如果不显式指定事务的访问模式，那么该事务的访问模式就是<code>读写</code>模式。</p></blockquote><p><strong><font color=orange>步骤2：一系列事务中的操作（主要是DML，不含DDL）</font></strong></p><p>一系列事务中的操作（主要是DML，不含DDL）</p><p><strong><font color=orange>步骤3：提交事务 或 中止事务（即回滚事务）</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 提交事务。当提交事务后，对数据库的修改是永久性的</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"># 回滚事务。即撤销正在进行的所有没有提交的修改</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"># 将事务回滚到某个保存点</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> [<span class="keyword">SAVEPOINT</span>]</span><br></pre></td></tr></table></figure><p>其中关于SAVEPOINT相关操作有：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可么存在多个保存点</span><br><span class="line"><span class="keyword">SAVEPOINT</span> 保存点名称;</span><br><span class="line">#删除某个保存点</span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span>保存点名称；</span><br></pre></td></tr></table></figure><h3 id="2-2-隐式事务"><a href="#2-2-隐式事务" class="headerlink" title="2.2 隐式事务"></a>2.2 隐式事务</h3><p>MySQL中有一个系统变量 <code>autocommit </code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;autocommit&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span>   autocommit  <span class="operator">|</span>   <span class="keyword">ON</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>默认情况下，如果不显式的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的<code>自动提交</code>。下边这两条语句就相当于放到两个独立的事务中去执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 假设此时autocommit是默认值</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">10</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; #此时这条DML操作是一个独立的事务</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">10</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>; #此时这条DML操作是一个独立的事务</span><br></pre></td></tr></table></figure><p>当然，如果想关闭这种 <code>自动提交</code> 的功能，可以使用下边两种方法之一：</p><ul><li>显式的的使用 <code>START TRANSACTION</code> 或者<code>BEGIN</code>语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</li><li>把系统变量<code>autocommit </code>的值设置为<code>OFF </code>，就像这样：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> OFF;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这样的话，写入的多条语句就算是属于同一个事务了，直到我们显式的写出<code>COMMIT</code>语句来把这个事务提交掉，或者显式的写出<code>ROLLBACK</code>语句来把这个事务回滚掉。</p><blockquote><p>补充: Oracle 默认不自动提交，需要手写COMMIT命令，而MySQL 默认自动提交。</p></blockquote><h3 id="2-3-隐式提交数据的情况"><a href="#2-3-隐式提交数据的情况" class="headerlink" title="2.3 隐式提交数据的情况"></a>2.3 隐式提交数据的情况</h3><ul><li><strong>数据定义语言</strong>(Data definition language，缩写为:DDL)<br>数据库对象，指的就是<code>数据库</code>、<code>表</code>、<code>视图</code>、<code>存储过程</code>等结构。当使用<code>CREATE </code>、<code>ALTER</code>、<code>DROP</code>等语句去修改数据库对象时，就会隐式的提交前边语句所属于的事务。即:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ... #事务中的一条语句</span><br><span class="line"><span class="keyword">UPDATE</span> ...#事务中的一条语句</span><br><span class="line">...  #事务中的其它语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ...# 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure><ul><li><p><strong>隐式使用或修改mysql数据库中的表</strong><br>当使用<code>ALTER USER</code>、<code>CREATE USER</code>、<code>DROP USER</code> 、<code>GRANT</code>、<code>RENAME USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code>等语句时也会隐式的提交前边语句所属于的事务</p></li><li><p><strong>事务控制或关于锁定的语句</strong></p><p>① 当在一个事务还没提交或者回滚时就又使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了另一个事务时，会<code>隐式的提交</code>上—个事务。即:</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ... #事务中的一条语句</span><br><span class="line"><span class="keyword">UPDATE</span> ... #事务中的一条语句</span><br><span class="line">...       #事务中的其它语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;   #此语句会隐式的提交前面语句所属于的事务</span><br></pre></td></tr></table></figure><p>② 当前的 <code>autocommit </code>系统变量的值为 <code>OFF </code>，我们手动把它调为 <code>ON </code>时，也会 <code>隐式的提交</code> 前边语句所属的事务。<br>③ 使用 <code>LOCK TABLES</code> 、 <code>UNLOCK TABLES</code> 等关于锁定的语句也会 <code>隐式的提交</code> 前边语句所属的事务。</p><ul><li><p><strong>加载数据的语句</strong><br>使用<code>LOAD DATA</code>语句来批量往数据库中导入数据时，也会<code>隐式的提交</code>前边语句所属的事务。</p></li><li><p><strong>关于MySQL复制的一些语句</strong><br>使用<code>START SLAVE</code>、<code>STOP SLAVE</code>、<code>RESET SLAVE</code>、<code>CHANGE MASTER TO</code>等语句时会<code>隐式的提交</code>前边语句所属的事务。</p></li><li><p><strong>其它的一些语句</strong></p><p>使用<code>ANALYZE TABLE</code>、<code>CACHE INDEX</code>、<code>CHECK TABLE</code>、<code>FLUSH</code>、<code>LOAD INDEX INTO CACHE </code>、<code>OPTIMIZE TABLE</code>、<code>REPAIR TABLE</code>、<code>RESET </code>等语句也会隐式的提交前边语句所属的事务。</p></li></ul><h3 id="2-4-使用举例1：提交与回滚"><a href="#2-4-使用举例1：提交与回滚" class="headerlink" title="2.4 使用举例1：提交与回滚"></a>2.4 使用举例1：提交与回滚</h3><p>我们看下在 MySQL 的默认状态下，下面这个事务最后的处理结果是什么。</p><p>先创建user3表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE atguigudb2;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user3(NAME <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">PRIMARY</span> KEY);</span><br></pre></td></tr></table></figure><ul><li><strong><font color=orange>情况一：</font></strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 <span class="keyword">VALUES</span>(<span class="string">&#x27;张三&#x27;</span>); #此时不会自动提交数据</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>; #开启一个新的事务</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 <span class="keyword">VALUES</span>(<span class="string">&#x27;李四&#x27;</span>); #此时不会自动提交数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 <span class="keyword">VALUES</span>(<span class="string">&#x27;李四&#x27;</span>); #受主键的影响，不能添加成功</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user3;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+--------+</span></span><br><span class="line"><span class="comment">| NAME   |</span></span><br><span class="line"><span class="comment">+--------+</span></span><br><span class="line"><span class="comment">| 张三   |</span></span><br><span class="line"><span class="comment">+--------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><strong><font color=orange>情况二：</font></strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> user3;  #DDL操作会自动提交数据，不受autocommit变量的影响。</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 <span class="keyword">VALUES</span>(<span class="string">&#x27;张三&#x27;</span>); #此时不会自动提交数据</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 <span class="keyword">VALUES</span>(<span class="string">&#x27;李四&#x27;</span>);# 默认情况下(即autocommit为<span class="literal">true</span>)，DML操作也会自动提交数据。</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 <span class="keyword">VALUES</span>(<span class="string">&#x27;李四&#x27;</span>); #事务的失败的状态</span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user3;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+--------+</span></span><br><span class="line"><span class="comment">| NAME   |</span></span><br><span class="line"><span class="comment">+--------+</span></span><br><span class="line"><span class="comment">| 张三   |</span></span><br><span class="line"><span class="comment">| 李四   |</span></span><br><span class="line"><span class="comment">+--------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><strong><font color=orange>情况三：</font></strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> user3;  #DDL操作会自动提交数据，不受autocommit变量的影响。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@completion_type</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@completion_type</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 <span class="keyword">VALUES</span>(<span class="string">&#x27;张三&#x27;</span>); </span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 <span class="keyword">VALUES</span>(<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 <span class="keyword">VALUES</span>(<span class="string">&#x27;李四&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user3;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+--------+</span></span><br><span class="line"><span class="comment">| NAME   |</span></span><br><span class="line"><span class="comment">+--------+</span></span><br><span class="line"><span class="comment">| 张三   |</span></span><br><span class="line"><span class="comment">+--------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>能看到相同的SQL代码，只是在事务开始之前设置了<code>SET @@completion_type = 1</code>;结果就和第一次处理的一样，只有一个“张三”。这是为什么呢?<br>这里讲解下 MySQL中completion_type参数的作用，实际上这个参数有3种可能:</p><ul><li><code>completion=0</code>，这是<code>默认情况</code>。当执行COMNIT的时候会提交事务，在执行下一个事务时，还需要使<code>START TRANSACTION </code>或者<code>BEGIN</code>来开启。</li><li><code>completion=1</code>，这种情况下，当提交事务后，相当于执行了<code>COMMIT AND CHAIN</code>，也就是开启一个链式事务，即提交事务之后会开启一个相同隔离级别的事务。</li><li><code>completion=2</code>，这种情况下<code>CONMMIT=COMMIT AND RELEASE</code>，也就是提交后，会自动与服务器断开连接</li></ul><blockquote><p>当我们设置 autocommit&#x3D;0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。</p><p>当我们设置 autocommit&#x3D;1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 ROLLBACK 时才会回滚。</p></blockquote><p>链事务跳转到4.分类</p><h3 id="2-5-使用举例2：测试不支持事务的Engine"><a href="#2-5-使用举例2：测试不支持事务的Engine" class="headerlink" title="2.5 使用举例2：测试不支持事务的Engine"></a>2.5 使用举例2：测试不支持事务的Engine</h3><p><font color=orange>1、创建测试的表</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USE atguigudb3;</span><br><span class="line">#举例<span class="number">2</span>：体会INNODB 和 MyISAM</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test1(i <span class="type">INT</span>) ENGINE <span class="operator">=</span> INNODB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test2(i <span class="type">INT</span>) ENGINE <span class="operator">=</span> MYISAM;</span><br></pre></td></tr></table></figure><p><font color=orange>2、针对于innodb表,ROLLBACK 会生效~</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test1 <span class="keyword">VALUES</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"># 执行完，发现表为空，说明回滚成功<span class="operator">~</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test1;</span><br></pre></td></tr></table></figure><p><font color=orange>3、针对于myisam表:不支持事务，<code>BEGIN</code>、<code>ROLLBACK</code> 这些都会失效~</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test2 <span class="keyword">VALUES</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"># 执行完，发现表中有上面插入的记录，说明MyISAM不支持事务<span class="operator">~</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test2;</span><br></pre></td></tr></table></figure><h3 id="2-6-使用举例3：SAVEPOINT"><a href="#2-6-使用举例3：SAVEPOINT" class="headerlink" title="2.6 使用举例3：SAVEPOINT"></a>2.6 使用举例3：SAVEPOINT</h3><p><font color=orange>1、创建测试表，并简单测试</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user3(NAME <span class="type">VARCHAR</span>(<span class="number">15</span>),balance <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3(NAME,balance) <span class="keyword">VALUES</span>(<span class="string">&#x27;张三&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"># 执行完，发现表中有上面插入的记录，说明默认创建的表是InnoDB的<span class="operator">~</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user3;</span><br></pre></td></tr></table></figure><p><font color=orange>2、测试<code>SAVEPOINT</code></font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 开启事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> user3 <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> user3 <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#设置保存点（类似于虚拟机的快照）</span><br><span class="line"><span class="keyword">SAVEPOINT</span> s1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> user3 <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#回滚到保存点</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> s1; </span><br><span class="line"></span><br><span class="line"># 执行完，发现balance<span class="operator">=</span><span class="number">800</span>，说明回滚到保存点s1成功<span class="operator">~</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user3;</span><br><span class="line"></span><br><span class="line"># 由于我们还么有<span class="keyword">commit</span>，所以本次可以 对此次事务彻底回滚<span class="operator">~</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>; #回滚操作</span><br><span class="line"></span><br><span class="line"># 执行完，发现balance<span class="operator">=</span><span class="number">1000</span>，说明回滚成功<span class="operator">~</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user3;</span><br></pre></td></tr></table></figure><h2 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3. 事务隔离级别"></a>3. 事务隔离级别</h2><p>MySQL是一个 <code>客户端／服务器</code> 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称为一个会话（ <code>Session </code>）。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。事务有 <code>隔离性</code> 的特性，理论上在某个事务 <code>对某个数据进行访问</code> 时，其他事务应该进行 <code>排队</code> ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 <code>性能影响太大</code> ，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时<code> 性能尽量高些</code> ，那就看二者如何权衡取舍了</p><h3 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h3><p>创建一个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">  studentno <span class="type">INT</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  class <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (studentno)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>然后向这个表里插入一条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;小谷&#x27;</span>, <span class="string">&#x27;1班&#x27;</span>);</span><br></pre></td></tr></table></figure><p>现在表里的数据就是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">+-----------+--------+-------+</span></span><br><span class="line"><span class="comment">| studentno | name   | class  |</span></span><br><span class="line"><span class="comment">+-----------+--------+-------+</span></span><br><span class="line"><span class="comment">| 1         | 小谷    | 1班   |</span></span><br><span class="line"><span class="comment">+-----------+--------+-------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="3-2-数据并发问题"><a href="#3-2-数据并发问题" class="headerlink" title="3.2 数据并发问题"></a>3.2 数据并发问题</h3><p>针对事务的隔离性和并发性怎么做取舍呢？先看一下访问相同数据的事务在 <code>不保证串行执行</code> （也就是执行完一个再执行另一个）的情况下可能会出现哪些问题：</p><p><font color=orange>1、脏写（ <code>Dirty Write</code> ）</font></p><p>对于两个事务 Session A、Session B，如果事务Session A <code>修改了</code> 另一个 <code>未提交</code> 事务Session B <code>修改过</code> 的数据，那就意味着发生了 <code>脏写</code></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301162312451.png" alt="image-20230116212006528"></p><p>Session A和Sessione各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为李四，然后Session A中的事务接着又把这条studentno列为1的记录的name列更新为张三’。如果之后Session B中的事务进行了回滚，那么Session A中的更新也将不复存在，这科现象就称之为脏写。</p><p>这时Session A中的事务就没有效果了，明明把数据更新了，最后也提交事务了，最后看到的数据什么变化也没有。这里大家对事务的隔离级比较了解的话，会发现默认隔离级别下，上面SessionA中的更新语句会处于等待状态，这里只是跟大家说明一下会出现这样现象。</p><p><font color=orange>2、脏读（ <code>Dirty Read</code> ）</font></p><p>对于两个事务 Session A、Session B，Session A <code>读取</code> 了已经被 Session B <code>更新</code> 但还 <code>没有被提交</code> 的字段。之后若 Session B <code>回滚</code> ，Session A <code>读取</code> 的内容就是 <code>临时且无效</code> 的。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301162312454.png" alt="image-20230116212448090"></p><p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为’张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为’张三’，而Session B中的事务稍后进行了回滚，那么Session A中的事务相当于&#x3D;&#x3D;读到了一个不存在的数据&#x3D;&#x3D;，这种现象就称之为 <code>脏读</code> 。</p><p><font color=orange>3、不可重复读（ <code>Non-Repeatable Read</code> ）</font></p><p>对于两个事务Session A、Session B，Session A <code>读取</code> 了一个字段，然后 Session B <code>更新</code> 了该字段。 之后Session A <code>再次读取</code>同一个字段，<code> 值就不同</code> 了。那就意味着发生了不可重复读。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301162312456.png" alt="image-20230116212712018"></p><p>在Session B中提交了几个 <code>隐式事务</code> （注意是隐式事务，意味着语句结束事务就提交了），这些事务都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看到最新的值，这种现象也被称之为 <code>不可重复读</code> 。</p><p><font color=orange>4、幻读（ <code>Phantom</code> ）</font></p><p>对于两个事务Session A、Session B, Session A 从一个表中 <code>读取</code> 了一个字段, 然后 Session B 在该表中 <code>插入</code> 了一些新的行。 之后, 如果 Session A <code>再次读取</code> 同一个表, 就会多出几行。那就意味着发生了幻读。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301162312229.png" alt="image-20230116213259278"></p><p>Session A中的事务先根据条件 studentno &gt; 0这个条件查询表student，得到了name列值为’张三’的记录；之后Session B中提交了一个 <code>隐式事务</code> ，该事务向表student中插入了一条新记录；之后Session A中的事务再根据相同的条件 studentno &gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记录，这种现象也被称之为 <code>幻读</code> 。我们把新插入的那些记录称之为<code>幻影记录</code>。</p><p><strong>注意1:</strong><br>有的同学会有疑问，那如果Session B中&#x3D;&#x3D;删除了&#x3D;&#x3D;一些符合studentno &gt; 的记录而不是插入新记录，那SessionA之后再根据<code>studentno &gt; 0</code>的条件读取的记录变少了，这种现象算不算幻读呢?这种现象<code>不属于幻读</code>，幻读强调的是一个事务按照某个<code>相同条件多次读取</code>记录时，后读取时读到了之前<code>没有读到的记录</code>。</p><p><strong>注意2:</strong><br>那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢? 这相当于对每一条记录都发生了<code>不可重复读</code>的现象。幻读只是重点强调了读取到了之前读取没有获取到的记录</p><h3 id="3-3-SQL中的四种隔离级别"><a href="#3-3-SQL中的四种隔离级别" class="headerlink" title="3.3 SQL中的四种隔离级别"></a>3.3 SQL中的四种隔离级别</h3><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题按照严重性来排一下序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">脏写 <span class="operator">&gt;</span> 脏读 <span class="operator">&gt;</span> 不可重复读 <span class="operator">&gt;</span> 幻读</span><br></pre></td></tr></table></figure><p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。 <code>SQL标准</code> 中设立了4个 <code>隔离级别</code> ：</p><ul><li><p><code>READ UNCOMMITTED</code> ：&#x3D;&#x3D;读未提交&#x3D;&#x3D;，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。&#x3D;&#x3D;不能避免脏读、不可重复读、幻读&#x3D;&#x3D;。</p></li><li><p><code>READ COMMITTED</code> ：&#x3D;&#x3D;读已提交&#x3D;&#x3D;，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。&#x3D;&#x3D;可以避免脏读，但不可重复读、幻读问题仍然存在&#x3D;&#x3D;。</p></li><li><p><code>REPEATABLE READ</code> ：&#x3D;&#x3D;可重复读&#x3D;&#x3D;，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。&#x3D;&#x3D;可以避免脏读、不可重复读，但幻读问题仍然存在&#x3D;&#x3D;。<font color=red>这是MySQL的默认隔离级别</font>。</p></li><li><p><code>SERIALIZABLE </code>：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。&#x3D;&#x3D;所有的并发问题都可以避免，但性能十分低下&#x3D;&#x3D;。&#x3D;&#x3D;能避免脏读、不可重复读和幻读&#x3D;&#x3D;。</p></li></ul><p><code>SQL标准</code> 中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301162312231.png" alt="image-20230116213753190"></p><blockquote><p>YES表示没有解决</p></blockquote><p><code>脏写</code> 怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p><p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，&#x3D;&#x3D;隔离级别越高，数据库的并发性能就越差&#x3D;&#x3D;，4种事务隔离级别与并发性能的关系如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301162312240.png" alt="image-20230116213915702"></p><h3 id="3-4-MySQL支持的四种隔离级别"><a href="#3-4-MySQL支持的四种隔离级别" class="headerlink" title="3.4 MySQL支持的四种隔离级别"></a>3.4 MySQL支持的四种隔离级别</h3><p>不同的数据库厂商对SQL标准中规定的四种隔离级别支持不一样。比如,<code>Oracle就只支持READ COMNITTED（默认隔离级别）和SERIALIZABLE隔离级别</code>。MySQL虽然支持4种隔离级别，但与SQL标准中所规定的各级隔离级别允许发生的问题却有些出入，MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的，禁止幻读的原因在第16章讲解。</p><p>MySQL的默认隔离级别为<code>REPEATABLE READ</code>，可以手动修改一下事务的隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 查看隔离级别，MySQL <span class="number">5.7</span><span class="number">.20</span>的版本之前：</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;tx_isolation&#x27;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+---------------+-----------------+</span></span><br><span class="line"><span class="comment">| Variable_name | Value           |</span></span><br><span class="line"><span class="comment">+---------------+-----------------+</span></span><br><span class="line"><span class="comment">| tx_isolation | REPEATABLE-READ  |</span></span><br><span class="line"><span class="comment">+---------------+-----------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"># MySQL <span class="number">5.7</span><span class="number">.20</span>版本之后，引入transaction_isolation来替换tx_isolation</span><br><span class="line"></span><br><span class="line"># 查看隔离级别，MySQL <span class="number">5.7</span><span class="number">.20</span>的版本及之后：</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+-----------------------+-----------------+</span></span><br><span class="line"><span class="comment">| Variable_name         | Value           |</span></span><br><span class="line"><span class="comment">+-----------------------+-----------------+</span></span><br><span class="line"><span class="comment">| transaction_isolation | REPEATABLE-READ |</span></span><br><span class="line"><span class="comment">+-----------------------+-----------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#或者不同MySQL版本中都可以使用的：</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction_isolation</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+-------------------------+</span></span><br><span class="line"><span class="comment">| @@transaction_isolation |</span></span><br><span class="line"><span class="comment">+-------------------------+</span></span><br><span class="line"><span class="comment">| REPEATABLE-READ         |</span></span><br><span class="line"><span class="comment">+-------------------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="3-5-如何设置事务的隔离级别"><a href="#3-5-如何设置事务的隔离级别" class="headerlink" title="3.5 如何设置事务的隔离级别"></a>3.5 如何设置事务的隔离级别</h3><p><font color=orange>1、通过下面的语句修改事务的隔离级别：</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;</span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line"><span class="operator">&gt;</span> READ UNCOMMITTED</span><br><span class="line"><span class="operator">&gt;</span> READ COMMITTED</span><br><span class="line"><span class="operator">&gt;</span> REPEATABLE READ</span><br><span class="line"><span class="operator">&gt;</span> SERIALIZABLE</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;隔离级别&#x27;</span></span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line"><span class="operator">&gt;</span> READ<span class="operator">-</span>UNCOMMITTED</span><br><span class="line"><span class="operator">&gt;</span> READ<span class="operator">-</span>COMMITTED</span><br><span class="line"><span class="operator">&gt;</span> REPEATABLE<span class="operator">-</span>READ</span><br><span class="line"><span class="operator">&gt;</span> SERIALIZABLE</span><br></pre></td></tr></table></figure><p><font color=orange>2、关于设置时使用GLOBAL或SESSION的影响：</font></p><p><font color=blue>①使用<code>GLOBAL</code>关键字（在全局范围影响）：</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span>;</span><br></pre></td></tr></table></figure><p>则：</p><ul><li>当前已经存在的会话无效</li><li>只对执行完该语句之后产生的会话起作用</li></ul><p><font color=blue>②使用 SESSION 关键字（在会话范围影响）：</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span>;</span><br></pre></td></tr></table></figure><p>则：</p><ul><li>对当前会话的所有后续的事务有效</li><li>如果在事务之间执行，则对后续的事务有效</li><li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</li></ul><p>如果在服务器启动时想改变事务的默认隔离级别，可以修改启动参数<code>transaction_isolation</code>的值。比如，在启动服务器时指定了<code>transaction_isolation=SERIALIZABLE</code>,那么事务的默认隔离级别就从原来的<code>REPEATABLE-READ</code>变成了 <code>SERIALIZABLE</code>。</p><blockquote><p>小结：</p><p>数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。</p></blockquote><p><font color=orange>3、演示global</font></p><ul><li>开启会话A</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301162312247.png" alt="image-20230116223912102"></p><ul><li>再开启另一个会话B</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301162312256.png" alt="image-20230116224955767"></p><ul><li>会话A中退出mysql，再登录，会发现设置的隔离级别已经生效了~</li></ul><blockquote><p>msql服务器重启 <code>systemctl restart mysqld</code> 后，隔离级别又重新回到默认~ 毕竟咱们设置的都是在内存级别的~</p></blockquote><p><font color=orange>4、演示session</font></p><ul><li>会话A中</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301162312737.png" alt="image-20230116225823169"></p><ul><li>会话B中，事务隔离级别也变更成了我们设置的那个~</li></ul><h3 id="3-6-不同隔离级别举例"><a href="#3-6-不同隔离级别举例" class="headerlink" title="3.6 不同隔离级别举例"></a>3.6 不同隔离级别举例</h3><p>1、创建数据表，并初始化数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use atguigudb3;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> account(</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">  balance <span class="type">DECIMAL</span>(<span class="number">15</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account <span class="keyword">VALUES</span>(<span class="number">1</span> ,<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;100&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure><p>2、在Xshell中开两个Session，模拟两个事务~ </p><p>3、将两个session中的隔离级别都设置成<code>read-uncommitted</code></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301180034628.png" alt="image-20230117150951856"></p><p><strong><font color=orange>4、演示1. 读未提交之脏读</font></strong></p><ul><li>案例一</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301180034626.png" alt="image-20230117152005238"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301180034637.png" alt="image-20230117151854807"></p><blockquote><p>之后事务1进行回滚，事务2读取的数据就回到了 100~</p></blockquote><ul><li>案例二</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301180034639.png"></p><p><font color=orange>5、演示2：读已提交</font></p><ul><li>环境准备</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">truncate</span> <span class="keyword">table</span> account;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> account <span class="keyword">VALUES</span>(<span class="number">1</span> ,<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;100&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">2</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> balance <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 张三   <span class="operator">|</span>     <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 李四   <span class="operator">|</span>       <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><ul><li>将两个session的隔离级别设置为：<code>read-committed</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> session transaction_isolation <span class="operator">=</span> <span class="string">&#x27;read-committed&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@transaction_isolation</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@transaction_isolation</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span> READ<span class="operator">-</span>COMMITTED          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>演示图解</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301180034635.png"></p><p><font color=orange>6、演示三、可重复读</font></p><ul><li>将两个session的隔离级别设置为：<code>repeatable-read</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> session transaction_isolation <span class="operator">=</span> <span class="string">&#x27;repeatable-read&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@transaction_isolation</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@transaction_isolation</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>演示图解</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301180034647.png"></p><p><font color=orange>7、演示四、幻读</font></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301180034488.png" alt="image-20230117235449796"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301180034490.png"></p><p>这里要灵活的理解读取的意思。第一次select是读取，第二次的insert其实也属于隐式的读取，只不过是在mysql的机制中读取的，&#x3D;&#x3D;插入数据也是要先读取一下有没有主键冲突才能决定是否执行插入&#x3D;&#x3D;</p><p><font color=red>幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的select 操作得到的结果所表征的数据状态无法支撑后续的业务操作</font>。更为具体一些：&#x3D;&#x3D;select某记录是否存在，不存在，准备插入此记录，但执行insert时发现此记录已存在，无法插入，此时就发生了幻读&#x3D;&#x3D;（如上图所示）。</p><p>在RR隔离级别下，step1、step2是会正常执行的，step3则会报错主键冲突，对于事务B的业务来说是执行失败的，这里事务B就是发生了幻读，因为事务B在step1中读取的数据状态并不能支撑后续的业务操作，事务B:“见鬼了，我刚才读到的结果应该可以支持我这样操作才对啊，为什么现在不可以”。事务B不敢相信的又执行了step4，发现和step1读取的结果是一样的（RR下的 <code>MVCC</code>机制)。此时，幻读无疑已经发生，事务B无论读取多少次，都查不到id&#x3D;3的记录，但它的确无法插入这条他通过读取来认定不存在的记录（此数据已被事务A插入)，对于事务B来说，它幻读了。</p><p>&#x3D;&#x3D;其实RR（Mysql默认隔离级别）也是可以避免幻读的&#x3D;&#x3D;，通过对select操作手动加行X锁(独占锁) (SELECT … FOR UPDATE这也正是SERIALIZABLE 隔离级别下会隐式为你做的事情)，同时，即便当前记录不存在，比如id &#x3D; 3是不存在的，当前事务也会获得一把记录锁（因为InnoDB的行锁锁定的是索引，故记录实体存在与否没关系，存在就加<code>行X锁</code>，不存在就加<code>间隙锁</code>），其他事务则无法插入此索引的记录，故杜绝了幻读。</p><p>在<code>SERIALIZABLE隔离级别</code>下，step1执行时是会隐式的添加<code>行(X)锁/gap(X)锁</code>的，从而step2会被阻塞，step3 会正常执行，待事务1提交后，事务2才能继续执行（主键冲突执行失败)，对于事务1来说业务是正确的，成功的阻塞扼杀了扰乱业务的事务2，对于事务1来说他前期读取的结果是可以支撑其后续业务的。</p><p>所以MySQL的幻读并非什么读取两次返回结果集不同，而是事务在插入事先检测不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测读获取到的数据如同鬼影一般</p><p><font color=blue>补充：隔离级别是 <code>SERIALIZABLE</code> 时的效果：</font></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301180034511.png"></p><h2 id="4-事务的常见分类"><a href="#4-事务的常见分类" class="headerlink" title="4. 事务的常见分类"></a>4. 事务的常见分类</h2><p>从事务理论的角度来看，可以把事务分为以下几种类型：</p><ul><li>扁平事务（Flat Transactions）</li><li>带有保存点的扁平事务（Flat Transactions with Savepoints）</li><li>链事务（Chained Transactions）</li><li>嵌套事务（Nested Transactions）</li><li>分布式事务（Distributed Transactions）</li></ul><p>下面简单介绍这几种类型：</p><p>1）<code>扁平事务</code>是事务类型中最简单的一种，但是在实际生产环境中，这可能是使用最频繁的事务，在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束，其间的操作是原子的，要么都执行，要么都回滚，因此，扁平事务是应用程序成为原子操作的基本组成模块。扁平事务虽然简单，但是在实际环境中使用最为频繁，也正因为其简单，使用频繁，故每个数据库系统都实现了对扁平事务的支持。扁平事务的主要限制是不能提交或者回滚事务的某一部分，或分几个步骤提交。</p><p>扁平事务一般有三种不同的结果：①事务成功完成。在平常应用中约占所有事务的96%。②应用程序要求停止事务。比如应用程序在捕获到异常时会回滚事务，约占事务的3%。③外界因素强制终止事务。如连接超时或连接断开，约占所有事务的1%。</p><p>2）<code>带有保存点的扁平事务</code>除了支持扁平事务支持的操作外，还允许在事务执行过程中回滚到同一事务中较早的一个状态。这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销太大。</p><p><code>保存点（Savepoint）</code>用来通知事务系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。对于扁平的事务来说，隐式的设置了一个保存点，然而在整个事务中，只有这一个保存点，因此，回滚只能会滚到事务开始时的状态。</p><p>3）<code>链事务</code>是指一个事务由多个子事务链式组成，它可以被视为保存点模式的一个变种。带有保存点的扁平事务，当发生系统崩溃时，所有的保存点都将消失，这意味着当进行恢复时，事务需要从开始处重新执行，而不能从最近的一个保存点继续执行。链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务，前一个子事务的提交操作和下一个子事务的开始操作合并成一个原子操作，这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行一样。这样，<strong>在提交子事务时就可以释放不需要的数据对象，而不必等到整个事务完成后才释放</strong>。其工作方式如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301162312756.png" alt="image-20230116230734528"></p><p>链事务与带有保存点的扁平事务的不同之处体现在：</p><p>①带有保存点的扁平事务能回滚到任意正确的保存点，而链事务中的回滚仅限于当前事务，即只能恢复到最近的一个保存点。</p><p>②对于锁的处理，两者也不相同，链事务在执行COMMIT后即释放了当前所持有的锁，而带有保存点的扁平事务不影响迄今为止所持有的锁。</p><p>4）<code>嵌套事务</code>是个层次结构框架，由一个顶层事务（Top-Level Transaction）控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务（Subtransaction），其控制着每一个局部的变换，子事务本身也可以是嵌套事务。因此，嵌套事务的层次结构可以看成是一棵树。</p><p>5）<code>分布式事务</code>通常是在一个分布式环境下运行的扁平事务，因此，需要根据数据所在位置访问网络中不同节点的数据库资源。例如，一个银行用户从招商银行的账户向工商银行的账户转账1000元，这里需要用到分布式事务，因为不能仅调用某一家银行的数据库就完成任务。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十、数据库其他调优策略</title>
      <link href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC10%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/"/>
      <url>/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC10%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据库调优的措施"><a href="#1-数据库调优的措施" class="headerlink" title="1.数据库调优的措施"></a>1.数据库调优的措施</h2><h3 id="1-1调优的目标"><a href="#1-1调优的目标" class="headerlink" title="1.1调优的目标"></a>1.1调优的目标</h3><ul><li>尽可能<code>节省系统资源</code>，以便系统可以提供更大负荷的服务（吞吐量更大)</li><li>合理的结构设计和参数调整，以提高用户<code>操作响应的速度</code>（响应速度更快)</li><li>减少系统的瓶颈，提高MySQL数据库整体的性能</li></ul><h3 id="1-2-如何定位调优问题"><a href="#1-2-如何定位调优问题" class="headerlink" title="1.2 如何定位调优问题"></a>1.2 如何定位调优问题</h3><p>不过随着用户量的不断增加，以及应用程序复杂度的提升，我们很难用“<code>更快</code>”去定义数据库调优的目标，因为用户在不同时间段访问服务器遇到的瓶颈不同，比如双十一促销的时候会带来大规模的<code>并发访问</code>。还有用户在进行不同业务操作的时候，数据库的<code>事务处理</code>和<code>SQL查询</code>都会有所不同。因此还需要更加精细的定位，去确定调优的目标。</p><p>如何确定呢?一般情况下，有如下几种方式：</p><ul><li><p><strong>用户的反馈(主要)</strong><br>用户是服务的对象，因此他们的反馈是最直接的。虽然他们不会直接提出技术建议，但是有些问题往往是用户第一时间发现的。要重视用户的反馈，找到和数据相关的问题。</p></li><li><p><strong>日志分析（主要)</strong><br>可以通过查看数据库日志和操作系统日志等方式找出异常情况，通过它们来定位遇到的问题。<br>服务器资源使用监控<br>通过监控服务器的CPU、内存、I&#x2F;O等使用情况，可以实时了解服务器的性能使用，与历史情况进行对比。</p></li><li><p><strong>数据库内部状况监控</strong><br>在数据库的监控中，<code>活动会话（Active Session)监控</code>是一个重要的指标。通过它可以清楚地了解数据库当前是否处于非常繁忙的状态，是否存在SQL堆积等。</p></li><li><p><strong>其它</strong></p><p>除了活动会话监控以外也可以对<code>事务、锁等待</code>等进行监控，这些都可以帮助我们对数据库的运行状态有更全面的认识。</p></li></ul><h3 id="1-3-调优的维度和步骤"><a href="#1-3-调优的维度和步骤" class="headerlink" title="1.3 调优的维度和步骤"></a>1.3 调优的维度和步骤</h3><p>需要调优的对象是整个数据库管理系统，它不仅包括SQL查询，还包括数据库的部署配置、架构等。从这个角度来说，思考的维度就不仅仅局限在SQL优化上了。通过如下的步骤进行梳理：</p><h4 id="第1步：选择适合的DBMS"><a href="#第1步：选择适合的DBMS" class="headerlink" title="第1步：选择适合的DBMS"></a>第1步：选择适合的DBMS</h4><p>如果对<code>事务性处理</code>以及<code>安全性要求高</code>的话，可以选择商业的数据库产品。这些数据库在事务处理和查询性能上都比较强，比如采用SQL Server、Oracle，那么<code>单表存储上忆条数据</code>是没有问题的。如果数据表设计得好，即使不采用<code>分库分表</code>的方式，查询效率也不差。</p><p>除此以外也可以采用开源的MySQL进行存储，它有很多存储引擎可以选择，如果进行事务处理的话可以选择lnnoDB，非事务处理可以选择MylSAM</p><p>NoSQL阵营包括<code>键值型数据库、文档型数据库、搜索引擎，列式存储</code>和<code>图形数据库</code>。这些数据库的优缺点和使用场景各有不同，比如列式存储数据库可以大幅度降低系统的I&#x2F;O，适合于分布式文件系统，但如果数据需要频繁地增删改，那么列式存储就不太适用了。</p><p><font color=red>DBMS的选择关系到了后面的整个设计过程，所以第一步就是要选择适合的DBMS</font>。如果已经确定好了DBMS，那么这步可以跳过。</p><h4 id="第2步-优化表设计"><a href="#第2步-优化表设计" class="headerlink" title="第2步:优化表设计"></a>第2步:优化表设计</h4><p>选择了DBMS 之后就需要进行表设计了。而数据表的设计方式也直接影响了后续的SQL查询语句。RDBMS中，每个对象都可以定义为一张表，表与表之间的关系代表了对象之间的关系。如果用的是MySQL，还可以根据不同表的使用需求，选择不同的存储引擎。除此以外，还有一些优化的原则可以参考:</p><ol><li>表结构要尽量<code>遵循三范式</code>的原则。这样可以让数据结构更加清晰规范，减少冗余字段，同时也减少了在更新，插入和删除数据时等异常情况的发生</li><li>如果<code>查询</code>应用比较多，尤其是需要进行<code>多表联查</code>的时候，可以采用<code>反范式</code>进行优化。反范式采用<code>空间换时间</code>的方式，通过增加冗余字段提高查询的效率。</li><li><code>表字段的数据类型</code>选择，关系到了查询效率的高低以及存储空间的大小。一般来说，如果字段可以采用数值类型就不要采用字符类型。字符长度要尽可能设计得短一些。针对字符类型来说，当确定字符长度固定时，就可以采用CHAR 类型。当长度不固定时，通常采用VARCHAR类型。</li></ol><p>数据表的结构设计很基础，也很关键。<font color=red>好的表结构可以在业务发展和用户量增加的情况下依然发挥作用，不好的表结构设计会让数据表变得非常臃肿，查询效率也会降低</font></p><h4 id="第3步-优化逻辑查询"><a href="#第3步-优化逻辑查询" class="headerlink" title="第3步:优化逻辑查询"></a>第3步:优化逻辑查询</h4><p>当建立好数据表之后，就可以对数据表进行增删改查的操作了。这时首先需要考虑的是逻辑查询优化。</p><p>SQL查询优化，可以分为<code>逻辑查询优化</code>和<code>物理查询优化</code>。逻辑查询优化就是通过改变SQL语句的内容让SQL执行效率更高效，采用的方式是对SQL语句进行等价变换，对查询进行重写。</p><p><font color=red>SQL的查询重写包括了子查询优化、等价谓词重写、视图重写、条件简化、连接消除和嵌套连接消除等</font>。</p><p>比如在讲解EXISTS子查询和lN子查询的时候，会根据小表驱动大表的原则选择适合的子查询。在WHERE子句中会尽量避免对字段进行函数运算，它们会让字段的索引失效。</p><p>举例：</p><p>查询评论内容开头为abc的内容都有哪些，如果在WHERE子句中使用了函数，语句就会写成下面这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> comment_id, comment_text,comment_time <span class="keyword">FROM</span> product_comment </span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">SUBSTRING</span>(comnment_text,<span class="number">1</span>,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p>采用查询重写的方式进行等价替换：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> comment_id, comment_text,comment_time <span class="keyword">FROM</span> product_comment <span class="keyword">WHERE</span> comment_text <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="第4步-优化物理查询"><a href="#第4步-优化物理查询" class="headerlink" title="第4步:优化物理查询"></a>第4步:优化物理查询</h4><p>物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术(比如索引等)，通过计算代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。<strong>在这个部分中需要掌握的重点是对索引的创建和使用。</strong></p><p>但索引不是万能的，要根据实际情况来创建索引。那么都有哪些情况需要考虑呢?在前面几章中已经进行了细致的剖析。</p><p>SQL查询时需要对不同的数据表进行查询，因此在物理查询优化阶段也需要确定这些查询所采用的路径，具体的情况包括:</p><ol><li><p><code>单表扫描</code>︰对于单表扫描来说，可以全表扫描所有的数据，也可以局部扫描。</p></li><li><p><code>两张表的连接</code>︰常用的连接方式包括了嵌套循环连接、 HASH连接和合并连接。</p></li><li><p><code>多张表的连接</code>︰多张数据表进行连接的时候，<code>顺序</code>很重要，因为不同的连接路径查询的效率不同，搜索空间也会不同。在进行多表连接的时候，搜索空间可能会达到<code>很高的数据量级</code>，巨大的搜索空间显然会占用更多的资源，因此需要通过调整连接顺序，将搜索空间调整在一个可接受的范围内。</p></li></ol><h4 id="第5步-使用Redis或-Memcached-作为缓存"><a href="#第5步-使用Redis或-Memcached-作为缓存" class="headerlink" title="第5步:使用Redis或 Memcached 作为缓存"></a>第5步:使用Redis或 Memcached 作为缓存</h4><p>除了可以对SQL本身进行优化以外，还可以请外援提升查询的效率</p><p>因为数据都是存放到数据库中，需要从数据库层中取出数据放到内存中进行业务逻辑的操作，当用户量增大的时候，如果频繁地进行数据查询，会消耗数据库的很多资源。如果将常用的数据直接放到内存中，就会大幅提升查询的效率</p><p>键值存储数据库可以帮我们解决这个问题。</p><p>常用的键值存储数据库有&#x3D;&#x3D;Redis 和Memcached&#x3D;&#x3D;，它们都可以将数据存放到内存中。</p><p>从可靠性来说，<code> Redis 支持持久化</code>，可以让我们的数据保存在硬盘上，不过这样一来性能消耗也会比较大。而Memcached仅仅是内存存储，不支持持久化。</p><p><font color=red>通常对于查询响应要求高的场景（响应时间短，吞吐量大)，可以考虑内存数据库，毕竟术业有专攻</font>。传统的RDBMS，都是将数据存储在硬盘上，而内存数据库则存放在内存中，查询起来要快得多。不过使用不同的工具，也增加了开发人员的使用成本。</p><h4 id="第6步：库级优化"><a href="#第6步：库级优化" class="headerlink" title="第6步：库级优化"></a>第6步：库级优化</h4><p>库级优化是站在数据库的维度上进行的优化策略，比如控制一个库中的数据表数量。另外，单一的数据库总会遇到各种限制，不如取长补短，利用”外援”的方式。通过<code>主从架构</code>优化读写策略，通过对数据库进行垂直或者水平切分，突破单一数据库或数据表的访问限制，提升查询的性能。</p><p><font color=blue>1、读写分离</font></p><p>如果读和写的业务量都很大，并且它们都在同一个数据库服务器中进行操作，那么数据库的性能就会出现瓶颈，这时为了提升系统的性能，优化用户体验，可以采用<code>读写分离</code>的方式降低主数据库的负载，比如用主数据库(master）完成写操作，用从数据库(slave）完成读操作。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238322.png" alt="image-20230109145409011"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238304.png" alt="image-20230109145417159"></p><p><font color=blue>2、数据分片</font></p><p>对<code>数据库分库分表</code>。当数据量级达到千万级以上时，有时候要把一个数据库切成多份，放到不同的数据库服务器上，减少对单一数据库服务器的访问压力。如果你使用的是 MySQL，就可以使用MySQL自带的分区表功能，当然你也可以考虑自己做<code>垂直拆分（分库)</code>、<code>水平拆分(分表）</code>、<code>垂直+水平拆分(分库分表)</code></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238320.png" alt="image-20230109145626914"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238323.png" alt="image-20230109145636975"></p><blockquote><ul><li>垂直分表：比如按照热数据、冷数据进行分表。</li><li>水平分表：比如按照日期范围进行划分。</li></ul><p>但需要注意的是，分拆在提升数据库性能的同时，也会增加维护和使用成本</p></blockquote><h2 id="2-优化MySQL服务器"><a href="#2-优化MySQL服务器" class="headerlink" title="2. 优化MySQL服务器"></a>2. 优化MySQL服务器</h2><p>优化MySQL服务器主要从两个方面来优化，一方面是对<code>硬件</code>进行优化。另一方面是对MySQL<code>服务的参数</code>进行优化。这部分的内容需要较全面的知识，一般只有<code>专业的数据库管理员</code>才能进行这一类的优化。对于可以定制参数的操作系统，也可以针对MySQL进行操作系统优化。</p><h3 id="2-1-优化服务器硬件"><a href="#2-1-优化服务器硬件" class="headerlink" title="2.1 优化服务器硬件"></a>2.1 优化服务器硬件</h3><p><font color=red>服务器的硬件性能直接决定着MySQL数据库的性能</font>。硬件的性能瓶颈直接决定MySQL数据库的运行速度和效率。针对性能瓶颈提高硬件配置，可以提高MySQL数据库查询、更新的速度。<br>(1）<code>配置较大的内存</code>。足够大的内存是提高MySQL数据库性能的方法之一。内存的速度比磁盘I&#x2F;O快得多，可以通过增加系统的缓冲区容量使数据在内存中停留的时间更长，以<code>读少磁盘I/O</code>。<br>(2）<code>配置高速磁盘系统</code>，以减少读盘的等待时间，提高响应速度。磁盘的I&#x2F;O能力，也就是它的寻道能力，目前的<code>SCSI</code>高速旋转的是7200转&#x2F;分钟，这样的速度，一旦访问的用户量上去，磁盘的压力就会过大，如果是每天的网站pv (page view)在150w，这样的一般的配置就无法满足这样的需求了。现在<code>SSD</code>盛行，在SSD上随机访问和顺序访问性能几乎差不多，使用SSD可以减少随机IO带来的性能损耗。<br>(3)<code>合理分布磁盘I/O</code>，把磁盘I&#x2F;O分散在多个设备上，以减少资源竞争，提高并行操作能力。</p><p>(4)<code>配置多处理器</code>，MySQL是多线程的数据库，多处理器可同时执行多个线程。</p><h3 id="2-2-优化MySQL的参数"><a href="#2-2-优化MySQL的参数" class="headerlink" title="2.2 优化MySQL的参数"></a>2.2 优化MySQL的参数</h3><p>通过优化MySQL的参数可以提高资源利用率，从而达到提高MySQL服务器性能的目的</p><p>MySQL服务的配置参数都在<code>my.cnf</code>或者<code>my.ini</code>文件的[mysqld]组中，配置完参数以后，需要重新启动MySQL服务才会生效。</p><p>下面对几个对性能影响比较大的参数进行详细介绍。</p><ul><li><p><code>innodb_buffer_pool_size</code>∶这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的<code>表和索引的最大缓存</code>。它不仅仅缓存<code>索引数据</code>，还会缓存<code>表的数据</code>。这个值越大，查询的速度就会越快。但是这个值太大会影响操作系统的性能。</p></li><li><p><code>key_buffer_size</code>: 表示<code>索引缓冲区的大小</code>。索引缓冲区是所有的<code>线程共享</code>。增加索引缓冲区可以得到更好处理的索引（对所有读和多重写)。当然，这个值不是越大越好，它的大小取决于内存的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在<code>4GB</code>左右的服务器该参数可设置为<code>256M</code>或<code>384M</code>。</p></li><li><p><code>table_cache</code>:表示<code>同时打开的表的个数</code>。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。默认为2402，调到512-1024最佳。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能</p></li><li><p><code>query_cache_size </code>:表示查询缓冲区的大小。可以通过在MySQL控制台观察，如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size的值;如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存;</p></li><li><p><code>Qcache_free_blocks</code>，如果该值非常大，则表明缓冲区中碎片很多。MySQL8.0之后失效。该参数需要和query_cache_type配合使用。</p></li><li><p><code>query_cache_type</code>的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type&#x3D;0并不会导致MySQL释放query_cache_size所配置的缓存区内存。</p><ul><li>当query_cache_type&#x3D;1时，所有的查询都将使用查询缓存区，除非在查询语句中指定SQL_NO_CACHE，如SELECT SQL_NO_CACHE FROM tbl_name。</li><li>当query_cache_type&#x3D;2时，只有在查询语句中使用SQL_CACHE 关键字，查询才会使用查询缓存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况。</li></ul></li><li><p><code>sort_buffer_size</code>∶表示每个<code>需要进行排序的线程分配的缓冲区的大小</code>。增加这个参数的值可以提高<code>ORDER BY</code>或<code>GROUP BY</code>操作的速度。默认数值是2097144字节〈约2MB)。对于内存在4GB左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100×6&#x3D; 600MB</p></li><li><p><code>join_buffer_size = 8M</code> :表示<code>联合查询操作所能使用的缓冲区大小</code>，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</p></li><li><p><code>read_buffer_size </code>:表示<code>每个线程连续扫描时为扫描的每个表分配的缓冲区的大小(字节）</code>。当线程从表中连续读取记录时需要到这个缓冲区。SET SESSION read_buffer_size&#x3D;n可以临时设置该参数的值。默认为64K，可以设置为4M。</p></li><li><p><code>innodb_flush_log_at_trx_commit</code>∶表示<code>何时将缓冲区的数据写入日志文件</code>，并且将日志文件写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值为1。</p><ul><li>值为0时，表示<code>每秒1次</code>的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。</li><li>值为1时，表示<code>每次提交事务时</code>将数据写入日志文件并将日志文件写入磁盘进行同步。该模式是最安全的，但也是最慢的一种方式。因为每次事务提交或事务外的指令都需要把日志写入(flush）硬盘。</li><li>值为2时，表示<code>每次提交事务时</code>将数据写入日志文件，<code>每隔1秒</code>将日志文件写入磁盘。该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。</li></ul></li><li><p><code>innodb_log_buffer_size</code>:这是InnoDB存储引擎的<code>事务日志使用的缓冲区</code>。为了提高性能，也是先将信息写入Innodb Log Buffer中，当满足innodb_flush_log_trx_commit参数所设置的相应条件（或者日志缓冲区写满)之后，才会将日志写到文件(或者同步到磁盘〉中</p></li><li><p><code>max_connections</code>:表示允<code>许连接到MySQL数据库的最大数量</code>，默认值是<code>151</code>。如果状态变量 connection_errors_max_connections不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这时可以考虑增大max_connections的值，在Linux平台下，性能好的服务器，支持500-1000个连接不是难事，需要根据服务器性能进行评估设定。这个连接数<code>不是越大越好</code>，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死</p></li><li><p><code>back_log </code>：用于<code>控制MySQL监听TCP端口时设置的积压请求栈大小</code>。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections &#x2F; 5）， 对于Linux系统推荐设置为小于512的整数，但最大不超过900。</p><p><font color=red>如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</font></p></li><li><p><code>thread_cache_size </code>：<code>线程池缓存线程数量的大小</code>，当客户端断开连接后将当前线程缓存起来，当在接到新的连接请求时快速响应无需创建新的线程。这尤其对那些使用短连接的应用程序来说可以极大的提高创建连接的效率。那么为了提高性能可以增大该参数的值。默认为60，可以设置为120。</p><p>可以通过如下几个MySQL状态值来适当调整线程池的大小：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Thread%&#x27;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+-------------------+-------+</span></span><br><span class="line"><span class="comment">| Variable_name | Value |</span></span><br><span class="line"><span class="comment">+-------------------+-------+</span></span><br><span class="line"><span class="comment">| Threads_cached | 2 |</span></span><br><span class="line"><span class="comment">| Threads_connected | 1 |</span></span><br><span class="line"><span class="comment">| Threads_created | 3 |</span></span><br><span class="line"><span class="comment">| Threads_running | 2 |</span></span><br><span class="line"><span class="comment">+-------------------+-------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>当 Threads_cached 越来越少，但 Threads_connected 始终不降，且 Threads_created 持续升高，可适当增加 thread_cache_size 的大小。</p></blockquote><ul><li><code>wait_timeout </code>：指定 <code>一个请求的最大连接时间 </code>，对于4GB左右内存的服务器可以设置为5-10。</li><li><code>interactive_timeout </code>：表示服务器在关闭连接前等待行动的秒数</li></ul><p>这里给出一份my.cnf的参考配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port = 3306 </span><br><span class="line">serverid = 1 </span><br><span class="line">socket = /tmp/mysql.sock </span><br><span class="line">skip-locking #避免MySQL的外部锁定，减少出错几率增强稳定性。</span><br><span class="line">skip-name-resolve </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！ back_log = 384</span></span><br><span class="line">key_buffer_size = 256M </span><br><span class="line">max_allowed_packet = 4M </span><br><span class="line">thread_stack = 256K</span><br><span class="line">table_cache = 128K </span><br><span class="line">sort_buffer_size = 6M </span><br><span class="line">read_buffer_size = 4M</span><br><span class="line">read_rnd_buffer_size=16M </span><br><span class="line">join_buffer_size = 8M </span><br><span class="line">myisam_sort_buffer_size =64M t</span><br><span class="line">able_cache = 512 thread_cache_size = 64 query_cache_size = 64M</span><br><span class="line">tmp_table_size = 256M </span><br><span class="line">max_connections = 768 </span><br><span class="line">max_connect_errors = 10000000</span><br><span class="line">wait_timeout = 10 </span><br><span class="line">thread_concurrency = 8 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">该参数取值为服务器逻辑CPU数量2，在本例中，服务器有2颗物理CPU，而每颗物理CPU又支持H.T超线程，所以实际取值为42=8</span> </span><br><span class="line">skipnetworking </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启该选项可以彻底关闭MySQL的TCP/IP连接方式，如果WEB服务器是以远程连接的方式访问MySQL数据库服务器则不要开启该选项！否则将无法正常连接！ table_cache=1024</span></span><br><span class="line">innodb_additional_mem_pool_size=4M </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">默认为2M</span> </span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">innodb_log_buffer_size=2M </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">默认为1M</span> </span><br><span class="line">innodb_thread_concurrency=8 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">你的服务器CPU有几个就设置为几。建议用默认一般为8</span> </span><br><span class="line">tmp_table_size=64M </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">默认为16M，调到64-256最挂</span></span><br></pre></td></tr></table></figure><p>很多情况还需要具体情况具体分析！</p><p><strong>举例：</strong><br>下面是一个电商平台，类似京东或天猫这样的平台。商家购买服务，入住平台，开通之后，商家可以在系统中上架各种商品，客户通过手机App、微信小程序等渠道购买商品，商家接到订单以后安排快递送货。</p><p><code>刚刚上线</code>的时候，系统运行状态良好。但是，随着入住的<code>商家不断增多</code>，使用系统的<code>用户量越来越多</code>，每天的订单数据达到了5万条以上。这个时候，系统开始出现问题，<code>CPU使用率不断飙升</code>。终于，双十一或者618活动高峰的时候，CPU使用率达到<code>99%</code>，这实际上就意味着，系统的计算资源已经耗尽，再也无法处理任何新的订单了。换句话说，系统已经崩溃了。</p><p>这个时候，我们想到了对系统参数进行调整，因为参数的值决定了资源配置的方式和投放的程度。为了解决这个问题，一共调整3个系统参数，分别是</p><ul><li><code>InnoDB_flush_log_at_trx_commit</code></li><li><code>lnnoDB_buffer_pool_size</code></li><li><code>lnnoDB_buffer_pool_instances</code></li></ul><p>下面就说一说调整这三个参数的原因是什么：<br><font color=blue>（1）调整系统参数lnnoDB_flush_log_at_trx_commit</font><br>这个参数适用于InnoDB存储引擎，电商平台系统中的表用的存储引擎都是InnoDB。默认的值是1，意思是每次提交事务的时候，都把数据写入日志，并把日志写入磁盘。这样做的好处是<code>数据安全性最佳</code>，不足之处在于每次提交事务，都要进行磁盘写入的操作。在<code>大并发的场景下</code>，过于频繁的磁盘读写会导致CPU资源浪费，系统效率变低。</p><p>这个参数的值还有2个可能的选项，分别是0和2。把这个参数的值改成了2。这样就不用每次提交事务的时候都启动磁盘读写了，在大并发的场景下，可以改善系统效率，降低CPU使用率。即便出现故障，损失的数据也比绞小。</p><p><font color=blue>（2）调整系统参数InnoDB_buffer_pool_size</font><br>这个参数的意思是，InnoDB存储引擎使用<code>缓存来存储索引和数据</code>。这个值越大，可以加载到缓存区的索引和数据量就越多，需要的<code>磁盘读写就越少</code>。</p><p>因为MySQL服务器是数据库<code>专属服务器</code>，只用来运行MySQL数据库服务，没有其他应用了，而我们的计算机是64位机器，内存也有128G。于是把这个参数的值调整为64G。这样一来，磁盘读写次数可以大幅降低，就可以充分利用内存，释放出一些CPU的资源</p><p><font color=blue>（3）调整系统参数InnoDB_buffer_pool_instances</font><br>这个参数可以将InnoDB的缓存区分成几个部分，这样可以提高系统的<code>并行处理能力</code>，因为可以允许多个进程同时处理不同部分的缓存区。</p><p>把InnoDB_buffer_pool_instances的值修改为64，意思就是把 InnoDB的缓存区分成64个分区，这样就可以同时有<code>多个进程</code>进行数据操作，CPU的效率就高多了。修改好了系统参数的值，要重启MySQL数据库服务器。</p><blockquote><p>总结一下就是遇到CPU资源不足的问题，可以从下面2个思路去解决。</p><ul><li>疏通拥堵路段，消除瓶颈，让等待的时间更短</li><li>开拓新的通道，增加并行处理能力</li></ul></blockquote><h2 id="3-优化数据库结构"><a href="#3-优化数据库结构" class="headerlink" title="3. 优化数据库结构"></a>3. 优化数据库结构</h2><p>一个好的<code>数据库设计方案</code>对于数据库的性能常常会起到<code>事半功倍</code>的效果。合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计需要考虑<code>数据冗余</code>、<code>查询和更新的速度</code>、<code>字段的数据类型</code>是否合理等多方面的内容</p><h3 id="3-1-拆分表-冷热数据分离"><a href="#3-1-拆分表-冷热数据分离" class="headerlink" title="3.1 拆分表:冷热数据分离"></a>3.1 拆分表:冷热数据分离</h3><p>拆分表的思路是，把1个包含很多字段的表拆分成2个或者多个相对较小的表，这样做的原因是，这些表中某些字段的操作频率很高（<code>热数据</code>），经常要进行查询或者更新操作，而另外一些字段的使用频率却很低（<code>冷数据</code>），<code>冷热数据分离</code>，可以减小表的宽度。如果放在一个表里面，每次查询都要读取大记录，会消耗较多的资源。</p><p>MySQL限制每个表最多存储<code>4096</code>列，并且每一行数据的大小不能超过<code>65535</code>字节。表越宽，把表装载进内存缓冲池时所占用的内存也就越大，也会消耗更多的IO。冷热数据分离的目的是:&#x3D;&#x3D;①减少磁盘Io，保证热数据的内存缓存命中率。②更有效的利用缓存，避免读入无用的冷数据。&#x3D;&#x3D;</p><p><strong>举例1:</strong><code>会员members表</code>存储会员登录认证信息。该表中有很多字段，如id、姓名、密码、地址、电话、个人描述字段。其中地址、电话、个人描述等字段并不常用，可以将这些不常用的字段分解出另一个表。将这个表取名叫members_detail，表中有member_id、address、telephone、description等字段。这样就把会员表分成了两个表，分别为<code>members表</code>和<code>members_detail表</code>。</p><p>创建这两个表的SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> members (</span><br><span class="line">  id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  username <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  password <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  last_login_time datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  last_login_ip <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> members_detail (</span><br><span class="line">  Member_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  address <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  telephone <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  description text</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果需要查询会员的基本信息或详细信息，那么可以用会员的id来查询。如果需要将会员的基本信息和详细信息同时显示，那么可以将members表和members_detail表进行联合查询，查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> members <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> members_detail <span class="keyword">on</span> members.id <span class="operator">=</span>members_detail.member_id;</span><br></pre></td></tr></table></figure><p>通过这种分解可以提高表的查询效率。对于字段很多且有些字段使用不频繁的表，可以通过这种分解的方式来优化数据库的性能。</p><h3 id="3-2-增加中间表"><a href="#3-2-增加中间表" class="headerlink" title="3.2 增加中间表"></a>3.2 增加中间表</h3><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。<font color=red>通过建立中间表，把需要经常联合查询的数据插入中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率</font>。</p><p>首先，分析经常联合查询表中的字段。然后，使用这些字段建立一个中间表，并将原来联合查询的表的数据插入中间表中。最后，使用中间表来进行查询。</p><p>举例1:学生信息表和班级表的SQL语句如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `class` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `className` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `address` <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `monitor` <span class="type">INT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `stuno` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `classId` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>现在有一个模块需要经常查询带有学生名称（name）、学生所在班级名称（className）、学生班级班长（monitor）的学生信息。根据这种情况可以创建一个 <code>temp_student </code>表。temp_student表中存储学生名称（stu_name）、学生所在班级名称（className）和学生班级班长（monitor）信息。创建表的语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `temp_student` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `stu_name` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  `className` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `monitor` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>接下来，从学生信息表和班级表中查询相关信息存储到临时表中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_student(stu_name,className,monitor)</span><br><span class="line">      <span class="keyword">select</span> s.name,c.className,c.monitor</span><br><span class="line">      <span class="keyword">from</span> student <span class="keyword">as</span> s,class <span class="keyword">as</span> c</span><br><span class="line">      <span class="keyword">where</span> s.classId <span class="operator">=</span> c.id</span><br></pre></td></tr></table></figure><p>以后，可以直接从temp_student表中查询学生名称、班级名称和班级班长，而不用每次都进行联合查询。这样可以提高数据库的查询速度</p><blockquote><p>如果用户信息修改了，是不是会导致temp_student中的数据不一致的问题呢?如何同步数据呢?</p><p>方式1:清空数据-&gt;重新添加数据</p><p>方式2:使用视图</p></blockquote><h3 id="3-3-增加冗余字段"><a href="#3-3-增加冗余字段" class="headerlink" title="3.3 增加冗余字段"></a>3.3 增加冗余字段</h3><p>设计数据库表时应尽量遵循范式理论的规约，尽可能减少冗余字段，让数据库设计看起来精致、优雅。但是，&#x3D;&#x3D;合理地加入冗余字段可以提高查询速度&#x3D;&#x3D;。</p><p>表的规范化程度越高，表与表之间的关系就越多，需要连接查询的情况也就越多。尤其在数据量大，而且需要频繁进行连接的时候，为了提升效率，我们也可以考虑增加冗余字段来减少连接。</p><p>这部分内容在《数据库的设计规范》章节中 <code>反范式化小节</code> 中具体展开讲解了。这里省略。</p><h3 id="3-4-优化数据类型"><a href="#3-4-优化数据类型" class="headerlink" title="3.4 优化数据类型"></a>3.4 优化数据类型</h3><p>改进表的设计时，可以考虑优化字段的数据类型。这个问题在大家刚从事开发时基本不算是问题。但是，随着你的经验越来越丰富，参与的项目越来越大，数据量也越来越多的时候，你就不能只从系统稳定性的角度来思考问题了，还要考虑到系统整体的稳定性和效率。此时，&#x3D;&#x3D;优先选择符合存储需要的最小的数据类型&#x3D;&#x3D;。</p><p>列的<code>字段越大</code>，建立索引时所需要的<code>空间也就越大</code>，这样一页中所能存储的索引节点的<code>数量就越少</code>，在遍历时所需要的<code>IO次数也就越多</code>，<code>索引的性能也就越差</code>。</p><p>具体来说:</p><p><font color=blue>情况1：对整数类型数据进行优化。</font></p><p>遇到整数类型的字段可以用 <code>INT </code>型 。这样做的理由是，INT 型数据有足够大的取值范围，不用担心数据超出取值范围的问题。刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以的。但在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。</p><p>对于 <code>非负型</code> 的数据（如自增ID、整型IP）来说，要优先使用无符号整型 <code>UNSIGNED</code> 来存储。因为无符号相对于有符号，同样的字节数，存储的数值范围更大。如tinyint有符号为-128-127，无符号为0-255，多出一倍的存储空间。</p><p><font color=blue>情况2：既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型。</font></p><p>跟文本类型数据相比，大整数往往占用 <code>更少的存储空间</code> ，因此，在存取和比对的时候，可以占用更少的内存空间。所以，在二者皆可用的情况下，尽量使用整数类型，这样可以提高查询的效率。如：将IP地址转换成整型数据。</p><p><font color=blue>情况3：避免使用TEXT、BLOB数据类型</font></p><p>MySQL<code>内存临时表</code>不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使<code>用磁盘临时表</code>进行。并且对于这种数据，Mysql还是要进行<code>二次查询</code>，会使SQL性能变得很差，但是不是说一定不能使用这样的数据类型。</p><p>如果一定要使用，建议把BLOB或是TEXT列<code>分离到单独的扩展表</code>中，查询时一定不要使用select *，而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。</p><p><font color=blue>情况4∶避免使用ENUM类型</font></p><p>修改ENUM值需要使用ALTER语句。</p><p>ENUN类型的ORDER BY操作效率低，需要额外操作。使用TINYINT来代替ENUM类型。</p><p><font color=blue>情况5:使用TIMESTAMP存储时间</font></p><p>TIMESTAMP存储的时间范围1970-01-0100:00:01~ 2038-01-19-03:14:07。TIMESTAMP使用4字节，DATETIME使用8个字节，同时TIMESTAN1P具有自动赋值以及自动更新的特性</p><p><font color=blue>情况6:用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</font></p><p>1)非精准浮点: float,double<br>2)精准浮点: decimal</p><p>Decimal类型为精准浮点数，在计算时不会丢失精度，尤其是财务相关的金融类数据。占用空间由定义的宽度决定，每4个字节可以存储3位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据</p><p><font color=red>总之，遇到数据量大的项目时，一定要在充分了解业务需求的前提下，合理优化数据类型，这样才能充分发挥资源的效率。使系统达到最优</font></p><h3 id="3-5-优化插入记录的速度"><a href="#3-5-优化插入记录的速度" class="headerlink" title="3.5 优化插入记录的速度"></a>3.5 优化插入记录的速度</h3><p>插入记录时，影响插入速度的主要是索引、唯一性校验、一次插入记录条数等。根据这些情况可以分别进行优化。这里我们分为MyISAM存储引擎和InnoDB存储引擎来讲。</p><p><strong><font color=blue>1. MyISAM引擎的表</font></strong></p><p><font color=orange>① 禁用索引</font><br>对于非空表，插入记录时，MySQL会根据表的索引对插入的记录建立索引。如果插入大量数据，建立索引就会降低插入记录的速度。为了解决这种情况，可以在插入记录之前禁用索引，数据插入完毕后再开启索引。禁用索引的语句如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name DISABLE KEYS;</span><br></pre></td></tr></table></figure><p>重新开启索引的语句如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name ENABLE  KEYS;</span><br></pre></td></tr></table></figure><blockquote><p>若对于空表批量导入数据，则不需要进行此操作，因为MyISAM引擎的表是在导入数据之后才建立索引的</p></blockquote><p><font color=orange>②禁用唯一性检查</font><br>插入数据时，MySQL会对插入的记录进行唯一性校验。这种唯一性校验会降低插入记录的速度。为了降低这种情况对查询速度的影响，可以在插入记录之前禁用唯一性检合，等到记录插入完毕后再开启。禁用唯一性检查的语句如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> UNIQUE_GHECKS<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>开启唯一性检查的语句如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> UNIQUE_GHECKS<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><font color=orange>③使用批量插入</font><br>插入多条记录时，可以使用一条INSERT语句插入一条记录，也可以使用一条INSERT语句插入多条记录。插入一条记录的INSERT语句情形如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">18</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="number">17</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;wangwu&#x27;</span>,<span class="number">17</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;zhaoliu&#x27;</span>,<span class="number">19</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>使用一条INSERT语句插入多条记录的情形如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">18</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="number">17</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;wangwu&#x27;</span>,<span class="number">17</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">4</span>,<span class="string">&#x27;zhaoliu&#x27;</span>,<span class="number">19</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>第2种情形的插入速度要比第1种情形快。</p><p><font color=orange>④ 使用LOAD DATA INFILE 批量导入</font><br>当需要批量导入数据时，如果能用LOAD DATA INFILE语句，就尽量使用。因为LOAD DATA INFILE语句导入数据的速度比INSERT语句快。</p><p><strong><font color=blue>2. InnoDB引擎的表：</font></strong></p><p><font color=orange>① 禁用唯一性检查</font><br>插入数据之前执行 <code>set unique_checks=0</code>来禁止对唯一索引的检查，数据导入完成之后再运行<code>set unique_checks=1</code>。这个和MyISAM引擎的使用方法一样。</p><p><font color=orange>② 禁用外键检查</font><br>插入数据之前执行禁止对外键的检查，数据插入完成之后再恢复对外键的检查。禁用外键检查的语句如下;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> foreign_key_checks<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>恢复对外键的检查语句如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> foreign_key_checks<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><font color=orange>③ 禁止自动提交</font><br>插入数据之前禁止事务的自动提交，数据导入完成之后，执行恢复自动提交操作。禁止自动提交的语句如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>恢复自动提交的语句如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="3-6-使用非空约束"><a href="#3-6-使用非空约束" class="headerlink" title="3.6 使用非空约束"></a>3.6 使用非空约束</h3><p>在设计字段的时候，如果业务允许&#x3D;&#x3D;，建议尽量使用非空约束&#x3D;&#x3D;。这样做的好处是:</p><p>①进行比较和计算时，省去要对NULL值的字段判断是否为空的开销，提高存储效率。<br>②非空字段也容易创建索引。因为索引NULL列需要额外的空间来保存，所以要占用更多的空间。使用非空约束，就可以节省存储空间(每个字段1个bit)</p><h3 id="3-7-分析表、检查表与优化表"><a href="#3-7-分析表、检查表与优化表" class="headerlink" title="3.7 分析表、检查表与优化表"></a>3.7 分析表、检查表与优化表</h3><p>MySQL提供了分析表、检查表和优化表的语句。<code>分析表</code>主要是分析关键字的分布，<code>检查表</code>主要是检查表是否存在错误，<code>优化表</code>主要是消除删除或更新造成的空间浪费。</p><p><strong><font color=blue>1.分析表</font></strong></p><p>MySQL中提供了ANALYZE TABLE语句分析表，ANALYZE TABLE语句的基本语法如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name[,tbl_name]…</span><br></pre></td></tr></table></figure><p>默认的，MySQL服务会将 ANALYZE TABLE语句写到binlog中，以便在主从架构中，从服务能够同步数据。可以添加参数LOCAL 或者 NO_WRITE_TO_BINLOG取消将语句写到binlog中。</p><p>使用<code> ANALYZE TABLE</code> 分析表的过程中，数据库系统会自动对表加一个 <code>只读锁</code> 。在分析期间，只能读取表中的记录，不能更新和插入记录。ANALYZE TABLE语句能够分析InnoDB和MyISAM类型的表，但是不能作用于视图。</p><p>ANALYZE TABLE分析后的统计结果会反应到 <code>cardinality </code>的值，该值<code>统计了表中某一键所在的列不重复的值的个数</code>。&#x3D;&#x3D;该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用。&#x3D;&#x3D;也就是索引列的cardinality的值与表中数据的总条数差距越大，即使查询的时候使用了该索引作为查询条件，存储引擎实际查询的时候使用的概率就越小。下面通过例子来验证下。cardinality可以通过SHOW INDEX FROM 表名查看。</p><p>下面我们举例说明，使用下面的语句创建一张user表。</p><p><strong>演示</strong></p><p><font color=orange>1、创建表并添加1000条记录</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">08</span><span class="operator">-</span>数据库的其他优化策略</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user1` (</span><br><span class="line">  `id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `sex` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_name` (`name`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3;</span><br><span class="line"></span><br><span class="line">#######</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span>创建函数</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span>  rand_num (from_num <span class="type">INT</span> ,to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span>   </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span>RAND()<span class="operator">*</span>(to_num <span class="operator">-</span> from_num<span class="operator">+</span><span class="number">1</span>))   ;</span><br><span class="line"><span class="keyword">RETURN</span> i;  </span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">### 创建存储过程</span><br><span class="line">DELIMITER </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span>  insert_user( max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;   </span><br><span class="line"> <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line"> REPEAT  </span><br><span class="line"> <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;  </span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> `user1` ( NAME,age,sex ) </span><br><span class="line"> <span class="keyword">VALUES</span> (&quot;atguigu&quot;,rand_num(<span class="number">1</span>,<span class="number">20</span>),&quot;male&quot;);  </span><br><span class="line"> UNTIL i <span class="operator">=</span> max_num  </span><br><span class="line"> <span class="keyword">END</span> REPEAT;  </span><br><span class="line"> <span class="keyword">COMMIT</span>; </span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER;</span><br><span class="line"></span><br><span class="line">## 向表中添加<span class="number">1000</span>条记录</span><br><span class="line"><span class="keyword">CALL</span> insert_user(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><font color=orange>2、查看表中的索引</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> user1;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238324.png" alt="image-20230110220425583"></p><p>假如我们执行下列语句后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> user1 <span class="keyword">SET</span> NAME <span class="operator">=</span> <span class="string">&#x27;atguigu03&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">OPTIMIZE <span class="keyword">TABLE</span> t1;</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> user1;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238367.png" alt="image-20230110220901894"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238157.png" alt="image-20230110221011034"></p><blockquote><p>假如说我们把id&#x3D;3的数据Name修改成atguigudb04，此时直接查看索引，发现Cardinality还是2，但是执行ANALYZE后，在查看发现Cardinality已经变成3了~ 说明ANALYZE启动了刷新数据的作用。</p></blockquote><p><strong><font color=blue>2.检查表</font></strong><br>MySQL中可以使用 <code>CHECK TABLE</code> 语句来检查表。CHECK TABLE语句能够检查InnoDB和MyISAM类型的表是否存在错误。CHECK TABLE语句在执行过程中也会给表加上 <code>只读锁</code> 。</p><p>对于MyISAM类型的表，CHECK TABLE语句还会更新关键字统计数据。而且，CHECK TABLE也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。该语句的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option <span class="operator">=</span> &#123;QUICK <span class="operator">|</span> FAST <span class="operator">|</span> MEDIUM <span class="operator">|</span> EXTENDED <span class="operator">|</span></span><br></pre></td></tr></table></figure><p>其中，tbl_name是表名；option参数有5个取值，分别是QUICK、FAST、MEDIUM、EXTENDED和CHANGED。各个选项的意义分别是：</p><ul><li><code>QUICK </code>：不扫描行，不检查错误的连接。</li><li><code>FAST </code>：只检查没有被正确关闭的表。</li><li><code>CHANGED </code>：只检查上次检查后被更改的表和没有被正确关闭的表。</li><li><code>MEDIUM </code>：扫描行，以验证被删除的连接是有效的。也可以计算各行的关键字校验和，并使用计算出的校验和验证这一点。</li><li><code>EXTENDED </code>：对每行的所有关键字进行一个全面的关键字查找。这可以确保表是100%一致的，但是花的时间较长。</li></ul><p>option只对MyISAM类型的表有效，对InnoDB类型的表无效。比如：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238163.png" alt="image-20230109221418948"></p><p>该语句对于检查的表可能会产生多行信息。最后一行有一个状态的 <code>Msg_type </code>值，Msg_text 通常为 OK。如果得到的不是 OK，通常要对其进行修复；是 OK 说明表已经是最新的了。表已经是最新的，意味着存储引擎对这张表不必进行检查。</p><p><strong><font color=blue>3. 优化表</font></strong></p><p><font color=orange>方式1：OPTIMIZE TABLE</font><br>MySQL中使用 <code>OPTIMIZE TABLE</code> 语句来优化表。但是，OPTILMIZE TABLE语句只能优化表中的<code>VARCHAR</code> 、 <code>BLOB </code>或 <code>TEXT </code>类型的字段。一个表使用了这些字段的数据类型，若已经<code> 删除</code> 了表的一大部分数据，或者已经对含有可变长度行的表（含有VARCHAR、BLOB或TEXT列的表）进行了很多 <code>更新 </code>，则应使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的 <code>碎片</code></p><p>&#x3D;&#x3D;OPTIMIZE TABLE 语句对InnoDB和MyISAM类型的表都有效&#x3D;&#x3D;。该语句在执行过程中也会给表加上 <code>只读锁</code></p><p>OPTILMIZE TABLE语句的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><p>LOCAL | NO_WRITE_TO_BINLOG关键字的意义和分析表相同，都是指定不写入二进制日志。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238175.png" alt="image-20230109221840354"></p><p>执行完毕，Msg_text显示</p><blockquote><p>‘numysql.SYS_APP_USER’, ‘optimize’, ‘note’, ‘Table does not support optimize, doing recreate +analyze instead’</p></blockquote><p>原因是我服务器上的MySQL是InnoDB存储引擎。</p><p>到底优化了没有呢？看官网！<br> <a href="https://dev.mysql.com/doc/refman/8.0/en/optimize-table.html">https://dev.mysql.com/doc/refman/8.0/en/optimize-table.html</a></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238181.png" alt="image-20230109222045057"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238190.png" alt="image-20230109222114664"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238197.png" alt="image-20230109222213402"></p><p>在MyISAM中，是先分析这张表，然后会整理相关的MySQL datafile，之后回收未使用的空间；在InnoDB中，回收空间是简单通过Alter table进行整理空间。在优化期间，MySQL会创建一个临时表，优化完成之后会删除原始表，然后会将临时表rename成为原始表。</p><blockquote><p>说明： 在多数的设置中，根本不需要运行OPTIMIZE TABLE。即使对可变长度的行进行了大量的更新，也不需要经常运行， 每周一次 或 每月一次 即可，并且只需要对 特定的表 运行。</p></blockquote><p>举例：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.新建一张表，使用存储过程往里面放入100W数据，或者更多一些，争取能够以兆的单位显示</span><br><span class="line">2.查看服务器上数据文件的大小，文件目录是/var/1ib/mysq1/所在的数据库</span><br><span class="line">3.删除二分之一的数据，然后再查看当前数据文件的大小，会发现此时大小是不变的</span><br><span class="line">4.使用OPTIMIZE table表名；命令优化表</span><br><span class="line">5.再查看当前数据文件的大小，会发现此时大小已经变化了，做了空间的回收</span><br></pre></td></tr></table></figure><p>优化前：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238682.png" alt="image-20230109222430593"></p><p>优化后：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238710.png" alt="image-20230109222518548"></p><p><font color=orange>方式2：使用mysqlcheck命令</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mysqlcheck是Linux中的rompt,<span class="operator">-</span>o是代表optimize。</span><br><span class="line">mysqlcheck <span class="operator">-</span>o DatabaseName TableName <span class="operator">-</span>u root <span class="operator">-</span>p<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br></pre></td></tr></table></figure><p>举例：优化所有的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqlcheck <span class="operator">-</span>o DatabaseName <span class="operator">-</span>u root <span class="operator">-</span>p<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">#或</span><br><span class="line">mysqlcheck <span class="operator">-</span>o <span class="comment">--all-databases -u root -p******</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238715.png" alt="image-20230109222817921"></p><h3 id="3-8-小结"><a href="#3-8-小结" class="headerlink" title="3.8 小结"></a>3.8 小结</h3><p>上述这些方法都是有利有弊的。比如：</p><ul><li>修改数据类型，节省存储空间的同时，你要考虑到数据不能超过取值范围；</li><li>增加冗余字段的时候，不要忘了确保数据一致性；</li><li>把大表拆分，也意味着你的查询会增加新的连接，从而增加额外的开销和运维的成本。</li></ul><p>因此，你一定要结合实际的业务需求进行权衡。</p><h2 id="4-大表优化"><a href="#4-大表优化" class="headerlink" title="4. 大表优化"></a>4. 大表优化</h2><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下:</p><h3 id="4-1-限定查询的范围"><a href="#4-1-限定查询的范围" class="headerlink" title="4.1 限定查询的范围"></a>4.1 限定查询的范围</h3><p>&#x3D;&#x3D;禁止不带任何限制数据范围条件的查询语句&#x3D;&#x3D;。比如:当用户在查询订单历史的时候，可以控制在一个月的范围内.</p><h3 id="4-2-读-写分离"><a href="#4-2-读-写分离" class="headerlink" title="4.2 读&#x2F;写分离"></a>4.2 读&#x2F;写分离</h3><p>经典的数据库拆分方案，主库负责写，从库负责读</p><ul><li>一主一从模式:</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238723.png" alt="image-20230109223004555"></p><ul><li>双主双从模式：</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238732.png" alt="image-20230109223022039"></p><h3 id="4-3-垂直拆分"><a href="#4-3-垂直拆分" class="headerlink" title="4.3 垂直拆分"></a>4.3 垂直拆分</h3><p>当数据量级达到 <code>千万级</code> 以上时，有时候我们需要把一个数据库切成多份，放到不同的数据库服务器上，减少对单一数据库服务器的访问压力。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238740.png" alt="image-20230109223046920"></p><p><strong>垂直拆分的优点</strong>： 可以使得列数据变小，在查询时减少读取的Block数，减少I&#x2F;O次数。此外，垂直分区可以简化表的结构，易于维护。<br><strong>垂直拆分的缺点</strong>： 主键会出现冗余，需要管理冗余列，并会引起 JOIN 操作。此外，垂直拆分会让事务变得更加复杂。</p><h3 id="4-4-水平拆分"><a href="#4-4-水平拆分" class="headerlink" title="4.4 水平拆分"></a>4.4 水平拆分</h3><ul><li>尽量控制单表数据量的大小，建议控制在<code>1000万以内</code>。1000万并不是MySQL数据库的限制，过大会造成修改表结构、备份、恢复都会有很大的问题。此时可以用<code>历史数据归挡</code>(应用于日志数据)，<code>水平分表</code>〈应用于业务数据）等手段来控制数据量大小</li><li>这里主要考虑业务数据的水平分表策略。将大的数据表按照<code>某个属性维度</code>分拆成不同的小表，每张小表保持相同的表结构。比如可以按照年份来划分，把不同年份的数据放到不同的数据表中。2017年、2018年和2019年的数据就可以分别放到三张数据表中。</li><li>&#x3D;&#x3D;水平分表仅是解决了单一表数据过大的问题&#x3D;&#x3D;，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以&#x3D;&#x3D;水平拆分最好分库&#x3D;&#x3D;，从而达到分布式的目的</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301102238426.png" alt="image-20230109223215537"></p><p>水平拆分能够支持非常大的数据量存储，应用端改造也少，但<code>分片事务难以解决，跨节点Join性能较差，逻辑复杂</code>。《Java工程师修炼之道》的作者推荐&#x3D;&#x3D;尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度&#x3D;&#x3D;，一段的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络l&#x2F;O。</p><p>下面补充一下数据库分片的两种常见方案:</p><ul><li><p><strong>客户端代理:分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong>当当网的sharding-JDBC、阿里的TDDL是两种比较常用的实现。</p></li><li><p><strong>中间件代理:在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong>我们现在谈Mycat、360的Atlas、网易的DDB等等都是这种架构的实现。</p></li></ul><h2 id="5-其它调优策略"><a href="#5-其它调优策略" class="headerlink" title="5. 其它调优策略"></a>5. 其它调优策略</h2><h3 id="5-1-服务器语句超时处理"><a href="#5-1-服务器语句超时处理" class="headerlink" title="5.1 服务器语句超时处理"></a>5.1 服务器语句超时处理</h3><p>在MySQL 8.0中可以设置 <code>服务器语句超时的限制</code>，单位可以达到 <code>毫秒级别</code> 。当中断的执行语句超过设置的毫秒数后，服务器将终止查询影响不大的事务或连接，然后将错误报给客户端。</p><p>设置服务器语句超时的限制，可以通过设置系统变量 <code>MAX_EXECUTION_TIME </code>来实现。默认情况下，MAX_EXECUTION_TIME的值为0，代表没有时间限制。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> MAX_EXECUTION_TIME<span class="operator">=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">SET</span> SESSION MAX_EXECUTION_TIME<span class="operator">=</span><span class="number">2000</span>; #指定该会话中<span class="keyword">SELECT</span>语句的超时时间</span><br></pre></td></tr></table></figure><h3 id="5-2-创建全局通用表空间"><a href="#5-2-创建全局通用表空间" class="headerlink" title="5.2 创建全局通用表空间"></a>5.2 创建全局通用表空间</h3><p>MySQL8.0使用<code>CREATE TABLE SPACE</code> 语句来创建一个全局通用表空间。全局表空间可以被所有的数据库的表共享，而且相比于独享表空间，&#x3D;&#x3D;使用手动创建共享表空间可以节约元数据方面的内存&#x3D;&#x3D;。可以在创建表的时候，指定属于哪个表空间，也可以对已有表进行表空间修改等。</p><p>下面创建名为atguigu1的共享表空间，SQL语句如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE atguigu1 <span class="keyword">ADD</span> datafile <span class="string">&#x27;atguigu1.ibd&#x27;</span> file_block_size<span class="operator">=</span><span class="number">16</span>k;</span><br></pre></td></tr></table></figure><p>指定表空间，SQL语句如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(id <span class="type">int</span> ,name <span class="type">varchar</span>(<span class="number">18</span>)) engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset utf8mb4 tablespace atguigu1;</span><br></pre></td></tr></table></figure><p>也可以通过ALTER TABLE语句指定表空间，SQL语句如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test TABLESPACE atguigu1;</span><br></pre></td></tr></table></figure><p>如何删除创建的共享表空间?因为是共享表空间，所以不能直接通过drop table tbname删除，这样操作并不能回收空间。当确定共享表空间的数据都没用，并且依赖该表空间的表均已经删除时，可以通过drop tablespace删除共享表空间来释放空间，如果依赖该共享表空间的表存在，就会删除失败。如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> TABLESPACE atguigu1;</span><br><span class="line">Tablespace atguigu1 <span class="keyword">is</span> <span class="keyword">not</span> empty.</span><br></pre></td></tr></table></figure><p>所以应该首先删除依赖该表空间的数据表，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> test;</span><br></pre></td></tr></table></figure><p>最后即可删除表空间，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> TABLESPACE atguigu1 ;</span><br></pre></td></tr></table></figure><h3 id="5-3-MySQL-8-0新特性：隐藏索引对调优的帮助"><a href="#5-3-MySQL-8-0新特性：隐藏索引对调优的帮助" class="headerlink" title="5.3 MySQL 8.0新特性：隐藏索引对调优的帮助"></a>5.3 MySQL 8.0新特性：隐藏索引对调优的帮助</h3><p>不可见索引的特性对于性能调试非常有用。在MySQL 8.0中，索引可以被”隐藏”和“显示”。&#x3D;&#x3D;当一个索引被隐藏时，它不会被查询优化器所使用&#x3D;&#x3D;。也就是说。管理员可以隐藏一个索引，然后观察对数据库的影响。如果数据库性能有所下降，就说明这个索引是有用的，于是将其”恢复显示”即可;如果数据库性能看不出变化，就说明这个索引是多余的，可以删掉了。</p><p>需要注意的是当索引被隐藏时，它的内容仍然是和正常索引一样<code>实时更新</code>的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p><p>数据表中的主键不能被设置为<code>invisible</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九、数据库的设计规范</title>
      <link href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC09%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
      <url>/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC09%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="第11章-数据库的设计规范"><a href="#第11章-数据库的设计规范" class="headerlink" title="第11章 数据库的设计规范"></a>第11章 数据库的设计规范</h1><h2 id="1-为什么需要数据库设计"><a href="#1-为什么需要数据库设计" class="headerlink" title="1. 为什么需要数据库设计"></a>1. 为什么需要数据库设计</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230133292.png" alt="image-20221127170346275"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230133600.png" alt="image-20221127170536364"></p><h2 id="2-范-式"><a href="#2-范-式" class="headerlink" title="2. 范 式"></a>2. <strong>范 式</strong></h2><h3 id="2-1-范式简介"><a href="#2-1-范式简介" class="headerlink" title="2.1 范式简介"></a>2.1 范式简介</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230133440.png" alt="image-20221127170752919"></p><h3 id="2-2-范式都包括哪些"><a href="#2-2-范式都包括哪些" class="headerlink" title="2.2 范式都包括哪些"></a>2.2 范式都包括哪些</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230133471.png" alt="image-20221127171149489"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230133430.png" alt="image-20221127171744605"></p><h3 id="2-3-键和相关属性的概念"><a href="#2-3-键和相关属性的概念" class="headerlink" title="2.3 键和相关属性的概念"></a>2.3 键和相关属性的概念</h3><p>范式的定义会使用到主键和候选键，数据库中的键(Key)由一个或者多个属性组成。数据表中常用的几种键和属性的定义:</p><ul><li><code>超键</code>︰能唯─标识元组的属性集叫做超键。</li><li><code>候选键</code>︰如果超键不包括多余的属性，那么这个超键就是候选键。·主键:用户可以从候选键中选择一个作为主键。</li><li><code>外键</code>∶如果数据表R1中的某属性集不是R1的主键，而是另一个数据表R2的主键，那么这个属性集就是数据表R1的外键。</li><li><code>主属性</code>:包含在任一候选键中的属性称为主属性。</li><li><code>非主属性</code>:与主属性相对，指的是不包含在任何一个候选键中的属性。</li></ul><p>通常，我们也将候选键称之为<code>“码”</code>，把主键也称为<code>“主码”</code>。因为键可能是由多个属性组成的，针对单个属性，我们还可以用主属性和非主属性来进行区分。</p><p><strong><font color=blue>举例，这里有两个表：</font></strong></p><p><code>球员表(player)</code>：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号</p><p><code>球队表(team)</code>：球队编号 | 主教练 | 球队所在地</p><ul><li><code>超键</code>：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。</li><li><code>候选键</code>：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</li><li><code>主键</code>：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</li><li><code>外键</code>：球员表中的球队编号。</li><li><code>主属性</code>、<code>非主属性</code>：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。</li></ul><h3 id="2-4-第一范式-1st-NF"><a href="#2-4-第一范式-1st-NF" class="headerlink" title="2.4 第一范式(1st NF)"></a>2.4 第一范式(1st NF)</h3><p>第一范式主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值为&#x3D;&#x3D;不可再次拆分&#x3D;&#x3D;的最小数据单位。</p><p>我们在设计某个字段的时候，对于字段×来说，不能把字段×拆分成字段X_1和字段X_2。事实上，任何的DBMS都会满足第一范式的要求，不会将字段进行拆分。</p><p><strong>举例一：</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230133255.png" alt="image-20221127173416188"></p><p><strong>举例二：</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230133986.png" alt="image-20221127173605845"></p><p><strong>举例三</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230133511.png" alt="image-20221127174218098"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230133870.png" alt="image-20221127174259078"></p><h3 id="2-5-第二范式-2nd-NF"><a href="#2-5-第二范式-2nd-NF" class="headerlink" title="2.5 第二范式(2nd NF)"></a>2.5 第二范式(2nd NF)</h3><p>第二范式要求，在满足第一范式的基础上，还要&#x3D;&#x3D;满足数据表里的每一条数据记录，都是可唯一标识的（也就是一定有主键）。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。&#x3D;&#x3D;如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。(要求中的主键，其实可以拓展替换为候选键)</p><p>另外 第二范式只能&#x3D;&#x3D;完全函数依赖&#x3D;&#x3D;，不能部分函数依赖</p><p><strong>举例1：</strong><br>成绩表 （学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课程号也不能决定成绩，所以“<code>（学号，课程号）→成绩</code>”就是 完全依赖关系 。</p><p><strong>举例2：</strong></p><p><code>比赛表 player_game</code>，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这里候选键和主键都为（球员编号，比赛编号），我们可以通过候选键（或主键）来决定如下的关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)</span><br></pre></td></tr></table></figure><p>但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 姓名和年龄部分依赖球员编号。</span><br><span class="line">(球员编号) → (姓名，年龄)</span><br><span class="line"></span><br><span class="line"># 比赛时间, 比赛场地部分依赖(球员编号, 比赛编号)。</span><br><span class="line">(比赛编号) → (比赛时间, 比赛场地)</span><br></pre></td></tr></table></figure><p><strong><font color=red>对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢？(为什么要满足2NF)</font></strong></p><ol><li><p><code>数据冗余</code>： 如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。</p></li><li><p><code>插入异常</code>： 如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没<br>法插入。</p></li><li><p><code>删除异常</code>： 如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删<br>除掉。</p></li><li><p><code>更新异常</code>： 如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调<br>整，否则就会出现一场比赛时间不同的情况。</p></li></ol><p>为了避免出现上述的情况，我们可以把球员比赛表设计为下面的三张表。</p><table><thead><tr><th align="center">表名</th><th align="center">属性（字段）</th></tr></thead><tbody><tr><td align="center">球员 player 表</td><td align="center">球员编号、姓名和年龄等属性</td></tr><tr><td align="center">比赛 game 表</td><td align="center">比赛编号、比赛时间和比赛场地等属性</td></tr><tr><td align="center">球员比赛关系 player_game 表</td><td align="center">球员编号、比赛编号和得分等属性</td></tr></tbody></table><p>这样的话，每张数据表都符合第二范式，也就避免了异常情况的发生。</p><blockquote><p>1NF告诉我们字段属性需要是原子性的，而2NF告诉我们一张表就是一个独立的对象，一张表只表达一个意思</p></blockquote><p><strong>举例三</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230133665.png" alt="image-20221127193808695"></p><blockquote><p>小结: 第二范式(2NF）要求实体的属性完全依赖主关键字。如果存在不完全依赖，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与元实体之间是一对多的关系。</p></blockquote><h3 id="2-6-第三范式-3rd-NF"><a href="#2-6-第三范式-3rd-NF" class="headerlink" title="2.6 第三范式(3rd NF)"></a>2.6 第三范式(3rd NF)</h3><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，&#x3D;&#x3D;要求数据表中的所有非主键字段不能依赖于其他非主键字段。&#x3D;&#x3D;（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在”A–&gt;B–&gt;C”的决定关系）通俗地讲，该规则的意思是所有<code>非主键属性</code>之间不能有&#x3D;&#x3D;传递依赖&#x3D;&#x3D;关系，必须<code>相互独立</code>。（这里的主键可以拓展为候选键）</p><p><strong>举例一</strong></p><p><code>部门信息表</code> ：每个部门有部门编号（dept_id）、部门名称、部门简介等信息。</p><p><code>员工信息表</code> ：每个员工有员工编号、姓名、部门编号。列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。(因为会存在传递依赖，也就会导致4种不合理地方)</p><p>如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。</p><p><strong>举例二</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230134279.png" alt="image-20221127200525576"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230134792.png" alt="image-20221127200454347"></p><p><strong>举例三</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230134234.png" alt="image-20221127200701162"></p><table><thead><tr><th align="center">表名</th><th align="center">属性（字段）</th></tr></thead><tbody><tr><td align="center">球队表</td><td align="center">球员编号、姓名和球队名称</td></tr><tr><td align="center">球员表</td><td align="center">球队名称、球队主教练</td></tr></tbody></table><p><strong>举例四</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230134215.png" alt="image-20221127201249899"></p><blockquote><p>符合3NF后的数据模型通俗地讲，2NF和3NF通常以这句话概括:“每个非键属性依赖于键，依赖于整个键，并且除了键别无他物”。</p></blockquote><h3 id="2-7-小结"><a href="#2-7-小结" class="headerlink" title="2.7 小结"></a>2.7 小结</h3><p>关于数据表的设计，有三个范式要遵循。</p><p>（1）第一范式（1NF），确保每列保持<code>原子性</code></p><p>数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。</p><p>（2）第二范式（2NF），确保每列都和主键<code>完全依赖</code></p><p>尤其在复合主键的情况向下，非主键部分不应该依赖于部分主键。</p><p>（3）第三范式（3NF），确保每列都和主键<code>直接相关</code>，而不是间接相关</p><p><strong>范式的优点：</strong>数据的标准化有助于消除数据库中的<code>数据冗余</code>，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。</p><p><strong>范式的缺点：</strong>范式的使用，可能<code>降低查询的效率</code>。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要<code>关联多张表</code>，这不但代价昂贵，也可能使一些<code>索引策略无效</code>。</p><p>范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过<code>增加少量的冗余</code>或重复的数据来提高数据库的<code>读性能</code>，减少关联查询，join表的次数，实现<code>空间换取时间</code>的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</p><blockquote><p>范式本身没有优劣之分，只有适用场景不同。没有完美的设计，只有合适的设计，我们在数据表的设计中，还需要根据需求将范式和反范式混合使用。</p></blockquote><h2 id="3-反范式化"><a href="#3-反范式化" class="headerlink" title="3. 反范式化"></a>3. 反范式化</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>有的时候不能简单按照规范要求设计数据表，因为有的数据看似穴余，其实对业务来说十分重要。这个时候，我们就要遵循<code>业务优先</code>的原则，首先满足业务需求，再尽量减少冗余。</p><p>如果数据库中的数据量比较大，系统的UV和PV访问频次比较高，则完全按照MySQL的三大范式设计数据表，读数据时会产生大量的关联查询，在一定程度上会影响数据库的读性能。如果我们想对查询效率进行优化，反范式化也是一种优化思路。此时，可以通过在数据表中增加冗余字段来提高数据库的读性能。</p><p><font color=blue><strong>规范化 vs 性能</strong></font></p><blockquote><ol><li><p>为满足某种商业目标 , 数据库性能比规范化数据库更重要</p></li><li><p>在数据规范化的同时 , 要综合考虑数据库的性能</p></li><li><p>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</p></li><li><p>通过在给定的表中插入计算列，以方便查询</p></li></ol></blockquote><h3 id="3-2-应用举例"><a href="#3-2-应用举例" class="headerlink" title="3.2 应用举例"></a>3.2 应用举例</h3><p><strong>举例一</strong></p><p>员工的信息存储在 <code>employees</code> 表 中，部门信息存储在 <code>departments</code> 表 中。通过 employees 表中的department_id字段与 departments 表建立关联关系。如果要查询一个员工所在部门的名称：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> employee_id,department_name</span><br><span class="line"><span class="keyword">from</span> employees e <span class="keyword">join</span> departments d</span><br><span class="line"><span class="keyword">on</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure><p>如果经常需要进行这个操作，连接查询就会浪费很多时间。可以在 employees 表中增加一个冗余字段department_name，这样就不用每次都进行连接操作了。</p><p><strong>举例二</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230134576.png" alt="image-20221127203136246"></p><p><strong>举例三</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230134032.png" alt="image-20221127203343257"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230134928.png" alt="image-20221127203421605"></p><p><strong>举例四</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230134008.png" alt="image-20221127203526841"></p><p><strong><font color=blue>实验数据：模拟两张百万量级的数据表</font></strong></p><p>为了更好地进行 SQL 优化实验，我们需要给学生表和课程评论表随机模拟出百万量级的数据。我们可以通过存储过程来实现模拟数据。</p><ul><li><strong>创建表：</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE atguigudb3;</span><br><span class="line"></span><br><span class="line">USE atguigudb3;</span><br><span class="line"></span><br><span class="line">#学生表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">  stu_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT ， stu_name <span class="type">VARCHAR</span>(<span class="number">25</span>) ， create_time DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#课程评论表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> class_comment(</span><br><span class="line">  comment_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT ， class_id <span class="type">INT</span>,</span><br><span class="line">  comment_text <span class="type">VARCHAR</span>(<span class="number">35</span>) ， comment_time DATETIME ， stu_id <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><strong>创建存储过程</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">###创建向学生表中添加数据的存储过程</span><br><span class="line">DELIMITER</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> batch_insert_student(<span class="keyword">IN</span> <span class="keyword">START</span> <span class="type">INT</span>(<span class="number">10</span>),<span class="keyword">IN</span> max_num <span class="type">INT</span> (<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> date_start DATETIME <span class="keyword">DEFAULT</span> (<span class="string">&#x27;2017-01-01 00:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">DECLARE</span> date_temp DATETIME;</span><br><span class="line"><span class="keyword">SET</span> date_temp <span class="operator">=</span> date_start;</span><br><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">REPEAT</span><br><span class="line"><span class="keyword">SET</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> date_temp <span class="operator">=</span> DATE_ADD(date_temp,<span class="type">INTERVAL</span> RAND( )<span class="operator">*</span><span class="number">60</span> <span class="keyword">SECOND</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student(stu_id, stu_name,create_time)</span><br><span class="line"><span class="keyword">VALUES</span> ((<span class="keyword">START</span><span class="operator">+</span>i), CONCAT (<span class="string">&#x27;stu_&#x27;</span>,i), date_temp) ;</span><br><span class="line">UNTIL i <span class="operator">=</span> max_num</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###创建向课程评论表中添加数据的存储过程</span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> batch_insert_class_comments(<span class="keyword">IN</span> <span class="keyword">START</span> <span class="type">INT</span>(<span class="number">10</span>),<span class="keyword">IN</span> max_num <span class="type">INT</span> (<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> date_start DATETIME <span class="keyword">DEFAULT</span> (<span class="string">&#x27;2018-01-01 00:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">DECLARE</span> date_temp DATETIME;</span><br><span class="line"><span class="keyword">DECLARE</span> comment_text <span class="type">VARCHAR</span>(<span class="number">25</span>);</span><br><span class="line"><span class="keyword">DECLARE</span> stu_id <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">SET</span> date_temp <span class="operator">=</span> date_start;</span><br><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">REPEAT</span><br><span class="line"><span class="keyword">SET</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> date_temp <span class="operator">=</span> DATE_ADD(date_temp,<span class="type">INTERVAL</span> RAND( )<span class="operator">*</span><span class="number">60</span> <span class="keyword">SECOND</span>);</span><br><span class="line"><span class="keyword">SET</span> comment_text<span class="operator">=</span>SUBSTR(MD5(RAND()),<span class="number">1</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">SET</span> stu_id<span class="operator">=</span><span class="built_in">FLOOR</span>(RAND()<span class="operator">*</span><span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `class_comment`(`comment_id`,`class_id`,`comment_text`,`comment_time`,`stu_id`)</span><br><span class="line"><span class="keyword">VALUES</span> ((<span class="keyword">START</span><span class="operator">+</span>i),<span class="number">10001</span>,comment_text,date_temp,stu_id);</span><br><span class="line">UNTIL i <span class="operator">=</span> max_num</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure><ul><li><strong>调用存储过程</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#调用存储过程,学生id从<span class="number">10001</span>开始，添加<span class="number">1000000</span>条数据</span><br><span class="line"><span class="keyword">CALL</span> batch_insert_student(<span class="number">10000</span>,<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line">#添加数据的过程的调用，一个<span class="number">1000000</span>条数据</span><br><span class="line"><span class="keyword">CALL</span> batch_insert_class_comments(<span class="number">10000</span>,<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">#######</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student;#<span class="number">1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> class_comment;#<span class="number">1000000</span></span><br></pre></td></tr></table></figure><ul><li><strong>测试</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">###需求####</span><br><span class="line">#<span class="number">0.050</span></span><br><span class="line"><span class="keyword">SELECT</span> p.comment_text, p.comment_time, stu.stu_name</span><br><span class="line"><span class="keyword">FROM</span> class_comment <span class="keyword">AS</span> p <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student <span class="keyword">AS</span> stu</span><br><span class="line"><span class="keyword">ON</span> p.stu_id <span class="operator">=</span> stu.stu_id</span><br><span class="line"><span class="keyword">WHERE</span> p.class_id <span class="operator">=</span> <span class="number">10001</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> p.comment_id <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">10000</span>;</span><br></pre></td></tr></table></figure><p>运行时长为 0.050 秒，对于网站的响应来说，这已经很慢了，用户体验会非常差。<br>如果我们想要提升查询的效率，可以允许适当的数据冗余，也就是在商品评论表中增加用户昵称字段，在 class_comment 数据表的基础上增加 stu_name 字段，就得到了 class_comment2 数据表。</p><ul><li><strong>反范式优化实验对比</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">####进行反范式化的设计#####</span><br><span class="line">#表的复制</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> class_comment1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> class_comment;</span><br><span class="line"></span><br><span class="line">#添加主键，保证class_comment1与class_comment的结构相同</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> class_comment1</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(comment_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> class_comment1;</span><br><span class="line"></span><br><span class="line">#向课程评论表中增加stu_name字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> class_comment1</span><br><span class="line"><span class="keyword">ADD</span> stu_name <span class="type">VARCHAR</span>(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#给新添加的字段赋值</span><br><span class="line"><span class="keyword">UPDATE</span> class_comment1 c</span><br><span class="line"><span class="keyword">SET</span> stu_name<span class="operator">=</span>(</span><br><span class="line"><span class="keyword">SELECT</span> stu_name</span><br><span class="line"><span class="keyword">FROM</span> student s</span><br><span class="line"><span class="keyword">WHERE</span> c.stu_id<span class="operator">=</span>s.stu_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><strong>如果我们想要查询课程 ID 为 10001 的前 10000 条评论，需要写成下面这样：</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查询同样的需求</span><br><span class="line">#<span class="number">0.020</span></span><br><span class="line"><span class="keyword">SELECT</span> comment_text, comment_time, stu_name</span><br><span class="line"><span class="keyword">FROM</span> class_comment1</span><br><span class="line"><span class="keyword">WHERE</span> class_id <span class="operator">=</span> <span class="number">10001</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> class_id <span class="keyword">DESC</span> </span><br><span class="line">LIMIT <span class="number">10000</span>;</span><br></pre></td></tr></table></figure><p>优化之后只需要扫描一次聚集索引即可，运行时间为 0.020 秒，查询时间是之前的 1&#x2F;2。 你能看到，在数据量大的情况下，查询效率会有显著的提升。</p><h3 id="3-3-反范式的新问题"><a href="#3-3-反范式的新问题" class="headerlink" title="3.3 反范式的新问题"></a>3.3 反范式的新问题</h3><ul><li>存储<code>空间变大</code>了</li><li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则<code>数据不一致</code></li><li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常<code>消耗系统资源</code></li><li>在<code>数据量小</code>的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加<code>复杂</code></li></ul><h3 id="3-4-反范式的适用场景"><a href="#3-4-反范式的适用场景" class="headerlink" title="3.4 反范式的适用场景"></a>3.4 反范式的适用场景</h3><p>当冗余信息有价值或者能<code>大幅度提高查询效率</code>的时候，我们才会采取反范式的优化。</p><p><font color=blue>1. 增加冗余字段的建议 </font></p><p>1）这个冗余字段<code>不需要经常进行修改</code></p><p>2）这个冗余字段<code>查询的时候不可或缺</code> (因为经常要用，所以才增加该冗余字段)</p><p><font color=blue>2. 历史快照、历史数据的需要</font></p><p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的<code>订单收货信息</code>都属于<code>历史快照</code>，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p><p>反范式优化也常用在<code>数据仓库</code>的设计中，因为数据仓库通常<code>存储历史数据</code>，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p><blockquote><p><strong>简单总结下数据仓库和数据库在使用上的区别:</strong></p><ol><li>数据库设计的目的在于<code>捕获数据</code>，而数据仓库设计的目的在于<code>分析数据</code>；</li><li>数据库对数据的<code>增删改实时性</code>要求强，需要存储在线的用户数据，而数据仓库存储的一般是<code>历史数据</code>;</li><li>数据库设计需要<code>尽量避免冗余</code>，但为了提高查询效率也允许一定的<code>冗余度</code>，而数据仓库在设计上更偏向采用反范式设计</li></ol></blockquote><p>&#x3D;&#x3D;注意：&#x3D;&#x3D;我们的反范式 反的是第二 或 第三范式，第一范式是一定要遵守的哦~</p><h2 id="4-BCNF-巴斯范式"><a href="#4-BCNF-巴斯范式" class="headerlink" title="4. BCNF(巴斯范式)"></a>4. BCNF(巴斯范式)</h2><p>人们在3NF的基础上进行了改进，提出了**巴斯范式(BCNF)<strong>，也叫做</strong>巴斯-科德范式(Boyce-Codd NormalForm)**。BCNF被认为没有新的设计规范加入，只是对第三范式中设计规范要求更强，使得数据库冗余度更小。所以，称为是<code>修正的第三范式</code>，或<code>扩充的第三范式</code>，BCNF不被称为第四范式</p><p>若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到BC范式。</p><p>一般来说，一个数据库设计符合3NF或BCNF就可以了</p><p><strong>1、案例</strong></p><p>我们分析如下表的范式情况:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230134742.png" alt="image-20221221211602267"></p><p>在这个表中，一个仓库只有一个管理员，同时一个管理员也只管理一个仓库。先来梳理下这些属性之间的依赖关系。</p><p>仓库名决定了管理员，管理员也决定了仓库名，同时（仓库名，物品名）的属性集合可以决定数量这个属性。这样，我们就可以找到数据表的候选键。</p><p><code>候选键</code> ：是（管理员，物品名）和（仓库名，物品名），然后从候选键中选择一个作为 主键 ，比如（仓库名，物品名）。<br><code>主属性</code> ：包含在任一候选键中的属性，也就是仓库名，管理员和物品名。</p><p><code>非主属性</code> ：数量这个属性</p><p><strong>2、是否符合三范式</strong><br>如何判断一张表的范式呢？需要根据范式的等级，从低到高来进行判断</p><ul><li><p>首先，数据表每个属性都是原子性的，符合 1NF 的要求；</p></li><li><p>其次，数据表中非主属性”数量“都与候选键全部依赖，（仓库名，物品名）决定数量，（管理员，物品名）决定数量。因此，数据表符合 2NF 的要求；</p></li><li><p>最后，数据表中的非主属性，不传递依赖于候选键。因此符合 3NF 的要求。</p></li></ul><p><strong>3、存在的问题</strong><br>既然数据表已经符合了 3NF 的要求，是不是就不存在问题了呢？来看下面的情况：</p><ol><li>增加一个仓库，但是还没有存放任何物品。根据数据表实体完整性的要求，主键不能有空值，因此会出现插入异常 ；</li><li>如果仓库更换了管理员，就可能会 修改数据表中的多条记录 ；</li><li>如果仓库里的商品都卖空了，那么此时仓库名称和相应的管理员名称也会随之被删除。</li></ol><p>你能看到，即便数据表符合 3NF 的要求，同样可能存在插入，更新和删除数据的异常情况</p><p><strong>4、问题解决</strong><br>首先需要确认造成异常的原因：&#x3D;&#x3D;主属性仓库名对于候选键（管理员，物品名）是部分依赖的关系，&#x3D;&#x3D;这样就有可能导致上面的异常情况。因此引入&#x3D;&#x3D;BCNF，它在 3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。&#x3D;&#x3D;</p><p><font color=blue>如果在关系R中，U为主键，A属性是主键的一个属性，若存在A-&gt;Y，Y为主属性(也就是非候选码中的属性)，则该关系不属于BCNF</font>。</p><p>根据 BCNF 的要求，需要把仓库管理关系 warehouse_keeper 表拆分成下面这样：</p><ul><li><code>仓库表</code> ：（仓库名，管理员）</li><li><code>库存表</code> ：（仓库名，物品名，数量）</li></ul><p>这样就不存在主属性对于候选键的部分依赖或传递依赖，上面数据表的设计就符合 BCNF。</p><p><strong><font color=orange>再举例：</font></strong></p><p>有一个 学生导师表，其中包含字段：学生ID，专业，导师，专业GPA，这其中学生ID和专业是联合主键。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230134198.png" alt="image-20221221214347478"></p><p>这个表的设计满足三范式，但是这里存在另一个依赖关系，“专业”依赖于“导师”，也就是说每个导师只做一个专业方面的导师，只要知道了是哪个导师，自然就知道是哪个专业的了。</p><p>所以这个表的部分主键Major依赖于非主键属性Advisor，那么我们可以进行以下的调整，拆分成2个表：</p><p>学生导师表：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230134264.png" alt="image-20221221214511430"></p><p>导师表：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230134415.png" alt="image-20221221214533669"></p><h2 id="5-第四范式"><a href="#5-第四范式" class="headerlink" title="5. 第四范式"></a>5. 第四范式</h2><p>多值依赖的概念:</p><ul><li><code>多值依赖</code>即属性之间的一对多关系，记为K→→A</li><li><code>函数依赖</code>事实上是单值依赖，所以不能表达属性值之间的一对多关系</li><li><code>平凡的多值依赖</code>∶全集U&#x3D;K+A，一个K可以对应于多个A，即K→→A。此时整个表就是一组一对多关系</li><li><code>非平凡的多值依赖</code>︰全集U&#x3D;K+A+B，一个K可以对应于多个A，也可以对应于多个B，A与B互相独立，即K→→A，K→→B。整个表有多组一对多关系，且有：“一”部分是相同的属性集合，“多””部分是互相独立的属性集合</li></ul><p>第四范式即&#x3D;&#x3D;在满足巴斯-科德范式(BCNF）的基础上，消除非平凡且非函数依赖的多值依赖&#x3D;&#x3D;（即把同一表内的多对多关系删除)</p><p><strong>举例1：</strong><br>职工表(职工编号，职工孩子姓名，职工选修课程)。</p><p>在这个表中，同一个职工可能会有多个职工孩子姓名。同样，同一个职工也可能会有多个职工选修课程，即这里存在着多值事实，不符合第四范式。</p><p>如果要符合第四范式，只需要将上表分为两个表，使它们只有一个多值事实，例如： <code>职工表一 (职工编号，职工孩子姓名)</code>，<code>职工表二 (职工编号，职工选修课程)</code>，两个表都只有一个多值事实，所以符合第四范式</p><p><strong>举例2：</strong><br>比如建立课程、教师、教材的模型。我们规定，每门课程有对应的一组教师，每门课程也有对应的一组教材，一门课程使用的教材和教师没有关系。我们建立的关系表如下：</p><p>课程ID，教师ID，教材ID；这三列作为联合主键。</p><p>为了表述方便，我们用Name代替ID，这样更容易看懂：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230134153.png" alt="image-20221221215720852"></p><p>这个表除了主键，就没有其他字段了，所以肯定满足BC范式，但是却存在<code>多值依赖</code>导致的异常。</p><p>假如下学期想采用一本新的英版高数教材，但是还没确定具体哪个老师来教，那么就无法在这个表中维护Course高数和Book英版高数教材的的关系。</p><p>解决办法是把这个多值依赖的表拆解成2个表，分别建立关系。这是拆分后的表：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230134365.png" alt="image-20221221215822964"></p><p>以及</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230134435.png" alt="image-20221221215839791"></p><h2 id="6-第五范式、域键范式"><a href="#6-第五范式、域键范式" class="headerlink" title="6. 第五范式、域键范式"></a>6. 第五范式、域键范式</h2><p>除了第四范式外，还有更高级的第五范式（又称完美范式）和域键范式（DKNF）。</p><p>在满足第四范式（4NF）的基础上，消除不是由候选键所蕴含的连接依赖。&#x3D;&#x3D;如果关系模式R中的每一个连接依赖均由R的候选键所隐含&#x3D;&#x3D;，则称此关系模式符合第五范式。</p><p>函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上是连接依赖的一种特殊情况。但连接依赖不像函数依赖和多值依赖可以由<code>语义直接导出</code> ，而是在 <code>关系连接运算 </code>时才反映出来。存在连接依赖的关系模式仍可能遇到数据冗余及插入、修改、删除异常等问题。</p><p>第五范式处理的是<code>无损连接问题</code>，这个范式基本 <code>没有实际意义</code> ，因为无损连接很少出现，而且难以察觉。而域键范式试图定义一个<code>终极范式</code> ，该范式考虑所有的依赖和约束类型，但是实用价值也是最小的，只存在理论研究中。</p><h2 id="7-实战案例"><a href="#7-实战案例" class="headerlink" title="7. 实战案例"></a>7. 实战案例</h2><p>商超进货系统中的进货单表进行剖析：</p><p>进货单表：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230134807.png" alt="image-20221221230058669"></p><p>这个表中的字段很多，表里的数据量也很惊人。大量重复导致表变得庞大，效率极低。如何改造?</p><blockquote><p>在实际工作场景中，这种由于数据表结构设计不合理，而导致的数据重复的现象并不少见。往往是系统虽然能够运行，承载能力却很差，稍微有点流量，就会出现内存不足、CUP使用率飙升的情况，甚至会导致整个项目失败</p></blockquote><h3 id="7-1-迭代1次-考虑1NF"><a href="#7-1-迭代1次-考虑1NF" class="headerlink" title="7.1 迭代1次:考虑1NF"></a>7.1 迭代1次:考虑1NF</h3><p>第一范式要求:&#x3D;&#x3D;所有的字段都是基本数据字段，不可进一步拆分&#x3D;&#x3D;。这里需要确认，所有的列中，每个字段只包含—种数据。</p><p>这张表里把“property”这一字段，拆分成”specification (规格)“和”unit(单位)”，这2个字段如下:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135773.png" alt="image-20221221230249133"></p><h3 id="7-2-迭代2次-考虑2NF"><a href="#7-2-迭代2次-考虑2NF" class="headerlink" title="7.2 迭代2次:考虑2NF"></a>7.2 迭代2次:考虑2NF</h3><p>第二范式要求，在满足第一范式的基础上，&#x3D;&#x3D;还要满足数据表里的每一条数据记录，都是可唯一标识的。而且所有字段，都必须完全依赖主键，不能只依赖主键的一部分&#x3D;&#x3D;</p><p>第1步，就是要确定这个表的主键。通过观察发现，字段““listnumber(单号)”+”barcode(条码)”可以唯一标识每一条记录，可以作为主键。</p><p>第2步，确定好了主键以后，判断哪些字段完全依赖主键，哪些字段只依赖于主键的一部分。把只依赖于主键一部分的字段拆分出去，形成新的数据表。</p><p>首先，进货单明细表里面的“goodsname(名称)” “specification(规格)“unit(单位)“这些信息是商品的属性，只依赖于“barcode(条码)”，不完全依赖主键，可以拆分出去。把这3个字段加上它们所依赖的字段”“barcode(条码)”，拆分形成一个新的数据表“商品信息表”。<br>这样一来，原来的数据表就被拆分成了两个表</p><p>商品信息表:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135752.png" alt="image-20221221230713549"></p><p>进货单表：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135798.png" alt="image-20221221230734844"></p><p>此外，字段“supplierid(供应商编号)”“suppliername(供应商名称)””stock(仓库)“只依赖于”listnumber(单号)”，不完全依赖于主键，所以，可以把”supplierid”“suppliername”stock”这3个字段拆出去，再加上它们依赖的字段”listnumber(单号)””，就形成了一个新的表“<code>进货单头表</code>”。剩下的字段，会组成新的表，我们叫它”进货单明细表”。</p><p>原来的数据表就拆分成了3个表</p><p>进货单头表:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135984.png" alt="image-20221221230951770"></p><p>进货单明细表：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135702.png" alt="image-20221221231013100"></p><p>商品信息表：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135816.png" alt="image-20221221231042371"></p><p>现在来分析一下拆分后的3个表，保证这3个表都满足第二范式的要求</p><p>第3步，在”商品信息表”中，字段”barcode”是有<code>可能存在重复的</code>，比如，用户门店可能有散装称重商品和自产商品，会存在条码共用的情况。所以，所有的字段都不能唯一标识表里的记录。这个时候必须给这个表加上一个主键，比如说是自增字段”<code>itemnumber</code>”。</p><p>现在就可以把进货单明细表里面的字段”barcode”都替换成字段”itemnumber”，这就得到了新的如下表</p><p>进货单明细表：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135535.png" alt="image-20221221231358391"></p><p>商品信息表：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135871.png" alt="image-20221221231342038"></p><p>拆分后的3个数据表就全部满足了第二范式的要求</p><h3 id="7-3-迭代3次-考虑3NF"><a href="#7-3-迭代3次-考虑3NF" class="headerlink" title="7.3 迭代3次:考虑3NF"></a>7.3 迭代3次:考虑3NF</h3><p>进货单头表还有数据冗余的可能。因为“supplername “依赖”supplierid”那么，这个时候，就可以按照第三范式的原则进行拆分了。进一步拆分一下进货单头表，把它拆解成供货商表和进货单头表。</p><p>供货商表:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135024.png" alt="image-20221221231543741"></p><p>进货单头表：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135463.png" alt="image-20221221231609611"></p><p>这2个表都满足第三范式的要求了</p><h3 id="7-4-反范式化-业务优先的原则"><a href="#7-4-反范式化-业务优先的原则" class="headerlink" title="7.4 反范式化:业务优先的原则"></a>7.4 反范式化:业务优先的原则</h3><p>在进货单明细表中，<code>quantity * importprice = importvalue</code>、“importprice”、“quantity”和”importvalue可以通过任意两个计算出第三个来，这就存在冗余字段。如果严格按照第三范式的要求，应该进行进一步优化。优化的办法是删除其中一个字段，只保留另外2个，这样就没有冗余数据了。</p><p>可是，真的可以这样做吗? 要回答这个问题就要先了解下实际工作中的&#x3D;&#x3D;业务优先原则&#x3D;&#x3D;。</p><p>所谓的业务优先原则，就是指一切以业务需求为主，技术服务于业务。<strong>完全按照理论的设计不一定就是最优，还要根据实际情况来决定。</strong>这里就来分析一下不同选择的利与弊。</p><p>对于<code>quantity * importprice =importvalue</code>，看起来”importvalue”似乎是冗余字段，但并不会导致数据不一致，可是，如果把这个字段取消，是会影响业务的。</p><p>因为有的时候，供货商会经常进行一些促销活动，按金额促销，那他们拿来的进货单只有金额，没有价格。而”“importprice”反而是通过“importvalue &#x2F; quantity”计算出来的，经过四舍五入，会产生较大的误差。这样日积月累，最终会导致查询结果出现较大偏差，影响系统的可靠性。</p><p>举例:进货金额(importvalue)是25.5元，数量(quantity)是 34，那么进货价格(importprice)就等于25.5&#x2F;34&#x3D;0.74元，但是如果用这个计算出来的进货价格(importprice)来计算进货金额，那么，进货金额(importvalue)就等于0.74x34&#x3D;25.16元，其中相差了25.5-25.16&#x3D;0.34元</p><p>所以，本着业务优先的原则，在不影响系统可靠性的前提下，可适当增加数据冗余，保留“importvalue”importprice”和“quantity”。</p><p>因此，最后我们可以把进货单表拆分成下面的4个表:</p><p>进货单明细表：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135595.png" alt="image-20221221232106379"></p><p>商品信息表：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135389.png" alt="image-20221221232038171"></p><p>供货商表:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135598.png" alt="image-20221221231543741"></p><p>进货单头表：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135509.png" alt="image-20221221231609611"></p><p>这样一来，我们就避免了冗余，而且还能够满足业务的需求，这样的数据表设计，才是合格的设计。</p><h2 id="8-ER模型"><a href="#8-ER模型" class="headerlink" title="8. ER模型"></a>8. ER模型</h2><p>数据库设计是牵一发而动全身的。那有没有什么办法提前看到数据库的全貌呢?比如需要哪些数据表、数据表中应该有哪些字段，数据表与数据表之间有什么关系、通过什么字段进行连接，等等。这样才能进行整体的梳理和设计。</p><p>其实，ER模型就是一个这样的工具。ER模型也叫作<code>实体关系模型</code>，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。&#x3D;&#x3D;在开发基于数据库的信息系统的设计阶段，通常使用ER模型来描述信息需求和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库&#x3D;&#x3D;</p><h3 id="8-1-ER模型包括哪些要素"><a href="#8-1-ER模型包括哪些要素" class="headerlink" title="8.1 ER模型包括哪些要素?"></a>8.1 ER模型包括哪些要素?</h3><p>&#x3D;&#x3D;ER模型中有三个要素。分别是实体、属性和关系&#x3D;&#x3D;</p><ul><li><p><code>实体</code>，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在ER模型中，用<code>矩形</code>来表示。实体分为两类，分别是<code>强实体</code>和<code>弱实体</code>。强实体是指不依赖于其他实体的实体;弱实体是指对另一个实体有很强的依赖关系的实体。</p></li><li><p><code>属性</code>， 则是指实体的特性。比如超市的地址、联系电话、员工数等。在ER模型中用<code>椭圆形</code>来表示。</p></li><li><p><code>关系</code>， 则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在ER模型中用菱形来表示。</p></li></ul><p>注意:实体和属性不容易区分。这里提供一个原则:要从系统整体的角度出发去看，&#x3D;&#x3D;可以独立存在的是实体，不可再分的是属性&#x3D;&#x3D;。也就是说，属性不能包含其他属性。</p><h3 id="8-2-关系的类型"><a href="#8-2-关系的类型" class="headerlink" title="8.2 关系的类型"></a>8.2 关系的类型</h3><p>在ER模型的3个要素中，关系又可以分为3种类型，分别是一对一、一对多、多对多。</p><ul><li><p><code>一对一</code>︰指实体之间的关系是一一对应的，比如个人与身份证信息之间的关系就是一对一的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。</p></li><li><p><code>一对多</code>∶指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如说，新建一个班级表，而每个班级都有多个学生，每个学生则对应一个班级，班级对学生就是一对多的关系。</p></li><li><p><code>多对多</code>︰指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购商品。再比如一个选课表，有许多科目，每个科目有很多学生选，而每个学生又可以选择多个科目，这就是多对多的关系。</p></li></ul><h3 id="8-3-建模分析"><a href="#8-3-建模分析" class="headerlink" title="8.3 建模分析"></a>8.3 建模分析</h3><p>ER模型看起来比较麻烦，但是对我们把控项目整体非常重要。如果你只是开发一个小应用，或许简单设计几个表够用了，一旦要设计有一定规模的应用，在项目的初始阶段，建立完整的ER模型就非常关键了。开发应用项目的实质，其实就是<code>建模</code></p><p>此处设计的案例是<code>电商业务</code>，由于电商业务太过庞大且复杂，所以做了业务简化，比如针对SKU(StockKeepingUnit，库存量单位）和SPU(Standard Product Unit，标准化产品单元)的含义上，直接使用了SKU，并没有提及SPU的概念。本次电商业务设计总共有8个实体，如下所示。</p><ul><li>地址实体</li><li>用户实体</li><li>购物车实体</li><li>评论实体</li><li>商品实体</li><li>商品分类实体</li><li>订单实体</li><li>订单详情实体</li></ul><p>其中，<code>用户</code>和<code>商品分类</code>是强实体，因为它们不需要依赖其他任何实体。而其他同于弱实体，因为它们虽然都可以独立存在，但是它们都依赖用户这个实体，因此都是弱实体。知道了这些要素就可以给电商业务创建ER模型了，如图:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135079.png" alt="image-20221223000234590"></p><p>在这个图中，地址和用户之间的添加关系，是一对多的关系，而商品和商品详情示一对一的关系，商品和订单是多对多的关系。 这个 ER 模型，包括了 8个实体之间的 8种关系。</p><p>（1）用户可以在电商平台添加多个地址；</p><p>（2）用户只能拥有一个购物车；</p><p>（3）用户可以生成多个订单；</p><p>（4）用户可以发表多条评论；</p><p>（5）一件商品可以有多条评论；</p><p>（6）每一个商品分类包含多种商品；</p><p>（7）一个订单可以包含多个商品，一个商品可以在多个订单里。</p><p>（8）订单中又包含多个订单详情，因为一个订单中可能包含不同种类的商品</p><h3 id="8-4-ER-模型的细化"><a href="#8-4-ER-模型的细化" class="headerlink" title="8.4 ER 模型的细化"></a>8.4 ER 模型的细化</h3><p>有了这个 ER 模型就可以从整体上<code>理解</code>电商的业务了。刚刚的 ER 模型展示了电商业务的框架，但是只包括了订单，地址，用户，购物车，评论，商品，商品分类和订单详情这八个实体，以及它们之间的关系，还不能对应到具体的表，以及表与表之间的关联。需要<code>把属性加上</code>，用<code>椭圆</code>来表示，这样得到的 ER 模型就更加完整了。</p><p>因此，我们需要进一步去设计一下这个 ER 模型的各个局部，也就是细化下电商的具体业务流程，然后把它们综合到一起，形成一个完整的 ER 模型。这样可以理清数据库的设计思路。</p><p>接下来再分析一下各个实体都有哪些属性，如下所示。</p><p>（1） <code>地址实体</code> 包括用户编号、省、市、地区、收件人、联系电话、是否是默认地址。<br>（2） <code>用户实体</code> 包括用户编号、用户名称、昵称、用户密码、手机号、邮箱、头像、用户级别。<br>（3） <code>购物车实体</code> 包括购物车编号、用户编号、商品编号、商品数量、图片文件url<br>（4）<code>订单实体</code> 包括订单编号、收货人、收件人电话、总金额、用户编号、付款方式、送货地址、下单时间。<br>（5） <code>订单详情实体</code> 包括订单详情编号、订单编号、商品名称、商品编号、商品数量。<br>（6） <code>商品实体</code> 包括商品编号、价格、商品名称、分类编号、是否销售，规格、颜色。<br>（7） <code>评论实体</code> 包括评论id、评论内容、评论时间、用户编号、商品编号<br>（8） <code>商品分类实体</code> 包括类别编号、类别名称、父类别编号</p><p>这样细分之后就可以重新设计电商业务了，ER 模型如图：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135648.png" alt="image-20221223000842728"></p><h3 id="8-5-ER-模型图转换成数据表"><a href="#8-5-ER-模型图转换成数据表" class="headerlink" title="8.5 ER 模型图转换成数据表"></a>8.5 ER 模型图转换成数据表</h3><p>通过绘制 ER 模型已经理清了业务逻辑，现在就要进行非常重要的一步了：把绘制好的 ER模型，转换成具体的数据表，下面介绍下转换的原则：<br>（1）一个<code>实体</code>通常转换成一个 <code>数据表</code> ；<br>（2）一个 <code>多对多的关系</code> ，通常也转换成一个 <code>数据表</code> ；<br>（3）一个<code> 1 对 1</code> ，或者 <code>1 对多</code> 的关系，往往通过表的<code> 外键</code> 来表达，而不是设计一个新的数据表；<br>（4） <code>属性</code> 转换成表的 <code>字段 </code>。</p><p>下面结合前面的ER模型，具体讲解一下怎么运用这些转换的原则，把 ER 模型转换成具体的数据表，从而把抽象出来的数据模型，落实到具体的数据库设计当中</p><p><font color=orange>1、一个实体通常转换成一个数据表</font></p><p><strong>先来看一下强实体转换成数据表:</strong></p><p><code>用户实体</code>转换成<code>用户表</code>(user_info)的代码如下所示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_info`(</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>)<span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `user_name` <span class="type">varchar</span>(<span class="number">200</span>)<span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名称&#x27;</span>,</span><br><span class="line">  `nick_name` <span class="type">varchar</span> (<span class="number">200</span>)<span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户昵称&#x27;</span>,</span><br><span class="line">  `passwd` <span class="type">varchar</span> (<span class="number">200</span>)<span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户密码&#x27;</span>,</span><br><span class="line">  `phone_num` <span class="type">varchar</span> (<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  `head_img` <span class="type">varchar</span> ( <span class="number">200</span>)<span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;头像&#x27;</span>,</span><br><span class="line">  `user_level` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户级别&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>商品分类实体</code>转换成商品分类表 (base_category)，由于商品分类可以有一级分类和二级分类，比如一级分类有家居、手机等等分类，二级分类可以根据手机的一级分类分为手机配件，运营商等，这里我们把商品分类实体规划为两张表，分别是一级分类表和二级分类表，之所以这么规划是因为一级分类和二级分类都是有限的，存储为两张表业务结构更加清晰。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#一级分类表</span><br><span class="line">  <span class="keyword">CREATE</span> <span class="keyword">TABLE</span>`base_category1`(</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span> (<span class="number">10</span>) <span class="keyword">NOT</span><span class="operator">-</span><span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类名称&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;一级分类表&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#二级分类表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `base_category2`(</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span> (<span class="number">208</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;二级分类名称&#x27;</span>,</span><br><span class="line">  `category1_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;一级分类编号&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;二级分类表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>那么如果规划为—张表呢，表结构如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `base_category`(</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span> (<span class="number">200</span>)<span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类名不&#x27;</span>,</span><br><span class="line">  `category_parent_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;父分类编号&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY ( id  ) <span class="keyword">USING</span> BTREE</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB AUTO_INCRENENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span> <span class="string">&#x27;分类表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果这样分类的话，那么查询一级分类时候，就需要判断父分类编号是否为空，但是如果插入二级分类的时候也是空，就容易造成<code>业务数据混乱</code>。而且查询二级分类的时候IS NOT NULL条件是无法使用到索引的。同时，这样的设计也不符合第二范式(因为父分类编号并不依赖分类编号ID，因为父分类编号可以有很多数据为NULL)，所以需要进行表的拆分。因此无论是<code>业务需求</code>还是<code>数据库表的规范</code>来看都应该拆分为两张表。</p><p><strong>下面我们再把弱实体转换成数据表:</strong></p><p>地址实体转换成地址表(user_address) ，如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_address`(</span><br><span class="line">`id` <span class="type">bigint</span>(<span class="number">20</span>)<span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;province&#x27;</span> <span class="type">varchar</span> (<span class="number">500</span>)<span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;省&#x27;</span>,</span><br><span class="line">`city` <span class="type">varchar</span> (<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;市&#x27;</span>,</span><br><span class="line">`user_address` <span class="type">varchar</span> (<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;具体地址&#x27;</span>,</span><br><span class="line">`user_id bipint(<span class="number">20</span>)` <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">`consignee` <span class="type">varchar</span>( <span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;收件人&#x27;</span>,</span><br><span class="line">`phone_num ` <span class="type">varchar</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT ‘联系方式<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">`is_default` varchar( 1) DEFAULT NULL COMMENT &#x27;</span>是否是默认<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">PRIMARY KEY (`id`)</span></span><br><span class="line"><span class="string">)ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&#x27;</span>用户地址表<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure><p>订单实体转换成订单表（order_info)，如下所示，实际业务中订单的信息会非常多，我们这里做了简化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `order_info`(</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `consignee` <span class="type">varchar</span> (<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;收货人&#x27;</span>,</span><br><span class="line">  `consignee_tel` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;收件人电话&#x27;</span>,</span><br><span class="line">  `total_amount` <span class="type">decimal</span>( <span class="number">10</span>,<span class="number">2</span>)<span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;总金额&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `payment_way` <span class="type">varchar</span>(<span class="number">20</span>)<span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;付款方式&#x27;</span>,</span><br><span class="line">  `delivery_address` <span class="type">varchar</span>( <span class="number">1000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;送货地址&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;下单时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB AUTO_INCRENENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORNAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span> <span class="string">&#x27;订单表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>订单详情实体转换成订单详情表（order_detail)，如下所示。(用于体现多对多关系的，见下节)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#订单详情表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `order_detail`(</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;订单详情编号&#x27;</span>,</span><br><span class="line">  `order_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>)<span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku_id&#x27;</span>,</span><br><span class="line">  `sku_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku名称&#x27;</span>,</span><br><span class="line">  `sku_num` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;购买个数&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;订单明细表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>购物车实体转换成购物车表(cart_info)，如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `cart_info`(</span><br><span class="line">  `cart_id` <span class="type">bigint</span>(<span class="number">20</span>)<span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT<span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>)<span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;skuid&#x27;</span> ,</span><br><span class="line">  `sku_num` <span class="type">int</span>( <span class="number">11</span>)<span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line">  `img_url` <span class="type">varchar</span> ( <span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;图片文件&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB AUTO_INCRENENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;购物车表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>评论实体转换成评论表(members)，如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sku_comments`(</span><br><span class="line">  `comment_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT<span class="string">&#x27;评论编号&#x27;</span>,</span><br><span class="line">  `user_id` bigin)t (<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;用户编号&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">decimal</span>( <span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> NULI COMMENT <span class="string">&#x27;商品编号&#x27;</span>,</span><br><span class="line">  `comment` <span class="type">varchar</span>(<span class="number">2000</span>)<span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;评论内容&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;评论时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">）ENGINE<span class="operator">=</span>InnoDB AUTO_INCRENENT<span class="operator">=</span><span class="number">45</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMNENT<span class="operator">=</span><span class="string">&#x27;商品评论表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>商品实体转换成商品表(members)，如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sku_info`(</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COPMENT<span class="string">&#x27;商品编号(itemID)&#x27;</span>,</span><br><span class="line">   `price` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;价格&#x27;</span>,</span><br><span class="line">  `sku_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku名称&#x27;</span>,</span><br><span class="line">  `sku_desc` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;商品规格描述&#x27;</span>,</span><br><span class="line">  `category3_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;三级分类id(冗余)&#x27;</span>,</span><br><span class="line">  `color` <span class="type">varchar</span> (<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;颜色&#x27;</span>,</span><br><span class="line">  `is_sale` tinyint(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> CONMMENT<span class="string">&#x27;是否销售(1:是0:否)&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB AUTO_INCRENENT<span class="operator">=</span><span class="number">45</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span> <span class="string">&#x27;商品表&#x27;</span>;</span><br></pre></td></tr></table></figure><p><font color=orange>2、一个多对多的关系转换成一个数据表</font><br>这个ER模型中的多对多的关系有1个，即<code>商品</code>和<code>订单</code>之间的关系，同品类的商品可以出现在不同的订单中，不同的订单也可以包含同一类型的商品，所以它们之间的关系是多对多。针对这种情况需要设计一个独立的表来表示，这种表一般称为<code>中间表</code>。</p><p>我们可以设计一个独立的<code>订单详情表</code>，来代表商品和订单之间的包含关系。这个表关联到2个实体，分别是订单、商品。所以，表中必须要包括这2个实体转换成的表的主键。除此之外，我们还要包括该关系自有的属性:商品数量，商品下单价格以及商品名称。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#订单详情表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `order_detail`(</span><br><span class="line">`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;订单详情编号&#x27;</span>,</span><br><span class="line">`order_id` <span class="type">bigint</span>(<span class="number">20</span>)<span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line">`sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku_id &#x27;</span>,</span><br><span class="line">`sku_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku名称&#x27;</span>,</span><br><span class="line">`sku_num` <span class="type">varchar</span>(<span class="number">200</span>)<span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;购买个数&#x27;</span>,</span><br><span class="line">`create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB AUTO_INCRENENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;订单明细表&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>公司的订单相关表主要有：order、order_item、sku、spu…其中order_detail相当于order_item</p></blockquote><p><font color=orange>3、通过外键来表达1对多的关系</font><br>在上面的表的设计中，我们可以&#x3D;&#x3D;用外键来表达1对多&#x3D;&#x3D;的关系。比如在商品评论表sku_comments中<br>我们分别把user_id、sku_id定义成外键，以使用下面的语句设置外键。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span> fk_comment_user <span class="keyword">FOREIGN</span> KEY (user_id) <span class="keyword">REFERENCES</span> user_info (id),</span><br><span class="line"></span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_comment_sku <span class="keyword">FOREIGN</span> KEY (sku_id)<span class="keyword">REFERENCES</span> sku_info (sku_id)</span><br></pre></td></tr></table></figure><p>外键约束主要是在数据库层面上<code>保证数据的一致性</code>，但是因为插入和更新数据需要检查外键，理论上<code>性能会有所下降</code>，对性能是负面的影响。</p><p>实际的项目，不建议使用外键，一方面是<code>降低开发的复杂度</code>(有外键的话主从表类的操作必须先操作主表)，另外是有外键在<code>处理数据的时候非常麻烦</code>。在电商平台，由于<code>并发业务量比较大</code>，所以一般不设置外键，以免影响数据库<code>性能</code>。</p><p>&#x3D;&#x3D;在应用层面做数据的<code>一致性检查</code>，本来就是一个正常的功能需求&#x3D;&#x3D;。如学生选课的场景，课程肯定不是输入的，而是通过下拉或查找等方式从系统中进行选取，就能够保证是合法的课程ID，因此就不需要靠数据库的外键来检查了。</p><p><font color=orange>4、把属性转换成表的字段</font><br>在刚刚的设计中，我们也完成了把属性都转换成了表的字段，比如把商品属性转换成了商品信息表中的字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sku_info`(</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COPMENT<span class="string">&#x27;商品编号(itemID)&#x27;</span>,</span><br><span class="line">   `price` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;价格&#x27;</span>,</span><br><span class="line">  `sku_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku名称&#x27;</span>,</span><br><span class="line">  `sku_desc` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;商品规格描述&#x27;</span>,</span><br><span class="line">  `category3_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;三级分类id(冗余)&#x27;</span>,</span><br><span class="line">  `color` <span class="type">varchar</span> (<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;颜色&#x27;</span>,</span><br><span class="line">  `is_sale` tinyint(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> CONMMENT<span class="string">&#x27;是否销售(1:是0:否)&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB AUTO_INCRENENT<span class="operator">=</span><span class="number">45</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span> <span class="string">&#x27;商品表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>到这里，我们通过创建<code>电商项目业务流程</code>的ER模型，再把ER模型转换成具体的数据表的过程，完成利用ER模型设计电商项目数据库的工作。</p><p>其实，任何一个基于数据库的应用项目，都可以通过这种<code>先建立ER 模型</code> ，再<code>转换成数据表</code>的方式，完成数据库的设计工作。创建ER模型不是目的，目的是把业务逻辑梳理清楚，设计出优秀的数据库。不是为了建模而建模，要利用创建ER模型的过程来整理思路，这样创建ER模型才有意义。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212230135855.png" alt="image-20221223002758954"></p><h2 id="9-数据表的设计原则"><a href="#9-数据表的设计原则" class="headerlink" title="9. 数据表的设计原则"></a>9. 数据表的设计原则</h2><p>综合以上内容，总结出数据表设计的一般原则：“三少一多”</p><p><font color=orange>1、数据表的个数越少越好 </font></p><p>RDBMS的核心在于对实体和联系的定义，也就是E-R图(Entity Relationship Diagram)，数据表越少，证明实体和联系设计得越简洁，既方便理解又方便操作。</p><p><font color=orange>2、数据表中的字段个数越少越好</font></p><p>字段个数越多，数据冗余的可能性越大。设置字段个数少的前提是各个字段相互独立，而不是某个字段的取值可以由其他字段计算出来。当然字段个数少是相对的，通常会在<code>数据冗余</code>和<code>检索效率</code>中进行平衡。</p><p><font color=orange>3、数据表中联合主键的字段个数越少越好</font></p><p>设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式(也就是用多个字段来定义一个主健)。<strong>联合主键中的字段越多，占用的索列空间越大</strong>，不仅会加大理解难度，还会增加运行时间和索引空间，因此联合主键的字段个数越少越好。</p><p><font color=orange>4、使用主键和外键越多越好</font></p><p>数据库的设计实际上就是定义各种表，以及各种字段之间的关系。这些关系越多，证明这些实体之间的冗余度越低，<code>利用度越高</code>。这样做的好处在于不仅保证了数据表之间的<code>独立性</code>，还能提升相互之间的关联使用率。</p><p>&#x3D;&#x3D;这里的外键指业务上实现外键，也就是逻辑外键。不一定使用外键约束实现。&#x3D;&#x3D;</p><p>“三少一多”原则的核心就是<code>简单可复用</code>。简单指的是用更少的表、更少的字段、更少的联合主键字段来完成数据表的设计。可复用则是通过主键、外键的使用来增强数据表之间的复用率。因为一个主键可以理解是一张表的代表。键设计得越多，证明它们之间的利用率越高。</p><blockquote><p>注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。</p></blockquote><h2 id="10-数据库对象编写建议"><a href="#10-数据库对象编写建议" class="headerlink" title="10. 数据库对象编写建议"></a>10. 数据库对象编写建议</h2><p>前面讲了数据库的设计规范，下面给出的这些规范适用于大多数公司，按照下面的规范来使用数据库，这样数据库可以发挥出更高的性能</p><h3 id="10-1-关于库"><a href="#10-1-关于库" class="headerlink" title="10.1 关于库"></a>10.1 关于库</h3><ol><li>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。</li><li>【强制】库名中英文<code>一律小写</code>，不同单词采用<code>下划线</code>分割。须见名知意。</li><li>【强制】库的名称格式：业务系统名称_子系统名。</li><li>【强制】库名禁止使用关键字（如type,order等）。</li><li>【强制】创建数据库时必须<code>显式指定字符集</code>，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：CREATE DATABASE crm_fund <code>DEFAULT CHARACTER SET &#39;utf8&#39;</code>; </li><li>【建议】对于程序连接数据库账号，遵循<code>权限最小原则</code>。使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号<code>原则上不准有drop权限</code>。 </li><li>【建议】临时库以<code>tmp_</code>为前缀，并以日期为后缀；备份库以<code>bak_</code>为前缀，并以日期为后缀。</li></ol><h3 id="10-2-关于表、列"><a href="#10-2-关于表、列" class="headerlink" title="10.2 关于表、列"></a>10.2 关于表、列</h3><ol><li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以<code>英文字母开头</code>。 </p></li><li><p>【强制】 <code>表名、列名一律小写</code>，不同单词采用下划线分割。须见名知意。</p></li><li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用<code>统一前缀</code>。比如：crm_fund_item </p></li><li><p>【强制】创建表时必须<code>显式指定字符集</code>为utf8或utf8mb4。 </p></li><li><p>【强制】表名、列名禁止使用关键字（如type,order等）。</p></li><li><p>【强制】创建表时必须<code>显式指定表存储引擎</code>类型。如无特殊需求，一律为InnoDB。 </p></li><li><p>【强制】建表必须有comment。 </p></li><li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或<code>缩写</code>。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。</p></li><li><p>【强制】布尔值类型的字段命名为<code>is_描述</code>。如member表上表示是否为enabled的会员的字段命名为 is_enabled。 </p></li><li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据。通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器(如FastDFS)，数据库只存储文件地址信息。</p></li><li><p>【建议】建表时关于主键：<code>表必须有主键 </code></p><p>(1)强制要求主键为id，类型为int或bigint，且为auto_increment 建议使用unsigned无符号型。 (2)&#x3D;&#x3D;标识表里每一行主体的字段不要设为主键&#x3D;&#x3D;，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部页分裂和大量随机I&#x2F;O，性能下降。</p></li><li><p>【建议】核心表（如用户表）必须有行数据的<code>创建时间字段</code>（create_time）和<code>最后更新时间字段</code>（update_time），便于查问题。</p></li><li><p>【建议】&#x3D;&#x3D;表中所有字段尽量都是<code>NOT NULL</code>属性，业务可以根据需要定义<code>DEFAULT值</code>&#x3D;&#x3D;。 因为使用NULL值会存在<code>每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差、业务代码容易出现空指针</code>等问题。</p></li><li><p>【建议】所有存储相同数据的<code>列名和列类型必须一致</code>（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的<code>索引失效</code>，导致查询效率降低）。</p></li><li><p>【建议】中间表（或临时表）用于保留中间结果集，名称以<code>tmp_</code>开头。备份表用于备份或抓取源表快照，名称以<code>bak_</code>开头。中间表和备份表定期清理。</p></li><li><p>【示范】一个较为规范的建表语句：</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_info (</span><br><span class="line">  `id` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;自增主键&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;真实姓名&#x27;</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户邮箱&#x27;</span>,</span><br><span class="line">  `nickname` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">  `birthday` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;生日&#x27;</span>,</span><br><span class="line">  `sex` tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">  `short_introduce` <span class="type">varchar</span>(<span class="number">150</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;一句话介绍自己，最多50个汉字&#x27;</span>,</span><br><span class="line">  `user_resume` <span class="type">varchar</span>(<span class="number">300</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户提交的简历存放地址&#x27;</span>,</span><br><span class="line">  `user_register_ip` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户注册时的源ip&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `user_review_status` tinyint <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户资料审核状态，1为通过，2为审核中，3为未通过，4为还未提交审核&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uniq_user_id` (`user_id`),</span><br><span class="line">  KEY `idx_username`(`username`),</span><br><span class="line">  KEY `idx_create_time_status`(`create_time`,`user_review_status`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;网站用户基本信息&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="17"><li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</li></ol><h3 id="10-3-关于索引"><a href="#10-3-关于索引" class="headerlink" title="10.3 关于索引"></a>10.3 关于索引</h3><ol><li><p>【强制】InnoDB表必须主键为id int&#x2F;bigint auto_increment，且主键值<code>禁止被更新</code>。 </p></li><li><p>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为<code>BTREE</code> (此处是官方写法，代表的其实就是B+树)</p></li><li><p>【建议】主键的名称以<code>pk_</code>开头，唯一键以<code>uni_</code>或<code>uk_</code>开头，普通索引以<code>idx_</code>开头，一律使用小写格式，以字段的名称或缩写作为后缀。</p></li><li><p>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：<code>idx_sample_mid</code>。 </p></li><li><p>【建议】单个表上的索引个数<code>不能超过6个</code>。 </p></li><li><p>【建议】在建立索引时，多考虑建立<code>联合索引</code>，并把区分度最高的字段放在最前面。</p></li><li><p>【建议】在多表 JOIN 的SQL里，<code>保证被驱动表的连接列上有索引</code>，这样JOIN 执行效率最高。</p></li><li><p>【建议】建表或加索引时，保证表里互相不存在<code>冗余索引</code>。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</p></li></ol><h3 id="10-4-SQL编写"><a href="#10-4-SQL编写" class="headerlink" title="10.4 SQL编写"></a>10.4 SQL编写</h3><ol><li><p>【强制】程序端SELECT语句必须指定具体字段名称，<code>禁止写成 *</code>。 </p></li><li><p>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。 </p></li><li><p>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</p></li><li><p>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从<code>同步延迟</code>。</p></li><li><p>【建议】SELECT语句不要使用UNION，<code>推荐使用UNION ALL</code>，并且UNION子句个数限制在5个以内。</p></li><li><p>【建议】线上环境，多表 JOIN 不要超过5个表。</p></li><li><p>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p></li><li><p>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p></li><li><p>【建议】对单表的多次alter操作必须合并为一次。对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 &#x3D;&#x3D;因为alter table会产生<code>表锁</code>，期间阻塞对于该表的所有写入&#x3D;&#x3D;，对于业务可能会产生极大影响。</p></li><li><p>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。 </p></li><li><p>【建议】事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</p></li><li><p>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id&#x3D;XX;否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</p></li></ol><h2 id="11-PowerDesigner的使用"><a href="#11-PowerDesigner的使用" class="headerlink" title="11. PowerDesigner的使用"></a>11. PowerDesigner的使用</h2><p>PowerDesigner是一款开发人员常用的数据库建模工具，用户利用该软件可以方便地制作 <code>数据流程图 、概念数据模型 、 物理数据模型</code> ，它几乎包括了数据库模型设计的全过程，是Sybase公司为企业建模和设计提供的一套完整的集成化企业级建模解决方案</p><p><strong>安装：</strong><a href="https://www.cnblogs.com/luyj00436/p/16932603.html">https://www.cnblogs.com/luyj00436/p/16932603.html</a></p><h3 id="11-1-开始界面"><a href="#11-1-开始界面" class="headerlink" title="11.1 开始界面"></a>11.1 开始界面</h3><p>当前使用的PowerDesigner版本是16.5的。打开软件即是此页面，可选择Create Model,也可以选择Do Not Show page Again,自行在打开软件后创建也可以！完全看个人的喜好，在后面的学习中不在显示此页面。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242252532.png" alt="image-20221224154632222"></p><p>接下来我们开始为数据库建模</p><ul><li><code>Create Model</code>的作用类似于普通的一个文件，该文件可以单独存放也可以归类存放。</li><li><code>Create Project</code>的作用类似于文件夹，负责把有关联关系的文件集中归类存放。</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242254818.png" alt="image-20221224154752872"></p><h3 id="11-2-概念数据模型"><a href="#11-2-概念数据模型" class="headerlink" title="11.2 概念数据模型"></a>11.2 概念数据模型</h3><p>常用的模型有4种，分别是 <code>概念模型</code>(CDM Conceptual Data Model) ， <code>物理模型</code>（PDM,Physical Data Model） ， <code>面向对象的模型</code>（OOM Objcet Oriented Model） 和<code> 业务模型</code>（BPM Business Process Model） 。<br><font color=orange>1、我们先创建概念数据模型</font></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242252200.png" alt="image-20221224155815431"></p><p>点击上面的ok，即可出现下图左边的概念模型1，可以自定义概念模型的名字，在概念模型中使用最多的就是如图所示的Entity(实体),Relationship(关系)</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253052.png" alt="image-20221224160046422"></p><p><font color=orange>2、选中右边框中Entity这个功能，创建一个实体。双击实体，即可出现下面这个方框。</font>需要注意的是书写name的时候，code自行补全，name可以是英文的也可以是中文的，但是code必须是英文的。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253855.png" alt="image-20221224161617975"></p><p><font color=orange>3、填充实体字段</font></p><p>General中的name和code填好后，就可以点击Attributes（属性）来设置name（名字），code(在数据库中的字段名)，Data Type(数据类型) ，length(数据类型的长度)</p><p>Name: 实体名字一般为中文，如论坛用户</p><p>Code: 实体代号，一般用英文，如XXXUser</p><p>Comment:注释，对此实体详细说明</p><p>Code属性：代号，一般用英文UID DataType</p><p>Domain域，表示属性取值范围如可以创建10个字符的地址域</p><p>M:Mandatory强制属性，表示该属性必填。不能为空</p><p>P:Primary Identifer是否是主标识符，表示实体唯一标识符</p><p>D:Displayed显示出来，默认全部勾选</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253086.png" alt="image-20221224161925349"></p><blockquote><p>Data Type可以使用点击下拉框或…的方式设置，字符串类型必须设置长度</p><p>Ctrl+D删除行或者点击 ×</p></blockquote><p><font color=orange>4、设置主标识符</font></p><p>如果不希望系统自动生成标识符而是手动设置的话，那么切换到Identifiers选项卡，添加一行Identifier，然后单击左上角的“属性”按钮，然后弹出的标识属性设置对话框中单击“添加行”按钮，选择该标识中使用的属性。例如将学号设置为学生实体的标识。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253330.png" alt="image-20221224162751124"></p><p><font color=orange>5、放大模型</font><br>创建好概念数据模型如图所示，但是创建好的字体很小，读者可以<code>按着ctrl键</code>同时滑动鼠标的可滑动按钮即可放大缩写字体，同时也可以看到主标识符有一个*号的标志，同时也显示出来了，name,Data type和length这些可见的属性</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253032.png" alt="image-20221224163015595"></p><p><font color=orange>6、实体关系</font><br>同理创建一个班级的实体（需要特别注意的是，点击完右边功能的按钮后需要点击鼠标指针状态的按钮或者右击鼠标即可，不然很容易乱操作，这点注意一下就可以了），然后使用<code>Relationship</code>（关系）这个按钮可以连接学生和班级之间的关系，建立一对多（班级对学生）或者多对一（学生对班级）的关系。<br><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253581.png" alt="image-20221224164046117"></p><p>需要注意的是点击Relationship这个按钮，就把班级和学生联系起来了，就是一条线，然后双击这条线进行编辑，在General这块起name和code</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253040.png" alt="image-20221224164247336"></p><p>面的name和code起好后就可以在Cardinalities这块查看班级和学生的关系，可以看到班级的一端是一条线，学生的一端是三条，代表班级对学生是一对多的关系即one对many的关系，点击应用，然后确定即可</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242254040.png" alt="image-20221224164331213"></p><p>一对多和多对一练习完还有多对多的练习，如下图操作所示，老师实体和上面介绍的一样，自己将name，data type等等修改成自己需要的即可，满足项目开发需求即可。（comment是解释说明，自己可以写相关的介绍和说明）</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253288.png" alt="image-20221224165228805"></p><p>多对多需要注意的是自己可以手动点击按钮将关系调整称为多对多的关系many对many的关系，然后点击应用和确定即可</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253487.png" alt="image-20221224165320074"></p><p>综上即可完成最简单的学生，班级，教师这种概念数据模型的设计，需要考虑数据的类型和主标识码，是否为空。关系是一对一还是一对多还是多对多的关系，自己需要先规划好再设计，然后就ok了。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253318.png" alt="image-20221224165416016"></p><p>最后<code>CTRL+S</code>保存为 <code>学生管理系统-1.cdm</code> </p><h3 id="11-3-物理数据模型"><a href="#11-3-物理数据模型" class="headerlink" title="11.3 物理数据模型"></a>11.3 物理数据模型</h3><p>上面是概念数据模型，下面介绍一下物理数据模型，以后 经常使用 的就是物理数据模型。打开PowerDesigner，然后点击File–&gt;New Model然后选择如下图所示的物理数据模型，物理数据模型的名字自己起，然后选择自己所使用的数据库即可。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253567.png" alt="image-20221224165757702"></p><p>创建好主页面如图所示，但是右边的按钮和概念模型略有差别，物理模型最常用的三个是<br><code>table(表) </code>， <code>view(视图) </code>， <code>reference(关系) </code>；</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242255487.png" alt="image-20221224174102692"></p><p>鼠标先点击右边table这个按钮然后在新建的物理模型点一下，即可新建一个表，然后双击新建如下图所示，在General的name和code填上自己需要的，点击应用即可），如下图：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253656.png" alt="image-20221224174149099"></p><p>然后点击Columns,如下图设置，非常简单，需要注意的就是P（primary主键） , F （foreign key外键） ,M（mandatory强制性的，代表不可为空） 这三个</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242255151.png" alt="image-20221224174330650"></p><p>在此设置学号的自增（MYSQL里面的自增是这个AUTO_INCREMENT），班级编号同理，不多赘述！</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253007.png" alt="image-20221224174611941"></p><p>在下面的这个点上对号即可，就设置好了自增</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242255742.png" alt="image-20221224174834132"></p><p>全部完成后如下图所示。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253631.png"></p><p>班级物理模型同理如下图所示创建即可</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253295.png" alt="image-20221224175133038"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212300124344.png" alt="image-20221224175204900"></p><p>完成后如下图所示</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253663.png"></p><p>上面的设置好如上图所示，然后下面是关键的地方，点击右边按钮Reference这个按钮，因为是班级对学生是一对多的，所以鼠标从学生拉到班级如下图所示，学生表将发生变化，学生表里面增加了一行，这行是班级表的主键作为学生表的外键，将班级表和学生表联系起来。（仔细观察即可看到区别。）</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253704.png"></p><p>做完上面的操作，就可以双击中间的一条线，显示如下图，修改name和code即可</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253934.png" alt="image-20221224180647469"></p><p>注意：可以在Integrity中为显示的关系起名字。默认是<code>FK+Code</code> ，比如：<code>FK_student_class_r</code></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253368.png" alt="image-20221224181202233"></p><p>学习了多对一或者一对多的关系，接下来学习多对对的关系，同理自己建好老师表，这里不在叙述，记得老师编号自增，建好如下图所示</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242255839.png"></p><p>下面是多对多关系的关键，由于物理模型多对多的关系需要一个中间表来连接，如下图，只设置一个字段，主键，自增</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253879.png" alt="image-20221224181753560"></p><p>点击应用，然后设置Columns，只添加一个字段</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242255478.png" alt="image-20221224181844319"></p><p>这是设置字段递增，前面已经叙述过好几次</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253456.png" alt="image-20221224182223863"></p><p>设置好后如下图所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242253934.png" alt="image-20221224182411930"></p><p>需要搞清楚，学生也可以有很多老师，老师也可以有很多学生，所以学生和老师都可以是主体；然后我们开始添加学生和教师的关系*~*</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242254975.png" alt="image-20221224182834083"></p><blockquote><p>思考一个问题：为什么N：N，需要建立中间表呢，有什么好处呢？</p></blockquote><h3 id="11-4-概念模型转为物理模型"><a href="#11-4-概念模型转为物理模型" class="headerlink" title="11.4 概念模型转为物理模型"></a>11.4 概念模型转为物理模型</h3><p>如下图所示先打开概念模型图，然后点击Tool,如下图所示</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242254127.png" alt="image-20221224221907744"></p><p>点开的页面如下所示，name和code已经从概念模型1改成物理模型1了</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242254256.png" alt="image-20221224221944635"></p><p>完成后如下图所示，将自行打开修改的物理模型，需要注意的是这些表的数据类型已经自行改变了，而且中间表出现两个主键，即双主键</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242254983.png" alt="image-20221224222505024"></p><h3 id="11-5-物理模型转为概念模型"><a href="#11-5-物理模型转为概念模型" class="headerlink" title="11.5 物理模型转为概念模型"></a>11.5 物理模型转为概念模型</h3><p>上面介绍了概念模型转物理模型，下面介绍一下物理模型转概念模型（如下图点击操作即可）</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242254438.png" alt="image-20221224222606851"></p><p>然后出现如下图所示界面，然后将物理修改为概念 ，点击应用确认即可</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242255254.png" alt="image-20221224222729059"></p><p>点击确认后将自行打开如下图所示的页面，自己观察有何变化，如果转换为oracle的，数据类型会发生变化，比如Varchar2等等）；</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242254414.png" alt="image-20221224222806888"></p><h3 id="11-6-物理模型导出SQL语句"><a href="#11-6-物理模型导出SQL语句" class="headerlink" title="11.6 物理模型导出SQL语句"></a>11.6 物理模型导出SQL语句</h3><p>下面介绍一下物理模型导出SQL语句（点击Database按钮的Generate Database或者按ctrl+G）</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242254638.png" alt="image-20221224223447802"></p><p>打开之后如图所示，修改好存在sql语句的位置和生成文件的名称即可</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242254640.png" alt="image-20221224223545246"></p><p>在Selection中选择需要导出的表，然后点击应用和确认即可</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242254591.png" alt="image-20221224223617401"></p><p>完成以后出现如下图所示，可以点击Edit或者close按钮</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242254982.png" alt="image-20221224223643530"></p><p>查看保存的sql文件：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202212242254912.png" alt="image-20221224223752525"></p><p>至此，就完成了导出sql语句，就可以到自己指定的位置查看导出的sql语句了；PowerDesigner在以后在项目开发过程中用来做需求分析和数据库的设计非常的方便和快捷~</p><blockquote><p>关于PowerDesigner导出SQL，字段没有注释，解决办法：<a href="https://blog.csdn.net/weixin_42732880/article/details/125869158">https://blog.csdn.net/weixin_42732880/article/details/125869158</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八、索引优化与查询优化</title>
      <link href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC08%E7%AB%A0_%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC08%E7%AB%A0_%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>都有哪些纬度可以进行数据库调优？简言之：</p><ul><li>索引失效、没有充分利用所以——<strong>索引建立</strong></li><li>关联查询太多 JOIN（设计缺陷或不得已的需求）——<strong>SQL 优化</strong></li><li>服务器调优及各个参数设置（缓冲、 线程数）——<strong>调整 my.cnf</strong></li><li>数据过多——<strong>分库分表</strong></li></ul><p>关于数据库调优的知识点非常分散，不同 DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。</p><p>虽然 SQL 查询优化的技术很多，但是大体方向上完全可以分为 <code>物理查询优化</code> 和 <code>逻辑查询优化</code> 两大块。</p><ul><li>物理查询优化是通过 <code>索引</code> 和 <code>表连接方式</code> 等技术来进行优化，这里重点需要掌握索引的使用</li><li>逻辑查询优化就是通过 SQL <code>等价变换</code> 提升查询效率，直白一点来讲就是，换一种执行效率更高的查询写法</li></ul><h2 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1. 数据准备"></a>1. 数据准备</h2><p>学员表插50万条， 班级表插1万条。</p><p><strong><font color=blue>步骤1：建表</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#班级表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `class` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`className` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`address` <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`monitor` <span class="type">INT</span> <span class="keyword">NULL</span> ,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line">#学员表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`stuno` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`age` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`classId` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">#<span class="keyword">CONSTRAINT</span> `fk_class_id` <span class="keyword">FOREIGN</span> KEY (`classId`) <span class="keyword">REFERENCES</span> `t_class` (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p><strong><font color=blue>步骤2：设置参数</font></strong></p><p>命令开启：允许创建函数设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;   </span><br><span class="line"># 不加<span class="keyword">global</span>只是当前窗口有效。</span><br></pre></td></tr></table></figure><p><strong><font color=blue>步骤3：创建函数</font></strong></p><p>随机产生字符串，保证每条数据都不同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#随机产生字符串</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">WHILE i <span class="operator">&lt;</span> n DO </span><br><span class="line"><span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>)); </span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#假如要删除</span><br><span class="line">#<span class="keyword">drop</span> <span class="keyword">function</span> rand_string;</span><br></pre></td></tr></table></figure><p>随机产生班级编号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#用于随机产生多少到多少的编号</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num (from_num <span class="type">INT</span> ,to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span>RAND()<span class="operator">*</span>(to_num <span class="operator">-</span> from_num<span class="operator">+</span><span class="number">1</span>))  ;</span><br><span class="line"><span class="keyword">RETURN</span> i; </span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#假如要删除</span><br><span class="line">#<span class="keyword">drop</span> <span class="keyword">function</span> rand_num;</span><br></pre></td></tr></table></figure><p><strong><font color=blue>步骤4：创建存储过程</font></strong></p><p>创建往stu表中插入数据的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#创建往stu表中插入数据的存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu(  <span class="keyword">START</span> <span class="type">INT</span> , max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;   #设置手动提交事务</span><br><span class="line">REPEAT  #循环</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;  #赋值</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (stuno, name ,age ,classId ) <span class="keyword">VALUES</span></span><br><span class="line">((<span class="keyword">START</span><span class="operator">+</span>i),rand_string(<span class="number">6</span>),rand_num(<span class="number">1</span>,<span class="number">50</span>),rand_num(<span class="number">1</span>,<span class="number">1000</span>)); </span><br><span class="line">UNTIL i <span class="operator">=</span> max_num </span><br><span class="line"><span class="keyword">END</span> REPEAT; </span><br><span class="line"><span class="keyword">COMMIT</span>;  #提交事务</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#假如要删除</span><br><span class="line">#<span class="keyword">drop</span> <span class="keyword">PROCEDURE</span> insert_stu;</span><br></pre></td></tr></table></figure><p>创建往class表中插入数据的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往class表添加随机数据</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `insert_class`( max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">REPEAT </span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class ( classname,address,monitor ) <span class="keyword">VALUES</span></span><br><span class="line">(rand_string(<span class="number">8</span>),rand_string(<span class="number">10</span>),rand_num(<span class="number">1</span>,<span class="number">100000</span>)); </span><br><span class="line">UNTIL i <span class="operator">=</span> max_num </span><br><span class="line"><span class="keyword">END</span> REPEAT; </span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#假如要删除</span><br><span class="line">#<span class="keyword">drop</span> <span class="keyword">PROCEDURE</span> insert_class;</span><br></pre></td></tr></table></figure><p><strong><font color=blue>步骤5：调用存储过程</font></strong></p><p>往class表添加1万条数据 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往class表添加<span class="number">1</span>万条数据 </span><br><span class="line"><span class="keyword">CALL</span> insert_class(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><p>往stu表添加50万条数据,这个时间会稍微有点长，请耐心等待哟~</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往stu表添加<span class="number">80</span>万条数据 </span><br><span class="line"><span class="keyword">CALL</span> insert_stu(<span class="number">100000</span>,<span class="number">800000</span>);</span><br></pre></td></tr></table></figure><p>查询下数据是否插入成功</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> class;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><p><strong><font color=blue>步骤6：删除某表上的索引</font></strong></p><p>创建删除索引存储过程。这是为了方便我们的学习，因为我们在演示某个索引的效果时，可能需要删除其它索引，如果需要一个个手工删除，就太费劲了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">PROCEDURE</span> `proc_drop_index`(dbname <span class="type">VARCHAR</span>(<span class="number">200</span>),tablename <span class="type">VARCHAR</span>(<span class="number">200</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">DECLARE</span> ct <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">DECLARE</span> _index <span class="type">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">   <span class="keyword">DECLARE</span> _cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span>  <span class="keyword">SELECT</span>  index_name  <span class="keyword">FROM</span></span><br><span class="line">information_schema.STATISTICS  <span class="keyword">WHERE</span> table_schema<span class="operator">=</span>dbname <span class="keyword">AND</span> table_name<span class="operator">=</span>tablename <span class="keyword">AND</span></span><br><span class="line">seq_in_index<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span>  index_name <span class="operator">&lt;&gt;</span><span class="string">&#x27;PRIMARY&#x27;</span> ;</span><br><span class="line">#每个游标必须使用不同的<span class="keyword">declare</span> continue handler <span class="keyword">for</span> <span class="keyword">not</span> found <span class="keyword">set</span> done<span class="operator">=</span><span class="number">1</span>来控制游标的结束</span><br><span class="line">   <span class="keyword">DECLARE</span>  CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">set</span> done<span class="operator">=</span><span class="number">2</span> ;   </span><br><span class="line">#若没有数据返回,程序继续,并将变量done设为<span class="number">2</span></span><br><span class="line">    <span class="keyword">OPEN</span> _cur;</span><br><span class="line">    <span class="keyword">FETCH</span> _cur <span class="keyword">INTO</span> _index;</span><br><span class="line">    WHILE _index<span class="operator">&lt;&gt;</span><span class="string">&#x27;&#x27;</span> DO</span><br><span class="line">       <span class="keyword">SET</span> <span class="variable">@str</span> <span class="operator">=</span> CONCAT(&quot;drop index &quot; , _index , &quot; on &quot; , tablename );</span><br><span class="line">       <span class="keyword">PREPARE</span> sql_str <span class="keyword">FROM</span> <span class="variable">@str</span> ;</span><br><span class="line">       <span class="keyword">EXECUTE</span> sql_str;</span><br><span class="line">       <span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> sql_str;</span><br><span class="line">       <span class="keyword">SET</span> _index<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;</span><br><span class="line">       <span class="keyword">FETCH</span> _cur <span class="keyword">INTO</span> _index;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line"> <span class="keyword">CLOSE</span> _cur;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>执行存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> proc_drop_index(&quot;dbname&quot;,&quot;tablename&quot;);</span><br></pre></td></tr></table></figure><h2 id="2-索引失效案例"><a href="#2-索引失效案例" class="headerlink" title="2. 索引失效案例"></a>2. 索引失效案例</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301613943.png" alt="image-20220816104223377"></p><h3 id="2-1-全值匹配我最爱"><a href="#2-1-全值匹配我最爱" class="headerlink" title="2.1 全值匹配我最爱"></a>2.1 全值匹配我最爱</h3><p><strong><font color=red>全值匹配可以充分的利用组合索引~</font></strong> </p><p>系统中经常出现的sql语句如下，当没有建立索引时，<code>possible_keys</code>和<code>key</code>都为NULL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># SQL_NO_CACHE表示不使用查询缓存。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">30</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> classId<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> classId<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> NAME <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p>此时执行SQL，数据查询速度会比较慢，耗时0.12s</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> classId<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> NAME <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.12</span> sec)</span><br></pre></td></tr></table></figure><p>接下来我们建立索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> student(age);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid <span class="keyword">ON</span> student(age,classId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student(age,classId,NAME);</span><br></pre></td></tr></table></figure><blockquote><p>💌Q &#x3D;&#x3D;上面三个索引有什么区别，为什么这么建立索引？&#x3D;&#x3D;<br>上面建立索引是与三条sql的使用场景对应的，遵守了全值匹配的规则，就是说建立几个复合索引字段，最好就用上几个字段。且按照顺序来用。</p></blockquote><p>建立索引后执行，发现使用到了联合索引，且耗时较短 0.00s</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> classId<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> NAME <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------------------------------+----------------------+---------+-------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys                                <span class="operator">|</span> key                  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>               <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------------------------------+----------------------+---------+-------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_age,idx_age_classid,idx_age_classid_name <span class="operator">|</span> idx_age_classid_name <span class="operator">|</span> <span class="number">73</span>      <span class="operator">|</span> const,const,const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------------------------------+----------------------+---------+-------------------+------+----------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">2</span> warnings (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> classId<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> NAME <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>上面的索引可能不生效哦，在数据量较大的情况下，我们进行全值匹配<code>SELECT *</code>，优化器可能经过计算发现，我们使用索引查询所有的数据后，还需要对查找到的数据进行回表操作，性能还不如全表扫描。这里我们没有造这么多数据，所以就不演示效果咯。</p><h3 id="2-2-最左匹配原则"><a href="#2-2-最左匹配原则" class="headerlink" title="2.2 最左匹配原则"></a>2.2 最左匹配原则</h3><p>在 MySQL 建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><p><strong><font color=blue>1. 下面的SQL将使用索引idx_age</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.name<span class="operator">=</span><span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong><font color=blue>2. 下面的sql不会使用索引，因为我没有创建classId或者name的索引</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> student.name<span class="operator">=</span><span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Q:为什么不会使用idx_age_classid索引？<br>索引idx_age_classid的B+树会先使用age排序，在使用classId给age相同的数据排序，这个索引根本用不上哟。这就是下面的最左前缀原则。</p></blockquote><p><strong><font color=blue>3.下面的sql查询就是遵守这一原则的正确打开方式</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> student.classId<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> student.name<span class="operator">=</span><span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong><font color=blue>4. 思考：下面sql会不会使用索引呢？</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> student.age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> student.name<span class="operator">=</span><span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p>答案是会！因为优化器会执行优化的哦，会调整查询条件的顺序。不过在开发过程中我们还是要保持良好的开发习惯哟。</p><p><strong><font color=blue>5. 思考：删去索引<code>idx_age_classid</code>和<code>idx_age</code>,只保留<code>idx_age_classid_name</code>，执行如下sql，会不会使用索引？</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span>  student.age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> student.name<span class="operator">=</span><span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p>答案是会，但是只会用一部分。看看执行结果</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301613171.png" alt="image-20220824161042002"></p><p>使用了idx_age_classid_name，但是key_len是5，也就是说只使用了age部分的排序，因为age是int类型，4个字节加上null值列表一共5个字节哦。想想就知道，B+树是先按照age排序，再按照classid排序，最后按照name排序，因此不能跳过classId的排序直接就使用name的排序哦。</p><p>结论：MySQL 可以为多个字段创建索引，一个索引可以包括 16 个字段，对于多列字段，**<font color=red>过滤条件要使用索引那必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法使用</font>**。如果查询条件中没有使用这些字段中的第一个字段时，多列索引不会被使用。</p><blockquote><p><strong>拓展:Alibaba《Java开发手册》</strong></p><p>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p></blockquote><h3 id="2-3-主键插入顺序"><a href="#2-3-主键插入顺序" class="headerlink" title="2.3 主键插入顺序"></a>2.3 主键插入顺序</h3><p>对于一个使用 InnoDB 存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在 <code>聚簇索引</code> 的叶子节点的。而记录又是存储在数据页中，数据页和记录又是按照 <code>记录主键值从小到大</code> 的顺序进行排序，所以如果我们 <code>插入</code> 的记录的 <code>主键是依次增大</code> 的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的 <code>主键值忽大忽小</code> 的话，就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在 1~100 之间：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301613083.png" alt="image-20220824161409652"></p><p>如果此时再插入一条主键值为 <code>9</code> 的记录，那它插入的位置就如下图:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301613098.png" alt="image-20220824161420173"></p><p>可这个数据页已经满了，再插进来咋办呢?我们需要把当前 <code>页面分裂</code> 成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着：<code>性能损耗</code>！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的 <code>主键值依次递增</code> ，这样就不会发生这样的性能损耗了。 所以我们建议：让主键具有 <code>AUTO_INCREMENT</code> ，让存储引擎自己为表生成主键，而不是我们手动插入，比如<code>person_info</code>表：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301613122.png" alt="image-20220824161706495"></p><p>我们自定义的主键列 <code>id</code> 拥有 <code>AUTO_INCREMENT</code> 属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。</p><blockquote><p>🎀Tips：<br>我们一般将主键策略设置为自动递增<code>AUTO_INCREMENT</code>哦！(核心业务表除外，后面会介绍这种情况)</p></blockquote><h3 id="2-4-计算、函数、类型转换（自动或手动）导致索引失效"><a href="#2-4-计算、函数、类型转换（自动或手动）导致索引失效" class="headerlink" title="2.4 计算、函数、类型转换（自动或手动）导致索引失效"></a>2.4 计算、函数、类型转换（自动或手动）导致索引失效</h3><p><strong><font color=blue>举例1：当使用函数时</font></strong></p><ol><li>这两条 sql 哪种写法更好？</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 此语句比下一条要好！（能够使用上索引）</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>; </span><br></pre></td></tr></table></figure><ol start="2"><li>创建索引</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> student(NAME); </span><br></pre></td></tr></table></figure><ol start="3"><li>第一种：索引优化生效</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_name      <span class="operator">|</span> idx_name <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+--------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> id      <span class="operator">|</span> stuno  <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> classId <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+--------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4290221</span> <span class="operator">|</span> <span class="number">247516</span> <span class="operator">|</span> aBCiho <span class="operator">|</span>   <span class="number">48</span> <span class="operator">|</span>     <span class="number">936</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ......  <span class="operator">|</span>          ........ <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4243832</span> <span class="operator">|</span> <span class="number">201127</span> <span class="operator">|</span> ABcIkb <span class="operator">|</span>   <span class="number">26</span> <span class="operator">|</span>     <span class="number">483</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+--------+--------+------+---------+</span></span><br><span class="line"><span class="number">22</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="4"><li>第二种：索引优化失效</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499907</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">2</span> warnings (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p>type 为“ALL”，表示没有使用到索引，查询时间为 0.21 秒，查询效率较之前低很多</p><p><strong><font color=blue>举例2：当条件有计算时</font></strong></p><ol><li>student表的字段stuno上设置有索引</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_sno <span class="keyword">ON</span> student(stuno);</span><br></pre></td></tr></table></figure><ol start="2"><li>索引优化失效</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE id, stuno, NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno<span class="operator">+</span><span class="number">1</span> <span class="operator">=</span> <span class="number">900001</span>; </span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301613370.png" alt="image-20220824165532304"></p><p>可以看到如果对索引进行了表达式计算，索引就失效了。这是因为我们需要把索引字段的值都取出来，然后一次进行表达式的计算来进行条件判断，因此采用的就是<code>全表扫描</code> 的方式，运行时间也会慢很多。</p><ol start="3"><li>去掉上面SQL的计算，索引优化生效：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE id, stuno, NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno <span class="operator">=</span> <span class="number">900000</span>; </span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301614089.png" alt="image-20220824165631933"></p><p> <strong><font color=blue>举例3：类型转换导致索引失效</font></strong></p><p>下列哪个SQL语句可以用到索引（假设name字段上设置有索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="number">123</span>;</span><br><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>name = 123</code> 发生类型转换，相当于使用了隐形 函数，索引失效</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301614546.png" alt="image-20220824170121497"></p><blockquote><p>结论：设计实体类属性时，一定要与数据库字段类型相对应。否则，就会出现类型转换的情况</p></blockquote><h3 id="2-5-范围条件右边的列索引失效"><a href="#2-5-范围条件右边的列索引失效" class="headerlink" title="2.5 范围条件右边的列索引失效"></a>2.5 范围条件右边的列索引失效</h3><p>环境准备：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除student表上的所有索引</span><br><span class="line"><span class="keyword">CALL</span> proc_drop_index(<span class="string">&#x27;atguigudb2&#x27;</span>,<span class="string">&#x27;student&#x27;</span>);</span><br><span class="line"># 创建age、classId、NAME的联合索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classId_name <span class="keyword">ON</span> student(age,classId,NAME);</span><br></pre></td></tr></table></figure><p><strong><font color=blue>1. 如果系统经常出现的sql如下，那么索引 idx_age_classId_name 这个索引还能正常使用么？</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student </span><br><span class="line"><span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.classId<span class="operator">&gt;</span><span class="number">20</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> ;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301614793.png" alt="image-20220824174623086"></p><p>不能，&#x3D;&#x3D;范围右边的列不能使用&#x3D;&#x3D;。比如 &lt;、&lt;&#x3D;、&gt;、&gt;&#x3D; 和 between 等</p><p>有同学会好奇，我改变下<code>WHERE</code>后面字段的顺序呢，是否可以使用呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student </span><br><span class="line"><span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.name <span class="operator">=</span><span class="string">&#x27;abc&#x27;</span> <span class="keyword">AND</span> student.classId<span class="operator">&gt;</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>答案也是不能<del>，因为 &#x3D;&#x3D;优化器会自动帮你满足最左前缀原则&#x3D;&#x3D; ，即优化器会 先根据联合索引进行排序 ，联合索引的顺序才能决定</del></p><blockquote><p><strong>解释一下为什么范围查询会导致索引失效：</strong><br>因为根据范围查找筛选后的数据，无法保证范围查找后面的字段是有序的。</p><p>例如：a_b_c这个索引，你根据b范围查找&gt;2的，在满足b&gt;2的情况下，如b：3,4，c可能是5,3、因为c无序，那么c的索引便失效了</p></blockquote><p><strong><font color=blue>2. 改进</font></strong></p><p>可以建立如下索引（范围字段放在最后）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_age_name_classid <span class="keyword">on</span> student(age,name,classid); </span><br></pre></td></tr></table></figure><p>进行验证，可以看到联合索引所有的列都用上了</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301614217.png" alt="image-20220824174830572"></p><blockquote><p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，&#x3D;&#x3D;务必把范围设计到的字段写在最后&#x3D;&#x3D;）</p></blockquote><h3 id="2-6-不等于（-或者-）索引失效"><a href="#2-6-不等于（-或者-）索引失效" class="headerlink" title="2.6 不等于（!&#x3D; 或者 &lt;&gt;）索引失效"></a>2.6 不等于（!&#x3D; 或者 &lt;&gt;）索引失效</h3><ul><li>为name字段创建索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> student(NAME);</span><br></pre></td></tr></table></figure><ul><li>查看索引是否失效</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="operator">&lt;&gt;</span> <span class="string">&#x27;abc&#x27;</span> ;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="operator">!=</span> <span class="string">&#x27;abc&#x27;</span> ;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301614465.png" alt="image-20220824182716862"></p><h3 id="2-7-is-null可以使用索引，is-not-null无法使用索引"><a href="#2-7-is-null可以使用索引，is-not-null无法使用索引" class="headerlink" title="2.7 is null可以使用索引，is not null无法使用索引"></a>2.7 is null可以使用索引，is not null无法使用索引</h3><ul><li>IS NULL：可以触发索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301614009.png" alt="image-20220824182818489"></p><ul><li>IS NOT NULL：无法触发索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301614481.png" alt="image-20220824182851982"></p><blockquote><p>结论：最好在设计数据库的时候就将 <code>字段设置为 NOT NULL 约束</code>。比如可以将 INT 类型的字段，默认设置为 0。将字符串的默认值设置为空字符串（“”）。</p><p>扩展：同理，在查询中使用 <code>not like</code> 也无法使用索引，导致全表扫描</p></blockquote><h3 id="2-8-like-以通配符-开头索引失效"><a href="#2-8-like-以通配符-开头索引失效" class="headerlink" title="2.8 like 以通配符 % 开头索引失效"></a>2.8 like 以通配符 % 开头索引失效</h3><p>在使用 LIKE 关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引就不会其作用。只有“%”不在第一个位置，索引才会起作用。</p><ul><li>使用到索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;ab%&#x27;</span>; </span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301614010.png" alt="image-20220824183323044"></p><ul><li>未使用到索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;%ab%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301614737.png" alt="image-20220824183400615"></p><blockquote><p><strong>拓展：Alibaba《Java 开发手册》</strong></p><p>【强制】页面搜索&#x3D;&#x3D;严禁左模糊或者全模糊&#x3D;&#x3D;，如果需要请走搜索引擎来解决。</p></blockquote><h3 id="2-9-OR-前后存在非索引的列，索引失效"><a href="#2-9-OR-前后存在非索引的列，索引失效" class="headerlink" title="2.9 OR 前后存在非索引的列，索引失效"></a>2.9 OR 前后存在非索引的列，索引失效</h3><p>在WHERE 子句中，如果在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引，那么索引会失效。也就是说，&#x3D;&#x3D;OR 前后的两个条件中的列都是索引时，查询中才使用索引&#x3D;&#x3D;。</p><p>因为 OR 的含义就是两个只要满足一个即可，因此 &#x3D;&#x3D;只有一个条件列进行了索引是没有意义的&#x3D;&#x3D;，只要有条件列没有进行索引，就会进行&#x3D;&#x3D;全表扫描&#x3D;&#x3D;，因此索引的条件列也会失效。</p><p>查询语句使用 OR 关键字的情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建索引（只有<span class="keyword">OR</span>前面的字段有索引）</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> student(age);</span><br><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">OR</span> classid <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301614874.png" alt="image-20220824183640699"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 再为<span class="keyword">OR</span>后面的字段创建一个索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_cid <span class="keyword">ON</span> student(classid);</span><br><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">OR</span> classid <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301614428.png" alt="image-20220824184608531"></p><blockquote><p>解释下 OR 前后存在非索引的列，索引失效</p><p>因为 OR前后一个使用索引，一个进行全表扫描，还没有直接进行全表扫描更快~</p></blockquote><h3 id="2-10-数据库和表的字符集统一使用utf8mb4-utf8mb3"><a href="#2-10-数据库和表的字符集统一使用utf8mb4-utf8mb3" class="headerlink" title="2.10 数据库和表的字符集统一使用utf8mb4&#x2F;utf8mb3"></a>2.10 数据库和表的字符集统一使用utf8mb4&#x2F;utf8mb3</h3><p>统一使用 utf8mb4（5.5.3版本以上支持）兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的 <code>字符集</code> 进行比较前需要进行 <code>转换</code> 会造成索引失效。</p><h3 id="2-11-练习及一般性建议"><a href="#2-11-练习及一般性建议" class="headerlink" title="2.11 练习及一般性建议"></a>2.11 练习及一般性建议</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301614388.png"></p><p><strong>一般性建议：</strong></p><ul><li>对于单列索引，尽量选择针对当前 query 过滤性更好的索引</li><li>在选择组合索引的时候，当前 query 中过滤性最好的字段在索引字段顺序中，位置越靠前越好</li><li>在选择组合索引的时候，尽量选择能够包含当前 query 中的 where 子句中更多字段的索引</li><li>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。</li></ul><p>总之，书写 SQL 语句时，尽量避免造成索引失效的情况。</p><h2 id="3-关联查询优化"><a href="#3-关联查询优化" class="headerlink" title="3. 关联查询优化"></a>3. 关联查询优化</h2><h3 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h3><p>创建Type表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `type` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`card` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>创建book表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `book` (</span><br><span class="line">`bookid` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`card` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`bookid`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在type表中执行20次如下数据，插入20条数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TYPE(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">20</span>));</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>同样的，在book表中插入20条数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">20</span>));</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><h3 id="3-1-采用左外连接"><a href="#3-1-采用左外连接" class="headerlink" title="3.1 采用左外连接"></a>3.1 采用左外连接</h3><p>我们知道多表查询分为外连接和内连接，而外连接又分为左外连接，右外连接和满外连接。其中外连接中，左外连接与右外连接可以通过交换表来相互改造，其原理也是类似的，而满外连接无非是二者的一个综合，因此外连接我们只介绍左外连接的优化即可。</p><p><strong><font color=blue>1.下面开始 EXPLAIN 分析，当没有使用索引时，可以看到是全表扫描~</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> `type` <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card <span class="operator">=</span> book.card;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301614498.png" alt="image-20220824230108579"></p><p>在上面的查询sql中，type表是驱动表，book表是被驱动表。在执行查询时，会先查找驱动表中符合条件的数据，再根据驱动表查询到的数据在被驱动表中根据匹配条件查找对应的数据。因此被驱动表嵌套查询的次数是20*20&#x3D;400次。实际上，由于我们总是需要在被驱动表中进行查询，优化器帮我们已经做了优化，上面的查询结果中可以看到，使用了<code>join buffer</code>，将数据缓存起来，提高检索的速度。</p><p><strong><font color=blue>2. 为了提高外连接的性能，我们添加下索引</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX Y <span class="keyword">ON</span> book(card); #【被驱动表】，可以避免全表扫描</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> `type` </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card <span class="operator">=</span> book.card;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301614819.png" alt="image-20220824230338583"></p><p>对于外层表来说，虽然其查询仍然是全表扫描，但是因为是左外连接，<code>LEFT JOIN</code>左边的表的数据无论是否满足条件都会保留，因此全表扫描也是不赖的。另外可以看到第二行的 type 变为了 ref，rows 也变成了1，优化比较明显。这是由左连接特性决定的。<code>LEFT JOIN</code> 条件用于确定如何从右表搜索行，左边一定都有，所以 <code>右边是我们的关键点，一定需要建立索引</code></p><p><strong><font color=blue>3. 我们当然也可以给type表建立索引。</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX X <span class="keyword">ON</span> `type`(card); #【驱动表】，无法避免全表扫描</span><br><span class="line"># <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `type` <span class="keyword">ADD</span> INDEX X (card);</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> `type` <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card <span class="operator">=</span> book.card;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301614985.png" alt="image-20220824230536748"></p><blockquote><p>注意，外连接的关联条件中，两个关联字段的类型、字符集一定要保持一致，否则索引会失效哦。</p></blockquote><p><strong><font color=blue>4. 删除索引Y，我们继续查询</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX Y <span class="keyword">ON</span> book;</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> `type` <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card <span class="operator">=</span> book.card;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301615026.png" alt="image-20220824230642449"></p><p>book表使用<code>join buffer</code>，再次验证了左外连接左边的表是驱动表，右边的表是被驱动表，后面我们将与内连接在这一点进行对比。</p><blockquote><p>左外链接左表是驱动表右表是被驱动表，右外链接和此相反，内链接则是按照数据量的大小，数据量少的是驱动表，多的是被驱动表</p></blockquote><h3 id="3-2-采用内连接"><a href="#3-2-采用内连接" class="headerlink" title="3.2 采用内连接"></a>3.2 采用内连接</h3><p><strong><font color=blue>1. 删除现有的索引，换成 inner join(MySQL自动选择驱动表)</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index X <span class="keyword">on</span> type;</span><br><span class="line"><span class="keyword">drop</span> index Y <span class="keyword">on</span> book;# (如果已经删除了可以不用再执行该操作)</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> type <span class="keyword">INNER</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card<span class="operator">=</span>book.card;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301615690.png" alt="image-20220826120632384"></p><p><strong><font color=blue>2. 为book表添加索引优化</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">ADD</span> INDEX Y (card);</span><br><span class="line"></span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span>  type <span class="keyword">INNER</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card<span class="operator">=</span>book.card;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301615170.png" alt="image-20220826120800619"></p><p><strong><font color=blue>3. 向type表中再增加20条数据，为type表增加索引优化，观察情况</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 再向type表中插入<span class="number">20</span>条数据，此时type:<span class="number">40</span>条数据，book:<span class="number">20</span>条数据 (过程省略)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> type <span class="keyword">ADD</span> INDEX X (card);</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> type <span class="keyword">INNER</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card<span class="operator">=</span>book.card;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301615458.png" alt="image-20220826121414744"></p><p>上面的两次查询中，第一次是使用type作为驱动表，book作为被驱动表。而第二次是使用book作为驱动表，type作为被驱动表。&#x3D;&#x3D;对于内连接来说，查询优化器可以决定谁作为驱动表，谁作为被驱动表出现的&#x3D;&#x3D;</p><p><strong><font color=blue>4. 接着，删除被驱动表的索引</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX X <span class="keyword">ON</span> `type`;</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> type <span class="keyword">INNER</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card<span class="operator">=</span>book.card;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301615018.png" alt="image-20220826122407713"></p><p>被驱动表进行了反转。这是因为内连接优化器可以决定（被）驱动表。在只有一个表存在索引的情况下，会<strong>选择存在索引的表作为被驱动表</strong>(因为被驱动表查询次数更多)</p><p><strong><font color=blue>5. 再加上索引，观察结果</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `type` <span class="keyword">ADD</span> INDEX X (card);</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> type <span class="keyword">INNER</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card<span class="operator">=</span>book.card;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301615138.png" alt="image-20220826123444163"></p><p>被驱动表又进行了反转~</p><blockquote><p>结论：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。“&#x3D;&#x3D;小表驱动大表&#x3D;&#x3D;”</p></blockquote><h3 id="3-3-join-语句原理"><a href="#3-3-join-语句原理" class="headerlink" title="3.3 join 语句原理"></a>3.3 join 语句原理</h3><p>join 方式连接多表，本质就是各个表之间数据的循环匹配。MySQL 5.5 版本之前，MySQL 只支持一种表间关联方式，就是嵌套循环。如果关联表的数据量很大，则 join 关联的执行时间会非常漫长。在 MySQL 5.5 以后的版本中，MySQL 通过引入 BNLJ 算法来优化嵌套执行。</p><h4 id="3-3-1-驱动表和被驱动表"><a href="#3-3-1-驱动表和被驱动表" class="headerlink" title="3.3.1 驱动表和被驱动表"></a>3.3.1 驱动表和被驱动表</h4><p>驱动表就是主表，被驱动表就是从表、非驱动表。</p><ul><li><strong>对于内连接来说:</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">JOIN</span> B <span class="keyword">ON</span> ...</span><br></pre></td></tr></table></figure><p>A 并不一定就是驱动表，优化器会根据你的查询语句做优化，决定先查哪张表。先查询的哪张表就是驱动表，反之就是被驱动表。通过 explain 关键字可以查看。</p><blockquote><p>3.2 已经总结了优化器选择的规律：两表中一个表有索引，一个表没有索引，则没有索引的为驱动表，有索引的为被驱动表；两个表都没有索引，则小表驱动大表。</p><p>💡Q:上面的规律是一成不变的吗？如果一个表有索引，但是数据量很小，一个表没有索引，但是数据量很大，情况会是怎样的呢？<br>我们要明白优化器的优化原理：对于内连接mysql会选择扫描次数比较少的作为驱动表，因此实际生产中最好使用<code>Explain</code>测试验证。</p></blockquote><ul><li><strong>对于外连接来说：</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> ...</span><br><span class="line"># 或</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> B <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> A <span class="keyword">ON</span> ...</span><br></pre></td></tr></table></figure><p>通常，大家会认为 A 就是驱动表，B 就是被驱动表。但也未必。测试如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> a(f1 <span class="type">INT</span>,f2 <span class="type">INT</span>,INDEX(f1)) ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> b(f1 <span class="type">INT</span>,f2 <span class="type">INT</span>) ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> a <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> b <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line"># 测试<span class="number">1</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> b <span class="keyword">ON</span>(a.f1<span class="operator">=</span>b.f1) <span class="keyword">WHERE</span> (a.f2<span class="operator">=</span>b.f2);</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301615050.png" alt="image-20220826132157586"></p><p>明明我们写的是<code>a LEFT JOIN b</code>,但是我们执行sql查询时，却是b作为了驱动表，a作为了被驱动表。</p><p>实际上，&#x3D;&#x3D;查询优化器会帮你把外连接改造为内连接，然后根据其优化策略选择驱动表与被驱动表&#x3D;&#x3D;</p><h4 id="3-3-2-Simple-Nested-Loop-Join（简单嵌套循环连接）"><a href="#3-3-2-Simple-Nested-Loop-Join（简单嵌套循环连接）" class="headerlink" title="3.3.2 Simple Nested-Loop Join（简单嵌套循环连接）"></a>3.3.2 Simple Nested-Loop Join（简单嵌套循环连接）</h4><p>算法相当简单，从表 A 取出一条数据 1，遍历表 B，将匹配到的数据放到 result。以此类推，驱动表 A 中的每一条记录与被动驱动表 B 的记录进行判断：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301615939.png" alt="image-20220826133623699"></p><p>可以看到这种方式效率是非常低的，以上述表 A 数据 100 条，表 B 数据 1000 条，则 A*B&#x3D;10 万次。开销统计如下：</p><table><thead><tr><th align="left">开销统计</th><th align="left">SNLJ</th></tr></thead><tbody><tr><td align="left">外表扫描次数</td><td align="left">1</td></tr><tr><td align="left">内表扫描次数</td><td align="left">A</td></tr><tr><td align="left">读取记录数</td><td align="left">A+B*A</td></tr><tr><td align="left">JOIN 比较次数</td><td align="left">B*A</td></tr><tr><td align="left">回表读取记录次数</td><td align="left">0</td></tr></tbody></table><p>当然 MySQL 肯定不会这么粗暴的进行表的连接，所以就出现了后面的两种其的优化算法。</p><p>另外，从读取记录数来看：A+B*A中，驱动表A对性能的影响权重更大。因此我们优化器会选择小表驱动大表。</p><h4 id="3-3-3-Index-Nested-Loop-Join（索引嵌套循环连接）"><a href="#3-3-3-Index-Nested-Loop-Join（索引嵌套循环连接）" class="headerlink" title="3.3.3 Index Nested-Loop Join（索引嵌套循环连接）"></a>3.3.3 Index Nested-Loop Join（索引嵌套循环连接）</h4><p>Index Nested-Loop Join 其优化的思路主要是为了 <code>减少内层表数据的匹配次数</code>，所以要求被驱动表上必须 <code>有索引</code> 才行。通过外层表匹配条件直接与内层索引进行匹配，避免和内层表的每条记录进行比较，这样极大地减少了对内层表的匹配次数。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301615162.png" alt="image-20220826134205095"></p><p>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故 MySQL 优化器都倾向于使用记录数少的表作为驱动表（外表）。</p><table><thead><tr><th align="left">开销统计</th><th align="left">SNLJ</th><th align="left">INLJ</th></tr></thead><tbody><tr><td align="left">外表扫描次数</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">内表扫描次数</td><td align="left">A</td><td align="left">0</td></tr><tr><td align="left">读取记录数</td><td align="left">A+B*A</td><td align="left">A+B（match）</td></tr><tr><td align="left">JOIN 比较次数</td><td align="left">B*A</td><td align="left">A*Index（Height）</td></tr><tr><td align="left">回表读取记录次数</td><td align="left">0</td><td align="left">B（match）（if possible）</td></tr></tbody></table><p>如果被驱动表加索引，效率是非常高的，如果索引不是主键索引，所以还得进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高</p><h4 id="3-3-4-Block-Nested-Loop-Join（快嵌套循环连接）"><a href="#3-3-4-Block-Nested-Loop-Join（快嵌套循环连接）" class="headerlink" title="3.3.4 Block Nested-Loop Join（快嵌套循环连接）"></a>3.3.4 Block Nested-Loop Join（快嵌套循环连接）</h4><p>如果存在索引，那么会使用 index 的方式进行 join，如果 join 的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把驱动表的记录再加载到内存匹配，这样周而复始，大大增加了 IO 次数。为了减少被驱动表的 IO 次数，就出现了 <code>Block Nested-Loop Join</code>的方式</p><p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了 <code>join buffer 缓冲区</code>，将驱动表 join 相关的部分数据列（大小受 join buffer 的限制）缓存到 join buffer 中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和 join buffer 中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被动表的访问频率。</p><blockquote><p>注意：</p><p>这里缓存的不只是关联表的列，select 后面的列也会缓存起来</p><p>在一个有 N 个 join 关联的 SQL 中会分配 N-1 个 join buffer。所以查询的时候尽量减少不必要的字段，可以 让 join buffer 中存放更多的列。</p></blockquote><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301615499.png" alt="image-20220826135208899"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301620444.png" alt="image-20220826135248800"></p><p>参数设置：</p><ul><li><p>block_nested_loop</p><p>通过 <code>show variables like &#39;%optimizer_switch%&#39;</code> 查看 <code>block_nested_loop</code> 状态。默认是开启的。</p></li><li><p>join_buffer_size</p><p>驱动表能不能一次加载完，要看 join buffer 能不能存储所有的数据，默认情况下 <code>join_buffer_size = 256K</code>。</p><p>join <em>buffer</em> size 的最大值在 32 位系统可以申请 4G，而在 64 位操做系统下可以申请大于 4G 的 join_buffer空间（64 位 Windows 除外，其大值会被截断为 4GB并发出警告）。</p></li></ul><h4 id="3-3-5-小结"><a href="#3-3-5-小结" class="headerlink" title="3.3.5 小结"></a>3.3.5 小结</h4><ol><li>保证被驱动表的 JOIN 字段已经创建了索引（减少内层表的循环匹配次数）</li><li>需要 JOIN 的字段，数据类型保持绝对一致。</li><li>LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。</li><li>INNER JOIN 时，MySQL 会自动将小结果集的表选为驱动表 。选择相信 MySQL 优化策略。</li><li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li><li>不建议使用子查询，建议将子查询 SQL 拆开结合程序多次查询，或使用 JOIN 来代替子查询。</li><li>衍生表建不了索引</li><li>默认效率比较：&#x3D;&#x3D;INLJ &gt; BNLJ &gt; SNLJ&#x3D;&#x3D;</li><li>正确理解小表驱动大表：大小不是指表中的记录数，而是永远用小结果集驱动大结果集（其本质就是减少外层循环的数据数量）。 比如A表有100条记录，B表有1000条记录，但是where条件过滤后，B表结果集只留下50个记录，A表结果集有80条记录，此时就可能是B表驱动A表。其实上面的例子还是不够准确，因为结果集的大小也不能粗略的用结果集的行数表示，而是&#x3D;&#x3D;表行数 * 每行大小&#x3D;&#x3D;。其实要理解你只需要结合Join Buffer就好了，因为表行数 * 每行大小越小，其占用内存越小,就可以在Join Buffer中尽量少的次数加载完了。</li></ol><h4 id="3-3-6-Hash-Join"><a href="#3-3-6-Hash-Join" class="headerlink" title="3.3.6 Hash Join"></a>3.3.6 Hash Join</h4><p>&#x3D;&#x3D;从 MySQL 8.0.20 版本开始将废弃 BNLJ，因为加入了 hash join 默认都会使用 hash join&#x3D;&#x3D;</p><ul><li><p>Nested Loop：</p><p>对于被连接的数据子集较小的情况，Nested Loop 是个较好的选择。</p></li><li><p>Hash Join 是做 <code>大数据集连接</code> 时的常用方法，优化器使用两个表中较小（相对较小）的表利用 join key 在内存中建立 <code>散列表</code>，然后扫描较大的表并探测散列表，找出与 Hash 表匹配的行。</p><ul><li>这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和</li><li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成 <code>若干不同的分区</code>，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高 I&#x2F;O 的性能。</li><li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是 Join 的重型升降机。Hash Join 只能应用于等值连接（如 WHERE A.COL1 &#x3D; B.COL2），这是由 Hash 的特点决定的。</li></ul></li></ul><table><thead><tr><th align="left">类型</th><th align="left">Nested Loop</th><th align="left">Hash Join</th></tr></thead><tbody><tr><td align="left">使用条件</td><td align="left">任何条件</td><td align="left">等值连接（&#x3D;）</td></tr><tr><td align="left">相关资源</td><td align="left">CPU、磁盘 I&#x2F;O</td><td align="left">内存、临时空间</td></tr><tr><td align="left">特点</td><td align="left">当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果</td><td align="left">当缺乏索引或者索引条件模糊时，Hash Join 比 Nested Loop 有效。在数据仓库环境下，如果表的记录数多，效率高</td></tr><tr><td align="left">缺点</td><td align="left">当索引丢失或者查询条件限制不够时，效率很低；当表的记录数较多，效率低</td><td align="left">为简历哈希表，需要大量内存。第一次的结果返回较慢</td></tr></tbody></table><h2 id="4-子查询优化"><a href="#4-子查询优化" class="headerlink" title="4. 子查询优化"></a>4. 子查询优化</h2><p>MySQL 从 4.1 版本开始支持子查询，使用子查询可以进行 SELECT 语句的嵌套查询，即一个 SELECT 查询的结果作为另一个 SELECT 语句的条件。<code>子查询可以一次性完成很多逻辑上需要多个步骤才能完成的操作</code> 。</p><p><strong>子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。</strong> 通常我们可以将其优化成一个连接查询~</p><p>原因:</p><p><font color=blue>①</font> 执行子查询时，MySQL 需要为内层查询语句的查询结果<code>建立一个临时表</code> ，然后外层查询语句从临时表中查询记录。查询完毕后，再<code>撤销这些临时表</code> 。这样会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p><p><font color=blue>②</font> 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 <code>不会存在索引</code> ，所以查询性能会受到一定的影响。</p><p><font color=blue>③</font> 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p><p>&#x3D;&#x3D;在 MySQL 中，可以使用连接（JOIN）查询来替代子查询。&#x3D;&#x3D; 连接查询 <code>不需要建立临时表</code>，其 <code>速度比子查询要快</code>，如果查询中使用索引的话，性能就会更好。</p><p><strong><font color=green>举例1：查询学生表中是班长的学生信息</font></strong></p><ul><li>使用子查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#创建班级表中班长的索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_monitor <span class="keyword">ON</span> class(monitor);</span><br><span class="line"></span><br><span class="line">#查询班长的信息</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student stu1</span><br><span class="line">    <span class="keyword">WHERE</span> stu1.`stuno` <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> monitor</span><br><span class="line">    <span class="keyword">FROM</span> class c</span><br><span class="line">    <span class="keyword">WHERE</span> monitor <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>推荐：使用多表查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> stu1.<span class="operator">*</span> <span class="keyword">FROM</span> student stu1 <span class="keyword">JOIN</span> class c </span><br><span class="line"><span class="keyword">ON</span> stu1.`stuno` <span class="operator">=</span> c.`monitor`</span><br><span class="line"><span class="keyword">WHERE</span> c.`monitor` <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p><strong><font color=green>举例2：取所有不为班长的同学</font></strong></p><ul><li>不推荐</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询不为班长的学生信息</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE a.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student a </span><br><span class="line"><span class="keyword">WHERE</span>  a.stuno  <span class="keyword">NOT</span>  <span class="keyword">IN</span> (</span><br><span class="line">            <span class="keyword">SELECT</span> monitor <span class="keyword">FROM</span> class b </span><br><span class="line">            <span class="keyword">WHERE</span> monitor <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><ul><li>推荐</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 转换成左连接查询</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>  student a <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> class b </span><br><span class="line"><span class="keyword">ON</span> a.stuno <span class="operator">=</span>b.monitor</span><br><span class="line"><span class="keyword">WHERE</span> b.monitor <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><blockquote><p>结论：尽量不要使用 NOT IN 或者 NOT EXISTS，用 <code>LEFT JOIN xxx ON xx WHERE xx IS NULL</code> 替代</p></blockquote><h2 id="5-排序优化"><a href="#5-排序优化" class="headerlink" title="5. 排序优化"></a>5. 排序优化</h2><h3 id="5-1-排序优化"><a href="#5-1-排序优化" class="headerlink" title="5.1 排序优化"></a>5.1 排序优化</h3><p><strong>问题：在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？</strong></p><p>在 MySQL 中，支持两种排序方式，分别是 <code>FileSort</code> 和 <code>Index</code> 排序。</p><ul><li>Index 排序中，索引可以保证数据的有序性，就不需要再进行排序，<code>效率更更高</code>。</li><li>FileSort 排序则一般在 <code>内存中</code> 进行排序，占用 <code>CPU 较多</code>。如果待排序的结果较大，会产生临时文件 I&#x2F;O 到磁盘进行排序的情况，效率低。</li></ul><p><strong>优化建议:</strong></p><ol><li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 <code>避免全表扫描</code>，在 ORDER BY 子句 <code>避免使用 FileSort 排序</code>。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</li><li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</li><li>无法使用 Index 时，需要对 FileSort 方式进行调优。</li></ol><h3 id="5-2-测试"><a href="#5-2-测试" class="headerlink" title="5.2 测试"></a>5.2 测试</h3><p>执先案例前，调用存储过程删除student和class表上的索引。只留主键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> proc_drop_index(<span class="string">&#x27;atguigudb2&#x27;</span>,<span class="string">&#x27;student&#x27;</span>);</span><br><span class="line"><span class="keyword">call</span> proc_drop_index(<span class="string">&#x27;atguigudb2&#x27;</span>,<span class="string">&#x27;class&#x27;</span>);</span><br></pre></td></tr></table></figure><p>以下是否能使用索引，能否去掉 <code>using filesort</code></p><p><strong>过程一：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid;  </span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301615099.png" alt="image-20220826151348825"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301615874.png" alt="image-20220826151419544"></p><p><strong>过程二：</strong></p><p><strong><font color=blue>1. 创建索引，但是不加limit限制，索引失效</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  INDEX idx_age_classid_name <span class="keyword">ON</span> student (age,classid,NAME);</span><br><span class="line"></span><br><span class="line">#不限制,索引失效</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid; </span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301615019.png" alt="image-20220826151550127"></p><p>我们不是建立了索引嘛，为啥显示没有使用呢？这是优化器通过计算发现，这里需要回表的数据量特别大，使用索引的性能代价反而比不上不用索引的。</p><p><strong><font color=blue>2. 假如我们最后只查询二级索引中有的字段，观察结果：</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 会使用索引 （覆盖索引）</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> SQL_NO_CACHE age,classid,name,id <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid;  </span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301615338.png" alt="image-20220826151951066"></p><p><strong><font color=blue>3. 假如我们限制排序返回的结果数量，观察结果：</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#增加limit过滤条件，使用上索引了。</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301615418.png" alt="image-20220826152308067"></p><p><strong>过程三：order by 时顺序错误，索引失效</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#创建索引age,classid,stuno</span><br><span class="line"><span class="keyword">CREATE</span>  INDEX idx_age_classid_stuno <span class="keyword">ON</span> student (age,classid,stuno); </span><br><span class="line"></span><br><span class="line">#以下哪些索引失效?</span><br><span class="line"># 失效</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classid LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># 失效</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classid,NAME LIMIT <span class="number">10</span>;  </span><br><span class="line"></span><br><span class="line"># 可以</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid,stuno LIMIT <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"># 可以</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age,classid LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># 可以</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>过程四：order by 时规则不一致, 索引失效 （顺序错，不索引；方向反，不索引）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 失效</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>, classid <span class="keyword">ASC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># 失效</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classid <span class="keyword">DESC</span>, NAME <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># 失效</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>,classid <span class="keyword">DESC</span> LIMIT <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"># 可以</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>, classid <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>过程五：无过滤，不索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 可以</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> classid;</span><br><span class="line"></span><br><span class="line"># 可以</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> classid,NAME; </span><br><span class="line"></span><br><span class="line"># 失效</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classid<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age;</span><br><span class="line"></span><br><span class="line"># 可以</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classid<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_cid <span class="keyword">ON</span> student(classid);</span><br><span class="line"></span><br><span class="line"># 可以</span><br><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classid<span class="operator">=</span><span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age;</span><br></pre></td></tr></table></figure><p><strong>小结：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">INDEX a_b_c(a,b,c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 能使用索引最左前缀 <span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a,b</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a,b,c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">DESC</span>,b <span class="keyword">DESC</span>,c <span class="keyword">DESC</span></span><br><span class="line"></span><br><span class="line">如果 <span class="keyword">WHERE</span> 使用索引的最左前缀定义为常量，则 <span class="keyword">order</span> <span class="keyword">by</span> 能使用索引 </span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b,c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">AND</span> b <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b,c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">AND</span> b <span class="operator">&gt;</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b,c</span><br><span class="line"></span><br><span class="line">不能使用索引进行排序</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">ASC</span>,b <span class="keyword">DESC</span>,c <span class="keyword">DESC</span> <span class="comment">/* 排序不一致 */</span> </span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> g <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b,c <span class="comment">/*丢失a索引*/</span></span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> c <span class="comment">/*丢失b索引*/</span></span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> a,d <span class="comment">/*d不是索引的一部分*/</span></span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="keyword">in</span> (...) <span class="keyword">ORDER</span> <span class="keyword">BY</span> b,c <span class="comment">/*对于排序来说，多个相等条件也是范围查询*/</span></span><br></pre></td></tr></table></figure><h3 id="5-3-案例实战"><a href="#5-3-案例实战" class="headerlink" title="5.3 案例实战"></a>5.3 案例实战</h3><p>下面我们通过一个案例来实战filesort和index两种排序。&#x3D;&#x3D;对ORDER BY子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序&#x3D;&#x3D;。</p><p><font color=blue><strong>场景:查询年龄为30岁的，且学生编号小于101000的学生，按用户名称排序</strong></font></p><p>执行案例前先清除student上的索引，只留主键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX idx_age <span class="keyword">ON</span> student;</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_age_classid_stuno <span class="keyword">ON</span> student;</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student;</span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">call</span> proc_drop_index(<span class="string">&#x27;atguigudb2&#x27;</span>,<span class="string">&#x27;student&#x27;</span>);</span><br></pre></td></tr></table></figure><p>测试以下的查询，此时显然使用的是filesort进行排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span><span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME ;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301616220.png" alt="image-20220317213102709"></p><p>结论：type 是 ALL，即最坏的情况。Extra 里还出现了 Using filesort，也是最坏的情况。优化是必须的。</p><p><strong>方案一：为了去掉 filesort 我们可以创建特定索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建新索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> student(age,NAME);</span><br><span class="line"># 进行测试，可以看到已经使用了索引，虽然仅仅使用到了age这个字段</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span> <span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME ;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301616745.png" alt="image-20220317213227501"></p><p><strong>方案二：尽量让 where 的过滤条件和排序使用上索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX idx_age_name <span class="keyword">ON</span> student;</span><br><span class="line"># 建立三个字段的索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_stuno_name <span class="keyword">ON</span> student (age,stuno,NAME);</span><br><span class="line"># 进行测试</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span><span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME ;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301616962.png" alt="image-20220317213450582"></p><p>此时又使用了filesort，这是为什么呢？这是因为此时filesort的性能更高。不信你可以对比执行下（0.03sec和0.00sec），看看时间的区别。结果竟然有 filesort 的 sql 运行速度，超过了已经优化掉 filesort的 sql，而且快了很多，几乎一瞬间就出现了结果。看来优化器做的工作真的特别灵活</p><p><strong>原因</strong>：所有的排序都是在条件过滤之后才执行的。所以，如果条件过滤大部分数据的话，剩下几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。相对的 stuno &lt; 10100 这个条件，如果没有用到索引的话，要对几万条数据进行扫描，这是非常消耗性能的，所以索引放在这个字段上性价比最高，是最优选择。</p><blockquote><p>结论:</p><ol><li>两个索引同时存在，mysql 自动选择最优的方案。（对于这个例子，mysql 选择 idx_age_stuno_name）。但是，<code>随着数据量的变化，选择的索引也会随之变化的</code> 。</li><li><strong>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</strong></li></ol></blockquote><p>思考：这里我们使用如下索引，是否可行? (<strong>可行</strong>)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX idx_age_stuno_name <span class="keyword">ON</span> student;</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_stuno <span class="keyword">ON</span> student(age,stuno);</span><br></pre></td></tr></table></figure><h3 id="5-4-filesort-算法：双路排序和单路排序"><a href="#5-4-filesort-算法：双路排序和单路排序" class="headerlink" title="5.4 filesort 算法：双路排序和单路排序"></a>5.4 filesort 算法：双路排序和单路排序</h3><p>排序的字段若不在索引列上，则 filesort 会有两种算法：<code>双路排序</code> 和 <code>单路排序</code></p><p><font color=blue>1. <strong>双路排序（慢）</strong></font></p><ul><li><code>MySQL4.1 之前是使用双路排序</code>，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和 <code>order by 列</code>，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li><li>从磁盘取排序字段，在 buffer 进行排序，再从 <code>磁盘取其他字段</code> 。</li></ul><p>取一批数据，要对磁盘进行两次扫描，众所周知，IO 是很耗时的，所以在 MySQL4.1 之后，出现了第二种改进的算法，就是单路排序。</p><p><font color=blue>2. <strong>单路排序（快）</strong></font></p><p>从磁盘读取查询需要的 <code>所有列</code> ，按照 order by 列在 buffer 对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</p><p><strong>结论及引申出的问题</strong></p><ul><li><p>由于单路是后出的，总体而言好过双路</p></li><li><p>但是用单路有问题</p><ul><li><p>在 sort_buffer 中，单路比多路要<code>多占用很多空间</code>，因为单路是把所有字段都取出，所以可能取出的数据的总大小超出了<code>sort_buffer</code>的容量，导致每次只能取 sort_buffer 容量大小的数据，进行排序（创建 temp 文件，多路合并），排完再取 sort_buffer 容量大小，再排……从而多次I&#x2F;O。</p></li><li><p>单路本来想省一次 I&#x2F;O 操作，<code>反而导致了大量的 I/O 操作</code>，反而得不偿失。</p></li></ul></li></ul><p><font color=red><strong>优化策略</strong></font></p><ul><li><p><strong>尝试提高 sort_buffer_size</strong></p><ul><li><p>不管用哪种算法，提高这个参数都会提高效率，要根据系统的能力去提高，因为这个参数是针对每个进程（connection）的 1M - 8M 之间调整。MySQL5.7，InnoDB 存储引擎默认值都是 1048576 字节，1MB。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301616578.png" alt="image-20220826160456207"></p></li></ul></li><li><p><strong>尝试提高 max_length_for_sort_data</strong></p><ul><li><p>提高这个参数，会增加改进算法的概率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span><span class="string">&#x27;%max_length_for_sort_data%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大，明显症状是高的磁盘 I&#x2F;O 活动和低的处理器使用率。如果需要返回的列的总长度大于 max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192字节之间调整。</p></li></ul></li><li><p><em><em>Order by 时 select</em> 是一个大忌。最好只Query需要的字段。</em>*</p><ul><li>当 Query 的字段大小综合小于 max_length_for_sort_data，而且排序字段不是 TEXT|BLOG 类型时，会改进后的算法——单路排序，否则用老算法——多路排序。</li><li>两种算法的数据都有可能超出 sort_buffer_size 的容量，超出之后，会创建 tmp 文件进行合并排序，导致多次 I&#x2F;O，但是用单路排序算法的风险会更大一些，所以要提高 sort_buffer_size</li></ul></li></ul><h2 id="6-GROUP-BY优化"><a href="#6-GROUP-BY优化" class="headerlink" title="6. GROUP BY优化"></a>6. GROUP BY优化</h2><ul><li>group by 使用索引的原则几乎跟 order by 一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li><li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li><li>当无法使用索引列，增大 <code>max_length_for_sort_data</code> 和 <code>sort_buffer_size</code> 参数的设置</li><li>where 效率高于 having，能写在 where 限定的条件就不要写在 having 中了</li><li>减少使用 order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的。</li><li>包含了 order by、group by、distinct 这些查询的语句，where 条件过滤出来的结果集请保持在 1000 行以内，否则 SQL 会很慢。</li></ul><h2 id="7-优化分页查询"><a href="#7-优化分页查询" class="headerlink" title="7. 优化分页查询"></a>7. 优化分页查询</h2><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见有非常头疼的问题就是 <code>limit 2000000,10</code>，此时需要 MySQL 排序前 2000010 记录，仅仅返回 2000000-2000010 的记录，其他记录丢弃，查询排序的代价非常大。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LIMIT <span class="number">2000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>优化思路一</strong></p><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student t,(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">2000000</span>,<span class="number">10</span>) a</span><br><span class="line"><span class="keyword">WHERE</span> t.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301616923.png" alt="image-20220118212331595"></p><p><strong>优化思路二</strong></p><p>该方案适用于主键自增的表，可以把 Limit 查询转换成某个位置的查询 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">2000000</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301616809.png" alt="image-20220118212357618"></p><h2 id="8-优先考虑覆盖索引"><a href="#8-优先考虑覆盖索引" class="headerlink" title="8. 优先考虑覆盖索引"></a>8. 优先考虑覆盖索引</h2><h3 id="8-1-什么是覆盖索引？"><a href="#8-1-什么是覆盖索引？" class="headerlink" title="8.1 什么是覆盖索引？"></a>8.1 什么是覆盖索引？</h3><p><strong>理解方式一</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。 &#x3D;&#x3D;一个索引包含了满足查询结果的数据就叫做覆盖索引。&#x3D;&#x3D;</p><p><strong>理解方式二</strong>：非聚簇复合索引的一种形式，它包括在查询里的 SELECT、JOIN 和 WHERE 子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p><p>简单说就是， <code>索引列+主键</code> 包含 <code>SELECT 到 FROM 之间查询的列</code>。</p><p><strong>举例一：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#删除之前的索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_age_stuno <span class="keyword">ON</span> student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> student (age,NAME);</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301616617.png" alt="image-20220317220113590"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> age,NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301616971.png" alt="image-20220317220203223"></p><blockquote><p>注意：前面我们提到如果使用上<code>&lt;&gt;</code>就不会使用上索引了 并不是绝对的。比如上面这条SQL就用上了！！！Attention！我们讲解的关于 索引失效以及索引优化都是根据效率来决定的。对于二级索引来说：查询时间 &#x3D; 二级索引计算时间 + 回表查询时间，由于我们使用的是覆盖索引，回表查询时间 &#x3D; 0，索引优化器考虑到这一点就使用上 二级索引了~</p></blockquote><p><strong>举例二：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301616195.png" alt="image-20220317220552145"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> id,age <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301616530.png" alt="image-20220317220630975"></p><p>同上，由于也使用了覆盖索引，最终SQL执行也正常使用上了索引~</p><h3 id="8-2-覆盖索引的利弊"><a href="#8-2-覆盖索引的利弊" class="headerlink" title="8.2 覆盖索引的利弊"></a>8.2 覆盖索引的利弊</h3><p><font color=#5d0308><strong>好处:</strong></font></p><p><strong><font color=blue>1. 避免Innodb表进行索引的二次查询（回表）</font></strong></p><p>Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取我们真实所需要的数据。</p><p>在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询，减少了 IO 操作，提升了查询效率。</p><p><strong><font color=blue>2. 可以把随机 IO 变成顺序 IO 加快查询效率</font></strong></p><p>由于覆盖索引是按键值的顺序存储的，对于 I&#x2F;O 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 I&#x2F;O 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 I&#x2F;O 转变成索引查找的顺序 I&#x2F;O。</p><p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p><p><strong><font color=#5d0308>弊端:</font></strong></p><p><code>索引字段的维护</code> 总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务 DBA，或者称为业务数据架构师的工作。</p><h2 id="9-如何给字符串添加索引"><a href="#9-如何给字符串添加索引" class="headerlink" title="9. 如何给字符串添加索引"></a>9. 如何给字符串添加索引</h2><p>有一张教师表，表定义如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> teacher(</span><br><span class="line">    ID <span class="type">bigint</span> unsigned <span class="keyword">primary</span> key,</span><br><span class="line">    email <span class="type">varchar</span>(<span class="number">64</span>),</span><br><span class="line">    ...</span><br><span class="line">)engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></table></figure><p>讲师要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> col1, col2 <span class="keyword">from</span> teacher <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>; </span><br></pre></td></tr></table></figure><p>如果 email 这个字段上没有索引，那么这个语句就只能做 <code>全表扫描</code> 。</p><h3 id="9-1-前缀索引"><a href="#9-1-前缀索引" class="headerlink" title="9.1 前缀索引"></a>9.1 前缀索引</h3><p>MySQL是支持前缀索引的。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">add</span> index index1(email); </span><br><span class="line">#或</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">add</span> index index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure><p>这两种不同的定义在数据结构和存储上有什么区别呢?下图就是这两个索引的示意图。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301616747.png" alt="image-20220828195350954"></p><p>以及</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301617322.png" alt="image-20220828195404648"></p><p><font color=blue><strong>如果使用的是 index1</strong> （即 email 整个字符串的索引结构），执行顺序是这样的:</font></p><ol><li>从 index1 索引树找到满足索引值是’ <a href="mailto:&#x7a;&#x68;&#x61;&#110;&#103;&#115;&#115;&#120;&#121;&#122;&#64;&#120;&#x78;&#120;&#x2e;&#x63;&#111;&#109;">&#x7a;&#x68;&#x61;&#110;&#103;&#115;&#115;&#120;&#121;&#122;&#64;&#120;&#x78;&#120;&#x2e;&#x63;&#111;&#109;</a> ’的这条记录，取得 ID2 的值;</li><li>到主键上查到主键值是 ID2 的行，判断 email 的值是正确的，将这行记录加入结果集;</li><li>取 index1 索引树上刚刚查到的位置的下一条记录，发现已经不满足email&#x3D;’ <a href="mailto:&#x7a;&#x68;&#97;&#110;&#x67;&#x73;&#x73;&#x78;&#121;&#122;&#x40;&#120;&#120;&#120;&#46;&#99;&#111;&#109;">&#x7a;&#x68;&#97;&#110;&#x67;&#x73;&#x73;&#x78;&#121;&#122;&#x40;&#120;&#120;&#120;&#46;&#99;&#111;&#109;</a> ’的条件了，循环结束。</li></ol><p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p><p><font color=blue><strong>如果使用的是 index2</strong>（即 email(6) 索引结构），执行顺序是这样的：</font></p><ol><li>从 index2 索引树找到满足索引值是’zhangs’的记录，找到的第一个是 ID1;</li><li>到主键上查到主键值是 ID1 的行，判断出 email 的值不是’ <a href="mailto:&#122;&#104;&#x61;&#110;&#103;&#115;&#x73;&#120;&#x79;&#x7a;&#64;&#120;&#x78;&#x78;&#46;&#99;&#x6f;&#109;">&#122;&#104;&#x61;&#110;&#103;&#115;&#x73;&#120;&#x79;&#x7a;&#64;&#120;&#x78;&#x78;&#46;&#99;&#x6f;&#109;</a> ’，这行记录丢弃;</li><li>取 index2 上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出 ID2，再到 ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集;</li><li>重复上一步，直到在 idxe2 上取到的值不是’zhangs’时，循环结束。</li></ol><p>也就是说 <font color=red><strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong> </font>前面已经讲过区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。</p><h3 id="9-2-前缀索引对覆盖索引的影响"><a href="#9-2-前缀索引对覆盖索引的影响" class="headerlink" title="9.2 前缀索引对覆盖索引的影响"></a>9.2 前缀索引对覆盖索引的影响</h3><p>前面我们说了使用&#x3D;&#x3D;前缀索引可能会增加扫描行数&#x3D;&#x3D;，这会影响到性能。其实，前缀索引的影响不止如此，我们再看一下另外一个场景：</p><p>如果使用 index1（即 email 整个字符串的索引结构）的话，可以利用覆盖索引，从 index1 查到结果后直接就返回了，不需要回到 ID 索引再去查一次。而如果使用 index2（即 email(6) 索引结构）的话，就不得不回到 ID 索引再去判断 email 字段的值。</p><p>即使你将 index2 的定义修改为 email(18) 的前缀索引，这时候虽然 index2 已经包含了所有的信息，但 InnoDB 还是要回到 id 索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,email <span class="keyword">from</span> teacher <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;songhongkangexxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>结论:</p><p>&#x3D;&#x3D;使用前缀索引就用不上覆盖索引对查询性能的优化了&#x3D;&#x3D;，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p></blockquote><h3 id="9-3-拓展内容"><a href="#9-3-拓展内容" class="headerlink" title="9.3 拓展内容"></a>9.3 拓展内容</h3><p>对于类似于邮箱这样的字段来说，使用前缀索引的效果可能还不错。但是，遇到前缀的区分度不够好的情况时，我们要怎么办呢?</p><p>比如，我们国家的身份证号，一共 18 位，其中前 6 位是地址码，所以同一个县的人的身份证号前 6 位一般会是相同的。</p><p>假设你维护的数据库是一个市的公民信息系统，这时候如果对身份证号做长度为 6 的前缀索引的话，这个索引的区分度就非常低了。按照我们前面说的方法，可能你需要创建长度为 12 以上的前缀索引，才能够满足区分度要求。</p><p>但是，索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。<br>那么，如果我们能够确定业务需求里面只有按照身份证进行等值查询的需求，还有没有别的处理方法呢?这种方法，既可以占用更小的空间，也能达到相同的查询效率。有!</p><p><strong>第一种方式是使用倒序存储。</strong>如果你存储身份证号的时候把它倒过来存，每次查询的时候：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> field list <span class="keyword">from</span> teacher <span class="keyword">where</span> id_card<span class="operator">=</span>reverse(input_id_card_string);</span><br></pre></td></tr></table></figure><p>由于身份证号的最后 6 位没有地址码这样的重复逻辑，所以最后这 6 位很可能就提供了足够的区分度。当然，实践中你还要使用 count(distinct) 方法去做验证。</p><p><strong>第二种方式是使用 hash 字段。</strong>你可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">add</span> id_card_crc <span class="type">int</span> unsignedadd index(id_card_crc);</span><br></pre></td></tr></table></figure><p>然后每次插入新记录的时候，都同时用 crc32() 这个函数得到校验码填到这个新字段，由于校验码可能存在冲突，也就是说两个不同的身份证号通过 crc32() 函数得到的结果可能是相同的，所以你的查询语句 where 部分要判断 id_card 的值是否精确相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> field list <span class="keyword">from</span> twhere id_card_rc<span class="operator">=</span>crc32(input_id_card_string) <span class="keyword">and</span> id_card<span class="operator">=</span>input id_card_string</span><br></pre></td></tr></table></figure><p>这样，索引的长度变成了4个字节，比原来小了很多。</p><blockquote><p>从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些，因为 crc32 算出来的值虽然有冲突的概率但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</p></blockquote><h2 id="10-索引下推"><a href="#10-索引下推" class="headerlink" title="10. 索引下推"></a>10. 索引下推</h2><p>Index Condition Pushdown(ICP) 是 MySQL 5.6 中新特性，是一种&#x3D;&#x3D;在存储引擎层使用索引过滤数据&#x3D;&#x3D;的一种优化方式。ICP 可以&#x3D;&#x3D;减少存储引擎访问基表的次数以及 MySQL 服务器访问存储引擎的次数&#x3D;&#x3D;。</p><h3 id="10-1-使用前后对比"><a href="#10-1-使用前后对比" class="headerlink" title="10.1 使用前后对比"></a>10.1 使用前后对比</h3><p><strong>在不使用 ICP 索引扫描的过程：</strong></p><ul><li>storage 层：只将满足 index key 条件的索引记录对应的整行记录取出，返回给 server 层</li><li>server 层：对返回的数据，使用后面的 where 条件过滤，直至返回最后一行。</li></ul><p><strong>使用 ICP 扫描的过程：</strong></p><ul><li>storage层：首先将 index key 条件满足的索引记录区间确定，然后在索引上使用 index filter 进行过滤。将满足的 index filter 条件的索引记录才去回表取出整行记录返回 server 层。不满足 index filter 条件的索引记录丢弃，不回表、也不会返回 server 层。</li><li>server 层：对返回的数据，使用 table filter 条件做最后的过滤。</li></ul><p><strong>使用前后的成本差别：</strong></p><ul><li>使用前，存储层多返回了需要被 index filter 过滤掉的整行记录</li><li>使用 ICP 后，直接就去掉了不满足 index filter 条件的记录，省去了他们回表和传递到 server 层的成本。</li><li>ICP 的加速效果取决于在存储引擎内通过 ICP 筛选掉的数据的比例。</li></ul><blockquote><p>索引中包含这个字段，但是没有使用到这个字段的索引(比如‘%a%’)，却可以使用这个字段在索引中进行条件过滤，从而减少回表的记录条数，这种情况就叫做索引下推</p></blockquote><h3 id="10-2-ICP-的开启、关闭"><a href="#10-2-ICP-的开启、关闭" class="headerlink" title="10.2 ICP 的开启、关闭"></a>10.2 ICP 的开启、关闭</h3><ul><li>默认情况下启用索引条件下推。可以通过设置系统变量 <code>optimizer_switch </code>控制 <code>indexcondition_pushdown</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#关闭索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch<span class="operator">=</span>index_condition_pushdown<span class="operator">=</span>off;</span><br><span class="line"></span><br><span class="line">#打开索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizerswitch<span class="operator">=</span>indexcondition_pushdown<span class="operator">=</span><span class="keyword">on</span>;</span><br></pre></td></tr></table></figure><ul><li>当使用索引条件下推时，<code>EXPLAIN</code>语句输出结果中<code>Extra</code>列内容显示为<code>Using index condition</code></li></ul><h3 id="10-3-ICP-使用案例"><a href="#10-3-ICP-使用案例" class="headerlink" title="10.3 ICP 使用案例"></a>10.3 ICP 使用案例</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301620330.png" alt="image-20220828212345673"></p><p>为该表定义联合索引 <code>zip_last_first(zipcode, lastname, firstname)</code> 。如果我们知道了一个人的邮编，但是不确定这个人的姓氏，我们可以进行如下检索:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> people</span><br><span class="line"><span class="keyword">WHERE</span> zipcode<span class="operator">=</span> <span class="string">&#x27;000001&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> address <span class="keyword">LIKE</span> <span class="string">&#x27;%北京市%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行查看SQL的查询计划，Extra 中显示了<code>Using index condition</code> ，这表示使用了索引下推。即：先使用索引的zipcode字段进行匹配，然后 &#x3D;&#x3D;索引下推&#x3D;&#x3D; 使用lastname字段进行过滤，最后再进行回表。</p><p>另外，Using where表示条件中包含需要过滤的非索引列的数据，即address LIKE ‘%北京市%’这个条件并不是索引列，需要在服务端过滤掉。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301617739.png" alt="image-20220828220045412"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301617764.png" alt="image-20220828212600518"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301617290.png" alt="image-20220828212715729"></p><h3 id="11-4-开启和关闭ICP的性能对比"><a href="#11-4-开启和关闭ICP的性能对比" class="headerlink" title="11.4 开启和关闭ICP的性能对比"></a>11.4 开启和关闭ICP的性能对比</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301617811.png"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301617219.png" alt="image-20220828213739703"></p><p>结果如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301617611.png" alt="image-20220828213847767"></p><p>多次测试效率对比来看，使用ICP优化的查询效率会好一些。这里建议多存储一些数据效果更明显。</p><h3 id="10-5-ICP-的使用条件"><a href="#10-5-ICP-的使用条件" class="headerlink" title="10.5 ICP 的使用条件"></a>10.5 ICP 的使用条件</h3><ol><li>只能用于二级索引（secondary index）</li><li>explain 显示的执行计划中 type 值（join 类型）为 <code>range</code> 、 <code>ref</code> 、 <code>eq_ref</code> 或者 <code>ref_or_null</code> 。</li><li>并非全部 where 条件都可以用 ICP 筛选，如果 where 条件的字段不在索引列中，还是要读取整表的记录到 server 端做 where 过滤。</li><li>ICP 可以用于 MyISAM 和 InnnoDB 存储引擎</li><li>MySQL 5.6 版本的不支持分区表的 ICP 功能，5.7 版本的开始支持。</li><li>当 SQL 使用覆盖索引时，不支持 ICP 优化方法。</li></ol><h2 id="11-普通索引-vs-唯一索引"><a href="#11-普通索引-vs-唯一索引" class="headerlink" title="11. 普通索引 vs 唯一索引"></a>11. 普通索引 vs 唯一索引</h2><p>在不同的业务场景下，应该选择普通索引，还是唯一索引？</p><p>假设你在维护一个居民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写入两个重复的身份证号。如果居民系统需要按照身份证号查姓名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> CUser <span class="keyword">where</span> id_card<span class="operator">=</span><span class="string">&#x27;xxxxxxxyyyyyyzzzzz&#x27;</span>;</span><br></pre></td></tr></table></figure><p>所以，你一定会考虑在 id_card 字段上建索引。<br>由于身份证号字段比较大，不建议把身份证号当做主键。现在有两个选择，要么给 id_card 字段创建 唯一素引，要么创建一个普通索引。如果业务代码已经保证了不会写入重复的身份证号，那么这两个选择逻辑上都是正确的。</p><p>你知道的，InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB中，每个数据页的大小默认是16KB</p><p><strong>从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什么呢？</strong></p><p>假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引，假设字段 k 上的值都不重复。 这个表的建表语句是:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> test(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    k <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">    index (k)</span><br><span class="line">)engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)。</p><h3 id="11-1-查询过程"><a href="#11-1-查询过程" class="headerlink" title="11.1 查询过程"></a>11.1 查询过程</h3><p>假设，执行查询的语句是 <code>select id from test where k=5</code>。</p><ul><li>对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一 个不满足k&#x3D;5条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li></ul><p>那么，这个不同带来的性能差距会有多少呢？答案是， <code>微乎其微</code>。</p><p>你知道的，InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB</p><p>因为引擎是按页读写的，所以说，当找到 k&#x3D;5 的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p><p>当然，如果 k&#x3D;5 这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。</p><p>但是，我们之前计算过，对于整型字段，一个数据页可以放近千个 key，因此出现这种情况的概率会很低。所以我们计算平均性能差异时，仍可以认为这个操作成本对于现在的 CPU 来说可以忽略不计。</p><h3 id="11-2-更新过程"><a href="#11-2-更新过程" class="headerlink" title="11.2 更新过程"></a>11.2 更新过程</h3><p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，介绍一下 change buffer。</p><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话， 在不影响数据一致性的前提下，<code>InooDB 会将这些更新操作缓存在 change buffer 中</code> ，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 <code>merge</code>。除了 <code>访问这个数据页</code> 会触发 merge 外，系统有 <code>后台线程会定期</code> merge。在 <code>数据库正常关闭（shutdown）</code> 的过程中，也会执行 merge 操作。</p><p>如果能够将更新操作先记录在 change buffer， <code>减少读磁盘</code> ，语句的执行速度会得到明显的提升。而且， 数据读入内存是需要占用 buffer pool 的，所以这种方式还能够 <code>避免占用内存</code> ，提高内存利用率。</p><p><strong>那么，什么条件下可以使用 change buffer 呢？</strong></p><p>对干唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4.400) 这个记录，就要先判断现在表中是否已经存在 k&#x3D;4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。</p><p>因此，&#x3D;&#x3D;唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用&#x3D;&#x3D;。</p><p>change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数<code>innodb change buffer maxsize</code> 来动态设置。这个参数设置为 50 的时候，表示 changebuffer 的大小最多只能占用 buffer pool 的 50%。</p><p><strong>如果要在这张表中插入一个新记录 (4,400) 的话，InnoDB的处理流程是怎样的？</strong></p><p>第一种情况是，这个记录要更新的目标页在内存中。这时：</p><ul><li>对干唯一索引来说，找到 3 和 5 之间的位置，判断为没有冲突，插入这个值，语句执行结束</li><li>对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。</li></ul><p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的CPU时间。</p><p>第二种情况是，这个记录要更新的目标页不在内存中。这时：</p><ul><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束;</li><li>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</li></ul><p>&#x3D;&#x3D;将数据从磁盘读入内存涉及随机 I&#x2F;O 的访问，是数据库里面成本最高的操作之一&#x3D;&#x3D;。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><blockquote><p>案例：</p><p>某个业务的库内存命中率突然从 99% 降低到了 75%，整个系统处于阻塞状态，更新语句全部堵住。而探究其原因后，发现这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引。</p></blockquote><h3 id="11-3-change-buffer的使用场景"><a href="#11-3-change-buffer的使用场景" class="headerlink" title="11.3 change buffer的使用场景"></a>11.3 change buffer的使用场景</h3><p>change buffer 只限于用在普通索引的场景下，而不适用于唯一索引。那么，现在有一个问题就是：<strong>普通索引的所有场景，使用 change buffer 都可以起到加速作用吗？</strong></p><p>因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是&#x3D;&#x3D;将记录的变更动作缓存下来&#x3D;&#x3D;，所以&#x3D;&#x3D;在一个数据页做 merge 之前，change buffer 记录的变更越多&#x3D;&#x3D;（也就是这个页面上要更新的次数越多），&#x3D;&#x3D;收益就越大&#x3D;&#x3D;。</p><p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是<code>账单类、日志类</code>的系统。</p><p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，之后由干马上要访问这个数据页，会立即触发 merge 过程，这样随机访问 I&#x2F;O 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，changebuffer 反而起到了副作用。</p><ol><li>普通索引和唯一索引应该怎么选择？其实，这两类索引在查询能力上是没差别的，主要考虑的是对 <code>更新性能</code> 的影响。所以，建议你 <code>尽量选择普通索引</code> 。</li><li>在实际使用中会发现， <code>普通索引</code> 和 <code>change buffer</code> 的配合使用，对于 <code>数据量大</code> 的表的更新优化还是很明显的。</li><li>如果所有的更新后面，都马上 <code>伴随着对这个记录的查询</code>，那么你应该关闭<code>change buffer</code> 。而在其他情况下，change buffer 都能提升更新性能。</li><li>由于唯一索引用不上 change buffer 的优化机制，因此如果 <code>业务可以接受</code> ，从性能角度出发建议优先考虑非唯一索引。但是如果”业务可能无法确保”的情况下，怎么处理呢？<ul><li>首先， <code>业务正确性优先</code> 。我们的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。 这种情况下，本节的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，给你多提供一个排查思路。</li><li>然后，在一些“<code>归档库</code> ”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半年， 然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率， 可以考虑把表里面的唯一索引改成普通索引。</li></ul></li></ol><h2 id="12-其它查询优化策略"><a href="#12-其它查询优化策略" class="headerlink" title="12. 其它查询优化策略"></a>12. 其它查询优化策略</h2><h3 id="12-1-EXISTS-和-IN-的区分"><a href="#12-1-EXISTS-和-IN-的区分" class="headerlink" title="12.1 EXISTS 和 IN 的区分"></a>12.1 EXISTS 和 IN 的区分</h3><p><strong>问题：</strong></p><p>不太理解哪种情况下应该使用 EXISTS，哪种情况应该用 IN。选择的标准是看能否使用表的索引吗?</p><p>回答:</p><p>索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为 <code>小表驱动大表</code>。在这种方式下效率是最高的。</p><p>比如下面这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> cc <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B <span class="keyword">WHERE</span> B.cc <span class="operator">=</span> A.cc)</span><br></pre></td></tr></table></figure><p>当 A 小于 B 时，用 EXISTS。因为 EXISTS 的实现，相当于外表循环，实现的逻辑类似于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in A</span><br><span class="line">    <span class="keyword">for</span> j in B</span><br><span class="line">        <span class="keyword">if</span> j.cc == i.cc then ...</span><br></pre></td></tr></table></figure><p>当 B 小于 A 时用 IN，因为实现的逻辑类似于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in B</span><br><span class="line">    <span class="keyword">for</span> j in A</span><br><span class="line">        <span class="keyword">if</span> j.cc == i.cc then ...</span><br></pre></td></tr></table></figure><p>结论：<strong>哪个表小就用哪个表来驱动，A 表小就用 EXISTS ，B 表小就用 IN</strong></p><h3 id="12-2-COUNT-与-COUNT-具体字段-效率"><a href="#12-2-COUNT-与-COUNT-具体字段-效率" class="headerlink" title="12.2 COUNT(*) 与 COUNT(具体字段) 效率"></a>12.2 COUNT(*) 与 COUNT(具体字段) 效率</h3><p>问：在MySQL中统计数据表的行数，可以使用三种方式 <code>SELECT COUNT(*)</code>、<code>SELECT COUNT(1)</code> 和 <code>SELECT COUNT(具体字段)</code>，使用这三者之间的查询效率是怎样的？</p><p>答：</p><p>前提：如果你要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。</p><p><strong>环节1：</strong><code>COUNT(*)</code> 和 <code>COUNT(1)</code> 都是对所有结果进行 COUNT，COUNT(*) 和 COUNT(1) 本质上并没有区别（二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的）。如果有 WHERE 子句，则是对所有符合筛选条件的数据行进行统计；如果没有 WHERE 子句，则是对数据表的数据行数进行统计。</p><p><strong>环节2：</strong>如果是 MvlSAM 存储引擎，统计数据表的行数只需要 O(1)的复杂度，这是因为每张MvlSAM 的数据表都有一个 meta 信息存储了 row_count 值，而一致性则由表级锁来保证。</p><p>如果是 InnoDB 存储引擎，因为 InnoDB 支持事务，采用行级锁和 MVCC 机制，所以无法像 MyISAM 一样，维护一个 row_count 变量，因此需要采用扫描全表，是 O(n) 的复杂度，进行循环+计数的方式来完成统计。</p><p><strong>环节3：</strong>在 InnoDB 引擎中，如果采用 COUNT(具体字段) 来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引。对于 <code>COUNT(*)</code> 和<code>COUNT(1)</code> 来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。</p><p>如果有多个二级索引，会使用 keylen 小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p><h3 id="12-3-关于-SELECT"><a href="#12-3-关于-SELECT" class="headerlink" title="12.3 关于 SELECT(*)"></a>12.3 关于 SELECT(*)</h3><p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用 SELECT &lt;字段列表&gt; 查询。原因：</p><ol><li>MySQL 在解析的过程中，会通过 <code>查询数据字典</code> 将”*”按序转换成所有列名，这会大大的耗费资源和时间。</li><li>无法使用 <code>覆盖索引</code></li></ol><h3 id="12-4-LIMIT-1-对优化的影响"><a href="#12-4-LIMIT-1-对优化的影响" class="headerlink" title="12.4 LIMIT 1 对优化的影响"></a>12.4 LIMIT 1 对优化的影响</h3><p>针对的是会扫描全表的SQL语句，如果你可以确定结果集只有一条，那么加上 <code>LIMIT 1</code> 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p><p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上 <code>LIMIT 1</code>了。</p><h3 id="12-5-多使用COMMIT"><a href="#12-5-多使用COMMIT" class="headerlink" title="12.5 多使用COMMIT"></a>12.5 多使用COMMIT</h3><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。</p><p>COMMIT 所释放的资源:</p><ul><li>回滚段上用于恢复数据的信息</li><li>被程序语句获得的锁</li><li>redo &#x2F; undo log buffer 中的空间</li><li>管理上述 3 种资源中的内部花费</li></ul><h2 id="13-淘宝数据库，主键如何设计的"><a href="#13-淘宝数据库，主键如何设计的" class="headerlink" title="13. 淘宝数据库，主键如何设计的?"></a>13. 淘宝数据库，主键如何设计的?</h2><p>聊一个实际问题：淘宝的数据库，主键是如何设计的？</p><p>某些错的离谱的答案还在网上年复一年的流传着，甚至还成为了所谓的 MySQL 军规。其中，一个最明显的错误就是关于 MySQL 的主键设计。</p><p>大部分人的回答如此自信：用8字节的 BIGINT 做主键，而不要用INT。<code>错</code>!</p><p>这样的回答，只站在了数据库这一层，而没有 <code>从业务的角度</code> 思考主键。主键就是一个自增 ID 吗？站在 2022 年的新年档口，用自增做主键，架构设计上可能 <code>连及格都拿不到</code>。</p><h3 id="13-1-自增ID的问题"><a href="#13-1-自增ID的问题" class="headerlink" title="13.1 自增ID的问题"></a>13.1 自增ID的问题</h3><p>自增 ID 做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增 ID 除了简单，其他都是缺点，总体来看存在以下几方面的问题：</p><p><font color=blue><strong>1. 可靠性不高</strong></font></p><p>存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。</p><p><font color=blue><strong>2. 安全性不高</strong></font></p><p>对外暴露的接口可以非常容易猜测对应的信息。比如：&#x2F;User&#x2F;1&#x2F; 这样的接口，可以非常容易猜测用户ID的值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。</p><p><font color=blue><strong>3. 性能差</strong></font></p><p>自增 ID 的性能较差，需要在数据库服务器端生成。</p><p><font color=blue><strong>4. 交互多</strong></font></p><p>业务还需要额外执行一次类似 <code>last_insert_id()</code> 的函数才能知道刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。</p><p><font color=blue><strong>5. 局部唯一性</strong></font></p><p>最重要的一点，自增 ID 是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都是唯一的。对于目前分布式系统来说，这简直就是噩梦。</p><h3 id="13-2-业务字段做主键"><a href="#13-2-业务字段做主键" class="headerlink" title="13.2 业务字段做主键"></a>13.2 业务字段做主键</h3><p>为了能够唯一地标识一个会员的信息，需要为 <code>会员信息表</code> 设置一个主键。那么，怎么为这个表设置主键，才能达到我们理想的目标呢? 这里我们考虑业务字段做主键。 表数据如下:</p><p>在这表里，哪个字段比较合适呢?</p><ul><li><strong>选择卡号(cardno)</strong></li></ul><p>会员卡号（cardno）看起来比较合适，因为会员卡号不能为空，而且有唯一性，可以用来标识一条会员记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo.membermaster</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> (</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> cardno <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">PRIMARY</span> KEY, <span class="comment">-- 会员卡号为主键 -&gt; membername TEXT,</span></span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> memberphone TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> memberpid TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> memberaddress TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> sex TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> birthday DATETIME</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> );</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.06</span> sec)</span><br></pre></td></tr></table></figure><p>不同的会员卡号对应不同的会员，字段“cardno”唯一地标识某一个会员。如果都是这样，会员卡号与会员一一对应，系统是可以正常运行的。</p><p>但实际情况是， <code>会员卡号可能存在重复使用</code> 的情况。比如，张三因为工作变动搬离了原来的地址，不再到商家的门店消费了 (退还了会员卡)，于是张三就不再是这个商家门店的会员了。但是，商家不想让 这个会 员卡空着，就把卡号是“10000001”的会员卡发给了王五。</p><p>从系统设计的角度看，这个变化只是修改了会员信息表中的卡号是“10000001”这个会员 信息，并不会影响到数据一致性。也就是说，修改会员卡号是“10000001”的会员信息， 系统的各个模块，都会获取到修改后的会员信息，不会出现“有的模块获取到修改之前的会员信息，有的模块获取到修改后的会员信息， 而导致系统内部数据不一致”的情况。因此，从 <code>信息系统层面</code> 上看是没问题的。</p><p>但是从使用系统的业务层面 来看，就有很大的问题 了，会对商家造成影响。</p><p>比如，我们有一个销售流水表(trans)，记录了所有的销售流水明细。2020 年 12 月 01 日，张三在门店购买了一本书，消费了 89 元。那么，系统中就有了张三买书的流水记录，如下所示:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301617739.png" alt="image-20220829162818316"></p><p>接着，我们查询一下 2020 年 12 月 01 日的会员销售记录:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> demo.trans <span class="keyword">AS</span> a</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">JOIN</span> demo.membermaster <span class="keyword">AS</span> b</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">JOIN</span> demo.goodsmaster <span class="keyword">AS</span> c</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> (a.cardno <span class="operator">=</span> b.cardno <span class="keyword">AND</span> a.itemnumber<span class="operator">=</span>c.itemnumber); </span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+ </span></span><br><span class="line"><span class="operator">|</span> membername <span class="operator">|</span> goodsname <span class="operator">|</span> quantity <span class="operator">|</span> salesvalue <span class="operator">|</span>           transdate <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+ </span></span><br><span class="line"><span class="operator">|</span> 张三        <span class="operator">|</span>        书 <span class="operator">|</span>    <span class="number">1.000</span> <span class="operator">|</span>      <span class="number">89.00</span> <span class="operator">|</span> <span class="number">2020</span><span class="number">-12</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+ </span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>如果会员卡“10000001”又发给了王五，我们会更改会员信息表。导致查询时:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> demo.trans <span class="keyword">AS</span> a</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">JOIN</span> demo.membermaster <span class="keyword">AS</span> b</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">JOIN</span> demo.goodsmaster <span class="keyword">AS</span> c</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> (a.cardno <span class="operator">=</span> b.cardno <span class="keyword">AND</span> a.itemnumber<span class="operator">=</span>c.itemnumber); </span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+ </span></span><br><span class="line"><span class="operator">|</span> membername <span class="operator">|</span> goodsname <span class="operator">|</span> quantity <span class="operator">|</span> salesvalue <span class="operator">|</span> transdate           <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+ </span></span><br><span class="line"><span class="operator">|</span> 王五        <span class="operator">|</span>        书 <span class="operator">|</span>    <span class="number">1.000</span> <span class="operator">|</span>      <span class="number">89.00</span> <span class="operator">|</span> <span class="number">2020</span><span class="number">-12</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+ </span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>这次得到的结果是：王五在 2020 年 12 月 01 日，买了一本书，消费 89 元。显然是错误的!结论：千万不能把会员卡号当做主键。</p><ul><li><strong>选择会员电话或身份证号</strong></li></ul><p>会员电话可以做主键吗？不行的。在实际操作中，手机号也存在 <code>被运营商收回</code> ，重新发给别人用的情况。</p><p>那身份证号行不行呢？好像可以。因为身份证决不会重复，身份证号与一个人存在一一对 应的关系。可问题是，身份证号属于 <code>个人隐私</code> ，顾客不一定愿意给你。要是强制要求会员必须登记身份证号，会把很多客人赶跑的。其实，客户电话也有这个问题，这也是我们在设计会员信息表的时候，允许身份证号和电话都为空的原因。</p><p><strong>所以，建议尽量不要用跟业务有关的字段做主键。毕竟，作为项目设计的技术人员，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现。</strong></p><blockquote><p>经验:</p><p>刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。</p></blockquote><h3 id="13-3-淘宝的主键设计"><a href="#13-3-淘宝的主键设计" class="headerlink" title="13.3 淘宝的主键设计"></a>13.3 淘宝的主键设计</h3><p>在淘宝的电商业务中，订单服务是一个核心业务。请问， <code>订单表的主键</code> 淘宝是如何设计的呢？是自增ID吗？</p><p>打开淘宝，看一下订单信息：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301617124.png" alt="image-20220829163123686"></p><p>从上图可以发现，订单号不是自增ID!我们详细看下上述4个订单号:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1550672064762308113</span><br><span class="line">1481195847180308113</span><br><span class="line">1431156171142308113</span><br><span class="line">1431146631521308113</span><br></pre></td></tr></table></figure><p>订单号是 19 位的长度，且订单的最后 5 位都是一样的，都是 08113。且订单号的前面 14 位部分是单调递增的。</p><p>大胆猜测，淘宝的订单 ID 设计应该是：<code>订单ID = 时间 + 去重字段 + 用户ID后6位尾号</code></p><p>这样的设计能做到全局唯一，且对分布式系统查询及其友好。</p><h3 id="13-4-推荐的主键设计"><a href="#13-4-推荐的主键设计" class="headerlink" title="13.4 推荐的主键设计"></a>13.4 推荐的主键设计</h3><p><code>非核心业务</code>：对应表的主键自增 ID，如告警、日志、监控等信息。</p><p><code>核心业务</code>：<strong>主键设计至少应该是全局唯一且是单调递增</strong>。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。</p><p>这里推荐最简单的一种主键设计：UUID。</p><p><strong>UUID的特点:</strong></p><p>全局唯一，占用 36 字节，数据无序，插入性能差。</p><p><strong>认识UUID:</strong></p><ul><li>为什么UUID是全局唯一的?</li><li>为什么UUID占用36个字节?</li><li>为什么UUID是无序的?</li></ul><p>MySQL数据库的UUID组成如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID = 时间 + UUID 版本（16字节）- 时钟序列（4字节） - MAC 地址（12字节）</span><br></pre></td></tr></table></figure><p>我们以 UUID 值：e0ea12d4-6473-11eb-943c-00155dbaa39d 举例</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301618227.png" alt="image-20220830155849839"></p><p><strong><font color=blue>1. 为什么UUID是全局唯一的？</font></strong></p><p>在 UUID 中时间部分占用 60 位，存储的类似 TIMESTAMP 的时间戳，但表示的是从1582-10-15 00:00:00.00 到现在的 100 ns 的计数。可以看到 UUID 存储的时间精度比 TIMESTAMPE 更高，时间维度发生重复的概率降低到1&#x2F;100ns。</p><p>时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。</p><p><strong><font color=blue>2. 为什么UUID占用36个字节？</font></strong></p><p>UUID 根据字符串进行存储，设计时还带有无用”-“字符串，因此总共需要36个字节。</p><p><strong><font color=blue>3. 为什么UUID是随机无序的呢？</font></strong></p><p>因为 UUID 的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</p><p><font color=red><strong>改造UUID</strong></font></p><p>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0 可以更换时间低位和时间高位的存储方式，这样 UUID 就是有序的UUID了。</p><p>MySQL 8.0 还解决了 UUID 存在的空间占用的问题，除去了 UUID 字符串中无意义的”-“字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。</p><p>可以通过 MySQL 8.0 提供的 uuid_to_bin 函数实现上述功能，同样的，MySQL 也提供了 bin_to_uuid 函数进行 转化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@uuid</span> <span class="operator">=</span> UUID();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@uuid</span>,uuid_to_bin(<span class="variable">@uuid</span>),uuid_to_bin(<span class="variable">@uuid</span>,<span class="literal">TRUE</span>);</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301618354.png" alt="image-20220118215859456"></p><p><strong>通过函数 <code>uuid_to_bin(@uuid,true)</code> 将 UUID 转化为有序 UUID 了</strong>。&#x3D;&#x3D;全局唯一 + 单调递增&#x3D;&#x3D;，这不就是我们想要的主键！</p><h3 id="13-5-有序-UUID-性能测试"><a href="#13-5-有序-UUID-性能测试" class="headerlink" title="13.5 有序 UUID 性能测试"></a>13.5 有序 UUID 性能测试</h3><p>16 字节的有序 UUID，相比之前 8 字节的自增ID，性能和存储空间对比究竟如何呢？</p><p>我们来做一个测试，插入 1 亿条数据，每条数据占用 500 字节，含有 3 个二级索引，最终的结果如下所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208301618602.png" alt="image-20220830155246358"></p><p>从上图可以看到插入 1 亿条数据有序 UUID 是最快的，而且在实际业务使用中有序 UUID 在 <code>业务端就可以生成</code> 。还可以进一步减少 SQL 的交互次数。</p><p>另外，虽然有序 UUID 相比自增 ID 多了 8 个字节，但实际只增大了 3G 的存储空间，还可以接受。</p><blockquote><p>在当今的互联网环境中，非常不推荐自增 ID 作为主键的数据库设计。更推荐类似有序 UUID 的全局唯一的实现。</p><p>另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样的主键设计就更为考验架构师的水平了。</p></blockquote><p><strong>如果不是 MySQL8.0 肿么办?</strong></p><p>手动赋值字段做主键！</p><p>比如，设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。</p><p>可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。</p><p>门店在添加会员的时候，先到总部 MySQL 数据库中获取这个最大值，在这个基础上加 1，然后用这个值作为新会员的“id”同时，更新总部 MySQL 数据库管理信息表中的当前会员编号的最大值。</p><p>这样一来，各个门店添加会员的时候，都对同一个总部 MySQL 数据库中的数据表字段进行操作，就解决了各门店添加会员时会员编号冲突的问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七、性能分析工具的使用</title>
      <link href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC07%E7%AB%A0_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC07%E7%AB%A0_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>在数据库调优中，我们的目标就是<code>响应时间更快，吞吐量更大</code>。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式</p><h1 id="1-数据库服务器的优化步骤"><a href="#1-数据库服务器的优化步骤" class="headerlink" title="1. 数据库服务器的优化步骤"></a>1. 数据库服务器的优化步骤</h1><p>当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。</p><p>整个流程划分成了<code> 观察（Show status）</code> 和 <code>行动（Action）</code> 两个部分。字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150030458.png" alt="image-20220811114111312"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150030400.png"><br><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150030169.png" alt="image-20220811114145753"></p><p>可以看到数据库调优的步骤中越往金字塔尖走，其成本越高，效果越差，因此我们在数据库调优的过程中，要重点把握金字塔底部的 &#x3D;&#x3D;sql 及索引调优，数据库表结构调优，系统配置参数调优&#x3D;&#x3D;等软件层面的调优</p><h1 id="2-查看系统性能参数"><a href="#2-查看系统性能参数" class="headerlink" title="2. 查看系统性能参数"></a>2. 查看系统性能参数</h1><p>可以使用 <code>SHOW STATUS</code> 语句查询一些数据库服务器的&#x3D;&#x3D;性能参数和使用频率&#x3D;&#x3D;。</p><p>其语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span>][SESSION] STATUES <span class="keyword">LIKE</span> <span class="string">&#x27;参数&#x27;</span>;</span><br></pre></td></tr></table></figure><p>一些常用的性能参数如下：</p><p>•<code>Connections</code>：连接MySQL服务器的次数。<br>•<code>Uptime</code>：MySQL服务器的上线时间。<br>•<code>Slow_queries</code>：慢查询的次数。<br>•<code>Innodb_rows_read</code>：Select查询返回的行数<br>•<code>Innodb_rows_inserted</code>：执行INSERT操作插入的行数<br>•<code>Innodb_rows_updated</code>：执行UPDATE操作更新的行数<br>•<code>Innodb_rows_deleted</code>：执行DELETE操作删除的行数<br>•<code>Com_select</code>：查询操作的次数。<br>•<code>Com_insert</code>：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。<br>•<code>Com_update</code>：更新操作的次数。<br>•<code>Com_delete</code>：删除操作的次数。</p><p>举例：</p><ul><li>若查询MySQL服务器的连接次数，则可以执行如下语句：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE &#x27;Connections&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Connections   | 34    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>若查询服务器工作时间，则可以执行如下语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Uptime&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Uptime        <span class="operator">|</span> <span class="number">332933</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>若查询MySQL服务器的慢查询次数，则可以执行如下语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Slow_queries&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Slow_queries  <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>注：慢查询次数参数可以结合慢查询日志找出慢查询语句，然后针对慢查询语句进行 <code>表结构优化</code> 或者<code>查询语句优化</code></p><ul><li>查看存储引擎增删改查的行数，则可以执行如下语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_rows_%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name        <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Innodb_rows_deleted  <span class="operator">|</span> <span class="number">0</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_rows_inserted <span class="operator">|</span> <span class="number">1000902</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_rows_read     <span class="operator">|</span> <span class="number">37011100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_rows_updated  <span class="operator">|</span> <span class="number">0</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h1 id="3-统计-SQL-的查询成本：last-query-cost"><a href="#3-统计-SQL-的查询成本：last-query-cost" class="headerlink" title="3. 统计 SQL 的查询成本：last_query_cost"></a>3. 统计 SQL 的查询成本：last_query_cost</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150030464.png" alt="image-20220811122857202"></p><p>我们依然使用student_info表为例（具体库表创建以及生成数据语句请参考上一篇章）</p><p>①如果我们想要查询 id&#x3D;900001 的记录，我们可以直接在聚簇索引上进行查找：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM student_info WHERE id = 900001;</span><br><span class="line">+--------+------------+--------+-----------+----------+---------------------+</span><br><span class="line">| id     | student_id | name   | course_id | class_id | create_time         |</span><br><span class="line">+--------+------------+--------+-----------+----------+---------------------+</span><br><span class="line">| 900001 |     154633 | SYnwsA |     10019 |    10134 | 2022-08-08 22:33:02 |</span><br><span class="line">+--------+------------+--------+-----------+----------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>然后再看下查询优化器的成本，实际上我们只需要检索一个页即可。<code>Value</code>表示 I&#x2F;O 加载的数据页的页数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE &#x27;last_query_cost&#x27;;</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Last_query_cost | 1.000000 |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>②我们扩大下查询范围，student_id&gt; 199900的学生记录呢？运行时间 0.01s，这时我们大概需要进行 232个页的查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student_info <span class="keyword">WHERE</span> student_id <span class="operator">&gt;</span> <span class="number">199900</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+--------+-----------+----------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> id     <span class="operator">|</span> student_id <span class="operator">|</span> name   <span class="operator">|</span> course_id <span class="operator">|</span> class_id <span class="operator">|</span> create_time         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+--------+-----------+----------+---------------------+</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>...</span><br><span class="line"><span class="operator">|</span> <span class="number">523982</span> <span class="operator">|</span>     <span class="number">200000</span> <span class="operator">|</span> vcaUvw <span class="operator">|</span>     <span class="number">10010</span> <span class="operator">|</span>    <span class="number">10173</span> <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">32</span>:<span class="number">31</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+--------+-----------+----------+---------------------+</span></span><br><span class="line"><span class="number">516</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+------------+</span></span><br><span class="line"><span class="operator">|</span> Last_query_cost <span class="operator">|</span> <span class="number">232.459000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>③我们再次扩大范围，假若我们想要查询 student_id &gt; 199000的学生记录呢？运行时间 0.02s，这时我们大概需要进行 2279个页的查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student_info <span class="keyword">WHERE</span> student_id <span class="operator">&gt;</span> <span class="number">199000</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>...</span><br><span class="line"><span class="number">5065</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> Last_query_cost <span class="operator">|</span> <span class="number">2279.509000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>不知道大家有没有发现，上面的查询页的数量是刚才的 10倍，但是查询的效率并没有明显的变化，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然页数量（<code>last_query_cost</code>）增加了不少，但是通过缓冲池的机制，并没有增加多少查询时间。</p><p><strong>使用场景：</strong>查询 <code>last_query_cost</code> 对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候</p><blockquote><p>🎈 SQL查询是一个动态的过程，从页加载的角度，我们可以得到以下两点结论：</p><ol><li><strong>位置决定效率</strong>：如果页就在数据库<code>缓冲池</code>中，那么效率是最高的，否则还需要从<code>内存</code>或者<code>磁盘</code>中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。即 &#x3D;&#x3D;数据库缓冲池&gt;内存&gt;磁盘&#x3D;&#x3D;</li><li><strong>批量决定效率</strong>：如果我们从磁盘中单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。即&#x3D;&#x3D;顺序读取&gt;大于随机读取&#x3D;&#x3D;</li></ol><p>所以说，遇到 I&#x2F;O 并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p><p>注：缓冲池和查询缓存并不是一个东西</p></blockquote><h1 id="4-定位执行慢的-SQL：慢查询日志"><a href="#4-定位执行慢的-SQL：慢查询日志" class="headerlink" title="4. 定位执行慢的 SQL：慢查询日志"></a>4. 定位执行慢的 SQL：慢查询日志</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150030839.png" alt="image-20220811155538530"></p><h2 id="4-1-开启慢查询日志"><a href="#4-1-开启慢查询日志" class="headerlink" title="4.1 开启慢查询日志"></a>4.1 开启慢查询日志</h2><p><strong><font color=blue>1. 开启 slow_query_log</font></strong></p><p>查看慢查询日志是否开启，以及日志的位置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name       <span class="operator">|</span> <span class="keyword">Value</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> slow_query_log      <span class="operator">|</span> OFF                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slow_query_log_file <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>hadoop102<span class="operator">-</span>slow.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+-----------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure><p>修改慢查询日志状态为开启，注意这里要加 <code>global</code>，因为它是全局系统变量，否则会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global slow_query_log=&#x27;ON&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure><p>再查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name       <span class="operator">|</span> <span class="keyword">Value</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> slow_query_log      <span class="operator">|</span> <span class="keyword">ON</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slow_query_log_file <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>hadoop102<span class="operator">-</span>slow.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+-----------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p><strong><font color=blue>2. 修改long_query_time阈值</font></strong></p><p>接下来我们来看下慢查询的时间阈值设置，使用如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%long_query_time%&#x27;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>这里如果我们想把时间缩短，比如设置成1秒，可以这样设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效，所以可以一并执行下列语句</span><br><span class="line">mysql&gt; set global long_query_time = 1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set long_query_time = 1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>再查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> long_query_time <span class="operator">|</span> <span class="number">1.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150030579.png" alt="image-20220811165316520"></p><h2 id="4-2-案例演示"><a href="#4-2-案例演示" class="headerlink" title="4.2 案例演示"></a>4.2 案例演示</h2><p><strong><font color=blue>步骤一、建表</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">    `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `stuno` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `age` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `classId` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p><strong><font color=blue>步骤二、 设置参数 log_bin_trust_function_creators</font></strong></p><p>创建函数，假如报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This function has none of DETERMINISTIC......</span><br></pre></td></tr></table></figure><p>命令开启：允许创建函数设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;   # 不加<span class="keyword">global</span>只是当前窗口有效</span><br></pre></td></tr></table></figure><p><strong><font color=blue>步骤三、创建函数</font></strong></p><p>随机产生字符串：(同上一章)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>) #该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">   <span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line">   <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">END</span> WHILE;</span><br><span class="line">  <span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line">#测试</span><br><span class="line"><span class="keyword">SELECT</span> rand_string(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>产生随机数值：（同上一章）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num (from_num <span class="type">INT</span> ,to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span>RAND()<span class="operator">*</span>(to_num <span class="operator">-</span> from_num<span class="operator">+</span><span class="number">1</span>))  ;</span><br><span class="line"><span class="keyword">RETURN</span> i; </span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line">#测试：</span><br><span class="line"><span class="keyword">SELECT</span> rand_num(<span class="number">10</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><strong><font color=blue>步骤四、创建存储过程</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu1(  <span class="keyword">START</span> <span class="type">INT</span> , max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;   #设置手动提交事务</span><br><span class="line">REPEAT  #循环</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;  #赋值</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (stuno, NAME ,age ,classId ) <span class="keyword">VALUES</span></span><br><span class="line">((<span class="keyword">START</span><span class="operator">+</span>i),rand_string(<span class="number">6</span>),rand_num(<span class="number">10</span>,<span class="number">100</span>),rand_num(<span class="number">10</span>,<span class="number">1000</span>)); </span><br><span class="line">UNTIL i <span class="operator">=</span> max_num </span><br><span class="line"><span class="keyword">END</span> REPEAT; </span><br><span class="line"><span class="keyword">COMMIT</span>;  #提交事务</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong><font color=blue>步骤五、调用存储过程</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#调用刚刚写好的函数, <span class="number">4000000</span>条记录,从<span class="number">100001</span>号开始</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CALL</span> insert_stu1(<span class="number">100001</span>,<span class="number">4000000</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">10</span> min <span class="number">47.03</span> sec)</span><br></pre></td></tr></table></figure><p>注意，这个时间会比较长，请耐心等待几分钟哟。结束后可以查询下是不是插入成功了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.82</span> sec)</span><br></pre></td></tr></table></figure><h2 id="4-3-测试及说明"><a href="#4-3-测试及说明" class="headerlink" title="4.3 测试及说明"></a>4.3 测试及说明</h2><p><strong><font color=blue>1. 执行一下下面的查询操作，进行慢查询语句的测试</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 注意：此时long_query_time已经设置为<span class="number">1</span>了哦<span class="operator">~</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno <span class="operator">=</span> <span class="number">3455655</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> id      <span class="operator">|</span> stuno   <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> classId <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3355654</span> <span class="operator">|</span> <span class="number">3455655</span> <span class="operator">|</span> ZfCwDz <span class="operator">|</span>   <span class="number">76</span> <span class="operator">|</span>     <span class="number">228</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">1.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;ZfCwDz&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> id      <span class="operator">|</span> stuno   <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> classId <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">32843</span> <span class="operator">|</span>  <span class="number">132844</span> <span class="operator">|</span> zfcWDZ <span class="operator">|</span>   <span class="number">32</span> <span class="operator">|</span>     <span class="number">304</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">889126</span> <span class="operator">|</span>  <span class="number">989127</span> <span class="operator">|</span> ZfCwDz <span class="operator">|</span>   <span class="number">77</span> <span class="operator">|</span>     <span class="number">249</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2015535</span> <span class="operator">|</span> <span class="number">2115536</span> <span class="operator">|</span> zfcWDZ <span class="operator">|</span>   <span class="number">36</span> <span class="operator">|</span>     <span class="number">459</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3176527</span> <span class="operator">|</span> <span class="number">3276528</span> <span class="operator">|</span> ZFcwdZ <span class="operator">|</span>   <span class="number">81</span> <span class="operator">|</span>     <span class="number">941</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3355654</span> <span class="operator">|</span> <span class="number">3455655</span> <span class="operator">|</span> ZfCwDz <span class="operator">|</span>   <span class="number">76</span> <span class="operator">|</span>     <span class="number">228</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">1.09</span> sec)</span><br></pre></td></tr></table></figure><p>从上面的结果可以看出来，查询学生编号合和姓名花费时间 都在1s以上。已经达到了秒的数量级，说明目前查询效率是非常低的，下面我们分析一下原因</p><p><strong><font color=blue>2. 先查看下慢查询的记录</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;slow_queries&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Slow_queries  <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><blockquote><p>🎯<strong>补充说明：</strong></p><p>在Mysql中，除了上述变量，控制慢查询日志的还有另外一个变量 <code>min_examined_row_limit</code> 。这个变量的意思是，查询<code>扫描过的最少记录数</code>。这个变量和查询执行时间，共同组成了判别一个查询是否慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并且查询执行时间超过 <code>long_query_time</code> 的值，那么这个查询就被记录到慢查询日志中。反之，则不被记录到慢查询日志中。另外，<code>min_examined_row_limit</code> 默认是 0，我们也一般不会去修改它。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">like</span> <span class="string">&#x27;min%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name          <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> min_examined_row_limit <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><p>当这个值为默认值0时，与 long_query_time&#x3D;10合在一起，表示只要查询的执行时间超过10秒钟，哪怕一个记录也没有扫描过，都要被记录到慢查询日志中。你也可以根据需要，通过修改”my.ini”文件，来修改查询时长，或者通过SET指令，用SQL语句修改<code>min_examined_row_limit</code> 的值。</p></blockquote><h2 id="4-4-慢查询日志分析工具：Mysqldumpslow"><a href="#4-4-慢查询日志分析工具：Mysqldumpslow" class="headerlink" title="4.4 慢查询日志分析工具：Mysqldumpslow"></a>4.4 慢查询日志分析工具：Mysqldumpslow</h2><p>在生产环境中，如果要手工分析日志，查找、分析 SQL，显然是个体力活，MySQL 提供了日志分析工具 &#x3D;&#x3D;mysqldumpslow&#x3D;&#x3D;。</p><blockquote><p>📑 注意:<br>1.该工具并不是 MySQL 内置的，不要在 MySQL 下执行，可以直接在根目录或者其他位置执行<br>2.该工具只有 Linux 下才是开箱可用的，实际上生产中mysql数据库一般也是部署在linux环境中的。如果您是windows环境下，可以参考博客<a href="https://www.cnblogs.com/-mrl/p/15770811.html%E3%80%82">https://www.cnblogs.com/-mrl/p/15770811.html。</a></p></blockquote><p>通过 <code>mysqldumpslow </code>可以查看慢查询日志帮助</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow --help</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150030616.png" alt="image-20220812155219680"></p><p>mysqldumpslow 命令的具体参数如下：</p><ul><li>-a: 不将数字抽象成N，字符串抽象成S</li><li><strong><font color=red>-s: 是表示按照何种方式排序：</font></strong><ul><li>c: 访问次数</li><li>l: 锁定时间</li><li>r: 返回记录</li><li><font color=blue>t: 查询时间</font></li><li>al:平均锁定时间</li><li>ar:平均返回记录数</li><li>at:平均查询时间 （默认方式）</li><li>ac:平均查询次数</li></ul></li><li><strong><font color=red>-t: 即为返回前面多少条的数据；</font></strong></li><li><strong><font color=red>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</font></strong></li></ul><p>接下来我们可以找到慢查询日志的位置</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150030118.png" alt="image-20220812160221292"></p><p>举例：我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@hadoop102</span> mysql]# mysqldumpslow <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">5</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>hadoop102<span class="operator">-</span>slow.log </span><br><span class="line"></span><br><span class="line">Reading mysql slow query log <span class="keyword">from</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>hadoop102<span class="operator">-</span>slow.log</span><br><span class="line">Count: <span class="number">1</span>  <span class="type">Time</span><span class="operator">=</span><span class="number">283.29</span>s (<span class="number">283</span>s)  Lock<span class="operator">=</span><span class="number">0.00</span>s (<span class="number">0</span>s)  <span class="keyword">Rows</span><span class="operator">=</span><span class="number">0.0</span> (<span class="number">0</span>), root[root]<span class="variable">@hadoop102</span></span><br><span class="line">  <span class="keyword">CALL</span> insert_stu1(N,N)</span><br><span class="line"></span><br><span class="line">Count: <span class="number">1</span>  <span class="type">Time</span><span class="operator">=</span><span class="number">1.09</span>s (<span class="number">1</span>s)  Lock<span class="operator">=</span><span class="number">0.00</span>s (<span class="number">0</span>s)  <span class="keyword">Rows</span><span class="operator">=</span><span class="number">5.0</span> (<span class="number">5</span>), root[root]<span class="variable">@localhost</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;S&#x27;</span></span><br><span class="line"></span><br><span class="line">Count: <span class="number">1</span>  <span class="type">Time</span><span class="operator">=</span><span class="number">1.03</span>s (<span class="number">1</span>s)  Lock<span class="operator">=</span><span class="number">0.00</span>s (<span class="number">0</span>s)  <span class="keyword">Rows</span><span class="operator">=</span><span class="number">1.0</span> (<span class="number">1</span>), root[root]<span class="variable">@localhost</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno <span class="operator">=</span> N</span><br><span class="line"></span><br><span class="line">Died <span class="keyword">at</span> <span class="operator">/</span>usr<span class="operator">/</span>bin<span class="operator">/</span>mysqldumpslow line <span class="number">162</span>, <span class="operator">&lt;&gt;</span> chunk <span class="number">3.</span></span><br></pre></td></tr></table></figure><p>可以看到上面 sql 中具体的数值类都被N代替，字符串都被使用 S 代替，如果想要显示真实的数据，可以加上参数 <code>-a</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@hadoop102</span> mysql]# mysqldumpslow <span class="operator">-</span>a <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">5</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>hadoop102<span class="operator">-</span>slow.log </span><br><span class="line"></span><br><span class="line">Reading mysql slow query log <span class="keyword">from</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>hadoop102<span class="operator">-</span>slow.log</span><br><span class="line">Count: <span class="number">1</span>  <span class="type">Time</span><span class="operator">=</span><span class="number">283.29</span>s (<span class="number">283</span>s)  Lock<span class="operator">=</span><span class="number">0.00</span>s (<span class="number">0</span>s)  <span class="keyword">Rows</span><span class="operator">=</span><span class="number">0.0</span> (<span class="number">0</span>), root[root]<span class="variable">@hadoop102</span></span><br><span class="line">  <span class="keyword">CALL</span> insert_stu1(<span class="number">100001</span>,<span class="number">4000000</span>)</span><br><span class="line"></span><br><span class="line">Count: <span class="number">1</span>  <span class="type">Time</span><span class="operator">=</span><span class="number">1.09</span>s (<span class="number">1</span>s)  Lock<span class="operator">=</span><span class="number">0.00</span>s (<span class="number">0</span>s)  <span class="keyword">Rows</span><span class="operator">=</span><span class="number">5.0</span> (<span class="number">5</span>), root[root]<span class="variable">@localhost</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;ZfCwDz&#x27;</span></span><br><span class="line"></span><br><span class="line">Count: <span class="number">1</span>  <span class="type">Time</span><span class="operator">=</span><span class="number">1.03</span>s (<span class="number">1</span>s)  Lock<span class="operator">=</span><span class="number">0.00</span>s (<span class="number">0</span>s)  <span class="keyword">Rows</span><span class="operator">=</span><span class="number">1.0</span> (<span class="number">1</span>), root[root]<span class="variable">@localhost</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno <span class="operator">=</span> <span class="number">3455655</span></span><br><span class="line"></span><br><span class="line">Died <span class="keyword">at</span> <span class="operator">/</span>usr<span class="operator">/</span>bin<span class="operator">/</span>mysqldumpslow line <span class="number">162</span>, <span class="operator">&lt;&gt;</span> chunk <span class="number">3.</span></span><br></pre></td></tr></table></figure><p>最后罗列下工作中常用的一些查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到返回记录集最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到访问次数最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure><h2 id="4-5-关闭慢查询日志"><a href="#4-5-关闭慢查询日志" class="headerlink" title="4.5 关闭慢查询日志"></a>4.5 关闭慢查询日志</h2><p>MySQL 服务器停止慢查询日志功能有两种方法：</p><p><strong><font color=blue>方式一：永久性方式</font></strong></p><p>修改my.cnf或my.ini文件，把【mysqld】组下的slow_query_log值设置为OFF，修改保存后，再重启MySQL服务，即可生效。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置文件</span></span><br><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="string">OFF</span></span><br></pre></td></tr></table></figure><p>或者，把slow_query_log一项注释掉 或 删除</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment">#slow_query_log =OFF</span></span><br></pre></td></tr></table></figure><p>重启MySQL服务，执行如下语句查询慢日志功能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow%&#x27;</span>;  #查询慢查询日志所在目录</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;  #查询超时时长</span><br></pre></td></tr></table></figure><p>可以看到，MySQL系统中的慢查询日志是关闭的。</p><p><strong><font color=blue>方式二：临时性方式</font></strong></p><p>使用 SET 语句来设置。<br>（1）停止 MySQL 慢查询日志功能，具体 SQL 语句如下。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SET</span> <span class="string">GLOBAL slow_query_log=off;</span></span><br></pre></td></tr></table></figure><p>（2）<font color=red>重启MySQL服务</font>，使用 SHOW 语句查询慢查询日志功能信息，具体演示如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@hadoop102</span> mysql]# systemctl restart mysqld;</span><br><span class="line">[root<span class="variable">@hadoop102</span> mysql]# mysql <span class="operator">-</span>hlocalhost <span class="operator">-</span>P3306 <span class="operator">-</span>uroot <span class="operator">-</span>p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome <span class="keyword">to</span> the MySQL monitor.  Commands <span class="keyword">end</span> <span class="keyword">with</span> ; <span class="keyword">or</span> \g.</span><br><span class="line">Your MySQL connection id <span class="keyword">is</span> <span class="number">10</span></span><br><span class="line">Server version: <span class="number">8.0</span><span class="number">.25</span> MySQL Community Server <span class="operator">-</span> GPL</span><br><span class="line"></span><br><span class="line">Copyright (c) <span class="number">2000</span>, <span class="number">2021</span>, Oracle <span class="keyword">and</span><span class="operator">/</span><span class="keyword">or</span> its affiliates.</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name             <span class="operator">|</span> <span class="keyword">Value</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> log_slow_admin_statements <span class="operator">|</span> OFF                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_slow_extra            <span class="operator">|</span> OFF                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_slow_slave_statements <span class="operator">|</span> OFF                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slow_launch_time          <span class="operator">|</span> <span class="number">2</span>                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slow_query_log            <span class="operator">|</span> OFF  #慢查询日志已关闭               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slow_query_log_file       <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>hadoop102<span class="operator">-</span>slow.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-----------------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> long_query_time <span class="operator">|</span> <span class="number">10.000000</span> <span class="operator">|</span> #已恢复至默认的 <span class="number">10</span>s</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h2 id="4-6-删除与恢复慢查询日志"><a href="#4-6-删除与恢复慢查询日志" class="headerlink" title="4.6 删除与恢复慢查询日志"></a>4.6 删除与恢复慢查询日志</h2><p>使用SHOW语句显示慢查询日志信息，具体SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name       <span class="operator">|</span> <span class="keyword">Value</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+-----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> slow_query_log      <span class="operator">|</span> <span class="keyword">ON</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slow_query_log_file <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>hadoop102<span class="operator">-</span>slow.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+-----------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>调优结束可以及时删除慢查询日志节省磁盘空间哟，当然手工删除也是可以的</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150030512.png" alt="image-20220812163728793"></p><p>如果误删了，而且还没有了备份，可以使用下面的命令来重新恢复生成哟，执行完毕后会在数据目录下重新生成查询日志文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#先要打开慢查询日志</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line">#恢复慢查询日志</span><br><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs slow</span><br></pre></td></tr></table></figure><blockquote><p>提示</p><p>慢查询日志都是使用<code>mysqladmin -uroot -p flush-logs slow</code> 命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在于新的日志文件中，如果需要旧的查询日志，就必须事先备份。</p></blockquote><h1 id="5-查看-SQL-执行成本：SHOW-PROFILE"><a href="#5-查看-SQL-执行成本：SHOW-PROFILE" class="headerlink" title="5. 查看 SQL 执行成本：SHOW PROFILE"></a>5. 查看 SQL 执行成本：SHOW PROFILE</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150030478.png" alt="image-20220812175708623"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> profiling     <span class="operator">|</span> OFF   <span class="operator">|</span> #当前是关闭状态</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> profiling <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;#开启</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>然后执行相关的查询语句。接着看下当前会话下有哪些profiles</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno <span class="operator">=</span> <span class="number">3455655</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>...</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;ZfCwDz&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>...</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profiles;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Query_ID <span class="operator">|</span> Duration   <span class="operator">|</span> Query                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span> <span class="number">0.00133475</span> <span class="operator">|</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span> <span class="number">0.00021050</span> <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno <span class="operator">=</span> <span class="number">3455655</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">3</span> <span class="operator">|</span> <span class="number">0.00053600</span> <span class="operator">|</span> <span class="keyword">SELECT</span> DATABASE()                           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="number">0.01693325</span> <span class="operator">|</span> <span class="keyword">show</span> databases                              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">5</span> <span class="operator">|</span> <span class="number">0.00375125</span> <span class="operator">|</span> <span class="keyword">show</span> tables                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">6</span> <span class="operator">|</span> <span class="number">1.75597875</span> <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno <span class="operator">=</span> <span class="number">3455655</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">7</span> <span class="operator">|</span> <span class="number">1.11115150</span> <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;ZfCwDz&#x27;</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+---------------------------------------------+</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>你能看到当前会话一共有7个查询，如果我们想要查看最近一次查询的开销，可以使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profile;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150030438.png" alt="image-20220812180852535"></p><p>我们也可以查看指定的Query ID的开销，只需要后面跟上 <code>for num</code>。也可以查看不同部分的开销，比如CPU、block.io等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profile cpu,block io for query 7;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150031520.png" alt="image-20220812181159314"></p><p>通过如果发现上一条 sql 慢的原因在于执行慢（<code>executing</code>字段耗时多），就可以接着用 <code>Explain</code> 进行分析具体的 sql 语句。等后面我们为其建立索引，就可以大大提高效率了</p><p>🔊**<font color=blue>show profile的常用查询参数：</font>**</p><p>① ALL：显示所有的开销信息。<br>② BLOCK IO：显示块 IO 开销。<br>③ CONTEXT SWITCHES：上下文切换开销。<br>④ CPU：显示 CPU 开销信息。<br>⑤ IPC：显示发送和接收开销信息。<br>⑥ MEMORY：显示内存开销信息。<br>⑦ PAGE FAULTS：显示页面错误开销信息。<br>⑧ SOURCE：显示和 Source_function，Source_file，Source_line 相关的开销信息。<br>⑨ SWAPS：显示交换次数开销信息。</p><p>🎨**<font color=blue>日常开发需要注意的结论：</font>**</p><p>① <code>Coverting Heap to MyISAM</code>：查询结果太大，内存不够，正在往磁盘中迁移<br>② <code>Creating tmp table</code>：创建临时表，先拷贝数据到临时表，用完再删除临时表<br>③<code>Coping to tmp table on disk</code>：把内存中临时表复制到磁盘上，警惕！<br>④ <code>locked</code></p><p>&#x3D;&#x3D;如果在 show profile 的查询结果中，出现了以上4条结果中的任何一条。则sql 语句需要优化&#x3D;&#x3D;</p><p><strong><font color=blue>最后，还需要注意：</font></strong></p><p><code>SHOW PROFILE</code> 命令将被弃用，不过我们可以从 <code>information_schema</code> 中的 <code>profiling</code> 数据表进行查看</p><h1 id="6-分析查询语句：EXPLAIN（重点）"><a href="#6-分析查询语句：EXPLAIN（重点）" class="headerlink" title="6. 分析查询语句：EXPLAIN（重点）"></a>6. 分析查询语句：EXPLAIN（重点）</h1><h2 id="6-1-EXPLAIN-概述"><a href="#6-1-EXPLAIN-概述" class="headerlink" title="6.1 EXPLAIN 概述"></a>6.1 EXPLAIN 概述</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150031440.png" alt="image-20220812182818655"></p><ul><li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">https://dev.mysql.com/doc/refman/5.7/en/explain-output.html</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">https://dev.mysql.com/doc/refman/8.0/en/explain-output.html</a></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150031002.png" alt="image-20220812183245510"></p><p><strong><font color=#681016>3. 版本情况</font></strong></p><ul><li><p>MySQL 5.6.3以前只能<code>EXPLAIN SELECT</code> ；MYSQL 5.6.3以后就可以<code>EXPLAIN SELECT，UPDATE，DELETE</code></p></li><li><p>在5.7以前的版本中，想要显示<code>partitions </code>需要使用<code>explain partitions</code>命令；想要显示<br><code>filtered </code>需要使用<code>explain extended</code> 命令。在5.7版本后，默认explain直接显示partitions和<br>filtered中的信息</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150031919.png" alt="image-20220812184127567"></p></li></ul><p><strong>注意：</strong>&#x3D;&#x3D;EXPLAIN 仅仅是查看执行计划，不会真实的执行 sql&#x3D;&#x3D;</p><h2 id="6-2-基本语法"><a href="#6-2-基本语法" class="headerlink" title="6.2 基本语法"></a>6.2 基本语法</h2><p>EXPLAIN 或 DESCRIBE语句的语法形式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> select_options</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">SELECT</span> select_options</span><br></pre></td></tr></table></figure><p>如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个EXPLAIN ，就像这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150031664.png" alt="image-20220812225914302"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150031294.png" alt="image-20220812225822122"></p><p>EXPLAIN 语句输出的各个列的作用如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150031821.png" alt="image-20220812225712460"></p><p>在这里把它们都列出来只是为了描述一个轮廓，让大家有一个大致的印象。</p><h2 id="6-3-数据准备"><a href="#6-3-数据准备" class="headerlink" title="6.3 数据准备"></a>6.3 数据准备</h2><p><strong><font color=blue>1. 建表</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s1 (</span><br><span class="line">     id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">     key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">     key2 <span class="type">INT</span>,</span><br><span class="line">     key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">     key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">     key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">     key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">     common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">      <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">      INDEX idx_key1 (key1),</span><br><span class="line">      <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">      INDEX idx_key3 (key3),</span><br><span class="line">      INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s2 (</span><br><span class="line">     id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">     key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">     key2 <span class="type">INT</span>,</span><br><span class="line">     key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">     key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">     key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">     key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">     common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">      <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">      INDEX idx_key1 (key1),</span><br><span class="line">      <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">      INDEX idx_key3 (key3),</span><br><span class="line">      INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>注：建两个表方便联合查询</p><p><strong><font color=blue>2. 创建存储函数</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string1(n <span class="type">INT</span>)</span><br><span class="line">    <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>) #该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">        <span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>创建函数，假如报错，需设置参数 <code>log_bin_trust_function_creators</code>，允许创建函数设置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;   # 不加<span class="keyword">global</span>只是当前窗口有效。</span><br></pre></td></tr></table></figure><p><strong><font color=blue>3. 创建存储过程</font></strong></p><p>创建往 s1 表中插入数据的存储过程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_s1 (<span class="keyword">IN</span> min_num <span class="type">INT</span> (<span class="number">10</span>),<span class="keyword">IN</span> max_num <span class="type">INT</span> (<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    REPEAT</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> s1 <span class="keyword">VALUES</span>(</span><br><span class="line">     (min_num <span class="operator">+</span> i),</span><br><span class="line">     rand_string1(<span class="number">6</span>),</span><br><span class="line">     (min_num <span class="operator">+</span> <span class="number">30</span> <span class="operator">*</span> i <span class="operator">+</span> <span class="number">5</span>),</span><br><span class="line">     rand_string1(<span class="number">6</span>),</span><br><span class="line">     rand_string1(<span class="number">10</span>),</span><br><span class="line">     rand_string1(<span class="number">5</span>),</span><br><span class="line">     rand_string1(<span class="number">10</span>),</span><br><span class="line">     rand_string1(<span class="number">10</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>创建往 s2 表中插入数据的存储过程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_s2 (<span class="keyword">IN</span> min_num <span class="type">INT</span> (<span class="number">10</span>),<span class="keyword">IN</span> max_num <span class="type">INT</span> (<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    REPEAT</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> s2 <span class="keyword">VALUES</span>((min_num <span class="operator">+</span> i),</span><br><span class="line">        rand_string1(<span class="number">6</span>),</span><br><span class="line">        (min_num <span class="operator">+</span> <span class="number">30</span> <span class="operator">*</span> i <span class="operator">+</span> <span class="number">5</span>),</span><br><span class="line">        rand_string1(<span class="number">6</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>),</span><br><span class="line">        rand_string1(<span class="number">5</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong><font color=blue>4. 调用存储过程</font></strong></p><p>s1 表数据的添加：加入 1 万条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL insert_s1(10001,10000);</span><br></pre></td></tr></table></figure><p>s2 表数据的添加：加入 1 万条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL insert_s2(10001,10000);</span><br></pre></td></tr></table></figure><h2 id="6-4-EXPLAIN-各列作用"><a href="#6-4-EXPLAIN-各列作用" class="headerlink" title="6.4 EXPLAIN 各列作用"></a>6.4 EXPLAIN 各列作用</h2><p>为了让大家有比较好的体验，我们调整了下<code>EXPLAIN</code>输出列的顺序。</p><h3 id="6-4-1-table"><a href="#6-4-1-table" class="headerlink" title="6.4.1 table"></a>6.4.1 table</h3><p>不论我们的查询语句有多复杂，里边儿包含了多少个表 ，到最后也是需要对每个表进行单表访问的，所以 MySQL 规定 EXPLAIN 语句输出的每条记录都对应着某个单表的访问方法，该条记录的 &#x3D;&#x3D;table 列代表着该表的表名&#x3D;&#x3D;（有时不是真实的表名字，可能是简称）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br></pre></td></tr></table></figure><p>如下图，&#x3D;&#x3D;一张表对应一个记录&#x3D;&#x3D;。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150031570.png" alt="image-20220812235854193"></p><p>注：临时表也会有对应的记录，比如我们使用UNION时就会出现临时表</p><h3 id="6-4-2-id"><a href="#6-4-2-id" class="headerlink" title="6.4.2 id"></a>6.4.2 id</h3><p>例1：下面的查询结果，两个记录似乎id都是1.这是为什么呢？</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150031032.png" alt="image-20220813001639812"></p><p>实际上，&#x3D;&#x3D;在查询语句中每出现一个SELECT关键字，MySQL就会为它分配一个唯一的id&#x3D;&#x3D; ，代表着一次查询。这个id 就是 <code>EXPLAIN</code>语句的第一列。</p><p>例2：下面的查询中只有一个SELECT，所以<code>EXPLAIN</code>的结果中也就只有一条id为 1 的记录喽~</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150031185.png" alt="image-20220813001157042"></p><p>例3：下面的查询有两个SELECT，所以<code>EXPLAIN</code>的结果中 会有两条记录，且id分别就是1和2喽~ 。其中 s1被称为驱动表，s2被称为 被驱动表</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150031326.png" alt="image-20220813005516485"></p><p>例4：下面这条SQL有一个坑，请注意！！！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key2 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>两个记录的 id 都是 1，小小的眼睛是否充满了大大的疑惑？</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150031679.png" alt="image-20220813105713820"></p><p>这是因为优化器会对上面的 sql 语句进行优化，将其转换为多表连接，而不是子查询。因为子查询其实是一种嵌套查询的情况，其时间复杂度是 O(n^m)，其中 m 是嵌套的层数，而多表查询的时间复杂度是 O(n*m)</p><p>例5：再看看 Union 联合查询的情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure><p>结果是这样，竟然会出现三张表~ Amazing！</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150031358.png" alt="image-20220813110019454"></p><p>这是因为 Union 是取表的并集，需要建临时表进行去重，因此会有三条记录。可以看到第三条记录的 <code>Extra</code> 就标识了它是一张临时表哦。<code>临时表 id 是 Null</code>。</p><p>例6：再看看 Union ALL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1  <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure><p>产生两条记录，因为它不会去重~</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150031768.png" alt="image-20220813110210174"></p><p><strong>💌小结</strong></p><ol><li>id如果相同，可以认为是一组，从上往下顺序执行</li><li>在所有组中，id值越大，优先级越高，越先执行</li><li>关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</li></ol><h3 id="6-4-3-select-type"><a href="#6-4-3-select-type" class="headerlink" title="6.4.3 select_type"></a>6.4.3 select_type</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150031617.png" alt="image-20220813114910520"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150031504.png" alt="image-20220813115146750"></p><p><strong><font color=blue>①：查询语句中不包含<code>UNION</code>或者子查询的查询都算作是<code>SIMPLE</code>类型</font></strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032310.png" alt="image-20220813133415051"></p><p>再看下连接查询，可以看到 连接查询也算是<code>SIMPLE</code>类型</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032728.png" alt="image-20220813133509606"></p><p><strong><font color=blue>②：Union 联合查询。其左边的查询是 <code>Primary</code>，右边的查询类型是 <code>Union</code>，去重的临时表查询类型是： <code>Union Result</code></font></strong></p><ul><li><p>对于包含<code>UNION</code>或者<code>UNION ALL</code>的大查询来说，它是由几个小查询组成的，其中除了最左边的那个查询的<code>select_type</code>值就是<code>PRIMARY</code>，其余的小查询的<code>select_type</code>值就是<code>UNION</code></p></li><li><p><code>MySQL</code>选择使用临时表来完成<code>UNION</code>查询的去重工作，针对该临时表的查询的<code>select_type</code>就是<br><code>UNION RESULT</code></p></li><li><p>对应子查询的大查询来说，子查询是外边的那个是<code>PRIMARY</code></p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032169.png" alt="image-20220813133840236"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032358.png" alt="image-20220813134118038"></p><p><strong><font color=blue>③：不会被优化成多表连接的子查询</font></strong></p><p>如果包含子查询的查询语句不能够转为多表连接的形式(也就是不会被优化器进行自动的优化)，并且该子查询是不相关的子查询</p><p>该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>SUBQUERY</code>。也就是外层查询是 <code>Primary</code>，内层查询是 <code>SUBQUERY</code></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032686.png" alt="image-20220813134931380"></p><p>如果子查询不能被转换为多表连接的形式，并且该子查询是相关子查询。</p><p>比如下面的查询在内部子查询使用了外部的表。则该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>DEPENDENT SUBQUERY</code>。 外层查询是<code>Primary</code>，内层查询是<code>DEPENDENT SUBQUERY</code> </p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032673.png" alt="image-20220813135056579"></p><p>需要注意的是 <code>DEPENDENT SUBQUERY</code> 的查询语句可能会被执行多次，因为内层查询依赖于外层的查询，因此可能会是外层传一个值，内层就执行一次的模式。</p><blockquote><p>子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。</p><p>子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条 件进行执行，那么这样的子查询叫做不相关子查询。</p></blockquote><p><strong><font color=blue>④：包含<code>UNION</code>或者<code>UNION ALL</code>的子查询</font></strong></p><p>在包含 <code>Union</code>或者 <code>Union All</code> 的子查询 sql 中，如果各个小查询都依赖于外查询，那么除了最左边的小查询外，各个小查询的类型都是 <code>DEPENDENT UNION</code> </p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032262.png" alt="image-20220813145005814"></p><p>外查询是 <code>Primary</code>，最左边的子查询是 <code>DEPENDENT SUBQUERY</code>，后面的子查询是 <code>DEPENDENT UNION</code>，临时去重表的类型是 <code>Union Result</code>。这里大家可能要困惑，第一个子查询中也没有看到依赖 s1 啊。这其实也是优化器会在执行时进行优化，将 <code>IN</code> 改成 <code>Exist</code>，并且把外部的表移到内部去。这里我们了解就行，以后会有文章给大家介绍优化器的。</p><p><strong><font color=blue>⑤：关于派生表的子查询</font></strong></p><p>对于包含<code>派生表</code>的查询，该派生表对应的子查询的<code>select_type</code>就是<code>DERIVED</code></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032278.png" alt="image-20220813145348553"></p><p><strong><font color=blue>⑥：子查询的物化后与外层连接查询</font></strong></p><p>当优化器在执行子查询时选择把子查询优化成为一张物化表，与外层查询进行连接查询时。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032153.png" alt="image-20220813150059254"></p><p>从下往上看，子查询的查询类型是 <code>MATERIALIZED</code>；物化过程是基于 id 为 2 的查询结果表进行的，其 table 是 <code>subquery 2</code>，查询类型是 <code>SIMPLE</code>，而外层也相当于是与固定的直接值进行查询，其类型也是 <code>SIMPLE</code></p><p>上面的介绍都是一些基本的情况，还没有真正的介绍与索引相关的情况哦。觉得是不是晕晕的了，我们用一个表格进行下总结吧</p><h3 id="6-4-4-partitions-可略"><a href="#6-4-4-partitions-可略" class="headerlink" title="6.4.4 partitions (可略)"></a>6.4.4 partitions (可略)</h3><p>代表分区表中的命中情况，非分区表，该项为 <code>NULL</code>。一般情况下我们的查询语句的执行计划的<code>partitions </code>列的值都是<code>NULL</code></p><p>官方文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/alter-table-partition-operations.html">https://dev.mysql.com/doc/refman/8.0/en/alter-table-partition-operations.html</a></p><p>如果想详细了解，可以如下方式测试。创建分区表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建分区表，</span></span><br><span class="line"><span class="comment">-- 按照id分区，id&lt;100 p0分区，其他p1分区</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_partitions (id <span class="type">INT</span> auto_increment,</span><br><span class="line">    NAME <span class="type">VARCHAR</span>(<span class="number">12</span>),<span class="keyword">PRIMARY</span> KEY(id))</span><br><span class="line">    <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(id)(</span><br><span class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> less than(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> less than MAXVALUE</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p>查询 id 大于200（200&gt;100，p1分区）的记录，查看执行计划，partitions 是 p1，符合我们的分区规则</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032328.png" alt="image-20220813151056438"></p><h3 id="6-4-5-type-☆"><a href="#6-4-5-type-☆" class="headerlink" title="6.4.5 type ☆"></a>6.4.5 type ☆</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150102778.png" alt="image-20220813152916930"></p><p>完整的访问方法如下： <code>system </code>、<code>const</code>、<code>eq_ref </code>、<code>ref </code>、<code>fulltext</code>、<code>ref_or_null</code>、<code>index_merge</code>、<code>unique_subquery</code>、<code>index_subquery</code>、 <code>range</code>、<code>index</code>、<code>ALL</code>。</p><p>我们详细解释一下：</p><p><strong>1️⃣system</strong></p><p>当表中只有一条记录，并且该表中存储引擎统计数据是精确的，比如 MYISAM，Memory，那么其访问方法就是<code>System</code>。这种方式几乎是性能最高的，当然我们几乎用不上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t(i int) Engine=MyISAM;#创建表</span><br><span class="line">INSERT INTO t VALUES(1);# 插入第一条记录</span><br><span class="line">EXPLAIN SELECT * FROM t;# 查看性能</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032626.png" alt="image-20220813161234015"><br>但凡我们再插入一条数据，其访问方式就变成了性能最差的全表扫描 <code>ALL</code>。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032680.png" alt="image-20220813161324653"></p><p>如果存储引擎是InnoDB，即使只有一条数据，其访问方式也是ALL，这是因为 InnnoDB 访问数据不是精确的</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032943.png" alt="image-20220813161518641"></p><p><strong>2️⃣Const</strong></p><p>当我们根据主键或者唯一的二级索引，与常数进行等值匹配时，对单表的访问方法就是 <code>const</code>。这个访问方式的效率低于 <code>system</code>，但也是很高效的。</p><p>比如对主键与常数匹配，进行等值查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032582.png" alt="image-20220813161700890"></p><p>比如对Unique标识的唯一二级索引key2与常数匹配，进行等值查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key2 <span class="operator">=</span> <span class="number">10066</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032734.png" alt="image-20220813163815258"></p><p>当我们把where后面的关键字改成key3 普通索引时，由于key3的字段值是可重复的。type类型就变成了 <code>All</code>，全表查询</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032927.png" alt="image-20220813164458327"></p><p>注意：此时可能有细心的小伙伴可能注意到我们的key3不是也有索引<code>idx_key3</code>，性能再查也不至于全表查询吧~ 但是忘记了一个细节，key3本身是varchar类型的， <code>key3 = 10066</code>会进行一个隐式类型转换，从而会导致 索引失效，我们也可以看到 <code>key</code>列对应的为空。</p><p>当修改成<code>key3 = 10066</code>后，结果如下图：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032846.png" alt="image-20220813172536786"></p><p><strong>3️⃣eq_ref</strong></p><p>再进行<strong>连接查询</strong>时，如果<strong>被驱动表</strong>是通过主键或者唯一二级索引等值匹配的方式进行查询的，那么被驱动表的访问方式是 <code>eq_ref</code>。这也是一种性能很不错的方式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br></pre></td></tr></table></figure><p>上面连接查询语句，对于驱动表来说，就是对s1全表进行扫描，找到符合条件的数据，因此其<code>type</code>是<code>All</code>,对被驱动表来说，相于直接访问驱动表查询到的数据进行等值查询，因此其访问方式是<code>eq_ref</code><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032989.png" alt="image-20220813173413307"></p><p><strong>4️⃣ref</strong></p><p>当使用普通的二级索引与常量进行等值匹配时，type 是 <code>ref</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032310.png" alt="image-20220813173618072"></p><p>下面考考你。以下 sql 的引用类型是什么呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key3 <span class="operator">=</span> <span class="number">10066</span>;</span><br></pre></td></tr></table></figure><p>看看答案。你是不是猜错了。是 <code>All</code>。这是因为 key3 的字段 varchar 类型，但是我们这里常量值是整形，因此需要使用函数进行&#x3D;&#x3D;隐式的类型转换&#x3D;&#x3D;，一旦使用函数，索引就失效了，因此访问类型变成了全表扫描 <code>All</code></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032919.png" alt="image-20220813173814439"></p><p>当我们常量使用对应的类型，就是期望的<code>ref</code>访问类型了</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150032015.png" alt="image-20220813173912091"></p><p><strong>5️⃣ref_or_null</strong></p><p>当使用普通的二级索引进行等值匹配时，当索引值可以是 Null 时，type 是 <code>ref_or_null</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key1 <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033169.png" alt="image-20220813174556607"></p><p><strong>6️⃣index_merge</strong></p><p>当进行单表访问时，如果多个查询字段分别建立了单列索引，使用 OR 连接，其访问类型是 <code>index_merge</code>。同时还可以看到 <code>key </code>这一字段，是使用了多个索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033310.png" alt="image-20220813174718756"></p><p>猜猜下面 sql 的引用类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>猜对了吗？答案是 <code>ref</code>，这是因为用 AND 连接两个查询时，实际上只使用了 key1 的索引。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033111.png" alt="image-20220813174912860"></p><p><strong>7️⃣unique_subquery</strong></p><p>针对一些包含 <code>IN</code> 的 子查询的查询语句中，如果优化器决定将 IN 子查询优化为 EXIST 子查询，而且子查询可以使用主键进行等值匹配的话，那么该子查询执行计划的 <code>type </code>就是 <code>unique_subquery</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key2 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2 <span class="keyword">where</span> s1.key1 <span class="operator">=</span> s2.key1) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033407.png" alt="image-20220813182322867"></p><p><strong>8️⃣range</strong></p><p>如果使用索引获取某些<code>范围区间</code>的记录，那么就可能使用到<code>range</code>访问方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key1 <span class="operator">&lt;</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033065.png" alt="image-20220813182743852"></p><p><strong>9️⃣index</strong></p><p>当我们可以使用<strong>索引覆盖</strong>，但是需要扫描的全部的索引记录时，该表的访问方式就是 <code>index</code>。索引覆盖后面文章介绍优化器时会详细介绍，为了便于大家理解，先简单介绍如下。比如下面 sql 语句中，key_part2 ，key_part2 都属于联合索引 <code>idx_key_part(key_part1, key_part2, key_part3)</code> 的一部分，&#x3D;&#x3D;在查找数据时可以用上这个联合索引，而不用进行回表操作&#x3D;&#x3D;，这种情况即&#x3D;&#x3D;索引覆盖&#x3D;&#x3D;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> key_part2 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part2 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033505.png" alt="image-20220813183057913"></p><p><strong>1️⃣0️⃣ALL</strong></p><p>最熟悉的全表扫描 <code>ALL</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033592.png" alt="image-20220813183153914"></p><blockquote><p>❤温馨提示：这里很多小伙伴会觉得记不住，其实您可以收藏这篇博客，执行 EXPLAIN 时对应结果，反向查找博文对应内容，毕竟咱们只需要能够读懂性能分析的结果</p></blockquote><p><strong>小结</strong></p><p>结果值从最好到最坏依次是： <font color=green>system &gt; const &gt; eq_ref &gt; ref </font>&gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <font color=green>range &gt; index &gt; ALL</font> 其中比较重要的几个提取出来（见绿色部分）</p><p>SQL 性能优化的目标：&#x3D;&#x3D;至少要达到 range 级别，要求是 ref 级别，最好是 consts 级别&#x3D;&#x3D;（阿里巴巴开发手册要求）</p><h3 id="6-4-6-possible-keys-和-key"><a href="#6-4-6-possible-keys-和-key" class="headerlink" title="6.4.6 possible_keys 和 key"></a>6.4.6 possible_keys 和 key</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150102167.png" alt="image-20220813225540107"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033297.png" alt="image-20220813225634984"></p><p>对应优化器来说，可以选择的 <code>possible_keys</code> 越少越好，因为选项越多，进行过滤花的时间也就对应更多。另外，优化器会对各个索引进行查询的效率进行评估，以此来选择实际使用的 <code>key</code>。而且由于优化器会对 sql 进行优化，完全可能会出现 <code>possible_keys</code> 是 null，但是 <code>key</code> 不为 null 的情况</p><h3 id="6-4-7-key-len-☆"><a href="#6-4-7-key-len-☆" class="headerlink" title="6.4.7 key_len ☆"></a>6.4.7 key_len ☆</h3><p>实际使用的索引的长度，单位是字节。可以帮助你检查是否充分利用了索引，主要针对&#x3D;&#x3D;联合索引&#x3D;&#x3D;具有一定的参考，对同一索引来说，key_len 值越大越好（与自己比较，后面将解释）。</p><p><font color=blue>① 下面SQL执行结果是 4，这个结果怎么算出来的呢？</font></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033607.png" alt="image-20220813230641143"></p><p>这是因为使用的是主键 id 作为索引，其类型是 int，占 4 个字节</p><p><font color=blue>② 再来猜猜下面的 key_len 是多少~</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key2 <span class="operator">=</span> <span class="number">10126</span>;</span><br></pre></td></tr></table></figure><p>什么？你猜的是 4，而答案是 5~</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033407.png" alt="image-20220813230839120"></p><p>这是因为虽然 key2 也是 int 类型，但是它被 unique 修饰，并没有标识非空（而主键都是非空的），因此加上空值标记，一共是5字节</p><p><font color=blue>③ 字符类型的索引长度为多少呢</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033945.png" alt="image-20220813231154852"></p><p>答案是 303，因为类型是 varchar(100)，100 个字符，utf-8 每个字符占 3 个字节，共 300 个字节，加上变长列表 2 个字节与一个空值标识占一个字节，共 303 字节。</p><p><font color=blue>④ 看看联合索引的情况</font></p><ul><li>看下面的联合索引，key_len还是303，不需要解释了吧</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033471.png" alt="image-20220813231414814"></p><ul><li>再看看下面这个联合索引，其结果是 606</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key_part2 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033975.png" alt="image-20220813231505907"></p><p>&#x3D;&#x3D;这个查询的 key-len 比上面的查询大，性能就比上面的好&#x3D;&#x3D;，怎么理解呢？其实只要你看过我之前介绍B+树的文章就很容易理解了。因为在目录页我除了考虑 <code>key_part1</code> ，还会考虑 <code>key_part2</code>，定位到的数据就更加精准，范围更小，需要加载 I&#x2F;O 的数据页数量就会更少，这样是不是性能就比较好啊~</p><ul><li>猜猜下面的 sql 执行后 key_len 是多少</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033287.png" alt="image-20220813231734678"></p><p>是空哦，因为都不会使用到索引，这就是我们一直在提的<strong>最左前缀原则</strong>，后面会详细介绍的。</p><p><strong><font color=blue>📚练习：key_len的长度计算公式：</font></strong></p><ul><li>varchar(10)变长字段且允许NULL &#x3D; <code>10 *( character set：utf8=3, gbk=2, latin1=1) + 1(NULL)+2(变长字段)</code></li><li>varchar(10)变长字段且不允许NULL &#x3D; <code>10* ( character set：utf8=3 ,gbk=2, latin1=1) +2(变长字段)</code></li><li>char(10)固定字段且允许NULL &#x3D; <code>10 *( character set：utf8=3, gbk=2, latin1=1) +1(NULL)</code></li><li>char(10)固定字段且不允许NULL &#x3D; <code>10* ( character set：utf8=3,gbk=2,latin1=1)</code></li></ul><h3 id="6-4-8-ref"><a href="#6-4-8-ref" class="headerlink" title="6.4.8 ref"></a>6.4.8 ref</h3><p>当索引列进行等值查询时，与索引列匹配的对象信息。</p><p><font color=blue>① 比如只是一个常数或者是某个列，其 <code>ref</code> 是 <code>const</code></font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033417.png" alt="image-20220814103925203"></p><p><font color=blue>② 当进行多表连接查询时，对被驱动表s2执行的查询引用了atguigudb1.s1.id字段进行等值查询</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033329.png" alt="image-20220814104029459"></p><p><font color=blue>③ 当连接条件使用函数时，其 <code>ref</code> 就是 <code>func</code></font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s2.key1 <span class="operator">=</span> <span class="built_in">UPPER</span>(s1.key1);</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033857.png" alt="image-20220814104217790"></p><h3 id="6-4-9-rows-☆"><a href="#6-4-9-rows-☆" class="headerlink" title="6.4.9 rows ☆"></a>6.4.9 rows ☆</h3><p><font color=blue>① 预估的需要读取的记录条目数，条目数越小越好。这是因为值越小，加载I&#x2F;O的页数就越少~</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033295.png" alt="image-20220814104350297"></p><h3 id="6-4-10-filtered"><a href="#6-4-10-filtered" class="headerlink" title="6.4.10 filtered"></a>6.4.10 filtered</h3><p>&#x3D;&#x3D;经过搜索条件后过滤剩下的记录所占的百分比&#x3D;&#x3D;。&#x3D;&#x3D;百分比越高越好&#x3D;&#x3D;，比如同样 rows 是 40，如果 filter 是 100，则是从 40 条记录里进行查找，如果 filter 是 10，则是从 400 条记录里进行查找，相比较而言当然是前者的效率更高哦。</p><p><font color=blue>① 如果执行的是单表扫描，那么计算时需要估计除了对应搜索条件外的其他搜索条件满足的记录有多少条</font> 晕了就看看下面的例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>结果是 10，表示有 347 条记录满足 key1 &gt; ‘z’ 的条件，这 347 条记录的 10% 满足 common_field &#x3D; ‘a’ 条件。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033280.png" alt="image-20220814104530103"></p><p><font color=blue>② 实际上，对于单表查询，这个字段没有太大的意义，我们更加关注连接查询时的 filtered 值，它决定了被驱动表要执行的次数。</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span></span><br><span class="line">s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>结果如下。在标明驱动表 s1 提供给被驱动表的记录数是 9895 条，其中 989.5 条满足过滤条件s1.key1 &#x3D; s2.key1，那么被驱动表需要执行 990 次查询。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033425.png" alt="image-20220814104852338"></p><blockquote><p>filtered&#x3D;(最终查询结果&#x2F;rows列数据)*100%，越大表示过滤后的数据，越是最终结果。<br>相比较filtered越小，减少了数据再次过滤的性能</p></blockquote><h3 id="6-4-11-Extra-☆"><a href="#6-4-11-Extra-☆" class="headerlink" title="6.4.11 Extra ☆"></a>6.4.11 Extra ☆</h3><p>顾名思义，<code>Extra </code>列是用来说明一些额外信息的，包含不适合在其他列中显示但十分重要的额外信息。我们可以通过这些额外信息来<code>更准确的理解MySQL到底将如何执行给定的查询语句</code>。MySQL提供的额外信息有好几十个，我们就不一一介绍了，所以我们只挑比较重要的额外信息介绍给大家。</p><p><font color=blue>① <code>No tables used</code></font></p><p>当查询语句的没有<code>FROM</code>子句时将会提示该额外信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033055.png" alt="image-20220814111715918"></p><p><font color=blue>② <code>Impossible WHERE</code></font></p><p>当查询条件永远不可能满足，查不到数据时会出现该信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">!=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033040.png" alt="image-20220814111830017"></p><p><font color=blue>③ <code>Using where</code></font></p><ul><li>当没有使用索引，普通的 where 查询时，会出现该信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150033056.png" alt="image-20220814111940959"></p><ul><li>使用索引查询，则默默使用索引，什么额外信息也没有。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034481.png" alt="image-20220814112044015"></p><ul><li>索引加普通 where，那还是 using where</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034568.png" alt="image-20220814112128725"></p><p><font color=blue>④ <code>No matching min/max row</code></font></p><p>当查询语句中有 MIN、MAX 等聚合函数，但是并没有符合 where 条件的搜索记录时，会提供额外信息 <code>No matching min/max row</code>（表中根本没有满足 where 条件的字句，找 min、max 没有意义）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(key1) <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;abcdefg&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034576.png" alt="image-20220814112312678"></p><p><font color=blue>⑤ <code>Select tables optimized away</code></font></p><p>当查询语句中有 MIN、MAX 等聚合函数，有符合 where 条件的搜索记录时</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(key1) <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;oCUPss&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034143.png" alt="image-20220814112508271"></p><p><font color=blue>⑥ <code>Using index</code> </font></p><p>在使用覆盖索引的情况提示。所谓覆盖索引，就是&#x3D;&#x3D;索引中覆盖了需要查询的所有字段，不需要再使用聚簇索引进行回表查找&#x3D;&#x3D;。比如下面的例子，使用 key1 作为查找条件，该字段建立了索引，B+ 树可以查找到 key1 字段和主键，因此下面只查找 key1 字段就不用进行回表操作，这是非常棒的情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034753.png" alt="image-20220814112621332"></p><p><font color=blue>⑦ <code>Using index condition</code></font></p><p>搜索列中虽然出现了索引列，但是不能够使用索引，这种情况是比较坑的~</p><p>比如下面的查询&#x3D;&#x3D;虽然出现了索引列作为查询条件，但是还是需要进行回表查找&#x3D;&#x3D;，回表操作是一个随机 I&#x2F;O，比较耗时。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key1 <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034072.png" alt="image-20220814114314395"></p><p>上面这种情况可以使用<font color=red><strong>索引下推</strong></font>(可以通过配置项进行配置)，&#x3D;&#x3D;使我们使用 WHERE key1 &gt; ‘z’ 得到的结果先进行模糊匹配 key1 LIKE ‘%a’，然后再去回表&#x3D;&#x3D;，就可以减少回表的次数了。</p><p><font color=blue>⑧ <code>Using join buffer</code></font></p><p>在连接查询中，当被驱动表不能够有效利用索引实现提升速度，数据库就使用缓存来尽可能提升一些性能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.common_field <span class="operator">=</span> s2.common_field;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034057.png" alt="image-20220814115201430"></p><p><font color=blue>⑨ <code>Not exists</code></font></p><p>当我们使用左（外）连接时，如果<code>WHERE</code>子句中包含要求被驱动表的某个列等于<code>NULL</code>值的搜索条件，而且那个列又是不允许存储<code>NULL</code>值的，那么在该表的执行计划的Extra列就会提示<code>Not exists</code>额外信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034447.png" alt="image-20220814115302073"></p><p><font color=blue>⑩ <code>Using intersect(…) 、 Using union(…) 和 Using sort_union(…)</code> </font></p><ul><li><p>如果执行计划的<code>Extra</code>列出现了<code>Using intersect(...)</code>提示，说明准备使用<code>Intersect</code>索引 合并的方式执行查询，括号中的<code>...</code>表示需要进行索引合并的索引名称；</p></li><li><p>如果出现了<code>Using union(...)</code>提示，说明准备使用<code>Union</code>索引合并的方式执行查询；</p></li><li><p>如果出现了<code>Using sort_union(...)</code>提示，说明准备使用<code>Sort-Union</code>索引合并的方式执行查询</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034777.png" alt="image-20220814115726815"></p><p><font color=blue>⑪ <code>Zero limit</code></font></p><p>当我们的<code>LIMIT</code>子句的参数为<code>0</code>时，表示压根儿不打算从表中读出任何记录，将会提示该额外信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 LIMIT 0;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034392.png" alt="image-20220814115904221"></p><p><font color=blue>⑫ <code>Using filesort</code></font></p><p>很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，MySQL把这种在内存中或者磁盘上进行排序的方式统称为**<font color=red>文件排序</font>**（英文名：<code>filesort</code>）。这种情况时比较悲壮的~</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> common_field LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034961.png" alt="image-20220814120453672"></p><p><font color=blue>⑬ <code>Using temporary</code></font></p><p>在许多查询的执行过程中，MySQL可能会借助临时表来完成一些功能，比如&#x3D;&#x3D;去重、排序&#x3D;&#x3D;之类的，比如我们在执行许多包含<code>DISTINCT</code>、<code>GROUP BY</code>、<code>UNION</code>等子句的查询过程中，如果不能有效利用索引来完成查询，MySQL很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的<code>Extra</code>列将会显示<code>Using temporary</code>提示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> common_field <span class="keyword">FROM</span> s1;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> common_field, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> amount <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> common_field;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034987.png" alt="image-20220814121232140"></p><p>执行计划中出现<code>Using temporary</code>并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们<code>最好能使用索引来替代掉使用临时表</code>。比如：扫描指定的索引idx_key1即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT key1, COUNT(*) AS amount FROM s1 GROUP BY key1;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034664.png" alt="image-20220814121019942"></p><h3 id="6-4-12-小结"><a href="#6-4-12-小结" class="headerlink" title="6.4.12 小结"></a>6.4.12 小结</h3><ul><li>EXPLAIN不考虑各种Cache，只考虑SQL本身</li><li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li><li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况部分统计</li><li>信息是估算的，并非精确值</li></ul><h1 id="7-EXPLAIN-的进一步使用"><a href="#7-EXPLAIN-的进一步使用" class="headerlink" title="7. EXPLAIN 的进一步使用"></a>7. EXPLAIN 的进一步使用</h1><h2 id="7-1-EXPLAIN-四种输出格式"><a href="#7-1-EXPLAIN-四种输出格式" class="headerlink" title="7.1 EXPLAIN 四种输出格式"></a>7.1 EXPLAIN 四种输出格式</h2><p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式： &#x3D;&#x3D;传统格式 ，JSON格式， TREE格式 以及 可视化输出&#x3D;&#x3D;。用户可以根据需要选择适用于自己的格式。</p><h3 id="7-1-1-传统格式"><a href="#7-1-1-传统格式" class="headerlink" title="7.1.1 传统格式"></a>7.1.1 传统格式</h3><p>传统格式简单明了，输出是一个表格形式，概要说明查询计划。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key2 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span><span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034257.png" alt="image-20220814131829731"></p><h3 id="7-1-2-JSON-格式"><a href="#7-1-2-JSON-格式" class="headerlink" title="7.1.2 JSON 格式"></a>7.1.2 JSON 格式</h3><p>第1种格式中介绍的<code>EXPLAIN</code>语句输出中缺少了一个衡量执行计划好坏的重要属性–成本。 而JSON格式是四种格式里面输出&#x3D;&#x3D;信息最详尽&#x3D;&#x3D;的格式，里面包含了执行的成本信息。</p><p><strong><font color=red>JSON格式：在EXPLAIN单词和真正的查询语句中间加上<code>FORMAT=JSON</code> </font></strong></p><p>传统格式与json格式的各个字段存在如下表所示的对应关系(mysql5.7官方文档)。<br><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034616.png" alt="image-20220814122734392"></p><p>案例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> s1.key1, s2.key1 <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.common_field <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p>结果如下，可以看到 json 格式的信息量会更加丰富。尤其是&#x3D;&#x3D;成本信息&#x3D;&#x3D;，是用于衡量一个执行计划的好坏的重要指标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field =&#x27;a&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">EXPLAIN: &#123;</span><br><span class="line">  &quot;query_block&quot;: &#123;</span><br><span class="line">    &quot;select_id&quot;: 1,</span><br><span class="line">    &quot;cost_info&quot;: &#123;</span><br><span class="line">      &quot;query_cost&quot;: &quot;1360.07&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;nested_loop&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s1&quot;,</span><br><span class="line">          &quot;access_type&quot;: &quot;ALL&quot;,</span><br><span class="line">          &quot;possible_keys&quot;: [</span><br><span class="line">            &quot;idx_key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: 9895,</span><br><span class="line">          &quot;rows_produced_per_join&quot;: 989,</span><br><span class="line">          &quot;filtered&quot;: &quot;10.00&quot;,</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;914.80&quot;,</span><br><span class="line">            &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;1013.75&quot;,</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;attached_condition&quot;: &quot;((`atguigudb1`.`s1`.`common_field` = &#x27;a&#x27;) and (`atguigudb1`.`s1`.`key1` is not null))&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s2&quot;,</span><br><span class="line">          &quot;access_type&quot;: &quot;eq_ref&quot;,</span><br><span class="line">          &quot;possible_keys&quot;: [</span><br><span class="line">            &quot;idx_key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key&quot;: &quot;idx_key2&quot;,</span><br><span class="line">          &quot;used_key_parts&quot;: [</span><br><span class="line">            &quot;key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key_length&quot;: &quot;5&quot;,</span><br><span class="line">          &quot;ref&quot;: [</span><br><span class="line">            &quot;atguigudb1.s1.key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: 1,</span><br><span class="line">          &quot;rows_produced_per_join&quot;: 989,</span><br><span class="line">          &quot;filtered&quot;: &quot;100.00&quot;,</span><br><span class="line">          &quot;index_condition&quot;: &quot;(cast(`atguigudb1`.`s1`.`key1` as double) = cast(`atguigudb1`.`s2`.`key2` as double))&quot;,</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;247.38&quot;,</span><br><span class="line">            &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;1360.08&quot;,</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure><p>我们使用<code>#</code>后面跟随注释的形式为大家解释了 <code>EXPLAIN FORMAT=JSON</code> 语句的输出内容，但是大家有疑问 <code>cost_info</code>里边的成本看着怪怪的，它们是怎么计算出来的？</p><p>先看 s1 表的 “cost_info”部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">&quot;read_cost&quot;: &quot;914.80&quot;,</span><br><span class="line">    &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">    &quot;prefix_cost&quot;: &quot;1013.75&quot;,</span><br><span class="line">    &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>read_cost</code> 是由下边这两部分组成的：<ul><li><p><code>IO</code>成本</p></li><li><p>检测 <code>rows × (1 - filter) </code>条记录的 <code>CPU </code>成本</p></li></ul></li></ul><blockquote><p>💚 rows和filter都是我们前边介绍执行计划的输出列，在JSON格式的执行计划中，rows相当于rows_examined_per_scan，filtered名称不变</p></blockquote><ul><li><p><code>eval_cost</code>是这样计算的：</p><ul><li>检测 <code>rows × filter</code> 条记录的成本。</li></ul></li><li><p><code>prefix_cost</code>就是单独查询 s1 表的成本，也就是：<code>read_cost + eval_cost</code></p></li><li><p><code>data_read_per_join </code>表示在此次查询中需要读取的数据量。</p></li></ul><p>对于 s2 表的 “cost_info” 部分是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">&quot;read_cost&quot;: &quot;247.38&quot;,</span><br><span class="line">    &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">    &quot;prefix_cost&quot;: &quot;1360.08&quot;,</span><br><span class="line">    &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 s2 表是被驱动表，所以可能被读取多次，这里的 <code>read_cost </code>和 <code>eval_cost </code>是访问多次 s2 表后累加起来的值，大家主要关注里边儿的 <code>prefix_cost </code>的值代表的是整个连接查询预计的成本，也就是单次查询 s1 表和多次查询 s2 表后的成本的和，也就是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">247.38</span> + <span class="number">98.95</span> + <span class="number">1013.75</span> = <span class="number">1360.08</span></span><br></pre></td></tr></table></figure><h3 id="7-1-3-TREE-格式"><a href="#7-1-3-TREE-格式" class="headerlink" title="7.1.3 TREE 格式"></a>7.1.3 TREE 格式</h3><p>TREE 格式是 8.0.16 版本之后引入的新格式，主要根据查询的各个部分之间的关系和各部分的执行顺序 来描述如何查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN FORMAT<span class="operator">=</span>TREE <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key2 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span><span class="string">&#x27;a&#x27;</span>\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">EXPLAIN: <span class="operator">-</span><span class="operator">&gt;</span> Nested loop <span class="keyword">inner</span> <span class="keyword">join</span>  (cost<span class="operator">=</span><span class="number">1360.08</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">990</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Filter</span>: ((s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>) <span class="keyword">and</span> (s1.key1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>))  (cost<span class="operator">=</span><span class="number">1013.75</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">990</span>)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Table</span> scan <span class="keyword">on</span> s1  (cost<span class="operator">=</span><span class="number">1013.75</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">9895</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> Single<span class="operator">-</span><span class="type">row</span> index lookup <span class="keyword">on</span> s2 <span class="keyword">using</span> idx_key2 (key2<span class="operator">=</span>s1.key1), <span class="keyword">with</span> index <span class="keyword">condition</span>: (<span class="built_in">cast</span>(s1.key1 <span class="keyword">as</span> <span class="keyword">double</span>) <span class="operator">=</span> <span class="built_in">cast</span>(s2.key2 <span class="keyword">as</span> <span class="keyword">double</span>))  (cost<span class="operator">=</span><span class="number">0.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="7-1-4-可视化输出"><a href="#7-1-4-可视化输出" class="headerlink" title="7.1.4 可视化输出"></a>7.1.4 可视化输出</h3><p>可视化输出，可以通过 MySQL Workbench 可视化查看 MySQL 的执行计划。通过点击 Workbench 的放大镜图标，即可生成可视化的查询计划</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034098.png"></p><p>上图按从左到右的连接顺序显示表。红色框表示 全表扫描 ，而绿色框表示使用索引查找对于每个表，显示使用的索引。还要注意的是，每个表格的框上方是每个表访问所发现的行数的估计值以及访问该表的成本</p><h2 id="7-2-SHOW-WARNINGS-的使用"><a href="#7-2-SHOW-WARNINGS-的使用" class="headerlink" title="7.2 SHOW WARNINGS 的使用"></a>7.2 SHOW WARNINGS 的使用</h2><p>&#x3D;&#x3D;可以显示数据库真正执行的 SQL&#x3D;&#x3D; ，因为有时候MySQL执行引擎会对我们的SQL进行优化~</p><p><font color=blue>① 先使用 <code>Explain</code>，我们写的 sql 按道理是使用 s1 作为驱动表，s2作为被驱动表</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> s1.key1, s2.key1 <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.common_field <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;<span class="operator">*</span></span><br></pre></td></tr></table></figure><p>但是 执行结果把 s2 作为了驱动表，s1 作为了被驱动表<br><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150034776.png" alt="image-20220814133158223"></p><p>紧接着使用<code>SHOW WARNINGS</code> ，原来执行引擎将<code> LEFT JOIN</code>优化成了 <code>INNER JOIN</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> WARNINGS\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">  Level: Note</span><br><span class="line">   Code: <span class="number">1003</span></span><br><span class="line">Message: <span class="comment">/* select#1 */</span> <span class="keyword">select</span> `atguigudb1`.`s1`.`key1` <span class="keyword">AS</span> `key1`,`atguigudb1`.`s2`.`key1` <span class="keyword">AS</span> `key1` </span><br><span class="line"><span class="keyword">from</span> `atguigudb1`.`s1` </span><br><span class="line"><span class="keyword">join</span> `atguigudb1`.`s2` </span><br><span class="line"><span class="keyword">where</span> ((`atguigudb1`.`s1`.`key1` <span class="operator">=</span> `atguigudb1`.`s2`.`key1`) </span><br><span class="line"><span class="keyword">and</span> (`atguigudb1`.`s2`.`common_field` <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>))</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>上面 message 中显示的&#x3D;&#x3D;是数据库优化、重写后真正执行的查询语句&#x3D;&#x3D;。果然它帮我们做了优化</p><p><font color=blue>② 再举一个例子：下面是一个 子查询SQL，应该对应着两个不同的id~</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><p>但是真正执行后，对应着竟然是相同的id</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150035985.png" alt="image-20220814134557598"></p><p>我们使用<code>SHOW WARNINGS\G;</code>进行分析，发现执行引擎将其优化成了 <strong>多表连接查询</strong>的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW WARNINGS\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Level: Warning</span><br><span class="line">   Code: 1739</span><br><span class="line">Message: Cannot use ref access on index &#x27;idx_key1&#x27; due to type or collation conversion on field &#x27;key1&#x27;</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">  Level: Note</span><br><span class="line">   Code: 1003</span><br><span class="line">Message: /* select#1 */ select `atguigudb1`.`s1`.`id` AS `id`,`atguigudb1`.`s1`.`key1` AS `key1`,`atguigudb1`.`s1`.`key2` AS `key2`,`atguigudb1`.`s1`.`key3` AS `key3`,`atguigudb1`.`s1`.`key_part1` AS `key_part1`,`atguigudb1`.`s1`.`key_part2` AS `key_part2`,`atguigudb1`.`s1`.`key_part3` AS `key_part3`,`atguigudb1`.`s1`.`common_field` AS `common_field` </span><br><span class="line">from `atguigudb1`.`s2` </span><br><span class="line">join `atguigudb1`.`s1` </span><br><span class="line">where ((`atguigudb1`.`s2`.`common_field` = &#x27;a&#x27;) </span><br><span class="line">and (cast(`atguigudb1`.`s1`.`key1` as double) = cast(`atguigudb1`.`s2`.`key2` as double)))</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="8-分析优化器执行计划：trace"><a href="#8-分析优化器执行计划：trace" class="headerlink" title="8. 分析优化器执行计划：trace"></a>8. 分析优化器执行计划：trace</h1><p><code>OPTIMIZE_TRACE</code> 是 mysql 5.6 中引入的一个跟踪工具，它可以跟踪优化器做出的各种决策，比如访问表的方法，各种开销计算，各种转换，结果会被记录到 <code>information_schema.optimizer_trace</code>中。</p><p>此功能默认关闭。开启trace，并设置格式为JSON，同时设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> optimizer_trace_max_mem_size<span class="operator">=</span><span class="number">1000000</span>;</span><br></pre></td></tr></table></figure><p>开启后，可分析如下语句：</p><ul><li>SELECT</li><li>INSERT</li><li>REPLACE</li><li>UPDATE</li><li>DELETE</li><li>EXPLAIN</li><li>SET</li><li>DECLARE</li><li>CASE</li><li>IF</li><li>RETURN</li><li>CALL</li></ul><p>测试：执行如下 SQL 语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>最后， 查询 information_schema.optimizer_trace 就可以知道 MySQL 是如何执行 SQL 的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G;</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line">*************************** <span class="number">1.</span> row ***************************</span><br><span class="line"> <span class="comment">//第1部分：查询语句</span></span><br><span class="line"> QUERY<span class="punctuation">:</span> select * from student where id &lt; <span class="number">10</span></span><br><span class="line"> <span class="comment">//第2部分：QUERY字段对应语句的跟踪信息</span></span><br><span class="line"> TRACE<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"> <span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;join_preparation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//预备工作</span></span><br><span class="line">    <span class="attr">&quot;select#&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;expanded_query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/* select#1 */ select `student`.`id` AS</span></span><br><span class="line"><span class="string">`id`,`student`.`stuno` AS `stuno`,`student`.`name` AS `name`,`student`.`age` AS</span></span><br><span class="line"><span class="string">`age`,`student`.`classId` AS `classId` from `student` where (`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">  <span class="punctuation">&#125;</span> <span class="comment">/* join_preparation */</span></span><br><span class="line"> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;join_optimization&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//进行优化</span></span><br><span class="line">    <span class="attr">&quot;select#&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;condition_processing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//条件处理</span></span><br><span class="line">       <span class="attr">&quot;condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WHERE&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;original_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">       <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;transformation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;equality_propagation&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;resulting_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">       <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;transformation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;constant_propagation&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;resulting_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">       <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;transformation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;trivial_condition_removal&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;resulting_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">     <span class="punctuation">&#125;</span> <span class="comment">/* condition_processing */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;substitute_generated_columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//替换生成的列</span></span><br><span class="line">     <span class="punctuation">&#125;</span> <span class="comment">/* substitute_generated_columns */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;table_dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>   <span class="comment">//表的依赖关系</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;row_may_be_null&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;map_bit&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;depends_on_map_bits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">       <span class="punctuation">]</span> <span class="comment">/* depends_on_map_bits */</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">     <span class="punctuation">]</span> <span class="comment">/* table_dependencies */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;ref_optimizer_key_uses&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>   <span class="comment">//使用键</span></span><br><span class="line">     <span class="punctuation">]</span> <span class="comment">/* ref_optimizer_key_uses */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;rows_estimation&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>   <span class="comment">//行判断</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;range_analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;table_scan&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">3973767</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">408558</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* table_scan */</span><span class="punctuation">,</span>   <span class="comment">//扫描表</span></span><br><span class="line">         <span class="attr">&quot;potential_range_indexes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>   <span class="comment">//潜在的范围索引</span></span><br><span class="line">         <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;key_parts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;id&quot;</span></span><br><span class="line">          <span class="punctuation">]</span> <span class="comment">/* key_parts */</span></span><br><span class="line">         <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* potential_range_indexes */</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;setup_range_conditions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>   <span class="comment">//设置范围条件</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* setup_range_conditions */</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;group_index_range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;not_group_by_or_distinct&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* group_index_range */</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;skip_scan_range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;potential_skip_scan_indexes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;query_references_nonkey_column&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">         <span class="punctuation">]</span> <span class="comment">/* potential_skip_scan_indexes */</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* skip_scan_range */</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;analyzing_range_alternatives&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//分析范围选项</span></span><br><span class="line">          <span class="attr">&quot;range_scan_alternatives&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ranges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">             <span class="string">&quot;id &lt; 10&quot;</span></span><br><span class="line">           <span class="punctuation">]</span> <span class="comment">/* ranges */</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;index_dives_for_eq_ranges&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;rowid_ordered&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;using_mrr&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;index_only&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">1.91986</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">         <span class="punctuation">]</span> <span class="comment">/* range_scan_alternatives */</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;analyzing_roworder_intersect&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;too_few_roworder_scans&quot;</span></span><br><span class="line">         <span class="punctuation">&#125;</span> <span class="comment">/* analyzing_roworder_intersect */</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* analyzing_range_alternatives */</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;chosen_range_access_summary&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>   <span class="comment">//选择范围访问摘要</span></span><br><span class="line">          <span class="attr">&quot;range_access_plan&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;range_scan&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;ranges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;id &lt; 10&quot;</span></span><br><span class="line">          <span class="punctuation">]</span> <span class="comment">/* ranges */</span></span><br><span class="line">         <span class="punctuation">&#125;</span> <span class="comment">/* range_access_plan */</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;rows_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;cost_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">1.91986</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">/* chosen_range_access_summary */</span></span><br><span class="line">       <span class="punctuation">&#125;</span> <span class="comment">/* range_analysis */</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">     <span class="punctuation">]</span> <span class="comment">/* rows_estimation */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;considered_execution_plans&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="comment">//考虑执行计划</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;plan_prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">       <span class="punctuation">]</span> <span class="comment">/* plan_prefix */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;best_access_path&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//最佳访问路径</span></span><br><span class="line">         <span class="attr">&quot;considered_access_paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">         <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;rows_to_scan&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;access_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;range&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;range_details&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;used_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span> <span class="comment">/* range_details */</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;resulting_rows&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">2.81986</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">         <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span> <span class="comment">/* considered_access_paths */</span></span><br><span class="line">       <span class="punctuation">&#125;</span> <span class="comment">/* best_access_path */</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;condition_filtering_pct&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span>  <span class="comment">//行过滤百分比</span></span><br><span class="line">        <span class="attr">&quot;rows_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cost_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">2.81986</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">     <span class="punctuation">]</span> <span class="comment">/* considered_execution_plans */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;attaching_conditions_to_tables&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//将条件附加到表上</span></span><br><span class="line">       <span class="attr">&quot;original_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;attached_conditions_computation&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">]</span> <span class="comment">/* attached_conditions_computation */</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;attached_conditions_summary&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="comment">//附加条件概要</span></span><br><span class="line">       <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;attached&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span> <span class="comment">/* attached_conditions_summary */</span></span><br><span class="line">     <span class="punctuation">&#125;</span> <span class="comment">/* attaching_conditions_to_tables */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;finalizing_table_conditions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;original_table_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;final_table_condition  &quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">     <span class="punctuation">]</span> <span class="comment">/* finalizing_table_conditions */</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;refine_plan&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="comment">//精简计划</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`student`&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">     <span class="punctuation">]</span> <span class="comment">/* refine_plan */</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">  <span class="punctuation">&#125;</span> <span class="comment">/* join_optimization */</span></span><br><span class="line"> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;join_execution&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>   <span class="comment">//执行</span></span><br><span class="line">    <span class="attr">&quot;select#&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">   <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">  <span class="punctuation">&#125;</span> <span class="comment">/* join_execution */</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">//第3部分：跟踪信息过长时，被截断的跟踪信息的字节数。</span></span><br><span class="line">MISSING_BYTES_BEYOND_MAX_MEM_SIZE<span class="punctuation">:</span> <span class="number">0</span>  <span class="comment">//丢失的超出最大容量的字节</span></span><br><span class="line"><span class="comment">//第4部分：执行跟踪语句的用户是否有查看对象的权限。当不具有权限时，该列信息为1且TRACE字段为空，一般在</span></span><br><span class="line">调用带有SQL SECURITY DEFINER的视图或者是存储过程的情况下，会出现此问题。</span><br><span class="line">INSUFFICIENT_PRIVILEGES<span class="punctuation">:</span> <span class="number">0</span>  <span class="comment">//缺失权限</span></span><br><span class="line"><span class="number">1</span> row in set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h1 id="9-MySQL-监控分析视图-sys-schema"><a href="#9-MySQL-监控分析视图-sys-schema" class="headerlink" title="9. MySQL 监控分析视图 sys schema"></a>9. MySQL 监控分析视图 sys schema</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150035027.png" alt="image-20220814140207739"></p><h2 id="9-1-Sys-schema视图摘要"><a href="#9-1-Sys-schema视图摘要" class="headerlink" title="9.1 Sys schema视图摘要"></a>9.1 Sys schema视图摘要</h2><ol><li>主机相关：以 host_summary 开头，主要汇总了 IO 延迟的信息。</li><li>Innodb 相关：以 innodb 开头，汇总了 innodb buffer 信息和事务等待 innodb 锁的信息。</li><li>I&#x2F;O相关：以 IO 开头，汇总了等待 I&#x2F;O、I&#x2F;O 使用量情况。</li><li>内存使用情况：以 memory 开头，从主机、线程、事件等角度展示内存的使用情况</li><li>连接与会话信息：processlist 和 session 相关视图，总结了会话相关信息。</li><li>表相关：以 schema_table 开头的视图，展示了表的统计信息。</li><li>索引信息：统计了索引的使用情况，包含冗余索引和未使用的索引情况。</li><li>语句相关：以 statement 开头，包含执行全表扫描、使用临时表、排序等的语句信息。</li><li>用户相关：以 user 开头的视图，统计了用户使用的文件 I&#x2F;O、执行语句统计信息。</li><li>等待事件相关信息：以 wait 开头，展示等待事件的延迟情况。</li></ol><h2 id="9-2-Sys-schema视图使用场景"><a href="#9-2-Sys-schema视图使用场景" class="headerlink" title="9.2 Sys schema视图使用场景"></a>9.2 Sys schema视图使用场景</h2><p><strong><font color=blue>1. 索引情况</font></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#1. 查询冗余索引</span><br><span class="line">select * from sys.schema_redundant_indexes;</span><br><span class="line"></span><br><span class="line">#2. 查询未使用过的索引</span><br><span class="line">select * from sys.schema_unused_indexes;</span><br><span class="line"></span><br><span class="line">#3. 查询索引的使用情况</span><br><span class="line">select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted</span><br><span class="line">from sys.schema_index_statistics where table_schema=&#x27;dbname&#x27;;</span><br></pre></td></tr></table></figure><p>举例：比如我们查看下数据的的冗余索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from sys.schema_redundant_indexes;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150035832.png" alt="image-20220814141233022"></p><p>我们任意选择一条，比如最后一条，然后查看下student_info的索引情况，看看是否<code>idx_cre_time</code>冗余了</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150035664.png" alt="image-20220814141532332"></p><p>可以 看到 <code>idx_cre_time</code>和<code>idx_cre_time_sid</code>两个索引中都有 <code>create_time</code>。而且联合索引性能要高于单列索引，所以<code>idx_cre_time </code>完全可以删掉~</p><p><strong><font color=blue>2. 表相关</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 查询表的访问量</span><br><span class="line"><span class="keyword">select</span> table_schema,table_name,<span class="built_in">sum</span>(io_read_requests<span class="operator">+</span>io_write_requests) <span class="keyword">as</span> io <span class="keyword">from</span> sys.schema_table_statistics <span class="keyword">group</span> <span class="keyword">by</span> table_schema,table_name <span class="keyword">order</span> <span class="keyword">by</span> io <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> 查询占用bufferpool较多的表</span><br><span class="line"><span class="keyword">select</span> object_schema,object_name,allocated,data</span><br><span class="line"><span class="keyword">from</span> sys.innodb_buffer_stats_by_table <span class="keyword">order</span> <span class="keyword">by</span> allocated limit <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span> 查看表的全表扫描情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.statements_with_full_table_scans <span class="keyword">where</span> db<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure><p>例如：查询表的访问量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 1. 查询表的访问量</span><br><span class="line">select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208150035051.png" alt="image-20220814142303829"></p><p><strong><font color=blue>3. 语句相关</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span> 监控<span class="keyword">SQL</span>执行的频率</span><br><span class="line"><span class="keyword">select</span> db,exec_count,query <span class="keyword">from</span> sys.statement_analysis</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> exec_count <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">2.</span> 监控使用了排序的<span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,first_seen,last_seen,query</span><br><span class="line"><span class="keyword">from</span> sys.statements_with_sorting limit <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">#<span class="number">3.</span> 监控使用了临时表或者磁盘临时表的<span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line"><span class="keyword">from</span> sys.statement_analysis <span class="keyword">where</span> tmp_tables<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">or</span> tmp_disk_tables <span class="operator">&gt;</span><span class="number">0</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (tmp_tables<span class="operator">+</span>tmp_disk_tables) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><strong><font color=blue>4. IO相关</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#查看消耗磁盘IO的文件</span><br><span class="line"><span class="keyword">select</span> file,avg_read,avg_write,avg_read<span class="operator">+</span>avg_write <span class="keyword">as</span> avg_io</span><br><span class="line"><span class="keyword">from</span> sys.io_global_by_file_by_bytes <span class="keyword">order</span> <span class="keyword">by</span> avg_read  limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong><font color=blue>5. InnoDB相关</font></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#行锁阻塞情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure><blockquote><p><strong><font color=red>风险提示：</font></strong></p><p>通过sys库去查询时，MySQL会&#x3D;&#x3D;消耗大量资源&#x3D;&#x3D;去收集相关信息，严重的可能会导致业务请求被阻塞，从而引起故障。建议生产上&#x3D;&#x3D;不要频繁&#x3D;&#x3D;的去查询sys或者<code>performance_ schema</code>、 <code>information_ schema</code>来完成监控、巡检等工作。</p></blockquote><h1 id="10-小结"><a href="#10-小结" class="headerlink" title="10. 小结"></a>10. 小结</h1><p>查询时数据库中最频繁的操作，提高查询速度可以有效地提高MySQL数据库的性能。通过对查询语句的分析可以了解查询语句的执行情况，找出查询语句执行的瓶颈，从而优化查询语句！</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六、索引的创建与设计原则</title>
      <link href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC06%E7%AB%A0_%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC06%E7%AB%A0_%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="1-索引的声明与使用"><a href="#1-索引的声明与使用" class="headerlink" title="1. 索引的声明与使用"></a>1. 索引的声明与使用</h1><h2 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a>1.1 索引的分类</h2><p>MySQL 的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p><ul><li>从 <code>功能逻辑</code> 按照上说，索引主要有 4 种：普通索引、唯一索引、主键索引、全文索引。</li><li>按照 <code>物理实现方式</code> ，索引可以分为 2 种：聚簇索引和非聚簇索引。</li><li>按照 <code>作用字段个数</code> 进行划分，分成单列索引和联合索引。</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091448863.png"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091448096.png" alt="image-20220807151930477"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091448134.png" alt="image-20220807152533114"></p><p><strong>小结：不同的存储引擎支持的索引类型也不一样</strong></p><ul><li><code>InnoDB</code>：支持 B-tree、Full-text 等索引，不支持 Hash 索引；</li><li><code>MyISAM</code>：支持 B-tree、Full-text 等索引，不支持 Hash 索引；</li><li><code>Memory</code>：支持 B-tree、Hash 等 索引，不支持 Full-text 索引；</li><li><code>NDB</code> ：支持 Hash 索引，不支持 B-tree、Full-text 等索引；</li><li><code>Archive</code>：不支 持 B-tree、Hash、Full-text 等索引;</li></ul><h2 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a>1.2 创建索引</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091448671.png" alt="image-20220807160116603"></p><h3 id="1、创建表的时候创建索引"><a href="#1、创建表的时候创建索引" class="headerlink" title="1、创建表的时候创建索引"></a>1、创建表的时候创建索引</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091448341.png" alt="image-20220807160201442"></p><p>&#x3D;&#x3D;隐式的索引创建：&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 1.隐式的添加索引(在添加有主键约束、唯一性约束或者外键约束的字段会自动的创建索引)</span><br><span class="line">CREATE TABLE dept(</span><br><span class="line">    dept_id INT PRIMARY KEY AUTO_INCREMENT,# 创建主键索引</span><br><span class="line">    dept_name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">    emp_id INT PRIMARY KEY AUTO_INCREMENT,# 主键索引</span><br><span class="line">    emp_name VARCHAR(20) UNIQUE,# 唯一索引</span><br><span class="line">    dept_id INT,</span><br><span class="line">    CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id)</span><br><span class="line">); # 外键索引</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;显式的索引创建&#x3D;&#x3D;的话，基本语法格式如下，共有七种情况~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name [col_name data_type]</span><br><span class="line">[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]</span><br></pre></td></tr></table></figure><ul><li><code>UNIQUE</code>、 <code>FULLTEXT</code> 和 <code>SPATIAL</code> 为可选参数，分别表示唯一索引、全文索引和空间索引;</li><li><code>INDEX</code>与<code>KEY</code> 为同义词，两者的作用相同，用来指定创建索引;</li><li><code>index_name</code> 指定索引的名称，为可选参数，如果不指定，那么 MySQL 默认 col_name 为索引名;</li><li><code>col_name</code>为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择;</li><li><code>length</code> 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度;</li><li><code>ASC</code> 或 <code>DESC</code> 指定升序或者降序的索引值存储。</li><li>特例：主键索引使用主键约束的方式来创建。</li></ul><p><font color=blue><strong>1、创建普通索引</strong></font></p><p>在book表中的year_publication字段上建立普通索引，SQL语句如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># ①创建普通的索引</span><br><span class="line">CREATE TABLE book(</span><br><span class="line">    book_id INT ,</span><br><span class="line">    book_name VARCHAR(100),</span><br><span class="line">    AUTHORS VARCHAR(100),</span><br><span class="line">    info VARCHAR(100) ,</span><br><span class="line">    COMMENT VARCHAR(100),</span><br><span class="line">    year_publication YEAR,</span><br><span class="line">    # 声明索引</span><br><span class="line">    INDEX idx_bname(book_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过命令查看索引有没有创建成功 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 方式1：</span><br><span class="line">SHOW CREATE TABLE book; # Linux下添加\G参数</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091448422.png" alt="image-20220808090523313"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 方式2：</span><br><span class="line">SHOW INDEX FROM book;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091448455.png" alt="image-20220808090846222"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#性能分析工具：EXPLAIN，查看索引是否正在使用</span><br><span class="line">EXPLAIN SELECT * from book where book_name = &#x27;mysql高级&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091448525.png" alt="image-20220808094918948"></p><p>EXPLAIN语句输出结果的各个行我们在下一章讲解，这里主要关注两个字段</p><ul><li>possible_keys行给出了MySQL在搜索数据记录时可选用的各个索引</li><li>key行时MySQL实际选用的索引</li></ul><p>可以看到，possible_keys和key值都为idx_bname，查询时使用了索引</p><p><font color=blue><strong>2、创建唯一索引</strong></font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># ②创建唯一索引</span><br><span class="line">CREATE TABLE book1 (</span><br><span class="line">  book_id INT,</span><br><span class="line">  book_name VARCHAR (100),</span><br><span class="line">  AUTHORS VARCHAR (100),</span><br><span class="line">  info VARCHAR (100),</span><br><span class="line">  COMMENT VARCHAR (100),</span><br><span class="line">  year_publication YEAR,</span><br><span class="line">  #声明索引</span><br><span class="line">  UNIQUE INDEX uk_idx_cmt (COMMENT)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show INDEX from book1;# 查看索引</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091448621.png" alt="image-20220808101437110"></p><p><font color=blue><strong>3、主键索引</strong></font></p><p>设定为主键后数据库会自动建立索引，innodb为聚簇索引，语法:</p><ul><li><p>随表一起建索引:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ③主键索引</span><br><span class="line"># 通过定义主键约束的方式定义主键索引</span><br><span class="line">create table book2(</span><br><span class="line">    book_id int primary key,</span><br><span class="line">    book_name varchar(100),</span><br><span class="line">    AUTHORS VARCHAR (100),</span><br><span class="line">    info VARCHAR (100),</span><br><span class="line">    COMMENT VARCHAR (100),</span><br><span class="line">    year_publication YEAR</span><br><span class="line">) ;</span><br></pre></td></tr></table></figure></li><li><p>删除主键索引:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 通过删除主键约束的方式删除主键索引</span><br><span class="line">alter table book2</span><br><span class="line">drop primary key;</span><br></pre></td></tr></table></figure></li><li><p>修改主键索引：必须先删除掉（drop）原索引，再新建（add）索引</p></li></ul><p><font color=blue><strong>4、创建单列索引</strong></font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#④ 创建单列索引</span><br><span class="line">CREATE TABLE book3(</span><br><span class="line">    book_id INT,</span><br><span class="line">    book_name VARCHAR(100),</span><br><span class="line">    AUTHORS VARCHAR (100),</span><br><span class="line">    info VARCHAR (100),</span><br><span class="line">    COMMENT VARCHAR (100),</span><br><span class="line">    year_publication YEAR,</span><br><span class="line">    UNIQUE INDEX idx_bname(book_name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">show index from book3;</span><br></pre></td></tr></table></figure><p><font color=blue><strong>5、创建组合索引</strong></font></p><p>举例：创建表 book4，在表中的 book_id、book_name和 info字段上建立组合索引，SQL 语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ⑤ 创建联合索引</span><br><span class="line">create table book4(</span><br><span class="line">    book_id INT,</span><br><span class="line">    book_name VARCHAR(100),</span><br><span class="line">    AUTHORS VARCHAR (100),</span><br><span class="line">    info VARCHAR (100),</span><br><span class="line">    COMMENT VARCHAR (100),</span><br><span class="line">    year_publication YEAR,</span><br><span class="line">    index mul_bid_bname_info(book_id,book_name,info)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SHOW INDEX FROM book4;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091449838.png" alt="image-20220808103642336"></p><p>注意上面三行依次是book_id,book_name,info，与我们创建索引时指定的顺序是严格对应的。在查询时会遵守最左索引原则，&#x3D;&#x3D;先进行book_id条件的比较，然后再进行book_name比较，最后才是info&#x3D;&#x3D;。因此注意把最常用的查询字段放在索引的最左边。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 分析</span><br><span class="line">explain select * from book4 where book_id = 1001 and book_name = &#x27;mysql&#x27;; # 会使用到mul_bid_bname_info索引</span><br><span class="line"></span><br><span class="line">explain select * from book4 where book_name = &#x27;mysql&#x27;;# 不会使用到mul_bid_bname_info索引</span><br></pre></td></tr></table></figure><p><font color=blue><strong>6、 创建全文索引</strong></font></p><p>FULLTEXT全文索引可以用于全文搜索，并且只为<code>CHAR</code>、<code>VARCHAR</code>和<code>TEXT</code>列创建索引。索引总是对整个列进行，不支持局部（前缀）索引。</p><p>举例1：创建表test4，在表中的 info 字段上建立全文索引，SQL 语句如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test4(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    age <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    FULLTEXT INDEX futxt_idx_info(info)</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure><blockquote><p>在 MySQL 5.7 及之后版本中可以不指定最后的 ENGINE 了，因为在此版本中 InnoDB 支持全文索引。</p></blockquote><p>语句执行完毕后，用SHOW CREATE TABLE查看表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test4\G;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091449852.png" alt="image-20220808105219393"></p><p>由结果可以看到，info字段上已经成功建立了一个名为futxt_idx_info的FULLTEXT索引。</p><p>举例2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    title <span class="type">VARCHAR</span> (<span class="number">200</span>),</span><br><span class="line">    body TEXT,</span><br><span class="line">    FULLTEXT index (title, body)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB ;</span><br></pre></td></tr></table></figure><p>创建了一个给 title 和 body 字段添加全文索引的表。</p><p>举例3：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `papers` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `title` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `content` text,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  FULLTEXT KEY `title` (`title`,`content`)</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>不同于 like 方式的的查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> content <span class="keyword">LIKE</span> ‘<span class="operator">%</span>查询字符串<span class="operator">%</span>’;</span><br></pre></td></tr></table></figure><p>全文索引用 <code>match+against</code> 方式查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title,content) AGAINST (‘查询字符串’);</span><br></pre></td></tr></table></figure><p>明显的提高查询效率</p><blockquote><p>注意点</p><ol><li>使用全文索引前，搞清楚版本支持情况；</li><li>全文索引比like + % 快 N倍，但是可能存在精度问题</li><li>如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</li></ol></blockquote><p><strong><font color=blue>7、创建空间索引</font></strong></p><p>空间索引创建中，要求空间类型的字段必须为 <code>非空</code> 。</p><p>举例：创建表 test5，在空间类型为 GEOMETRY 的字段上创建空间索引，SQL 语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test5(</span><br><span class="line">    geo GEOMETRY NOT NULL,</span><br><span class="line">    SPATIAL INDEX spa_idx_geo(geo)</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test5\G;</span><br></pre></td></tr></table></figure><p>可以看到，test5的geo字段上创建了名称为spa_idx_geo的空间索引。注意创建时指定空间类型字段值的非空约束，并且表的存储引擎为MyISAM</p><h3 id="2、在已经存在的表上创建索引"><a href="#2、在已经存在的表上创建索引" class="headerlink" title="2、在已经存在的表上创建索引"></a>2、在已经存在的表上创建索引</h3><p>在已经存在的表中创建索引可以使用 ALTER TABLE 语句或者 CREATE INDEX 语句。</p><p><font color=blue><strong>1. 使用 ALTER TABLE 语句创建索引</strong></font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]</span><br><span class="line">[index_name] (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091449511.png"></p><p><font color=blue> <strong>2. 使用 CREATE INDEX 创建索引</strong> </font></p><p>CREATE INDEX 语句可以在已经存在的表上添加索引，在 MySQL 中， CREATE INDEX 被映射到一个 ALTER TABLE 语句上，基本语法结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name</span><br><span class="line">ON table_name (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure><p>举例1：在book表的comment字段上建立名为 的普通索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_cmt on book(comment);</span><br></pre></td></tr></table></figure><p>举例2：在book表中的book_id字段上建立名为uk_idx_bid的唯一索引，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX uk_idx_bid ON book(book_id);</span><br></pre></td></tr></table></figure><p>举例3：在book表的book_id、book_name、info字段上建立联合索引，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX mul_bid_bname_info ON book(book_id,book_name,info);</span><br></pre></td></tr></table></figure><h2 id="1-3-删除索引"><a href="#1-3-删除索引" class="headerlink" title="1.3 删除索引"></a>1.3 删除索引</h2><p>MySQL中删除索引使用<code>ALTER TABLE</code>或<code>DROP INDEX</code>语句，两者可实现相同的功能，DROP INDEX语句在内部被映射到一个ALTER TABLE语句中</p><p><strong><font color=blue>1. 使用 ALTER TABLE 删除索引：</font></strong></p><p>ALTER TABLE删除索引的基本语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure><p>练习：删除book表中名称为idx_bk_id的唯一索引</p><p>首先查看book表中是否名称为idx_bk_id的索引，输入SHOW语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM book\G;</span><br></pre></td></tr></table></figure><p>下面删除该索引，输入删除语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE book DROP INDEX idx_bk_id;</span><br></pre></td></tr></table></figure><blockquote><p>提示</p><p>添加AUTO_INCREMENT约束字段的唯一索引不能被删除（）</p></blockquote><p><strong><font color=blue>2. 使用 DROP INDEX 语句删除索引：</font></strong></p><p>DROP INDEX删除索引的基本语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure><p>练习：删除book表中名称为idx_aut_info的组合索引，SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX idx_aut_info ON book;</span><br></pre></td></tr></table></figure><p>语句执行完毕，使用SHOW查看索引是否删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE book\G;</span><br></pre></td></tr></table></figure><p>可以看到，book表中已经没有名称为idx_aut_info的组合索引，删除索引成功。</p><blockquote><p>提示 删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p></blockquote><h1 id="2-MySQL-8-0-索引新特性"><a href="#2-MySQL-8-0-索引新特性" class="headerlink" title="2. MySQL 8.0 索引新特性"></a>2. MySQL 8.0 索引新特性</h1><h2 id="2-1-支持降序索引"><a href="#2-1-支持降序索引" class="headerlink" title="2.1 支持降序索引"></a>2.1 支持降序索引</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091449173.png" alt="image-20220808170744466"></p><p>举例：分别在 MySQL 5.7 版本和 MySQL 8.0 版本中创建数据表 ts1，结果如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ts1(a <span class="type">int</span>,b <span class="type">int</span>,index idx_a_b(a,b <span class="keyword">desc</span>)); </span><br></pre></td></tr></table></figure><p>在 MySQL 5.7 版本中查看数据表 ts1 的结构，结果如下:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091449413.png" alt="image-20220808172040782"></p><p>从结果可以看出，索引仍然是默认的<strong>升序</strong>。<br>在MySQL 8.0版本中查看数据表ts1的结构，结果如下:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091449270.png" alt="image-20220808171900102"></p><p>从结果可以看出，索引已经是<strong>降序</strong>了。下面继续测试降序索引在执行计划中的表现。</p><p>分别在 MySQL 5.7 版本和 MySQL 8.0 版本的数据表 ts1 中插入 800 条随机数据，执行语句如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ts_insert()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;</span> <span class="number">800</span></span><br><span class="line">    DO</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> ts1 <span class="keyword">select</span> rand()<span class="operator">*</span><span class="number">80000</span>,rand()<span class="operator">*</span><span class="number">80000</span>;</span><br><span class="line">        <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ; </span><br><span class="line">#调用</span><br><span class="line"><span class="keyword">CALL</span> ts_insert();</span><br></pre></td></tr></table></figure><p>在 MySQL 5.7 版本中查看数据表 ts1 的执行计划，结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 优化测试</span><br><span class="line">EXPLAIN SELECT * FROM ts1 ORDER BY a,b DESC LIMIT 5;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091449501.png" alt="image-20220808175038459"></p><p>从结果可以看出，执行计划中扫描数为 799，而且使用了 Using filesort。</p><blockquote><p>提示：Using filesort 是MySQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员可以通过优化索引来尽量避免出现 Using filesort，从而提高数据库执行速度。</p></blockquote><p>在 MySQL 8.0 版本中查看数据表 ts1 的执行计划</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091449174.png" alt="image-20220808175311396"></p><p>从结果可以看出，执行计划中扫描数为 5，而且没有使用 Using filesort。</p><blockquote><p>注意：降序索引只对查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述查询排序条件改为 order by a desc, b desc，MySQL 5.7 的执行计划要明显好于 MySQL 8.0。</p></blockquote><p>将排序条件改为<code>order by a desc,b desc</code>后，下面来对比不同版本中执行计划的效果。</p><p>在MySQL5.7版本中查看数据表ts1的执行计划，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 优化测试</span><br><span class="line">EXPLAIN SELECT * FROM ts1 ORDER BY a DESC,b DESC LIMIT 5;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091449645.png" alt="image-20220808175614660"></p><p>在 MySQL 8.0 版本中查看数据表 ts1 的执行计划</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091449045.png" alt="image-20220808175714902"></p><p>从结果可以看出，修改后MySQL5.7的执行计划明显好于MySQL8.0</p><h2 id="2-2-隐藏索引（invisible-indexes）"><a href="#2-2-隐藏索引（invisible-indexes）" class="headerlink" title="2.2 隐藏索引（invisible indexes）"></a>2.2 隐藏索引（invisible indexes）</h2><p>在 MySQL 5.7 版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。</p><p>从MySQL 8.x 开始支持 <code>隐藏索引(invisible indexes)</code>，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用 force index（强制使用索引），优化器也不会使用该索引）， 确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。<code>这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除</code>。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091449197.png" alt="image-20220808180625440"></p><p><font color=blue><strong>1. 创建表时直接创建</strong> </font></p><p>在 MySQL 中创建隐藏索引通过 SQL 语句 <code>INVISIBLE</code> 来实现，其语法形式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename(</span><br><span class="line">    propname1 type1[CONSTRAINT1],</span><br><span class="line">    propname2 type2[CONSTRAINT2],</span><br><span class="line">    ......</span><br><span class="line">    propnamen typen,</span><br><span class="line">    INDEX [indexname](propname1 [(length)]) INVISIBLE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上述语句比普通索引多了一个关键字 <code>INVISIBLE</code>，用来标记索引为不可见索引。</p><p>练习：在创建书籍表book时，在字段<code>idx_cmt</code>上创建隐藏索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#① 创建表时，隐藏索引</span><br><span class="line">create table book(</span><br><span class="line">    book_id INT,</span><br><span class="line">    book_name VARCHAR(100),</span><br><span class="line">    AUTHORS VARCHAR (100),</span><br><span class="line">    info VARCHAR (100),</span><br><span class="line">    COMMENT VARCHAR (100),</span><br><span class="line">    year_publication YEAR,</span><br><span class="line">    # 创建不可见的索引</span><br><span class="line">    index idx_cmt(comment) invisible</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过explain查看发现，优化器并没有使用索引，而是使用的全表扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from book7 where comment = &#x27;mysql...&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091449719.png" alt="image-20220808191648127"></p><p><font color=blue><strong>2. 在已经存在的表上创建</strong></font></p><p>可以为已经存在的表设置隐藏索引，其语法形式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX indexname</span><br><span class="line"><span class="keyword">ON</span> tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_year_pub ON book(year_publication) INVISIBLE;</span><br></pre></td></tr></table></figure><p><font color=blue><strong>3. 通过 ALTER TABLE 语句创建</strong></font></p><p>语法形式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename</span><br><span class="line"><span class="keyword">ADD</span> INDEX indexname (propname [(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE book</span><br><span class="line">ADD UNIQUE INDEX uk_idx_bname(book_name) INVISIBLE;</span><br></pre></td></tr></table></figure><p><font color=blue><strong>4. 切换索引可见状态</strong> </font></p><p>已存在的索引可通过如下语句切换可见状态:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引 </span><br><span class="line">ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 修改索引的可见性</span><br><span class="line">ALTER TABLE book ALTER INDEX idx_year_pub invisible;#可见---&gt;不可见</span><br><span class="line">ALTER TABLE book ALTER INDEX idx_cmt visible;#不可见---》可见</span><br></pre></td></tr></table></figure><p>如果将 idx_cmt 索引切换成可见状态，通过 explain 查看执行计划，发现优化器选择了<code>idx_cmt</code>索引</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091449525.png" alt="image-20220808192215266"></p><blockquote><p><strong>注意：</strong>当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p></blockquote><p>通过设置隐藏索引的可见性可以查看索引对调优的帮助。</p><p><strong><font color=blue>5. 使隐藏索引对查询优化器可见(了解)</font></strong></p><p>在 MySQL 8.x 版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关 （use_invisible_indexes）来打开某个设置，使隐藏索引对查询优化器可见。如果 use_invisible_indexes 设置为 off（默认），优化器会忽略隐藏索引。如果设置为 on，即使隐藏索引不可见，优化器在生成执行计划时仍会考虑使用隐藏索引。</p><p>（1）在 MySQL 命令行执行如下命令查看查询优化器的开关设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@optimizer_switch \G</span><br></pre></td></tr></table></figure><p>在输出的结果信息中找到如下属性配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_invisible_indexes=off</span><br></pre></td></tr></table></figure><p>此属性配置值为off，说明隐藏索引默认对查询优化器不可见。</p><p>（2）使隐藏索引对查询优化器可见，需要在 MySQL 命令行执行如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session optimizer_switch=&quot;use_invisible_indexes=on&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>SQL 语句执行成功，再次查看查询优化器的开关设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  select @@optimizer_switch \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@optimizer_switch:</span><br><span class="line">index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_</span><br><span class="line">intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_co</span><br><span class="line">st_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on</span><br><span class="line">,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on</span><br><span class="line">,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_ind</span><br><span class="line">exes=on,skip_scan=on,hash_join=on</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>此时，在输出结果中可以看到如下属性配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_invisible_indexes=on</span><br></pre></td></tr></table></figure><p>use_invisible_indexes 属性的值为 on，说明此时隐藏索引对查询优化器可见。</p><p>（3）使用 EXPLAIN 查看以字段 invisible_column 作为查询条件时的索引使用情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from classes where cname = &#x27;高一2班&#x27;;</span><br></pre></td></tr></table></figure><p>查询优化器会使用隐藏索引来查询数据。</p><p>（4）如果需要使隐藏索引对查询优化器不可见，则只需要执行如下命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session optimizer_switch=&quot;use_invisible_indexes=off&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>再次查看查询优化器的开关设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@optimizer_switch \G;</span><br></pre></td></tr></table></figure><p>此时，use_invisible_indexes 属性的值已经被设置为“off”。</p><h1 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3. 索引的设计原则"></a>3. 索引的设计原则</h1><h2 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h2><p><strong>第1步：创建数据库、创建表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE testdb1;</span><br><span class="line">USE atguigudb1;</span><br><span class="line">#<span class="number">1.</span>创建学生表和课程表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student_info` (</span><br><span class="line">     `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">     `student_id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">     `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     `course_id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">     `class_id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     `create_time` DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">     <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `course` (</span><br><span class="line">    `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `course_id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    `course_name` <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p><strong>第2步：创建模拟数据必需的存储函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#函数<span class="number">1</span>:创建随机产生字符串函数</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>)</span><br><span class="line">    <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>) #该函数会返回一个字符串 </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">       <span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line">       <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#函数<span class="number">2</span>:创建随机数函数</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num (from_num <span class="type">INT</span> ,to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span>RAND()<span class="operator">*</span>(to_num <span class="operator">-</span> from_num<span class="operator">+</span><span class="number">1</span>)) ;</span><br><span class="line"><span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>创建函数，假如报错:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This function has none of DETERMINISTIC......</span><br></pre></td></tr></table></figure><p>由于开启过慢查询日志 bin-log, 我们就必须为我们的 function 指定一个参数。</p><p>主从复制，主机会将写操作记录在 bin-log 日志中。从机读取 bin-log 日志，执行语句来同步数据。如果使用函数来操作数据，会导致从机和主机操作时间不一致。所以，默认情况下，mysql 不开启创建函数设置。</p><ul><li><p>查看 mysql 是否允许创建函数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_bin_trust_function_creators&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>命令开启：允许创建函数设置:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>; </span><br></pre></td></tr></table></figure></li><li><p>mysqld 重启，上述参数又会消失。永久方法：</p><ul><li><p>windows下：my.ini[mysqld]加上：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>linux下：&#x2F;etc&#x2F;my.cnf 下 my.cnf[mysqld] 加上：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>第3步：创建插入模拟数据的存储过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> # 存储过程1:创建插入课程表存储过程</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_course( max_num INT ) BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit = 0; #设置手动提交事务</span><br><span class="line">REPEAT #循环</span><br><span class="line">SET i=i+1; #赋值</span><br><span class="line">INSERT INTO course(course_id, course_name)VALUES(rand_num(10000,10100),rand_string(6));</span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT;</span><br><span class="line">COMMIT; #提交事务 </span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 存储过程<span class="number">2</span>:创建插入学生信息表存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu( max_num <span class="type">INT</span> ) <span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>; #设置手动提交事务</span><br><span class="line">REPEAT #循环</span><br><span class="line"><span class="keyword">SET</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>; #赋值</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student_info (course_id, class_id ,student_id ,NAME ) <span class="keyword">VALUES</span></span><br><span class="line">(rand_num(<span class="number">10000</span>,<span class="number">10100</span>),rand_num(<span class="number">10000</span>,<span class="number">10200</span>),rand_num(<span class="number">1</span>,<span class="number">200000</span>),rand_string(<span class="number">6</span>)); UNTIL i <span class="operator">=</span> max_num</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br><span class="line"><span class="keyword">COMMIT</span>; #提交事务</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong>第4步：调用存储过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CALL insert_course(100); # 课程表中添加100条数据</span><br><span class="line">CALL insert_stu(1000000);# 学生表中插入1000000条数据</span><br></pre></td></tr></table></figure><h2 id="3-2-哪些情况适合创建索引"><a href="#3-2-哪些情况适合创建索引" class="headerlink" title="3.2 哪些情况适合创建索引"></a>3.2 哪些情况适合创建索引</h2><h3 id="1、字段的数值有唯一性的限制"><a href="#1、字段的数值有唯一性的限制" class="headerlink" title="1、字段的数值有唯一性的限制"></a>1、字段的数值有唯一性的限制</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091450827.png" alt="image-20220808223333115"></p><h3 id="2、频繁作为-WHERE-查询条件的字段"><a href="#2、频繁作为-WHERE-查询条件的字段" class="headerlink" title="2、频繁作为 WHERE 查询条件的字段"></a>2、频繁作为 WHERE 查询条件的字段</h3><p>某个字段在 SELECT 语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p><p>比如 student_info 数据表（含 100 万条数据），假设我们想要查询 student_id&#x3D;123110 的用户信息。</p><p><font color=green>①查看<code>student_info</code>表中的索引</font></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091450245.png" alt="image-20220808232908970"></p><p>可以看出，我们没有对student_id字段创建索引。</p><p><font color=green>②进行如下查询</font>，耗时220ms</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091450669.png" alt="image-20220808232610826"></p><p><font color=green>③添加索引</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table student_info add index idx_sid(student_id);</span><br></pre></td></tr></table></figure><p><font color=green>④再查询。耗时0ms。性能提升杠杠的~</font></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091450316.png" alt="image-20220808233519505"></p><h3 id="3、经常-GROUP-BY-和-ORDER-BY-的列"><a href="#3、经常-GROUP-BY-和-ORDER-BY-的列" class="headerlink" title="3、经常 GROUP BY 和 ORDER BY 的列"></a>3、经常 GROUP BY 和 ORDER BY 的列</h3><p>索引其实就是让数据按照某种顺序进行存储或检索。当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，如果 <code>对分组或者排序的字段建立索引</code>，本身索引的数据就已经排好序了，进行分组查询和排序操作性能不是很nice吗？另外，如果待排序的列有多个，那么可以在这些列上建立 <code>组合索引</code> 。</p><p><font color=green>①下面在有<code>student_id</code>索引的情况下，查询：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT student_id,COUNT(*) AS num</span><br><span class="line">    -&gt; FROM student_info</span><br><span class="line">    -&gt; GROUP BY student_id</span><br><span class="line">    -&gt; LIMIT 100;</span><br><span class="line">+------------+-----+</span><br><span class="line">| student_id | num |</span><br><span class="line">+------------+-----+</span><br><span class="line">|          1 |   5 |</span><br><span class="line">.....此处省略n行......</span><br><span class="line">|          3 |   4 |</span><br><span class="line">|        101 |   7 |</span><br><span class="line">+------------+-----+</span><br><span class="line">100 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><font color=green>②删除索引</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#删除idx_sid索引</span><br><span class="line">DROP INDEX idx_sid ON student_info;</span><br></pre></td></tr></table></figure><p><font color=green>③再次查询 ，慢的像蜗牛~</font> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT student_id,COUNT(*) AS num</span><br><span class="line">    -&gt; FROM student_info</span><br><span class="line">    -&gt; GROUP BY student_id</span><br><span class="line">    -&gt; LIMIT 100;</span><br><span class="line">+------------+-----+</span><br><span class="line">| student_id | num |</span><br><span class="line">+------------+-----+</span><br><span class="line">|      95666 |   9 |</span><br><span class="line">.....此处省略n行......</span><br><span class="line">|     173440 |  14 |</span><br><span class="line">|      67234 |   9 |</span><br><span class="line">+------------+-----+</span><br><span class="line">100 rows in set (0.78 sec)</span><br></pre></td></tr></table></figure><p><strong>同样，如果是ORDER BY，也需要对字段创建索引</strong></p><p><font color=green>④如果同时使用<code>GROUP BY</code>和<code>ORDER BY</code>，先看看不加索引的情况</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT student_id,COUNT(*) AS num FROM student_info</span><br><span class="line">    -&gt; GROUP BY student_id</span><br><span class="line">    -&gt; ORDER BY create_time DESC</span><br><span class="line">    -&gt; LIMIT 100;</span><br><span class="line">ERROR 1055 (42000): Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column &#x27;atguigudb1.student_info.create_time&#x27; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by</span><br></pre></td></tr></table></figure><p><font color=green>⑤出现了一个异常信息，这是因为我们使用的<code>sql_mode</code>是<code>only_full_group_by</code>。修改下再来查询，时间代价是6.61s</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@sql_mode;</span><br><span class="line">+-----------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| @@sql_mode                                                                                                            |</span><br><span class="line">+-----------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION |</span><br><span class="line">+-----------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SET @@sql_mode = &#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec); # 去掉ONLY_FULL_GROUP_BY</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT student_id,COUNT(*) AS num FROM student_info</span><br><span class="line">    -&gt; GROUP BY student_id</span><br><span class="line">    -&gt; ORDER BY create_time DESC</span><br><span class="line">    -&gt; LIMIT 100;</span><br><span class="line">+------------+-----+</span><br><span class="line">| student_id | num |</span><br><span class="line">+------------+-----+</span><br><span class="line">|      21497 |   1 |</span><br><span class="line">|      17311 |   1 |</span><br><span class="line">.....此处省略n行......</span><br><span class="line">|     183509 |   1 |</span><br><span class="line">+------------+-----+</span><br><span class="line">100 rows in set (6.61 sec)</span><br></pre></td></tr></table></figure><p><font color=green>⑥再看看两个字段分别建立单列索引的情况，耗时5.26 s，快了一点点</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE student_info ADD INDEX idx_sid(student_id);</span><br><span class="line">Query OK, 0 rows affected (1.77 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; ALTER TABLE student_info ADD INDEX idx_cre_time(create_time);</span><br><span class="line">Query OK, 0 rows affected (1.49 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT student_id,COUNT(*) AS num FROM student_info</span><br><span class="line">    -&gt; GROUP BY student_id</span><br><span class="line">    -&gt; ORDER BY create_time DESC</span><br><span class="line">    -&gt; LIMIT 100;</span><br><span class="line">+------------+-----+</span><br><span class="line">| student_id | num |</span><br><span class="line">+------------+-----+</span><br><span class="line">|      64044 |   1 |</span><br><span class="line">.....此处省略n行......</span><br><span class="line">|     101052 |   1 |</span><br><span class="line">|     152620 |   1 |</span><br><span class="line">+------------+-----+</span><br><span class="line">100 rows in set (5.26 sec)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>建立多个单列索引，并不会都走，像刚才这个例子，只会走idx_sid索引</p><p><font color=green>⑦分析下它的查询过程,原来我们只用了一个索引，由于我们是先<code>GROUP BY student_id</code>,后<code>ORDER BY create_time</code>，我们实际上只使用了索引<code>idx_sid </code></font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT student_id,COUNT(*) AS num FROM student_info</span><br><span class="line">    -&gt; GROUP BY student_id</span><br><span class="line">    -&gt; ORDER BY create_time DESC</span><br><span class="line">    -&gt; LIMIT 100;</span><br><span class="line">+----+-------------+--------------+------------+-------+---------------+---------+---------+------+--------+----------+---------------------------------+</span><br><span class="line">| id | select_type | table        | partitions | type  | possible_keys | key     | key_len | ref  | rows   | filtered | Extra                           |</span><br><span class="line">+----+-------------+--------------+------------+-------+---------------+---------+---------+------+--------+----------+---------------------------------+</span><br><span class="line">|  1 | SIMPLE      | student_info | NULL       | index | idx_sid       | idx_sid | 4       | NULL | 997130 |   100.00 | Using temporary; Using filesort |</span><br><span class="line">+----+-------------+--------------+------------+-------+---------------+---------+---------+------+--------+----------+---------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p><font color=green>⑧建立联合索引的情况,芜湖起飞，直接0.25s。此时我们用<code>EXPLAIN</code>查看命中的也是 联合索引</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  ALTER TABLE student_info ADD INDEX idx_sid_cre_time(student_id,create_time DESC);</span><br><span class="line">Query OK, 0 rows affected (2.09 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT student_id,COUNT(*) AS num FROM student_info</span><br><span class="line">    -&gt; GROUP BY student_id</span><br><span class="line">    -&gt; ORDER BY create_time DESC</span><br><span class="line">    -&gt; LIMIT 100;</span><br><span class="line">+------------+-----+</span><br><span class="line">| student_id | num |</span><br><span class="line">+------------+-----+</span><br><span class="line">|       1226 |   8 |</span><br><span class="line">.....此处省略n行......</span><br><span class="line">|       1400 |   2 |</span><br><span class="line">+------------+-----+</span><br><span class="line">100 rows in set (0.25 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN SELECT student_id,COUNT(*) AS num FROM student_info</span><br><span class="line">    -&gt; GROUP BY student_id</span><br><span class="line">    -&gt; ORDER BY create_time DESC</span><br><span class="line">    -&gt; LIMIT 100;</span><br><span class="line">+----+-------------+--------------+------------+-------+--------------------------+------------------+---------+------+--------+----------+----------------------------------------------+</span><br><span class="line">| id | select_type | table        | partitions | type  | possible_keys            | key              | key_len | ref  | rows   | filtered | Extra                                        |</span><br><span class="line">+----+-------------+--------------+------------+-------+--------------------------+------------------+---------+------+--------+----------+----------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | student_info | NULL       | index | idx_sid,idx_sid_cre_time | idx_sid_cre_time | 10      | NULL | 997130 |   100.00 | Using index; Using temporary; Using filesort |</span><br><span class="line">+----+-------------+--------------+------------+-------+--------------------------+------------------+---------+------+--------+----------+----------------------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p><font color=green>⑨再来测试,交换字段顺序建立联合索引<code>idx_cre_time_sid</code>，耗时5.24s。下面查询真正使用的索引<code>key</code>是<code>idx_sid </code></font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE student_info ADD INDEX idx_cre_time_sid(create_time DESC,student_id);</span><br><span class="line">Query OK, 0 rows affected (2.10 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; DROP INDEX idx_sid_cre_time ON student_info; #删除联合索引idx_sid_cre_time</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; show INDEX from student_info; # 查看student_info中的索引</span><br><span class="line">+--------------+------------+------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span><br><span class="line">| Table        | Non_unique | Key_name         | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |</span><br><span class="line">+--------------+------------+------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span><br><span class="line">| student_info |          0 | PRIMARY          |            1 | id          | A         |      993366 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |</span><br><span class="line">| student_info |          1 | idx_sid          |            1 | student_id  | A         |      199180 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |</span><br><span class="line">| student_info |          1 | idx_cre_time     |            1 | create_time | A         |          82 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |</span><br><span class="line">| student_info |          1 | idx_cre_time_sid |            1 | create_time | D         |          77 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |</span><br><span class="line">| student_info |          1 | idx_cre_time_sid |            2 | student_id  | A         |      967825 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |</span><br><span class="line">+--------------+------------+------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT student_id,COUNT(*) AS num FROM student_info</span><br><span class="line">    -&gt; GROUP BY student_id</span><br><span class="line">    -&gt; ORDER BY create_time DESC</span><br><span class="line">    -&gt; LIMIT 100;</span><br><span class="line">+------------+-----+</span><br><span class="line">| student_id | num |</span><br><span class="line">+------------+-----+</span><br><span class="line">|      64044 |   1 |</span><br><span class="line">.....此处省略n行......</span><br><span class="line">|     101052 |   1 |</span><br><span class="line">|     152620 |   1 |</span><br><span class="line">+------------+-----+</span><br><span class="line">100 rows in set (5.24 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN SELECT student_id,COUNT(*) AS num FROM student_info</span><br><span class="line">    -&gt; GROUP BY student_id</span><br><span class="line">    -&gt; ORDER BY create_time DESC</span><br><span class="line">    -&gt; LIMIT 100;#起作用的是idx_sid</span><br><span class="line">+----+-------------+--------------+------------+-------+--------------------------+---------+---------+------+--------+----------+---------------------------------+</span><br><span class="line">| id | select_type | table        | partitions | type  | possible_keys            | key     | key_len | ref  | rows   | filtered | Extra                           |</span><br><span class="line">+----+-------------+--------------+------------+-------+--------------------------+---------+---------+------+--------+----------+---------------------------------+</span><br><span class="line">|  1 | SIMPLE      | student_info | NULL       | index | idx_sid,idx_cre_time_sid | idx_sid | 4       | NULL | 997130 |   100.00 | Using temporary; Using filesort |</span><br><span class="line">+----+-------------+--------------+------------+-------+--------------------------+---------+---------+------+--------+----------+---------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>如果我们仅仅使用GROUP BY 或者 ORDER BY，且后面只有一个字段，则单独建立索引；如果后面跟多个字段，则建立联合索引。如果既有GROUP BY 又有 ORDER BY，那就建立联合索引，且GROUP BY的字段写在前面，ORDER BY的字段写在后面。8.0后的版本也可以考虑使用降序索引</p><h3 id="4、UPDATE、DELETE-的-WHERE-条件列"><a href="#4、UPDATE、DELETE-的-WHERE-条件列" class="headerlink" title="4、UPDATE、DELETE 的 WHERE 条件列"></a>4、UPDATE、DELETE 的 WHERE 条件列</h3><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。 &#x3D;&#x3D;如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE student_info SET student_id = 10002</span><br><span class="line">    -&gt;  WHERE NAME = &#x27;462eed7ac6e791292a79&#x27;;# 550ms</span><br><span class="line">Query OK, 0 rows affected (0.55 sec)</span><br><span class="line">Rows matched: 0  Changed: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; ALTER TABLE student_info</span><br><span class="line">    -&gt; ADD INDEX idx_name(NAME);</span><br><span class="line">Query OK, 0 rows affected (2.26 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE student_info SET student_id = 10002</span><br><span class="line">    -&gt; WHERE NAME = &#x27;462eed7ac6e791292a79&#x27;;# 1ms</span><br><span class="line">Query OK, 0 rows affected (0.001 sec)</span><br><span class="line">Rows matched: 0  Changed: 0  Warnings: 0</span><br></pre></td></tr></table></figure><h3 id="5、DISTINCT-字段需要创建索引"><a href="#5、DISTINCT-字段需要创建索引" class="headerlink" title="5、DISTINCT 字段需要创建索引"></a>5、DISTINCT 字段需要创建索引</h3><p>有时候我们需要对某个字段进行去重，使用 <code>DISTINCT</code>，那么对这个字段创建索引，也会提升查询效率。</p><p>比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(student_id) <span class="keyword">FROM</span> `student_info`; </span><br></pre></td></tr></table></figure><p>运行结果（600637 条记录，运行时间 0.683s ）</p><p>如果我们对 student_id 创建索引，再执行 SQL 语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(student_id) <span class="keyword">FROM</span> `student_info`;</span><br></pre></td></tr></table></figure><p>运行结果（600637 条记录，运行时间<code>0.010s</code> ）<br>你能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照 <code>递增的顺序</code> 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。</p><h3 id="6、多表-JOIN-连接操作时，创建索引注意事项"><a href="#6、多表-JOIN-连接操作时，创建索引注意事项" class="headerlink" title="6、多表 JOIN 连接操作时，创建索引注意事项"></a>6、多表 JOIN 连接操作时，创建索引注意事项</h3><p>首先，<code>连接表的数量尽量不要超过 3 张</code> ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快(n ,n^2 , n^3…)，严重影响查询的效率。</p><p>其次，<code>对 WHERE 条件创建索引</code>，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p><blockquote><p>🔊注意：对于用连接的字段创建索引，这些&#x3D;&#x3D;字段在多张表中的 类型必须一致&#x3D;&#x3D; 。比如 course_id 在student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。否则在查询时，虽然也会帮我们进行隐式的类型转换，转换时会使用函数，但会导致&#x3D;&#x3D;索引失效&#x3D;&#x3D;。索引失效情况在后续文章中还会给大家详细介绍，敬请期待。</p></blockquote><p>举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句，耗时0.21s</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> c.course_id, NAME, s.student_id, course_name</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> student_info s <span class="keyword">JOIN</span> course c</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> s.course_id <span class="operator">=</span> c.course_id</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;WloNYD&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> course_id <span class="operator">|</span> NAME   <span class="operator">|</span> student_id <span class="operator">|</span> course_name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+------------+-------------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">10077</span> <span class="operator">|</span> WloNYD <span class="operator">|</span>      <span class="number">95666</span> <span class="operator">|</span> JfydVs      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">10077</span> <span class="operator">|</span> WloNYD <span class="operator">|</span>      <span class="number">95666</span> <span class="operator">|</span> nZkayq      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">10077</span> <span class="operator">|</span> WloNYD <span class="operator">|</span>      <span class="number">95666</span> <span class="operator">|</span> mTHDYg      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">10085</span> <span class="operator">|</span> wLonyD <span class="operator">|</span>      <span class="number">98444</span> <span class="operator">|</span> pZdpsR      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+------------+-------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.21</span> sec)</span><br></pre></td></tr></table></figure><p>这时，我们对 name 创建索引，再执行上面的 SQL 语句，耗时 0.00s </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE student_info</span><br><span class="line">    -&gt; ADD INDEX idx_name(NAME);# 为name创建索引</span><br><span class="line">Query OK, 0 rows affected (2.52 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT c.course_id, name, s.student_id, course_name</span><br><span class="line">    -&gt; FROM student_info s JOIN course c</span><br><span class="line">    -&gt; ON s.course_id = c.course_id</span><br><span class="line">    -&gt; WHERE name = &#x27;WloNYD&#x27;;</span><br><span class="line">+-----------+--------+------------+-------------+</span><br><span class="line">| course_id | name   | student_id | course_name |</span><br><span class="line">+-----------+--------+------------+-------------+</span><br><span class="line">|     10077 | WloNYD |      95666 | mTHDYg      |</span><br><span class="line">|     10077 | WloNYD |      95666 | nZkayq      |</span><br><span class="line">|     10085 | wLonyD |      98444 | pZdpsR      |</span><br><span class="line">|     10077 | WloNYD |      95666 | JfydVs      |</span><br><span class="line">+-----------+--------+------------+-------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="7、使用列的类型小的创建索引"><a href="#7、使用列的类型小的创建索引" class="headerlink" title="7、使用列的类型小的创建索引"></a>7、使用列的类型小的创建索引</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091450695.png" alt="image-20220809123640764"></p><h3 id="8、使用字符串前缀创建索引"><a href="#8、使用字符串前缀创建索引" class="headerlink" title="8、使用字符串前缀创建索引"></a>8、使用字符串前缀创建索引</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091450108.png" alt="image-20220809124018899"></p><p>创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> shop(address <span class="type">varchar</span>(<span class="number">120</span>) <span class="keyword">not</span> <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> shop <span class="keyword">add</span> index(address(<span class="number">12</span>));</span><br></pre></td></tr></table></figure><p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的;截取得少了，重复内容太多，字段的散列度（选择性）会降低。 <strong>怎么计算不同的长度的选择性呢?</strong></p><p>先看一下字段在全部数据中的选择度:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> address) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> shop;</span><br></pre></td></tr></table></figure><p>通过不同长度去计算，与全表的选择性对比:</p><p>公式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(列名, 索引长度))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>)</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">10</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub10, <span class="comment">-- 截取前10个字符的选择度 </span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">15</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub11, <span class="comment">-- 截取前15个字符的选择度 </span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">20</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub12, <span class="comment">-- 截取前20个字符的选择度 </span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">25</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub13 <span class="comment">-- 截取前25个字符的选择度</span></span><br><span class="line"><span class="keyword">from</span> shop;</span><br></pre></td></tr></table></figure><blockquote><p>🎯 拓展：Alibaba《Java开发手册》<br>【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。<br>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达90% 以上 ，可以使用 count(distinct left(列名, 索引长度))&#x2F;count(*)的区分度来确定。</p></blockquote><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091450829.png" alt="image-20220809124350692"></p><h3 id="9、区分度高（散列性高）的列适合作为索引"><a href="#9、区分度高（散列性高）的列适合作为索引" class="headerlink" title="9、区分度高（散列性高）的列适合作为索引"></a>9、区分度高（散列性高）的列适合作为索引</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091450732.png" alt="image-20220809125818380"></p><h3 id="10、使用最频繁的列放到联合索引的左侧"><a href="#10、使用最频繁的列放到联合索引的左侧" class="headerlink" title="10、使用最频繁的列放到联合索引的左侧"></a>10、使用最频繁的列放到联合索引的左侧</h3><p>这样也可以较少的建立一些索引。同时，由于”最左前缀原则”，可以增加联合索引的使用率。</p><h3 id="11、在多个字段都要创建索引的情况下，联合索引优于单值索引"><a href="#11、在多个字段都要创建索引的情况下，联合索引优于单值索引" class="headerlink" title="11、在多个字段都要创建索引的情况下，联合索引优于单值索引"></a>11、在多个字段都要创建索引的情况下，联合索引优于单值索引</h3><ul><li><p>索引建立的多，维护的成本也高。</p></li><li><p>&#x3D;&#x3D;多个字段进行联合查询时，其实只使用到一个索引&#x3D;&#x3D;。如下，只用到了idx_sid索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT student_id,COUNT(*) AS num FROM student_info</span><br><span class="line">    -&gt; GROUP BY student_id</span><br><span class="line">    -&gt; ORDER BY create_time DESC</span><br><span class="line">    -&gt; LIMIT 100;</span><br></pre></td></tr></table></figure></li><li><p>在建立联合索引的相关字段做查询时，联合索引都能生效，使用频率比较高。足够优化sql执行的速度了</p></li></ul><h2 id="3-3-限制索引的数目"><a href="#3-3-限制索引的数目" class="headerlink" title="3.3 限制索引的数目"></a>3.3 限制索引的数目</h2><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量<code>不超过6个</code>。原因：</p><p>①每个索索引都需要占用磁盘空间，&#x3D;&#x3D;索引越多，需要的磁盘空间就越大&#x3D;&#x3D;。</p><p>②&#x3D;&#x3D;索引会影响INSERT、DELETE、 UPDATE等语句的性能&#x3D;&#x3D;，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</p><p>③优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，&#x3D;&#x3D;如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能&#x3D;&#x3D;。</p><p>解释：表中创建的索引过多，优化器在possible_keys中选择合适的key 时需要的成本也会更多。比如下面查询中possible_keys有两个，实际使用的key只有一个，这其实优化器判断的哟。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT student_id,COUNT(*) AS num FROM student_info</span><br><span class="line">   -&gt; GROUP BY student_id</span><br><span class="line">   -&gt; ORDER BY create_time DESC</span><br><span class="line">   -&gt; LIMIT 100;</span><br><span class="line">+----+-------------+--------------+------------+-------+--------------------------+---------+---------+------+--------+----------+---------------------------------+</span><br><span class="line">| id | select_type | table        | partitions | type  | possible_keys            | key     | key_len | ref  | rows   | filtered | Extra                           |</span><br><span class="line">+----+-------------+--------------+------------+-------+--------------------------+---------+---------+------+--------+----------+---------------------------------+</span><br><span class="line">|  1 | SIMPLE      | student_info | NULL       | index | idx_sid,idx_cre_time_sid | idx_sid | 4       | NULL | 997449 |   100.00 | Using temporary; Using filesort |</span><br><span class="line">+----+-------------+--------------+------------+-------+--------------------------+---------+---------+------+--------+----------+---------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="3-4-哪些情况不适合创建索引"><a href="#3-4-哪些情况不适合创建索引" class="headerlink" title="3.4 哪些情况不适合创建索引"></a>3.4 哪些情况不适合创建索引</h2><h3 id="1、在-where-中使用不到的字段，不要设置索引"><a href="#1、在-where-中使用不到的字段，不要设置索引" class="headerlink" title="1、在 where 中使用不到的字段，不要设置索引"></a>1、在 where 中使用不到的字段，不要设置索引</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091450244.png" alt="image-20220809141101656"></p><h3 id="2、数据量小的表最好不要使用索引"><a href="#2、数据量小的表最好不要使用索引" class="headerlink" title="2、数据量小的表最好不要使用索引"></a>2、数据量小的表最好不要使用索引</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091451173.png" alt="image-20220809141554393"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091451943.png" alt="image-20220809141625335"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091451829.png"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091451813.png" alt="image-20220809141408722"></p><blockquote><p><strong>结论：在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。</strong></p></blockquote><h3 id="3、有大量重复数据的列上不要建立索引"><a href="#3、有大量重复数据的列上不要建立索引" class="headerlink" title="3、有大量重复数据的列上不要建立索引"></a>3、有大量重复数据的列上不要建立索引</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091451062.png"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091451766.png" alt="image-20220809142700207"></p><h3 id="4、避免对经常更新的表创建过多的索引"><a href="#4、避免对经常更新的表创建过多的索引" class="headerlink" title="4、避免对经常更新的表创建过多的索引"></a>4、避免对经常更新的表创建过多的索引</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091451766.png" alt="image-20220809142913807"></p><h3 id="5、不建议用无序的值作为索引"><a href="#5、不建议用无序的值作为索引" class="headerlink" title="5、不建议用无序的值作为索引"></a>5、不建议用无序的值作为索引</h3><p>例如身份证、UUID（在索引比较时需要转为 ASCII，并且插入时可能造成页分裂）、MD5、HASH、无序长字符串等。</p><h3 id="6、删除不再使用或者很少使用的索引"><a href="#6、删除不再使用或者很少使用的索引" class="headerlink" title="6、删除不再使用或者很少使用的索引"></a>6、删除不再使用或者很少使用的索引</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091451780.png" alt="image-20220809143114720"></p><h3 id="7、不要定义冗余或重复的索引"><a href="#7、不要定义冗余或重复的索引" class="headerlink" title="7、不要定义冗余或重复的索引"></a>7、不要定义冗余或重复的索引</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091455240.png" alt="image-20220809143241722"></p><p><strong><font color=green>冗余索引</font></strong></p><p>举例：建表语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    birthday <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    phone_number <span class="type">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    country <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(<span class="number">10</span>), birthday, phone_number),</span><br><span class="line">    KEY idx_name (name(<span class="number">10</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们知道，通过 <code>idx_name_birthday_phone_number</code> 索引就可以对 <code>name</code> 列进行快速搜索，再创建一 个专门针对 <code>name</code> 列的索引就算是一个 <code>冗余索引</code>，维护这个索引只会增加维护的成本，并不会对搜索有 什么好处。</p><p><strong><font color=green>重复索引</font></strong></p><p>另一种情况，我们可能会对某个列 <code>重复建立索引</code> ，比方说这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> repeat_index_demo (</span><br><span class="line">    col1 <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    col2 <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> uk_idx_c1 (col1),</span><br><span class="line">    INDEX idx_c1 (col1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们看到，col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p><h2 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202208091451878.png" alt="image-20220809143442576"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五、InnoDB数据存储结构</title>
      <link href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC05%E7%AB%A0_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC05%E7%AB%A0_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据的存储结构：页"><a href="#1-数据的存储结构：页" class="headerlink" title="1. 数据的存储结构：页"></a>1. 数据的存储结构：页</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251415034.png" alt="image-20220724103054165"></p><h2 id="1-1-磁盘与内存交互基本单位：页"><a href="#1-1-磁盘与内存交互基本单位：页" class="headerlink" title="1.1 磁盘与内存交互基本单位：页"></a>1.1 磁盘与内存交互基本单位：页</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251415335.png" alt="image-20220724103337984"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251415197.png" alt="image-20220724103747719"></p><h2 id="1-2-页结构概述"><a href="#1-2-页结构概述" class="headerlink" title="1.2 页结构概述"></a>1.2 页结构概述</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251415916.png" alt="image-20220724104418653"></p><h2 id="1-3-页的大小"><a href="#1-3-页的大小" class="headerlink" title="1.3 页的大小"></a>1.3 页的大小</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251415071.png" alt="image-20220724104412027"></p><h2 id="1-4-页的上层结构"><a href="#1-4-页的上层结构" class="headerlink" title="1.4 页的上层结构"></a>1.4 页的上层结构</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416875.png" alt="image-20220724104918055"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416509.png" alt="image-20220724104825429"></p><h1 id="2-页的内部结构"><a href="#2-页的内部结构" class="headerlink" title="2. 页的内部结构"></a>2. 页的内部结构</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416468.png" alt="image-20220724111001675"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416267.png" alt="image-20220724110313834"></p><h2 id="2-1-File-Header（文件头部）和File-Trailer（文件尾部）"><a href="#2-1-File-Header（文件头部）和File-Trailer（文件尾部）" class="headerlink" title="2.1 File Header（文件头部）和File Trailer（文件尾部）"></a>2.1 File Header（文件头部）和File Trailer（文件尾部）</h2><h3 id="2-1-1-File-Header（文件头部）"><a href="#2-1-1-File-Header（文件头部）" class="headerlink" title="2.1.1 File Header（文件头部）"></a>2.1.1 File Header（文件头部）</h3><p><strong>作用：</strong>描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）</p><p><strong>大小：</strong>38字节</p><p><strong>构成：</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416558.bmp"></p><ul><li><p><strong><font color=green>FIL_PAGE_OFFSET（4字节）</font></strong></p><p>每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。</p></li><li><p><strong><font color=green>FIL_PAGE_TYPE（2字节）</font></strong></p><p>这个代表当前页的类型</p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416462.png" alt="image-20220724125956493"></p><ul><li><p><strong><font color=green>FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）</font></strong></p><p>InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。</p></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416475.png" alt="image-20220724130103373"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416013.png" alt="image-20220724130110950"></p><ul><li><p><strong><font color=green>FIL_PAGE_SPACE_OR_CHKSUM（4字节）</font></strong></p><p>文件头部和文件尾部都有属性：<code>FIL_PAGE_SPACE_OR_CHKSUM</code></p><p><strong>作用：</strong><br>InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整。</p><p>&#x3D;&#x3D;为了检测一个页是否完整&#x3D;&#x3D;（也就是在同步的时候有没有发生只同步一半的尴尬情况），这时&#x3D;&#x3D;可以通过文件尾的校验和&#x3D;&#x3D;（checksum 值）&#x3D;&#x3D;与文件头的校验和做比对&#x3D;&#x3D;，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。</p><p><strong>具体的：</strong></p><p>每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，&#x3D;&#x3D;如果完全同步成功，则页的首部和尾部的校验和应该是一致的&#x3D;&#x3D;。如果写了一半儿断电了，那么在File Header中的校验和就代表着已经修改过的页，而在File Trailer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。这里，校验方式就是采用 &#x3D;&#x3D;Hash 算法&#x3D;&#x3D;进行校验。</p></li><li><p><strong><font color=green>FIL_PAGE_LSN（8字节）</font></strong></p><p>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</p></li></ul><h3 id="2-1-2-File-Trailer（文件尾部）"><a href="#2-1-2-File-Trailer（文件尾部）" class="headerlink" title="2.1.2 File Trailer（文件尾部）"></a>2.1.2 File Trailer（文件尾部）</h3><ul><li><p><strong><font color=green>前4个字节代表页的校验和：</font></strong><br>这个部分是和File Header中的校验和相对应的。</p></li><li><p><strong><font color=green>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：</font></strong></p><p>这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。</p></li></ul><h2 id="2-2-User-Records-用户记录-、最大最小记录、Free-Space-空闲空间"><a href="#2-2-User-Records-用户记录-、最大最小记录、Free-Space-空闲空间" class="headerlink" title="2.2 User Records(用户记录)、最大最小记录、Free Space(空闲空间)"></a>2.2 User Records(用户记录)、最大最小记录、Free Space(空闲空间)</h2><h3 id="2-2-1-Free-Space-空闲空间"><a href="#2-2-1-Free-Space-空闲空间" class="headerlink" title="2.2.1 Free Space (空闲空间)"></a>2.2.1 Free Space (空闲空间)</h3><p>我们自己存储的记录会按照指定的&#x3D;&#x3D;行格式&#x3D;&#x3D;存储到&#x3D;&#x3D;User Records&#x3D;&#x3D;部分。但是在一开始生成页的时候，其实并没有User Records这个部分，&#x3D;&#x3D;每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分&#x3D;&#x3D;，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去&#x3D;&#x3D;申请新的页&#x3D;&#x3D;了。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416340.png" alt="image-20220724130814897"></p><h3 id="2-2-2-User-Records-用户记录"><a href="#2-2-2-User-Records-用户记录" class="headerlink" title="2.2.2 User Records (用户记录)"></a>2.2.2 User Records (用户记录)</h3><p>User Records中的这些记录按照&#x3D;&#x3D;指定的行格式&#x3D;&#x3D;一条一条摆在User Records部分，相互之间形成&#x3D;&#x3D;单链表&#x3D;&#x3D;。</p><p><strong>用户记录里的一条条数据如何记录？</strong></p><p>这里需要讲讲记录行格式的记录头信息。</p><h3 id="2-2-3-Infimum-Supremum（最小最大记录）"><a href="#2-2-3-Infimum-Supremum（最小最大记录）" class="headerlink" title="2.2.3 Infimum + Supremum（最小最大记录）"></a>2.2.3 Infimum + Supremum（最小最大记录）</h3><p><strong>记录可以比较大小吗？</strong></p><p>是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是&#x3D;&#x3D;比较主键&#x3D;&#x3D;的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。</p><p>InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的，如图所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416484.png" alt="image-20220724131119987"></p><p>这两条记录&#x3D;&#x3D;不是我们自己定义的记录&#x3D;&#x3D;，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分，如图所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416501.png" alt="image-20220724131133664"></p><h2 id="2-3-Page-Directory-页目录-、Page-Header-页面头部"><a href="#2-3-Page-Directory-页目录-、Page-Header-页面头部" class="headerlink" title="2.3 Page Directory(页目录)、Page Header(页面头部)"></a>2.3 Page Directory(页目录)、Page Header(页面头部)</h2><h3 id="2-3-1-Page-Directory（页目录）"><a href="#2-3-1-Page-Directory（页目录）" class="headerlink" title="2.3.1 Page Directory（页目录）"></a>2.3.1 Page Directory（页目录）</h3><p><font color=green><strong>1.为什么需要页目录？</strong></font></p><p>在页中，记录是以&#x3D;&#x3D;单向链表&#x3D;&#x3D;的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是&#x3D;&#x3D;检索效率不高&#x3D;&#x3D;，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，&#x3D;&#x3D;专门给记录做一个目录&#x3D;&#x3D;，通过&#x3D;&#x3D;二分查找&#x3D;&#x3D;法的方式进行检索，提升效率。</p><p>需求：根据主键值查找页中的某条记录，如何实现快速查找呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM page_demo WHERE c1 = 3;</span><br></pre></td></tr></table></figure><p><font color=red>方式1：顺序查找</font></p><p>从Infimum记录（最小记录）开始，沿着链表一直往后找，总有一天会找到（或者找不到），在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。</p><p>如果一个页中存储了非常多的记录，这么查找性能很差。</p><p><font color=red>方式2：使用页目录，二分法查找</font></p><ol><li><p>将所有的记录分成几个组，<strong>这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记</strong>录。</p><ul><li><p>第 1 组，也就是最小记录所在的分组只有 1 个记录；</p></li><li><p>最后一组，就是最大记录所在的分组，会有 1-8 条记录；</p></li><li><p>其余的组记录数量在 4-8 条之间。</p></li></ul><p>这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会&#x3D;&#x3D;尽量平分&#x3D;&#x3D;。</p></li><li><p>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 <code>n_owned</code> 字段。</p></li><li><p><font color=blue>页目录用来存储每组最后一条记录的地址偏移量</font>，这些地址偏移量会按照<font color=blue>先后顺序存储</font>起来，每组的地址偏移量也被称之为<font color=blue>槽（slot）</font>，每个槽相当于指针指向了不同组的最后一个记录。</p></li></ol><p>举例1：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416213.png" alt="image-20220724131400355"></p><p>举例2：</p><p>现在的page_demo表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录。如下图：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416778.png" alt="image-20220724131423102"></p><p>从这个图中我们需要注意这么几点：</p><ul><li>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。</li><li>注意最小和最大记录的头信息中的n_owned属性<ul><li>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。</li><li>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</li></ul></li></ul><p>用箭头指向的方式替代数字，这样更易于我们理解，修改后如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417332.png" alt="image-20220724131446750"></p><p>再换个角度看一下：（单纯从逻辑上看一下这些记录和页目录的关系）</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417844.png" alt="image-20220724131513633"></p><p><font color=green><strong>2. 页目录分组的个数如何确定？</strong></font></p><p>为什么 上面例中 最小记录的n_owned值为1，而最大记录的n_owned值为5呢？</p><p>InnoDB规定：<strong>对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在1<del>8条之间，剩下的分组中记录的条数范围只能在是 4</del>8 条之间</strong>。</p><p>分组是按照下边的步骤进行的：</p><ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li><li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li><li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li></ul><p><font color=green><strong>3. 页目录结构下如何快速查找记录？</strong></font></p><p>现在向page_demo表中添加更多的数据。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO page_demo </span><br><span class="line">VALUES</span><br><span class="line">(5, 500, &#x27;zhou&#x27;), </span><br><span class="line">(6, 600, &#x27;chen&#x27;), </span><br><span class="line">(7, 700, &#x27;deng&#x27;), </span><br><span class="line">(8, 800, &#x27;yang&#x27;), </span><br><span class="line">(9, 900, &#x27;wang&#x27;), </span><br><span class="line">(10, 1000, &#x27;zhao&#x27;), </span><br><span class="line">(11, 1100, &#x27;qian&#x27;), </span><br><span class="line">(12, 1200, &#x27;feng&#x27;), </span><br><span class="line">(13, 1300, &#x27;tang&#x27;), </span><br><span class="line">(14, 1400, &#x27;ding&#x27;), </span><br><span class="line">(15, 1500, &#x27;jing&#x27;), </span><br><span class="line">(16, 1600, &#x27;quan&#x27;);</span><br></pre></td></tr></table></figure><p>添加了12条记录，现在页里一共有18条记录了（包括最小和最大记录），这些记录被分成了5个组，如图所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417557.png" alt="image-20220724152747713"></p><p>这里只保留了16条记录的记录头信息中的n_owned和next_record属性，省略了各个记录之间的箭头。</p><p>现在看怎么从这个页目录中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用二分法来进行快速查找。5个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low&#x3D;0，最高的槽就是high&#x3D;4。比方说我们想<font color=blue>找主键值为6的记录</font>，过程是这样的：</p><ol><li>计算中间槽的位置：(0+4)&#x2F;2&#x3D;2，所以查看槽2对应记录的主键值为8，又因为8 &gt; 6，所以设置high&#x3D;2，low保持不变。</li><li>重新计算中间槽的位置：(0+2)&#x2F;2&#x3D;1，所以查看槽1对应的主键值为4，又因为4 &lt; 6，所以设置low&#x3D;1，high保持不变。</li><li>因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中。此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。</li></ol><p>但是我们前边又说过，&#x3D;&#x3D;每个槽对应的记录都是该组中主键值最大的记录&#x3D;&#x3D;，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。</p><p>由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</p><p><strong>小结：</strong></p><p>在一个数据页中查找指定主键值的记录的过程分为两步：</p><ol><li>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。</li><li>通过记录的<code>next_record</code>属性遍历该槽所在的组中的各个记录。</li></ol><h3 id="2-3-2-Page-Header（页面头部）"><a href="#2-3-2-Page-Header（页面头部）" class="headerlink" title="2.3.2 Page Header（页面头部）"></a>2.3.2 Page Header（页面头部）</h3><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417062.png" alt="image-20220724153112168"></p><ul><li><p>PAGE_DIRECTION</p><p>假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是PAGE_DIRECTION。</p></li><li><p>PAGE_N_DIRECTION</p><p>假设连续几次插入新记录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。</p></li></ul><h2 id="2-4-从数据页的角度看B-树如何查询"><a href="#2-4-从数据页的角度看B-树如何查询" class="headerlink" title="2.4 从数据页的角度看B+树如何查询"></a>2.4 从数据页的角度看B+树如何查询</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417757.png" alt="image-20220724123214937"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417428.png" alt="image-20220724123449401"></p><h1 id="3-InnoDB行格式（或记录格式）"><a href="#3-InnoDB行格式（或记录格式）" class="headerlink" title="3. InnoDB行格式（或记录格式）"></a>3. InnoDB行格式（或记录格式）</h1><h2 id="3-1-指定行格式的语法"><a href="#3-1-指定行格式的语法" class="headerlink" title="3.1 指定行格式的语法"></a>3.1 指定行格式的语法</h2><p>在创建或修改表的语句中指定行格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称 # 创建</span><br><span class="line">ALTER TABLE 表名 ROW_FORMAT=行格式名称 # 修改</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE record_test_table (</span><br><span class="line">    -&gt;     col1 VARCHAR(8),</span><br><span class="line">    -&gt;     col2 VARCHAR(8) NOT NULL,</span><br><span class="line">    -&gt;     col3 CHAR(8),</span><br><span class="line">    -&gt;     col4 VARCHAR(8)</span><br><span class="line">    -&gt; ) CHARSET=ascii ROW_FORMAT=COMPACT;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure><p>向表中插入两条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO record_test_table(col1, col2, col3, col4) </span><br><span class="line">VALUES</span><br><span class="line">(&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;wangwu&#x27;, &#x27;songhk&#x27;), </span><br><span class="line">(&#x27;tong&#x27;, &#x27;chen&#x27;, NULL, NULL);</span><br></pre></td></tr></table></figure><h2 id="3-2-COMPACT行格式"><a href="#3-2-COMPACT行格式" class="headerlink" title="3.2 COMPACT行格式"></a>3.2 COMPACT行格式</h2><p>在MySQL 5.1版本中，&#x3D;&#x3D;默认设置为Compact行格式&#x3D;&#x3D;。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417467.png" alt="image-20220725090341137"></p><h3 id="3-2-1-变长字段长度列表"><a href="#3-2-1-变长字段长度列表" class="headerlink" title="3.2.1 变长字段长度列表"></a>3.2.1 变长字段长度列表</h3><p>MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为&#x3D;&#x3D;变长字段&#x3D;&#x3D;，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。&#x3D;&#x3D;在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表&#x3D;&#x3D;。</p><p>注意：这里面存储的变长长度和字段&#x3D;&#x3D;顺序是反过来的&#x3D;&#x3D;。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。</p><p>以record_test_table表中的第一条记录举例：因为record_test_table表的col1、col2、col4列都是VARCHAR(8)类型的，所以这三个列的值的长度都需要保存在记录开头处，注意record_test_table表中的各个列都使用的是ascii字符集（每个字符只需要1个字节来进行编码，如果是UTF-8，则需要3个字节哦~ ~~）</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417716.png" alt="image-20220725085822376"></p><p>又因为这些长度值需要按照列的逆序存放，所以最后变长字段长度列表的字节串用十六进制表示的效果就是（各个字节之间实际上没有空格，用空格隔开只是方便理解）：<br>06 04 08 </p><p>把这个字节串组成的变长字段长度列表填入上边的示意图中的效果就是：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417011.png" alt="image-20220725085836023"></p><h3 id="3-2-2-NULL值列表"><a href="#3-2-2-NULL值列表" class="headerlink" title="3.2.2 NULL值列表"></a>3.2.2 NULL值列表</h3><p>Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了。</p><p><strong>为什么定义NULL值列表？</strong></p><p>之所以要存储NULL是因为数据都是需要对齐的，如果&#x3D;&#x3D;没有标注出来NULL值&#x3D;&#x3D;的位置，就有可能在查询数据的时候&#x3D;&#x3D;出现混乱&#x3D;&#x3D;。如果使&#x3D;&#x3D;用一个特定的符号&#x3D;&#x3D;放到相应的数据位表示空置的话，虽然能达到效果，但是这样很&#x3D;&#x3D;浪费空间&#x3D;&#x3D;，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，格式如下：</p><ul><li><p>二进制位的值为1时，代表该列的值为NULL。</p></li><li><p>二进制位的值为0时，代表该列的值不为NULL。</p></li></ul><p>例如：字段 a、b、c，其中a是主键，在某一行中存储的数依次是 a&#x3D;1、b&#x3D;null、c&#x3D;2。那么Compact行格式中的NULL值列表中存储：01。第一个0表示c不为null，第二个1表示b是null。这里之所以没有a是因为数据库会自动跳过主键，因为主键肯定是非NULL且唯一的，在NULL值列表的数据中就会自动跳过主键。</p><p>record_test_table的两条记录的NULL值列表就如下：</p><p>第一条记录：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417444.png" alt="image-20220725090200671"></p><p>第二条记录：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417659.png" alt="image-20220725090210661"></p><h3 id="3-2-3-记录头信息（5字节）"><a href="#3-2-3-记录头信息（5字节）" class="headerlink" title="3.2.3 记录头信息（5字节）"></a>3.2.3 记录头信息（5字节）</h3><p><strong><font color=blue>1. 记录头信息概述</font></strong></p><p>创建表page_demo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE page_demo(</span><br><span class="line">    -&gt;     c1 INT,</span><br><span class="line">    -&gt;     c2 INT,</span><br><span class="line">    -&gt;     c3 VARCHAR(10000),</span><br><span class="line">    -&gt;     PRIMARY KEY (c1)</span><br><span class="line">    -&gt; ) CHARSET=ascii ROW_FORMAT=Compact;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure><p>这个表中记录的行格式示意图：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417972.png" alt="image-20220724170923339"></p><p>这些记录头信息中各个属性如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417949.png" alt="image-20220724170944226"></p><p>简化后的行格式示意图：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251421140.png" alt="image-20220724171000430"></p><p>插入数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO page_demo </span><br><span class="line">VALUES</span><br><span class="line">(1, 100, &#x27;song&#x27;), </span><br><span class="line">(2, 200, &#x27;tong&#x27;), </span><br><span class="line">(3, 300, &#x27;zhan&#x27;), </span><br><span class="line">(4, 400, &#x27;lisi&#x27;);</span><br></pre></td></tr></table></figure><p>图示如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417875.png" alt="image-20220724171028579"></p><p>注：为啥编号是从2开始的，因为默认会有一个最小记录和最大记录</p><p><strong><font color=blue>2. 头信息中各个属性详细分析</font></strong></p><ul><li><p><strong><font color=green>delete_mask</font></strong></p><p>这个属性标记着当前记录是否被删除，占用1个二进制位。</p><ul><li><p>值为0：代表记录并没有被删除</p></li><li><p>值为1：代表记录被删除掉了</p></li></ul><p><font color=red><strong>被删除的记录为什么还在页中存储呢？</strong></font></p><p>你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其他的记录在磁盘上需要&#x3D;&#x3D;重新排列，导致性能消耗&#x3D;&#x3D;。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的&#x3D;&#x3D;垃圾链表&#x3D;&#x3D;，在这个链表中的记录占用的空间称之为&#x3D;&#x3D;可重用空间&#x3D;&#x3D;，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉</p></li><li><p><strong><font color=green>min_rec_mask</font></strong></p><p>B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。</p><p>我们自己插入的四条记录的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录。</p></li><li><p><strong><font color=green>record_type</font></strong></p><p>这个属性表示当前记录的类型，一共有4种类型的记录：</p><ul><li><p>0：表示普通记录</p></li><li><p>1：表示B+树非叶节点记录</p></li><li><p>2：表示最小记录</p></li><li><p>3：表示最大记录</p></li></ul><p>从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的record_type值都是0，而最小记录和最大记录的record_type值分别为2和3。至于record_type为1的情况，我们在索引的数据结构章节讲过。</p></li><li><p><strong><font color=green>heap_no</font></strong></p><p>这个属性表示当前记录在本页中的位置。</p><p>从图中可以看出来，我们插入的4条记录在本页中的位置分别是：2、3、4、5。</p><p><font color=red>怎么不见heap_no值为0和1的记录呢？</font></p><p>MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为&#x3D;&#x3D;伪记录&#x3D;&#x3D;或者&#x3D;&#x3D;虚拟记录&#x3D;&#x3D;。这两个伪记录一个代表&#x3D;&#x3D;最小记录&#x3D;&#x3D;，一个代表&#x3D;&#x3D;最大记录&#x3D;&#x3D;。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前。</p></li><li><p><strong><font color=green>n_owned</font></strong></p><p>页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。 详情见page directory。</p></li><li><p><strong><font color=green>next_record</font></strong></p><p>记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的&#x3D;&#x3D;地址偏移量&#x3D;&#x3D;。</p><p>比如：第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。</p><p>注意，<strong>下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录</strong>。而且规定Infimum记录（也就是最小记录）的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum记录（也就是最大记录）。下图用箭头代替偏移量表示next_record。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417284.png" alt="image-20220724173342146"></p></li></ul><p><strong><font color=blue>3. 演示删除和添加操作</font></strong></p><p>&#x3D;&#x3D;删除操作：&#x3D;&#x3D;</p><p>从表中删除掉一条记录，这个链表也是会跟着变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM page_demo WHERE c1 = 2;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br></pre></td></tr></table></figure><p>删掉第2条记录后的示意图就是：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418963.png" alt="image-20220724173857326"></p><p>从图中可以看出来，删除第2条记录前后主要发生了这些变化：</p><ul><li>第2条记录并没有从存储空间中移除，而是把该条记录的<code>delete_mask</code>值设置为1。</li><li>第2条记录的<code>next_record</code>值变为了0，意味着该记录没有下一条记录了。</li><li>第1条记录的<code>next_record</code>指向了第3条记录。</li><li>最大记录的<code>n_owned</code>值从 5 变成了 4 。</li></ul><p><font color=red>所以，不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的</font>。</p><p>&#x3D;&#x3D;添加操作：&#x3D;&#x3D;</p><p>主键值为2的记录被我们删掉了，但是存储空间却没有回收，如果我们再次把这条记录插入到表中，会发生什么事呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO page_demo VALUES(2, 200, &#x27;tong&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>我们看一下记录的存储情况：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418651.png" alt="image-20220724173938500"></p><p><strong><font color=blue>直接复用了原来被删除记录的存储空间</font>。</strong></p><p><strong>说明：</strong>当数据页中存在多条被删除掉的记录时，这些记录的<code>next_record</code>属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。</p><h3 id="3-2-4-记录真实的数据"><a href="#3-2-4-记录真实的数据" class="headerlink" title="3.2.4 记录真实的数据"></a>3.2.4 记录真实的数据</h3><p>记录的真实数据除了我们自己定义的列的数据以外，还会有三个隐藏列：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418835.png" alt="image-20220725090426277"></p><p>实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR。</p><ul><li>&#x3D;&#x3D;一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键&#x3D;&#x3D;。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。</li><li>事务ID和回滚指针在后面的《第14章_MySQL事务日志》章节中讲解。</li></ul><p>举例：分析Compact行记录的内部结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytest(</span><br><span class="line">    col1 VARCHAR(10),</span><br><span class="line">    col2 VARCHAR(10),</span><br><span class="line">    col3 CHAR(10),</span><br><span class="line">    col4 VARCHAR(10)</span><br><span class="line">)ENGINE=INNODB CHARSET=LATIN1 ROW_FORMAT=COMPACT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO mytest</span><br><span class="line">VALUES(&#x27;a&#x27;,&#x27;bb&#x27;,&#x27;bb&#x27;,&#x27;ccc&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO mytest</span><br><span class="line">VALUES(&#x27;d&#x27;,&#x27;ee&#x27;,&#x27;ee&#x27;,&#x27;fff&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO mytest</span><br><span class="line">VALUES(&#x27;d&#x27;,NULL,NULL,&#x27;fff&#x27;);</span><br></pre></td></tr></table></figure><p>在Windows操作系统下，可以选择通过程序UltraEdit打开表空间文件mytest.ibd这个二进制文件。内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">0000c070 73 75 70 72 65 6d 75 6d 03 02 01 00 00 00 10 00|supremum........|</span><br><span class="line">0000c080 2c 00 00 00 2b 68 00 00 00 00 00 06 05 80 00 00|,...+h..........|</span><br><span class="line">0000c090 00 32 01 10 61 62 62 62 62 20 20 20 20 20 20 20|.2..abbbb|</span><br><span class="line">0000c0a0 20 63 63 63 03 02 01 00 00 00 18 00 2b 00 00 00|ccc........+...|</span><br><span class="line">0000c0b0 2b 68 01 00 00 00 00 06 06 80 00 00 00 32 01 10|+h...........2..|</span><br><span class="line">0000c0c0 64 65 65 65 65 20 20 20 20 20 20 20 20 66 66 66|deeeefff|</span><br><span class="line">0000c0d0 03 01 06 00 00 20 ff 98 00 00 00 2b 68 02 00 00|..........+h...|</span><br><span class="line">0000c0e0 00 00 06 07 80 00 00 00 32 01 10 64 66 66 66 00|........2..dfff.|</span><br><span class="line">------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418739.png"></p><p>该行记录从0000c078开始，参考下面的，相信大家会有更好的理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------------------</span><br><span class="line">03 02 01                     /*变长字段长度列表，逆序*/</span><br><span class="line">00                              /*NULL标志位，第一行没有NULL值*/</span><br><span class="line">00 00 10 00 2c            /*Record Header，固定5字节长度*/</span><br><span class="line">00 00 00 2b 68 00       /*RowID InnoDB自动创建，6字节*/</span><br><span class="line">00 00 00 00 06 05       /*TransactionID*/</span><br><span class="line">80 00 00 00 32 01 10   /*Roll Pointer*/</span><br><span class="line">61                               /*列1数据&#x27;a&#x27;*/</span><br><span class="line">62 62                          /*列2数据&#x27;bb&#x27;*/</span><br><span class="line">62 62 20 20 20 20 20 20 20 20/*列3数据&#x27;bb&#x27;*/</span><br><span class="line">63 63 63                     /*列4数据&#x27;ccc&#x27;*/</span><br><span class="line">---------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>注意1：InnoDB每行有隐藏列TransactionID和Roll Pointer。:<br>注意2：固定长度CHAR字段在未能完全占用其长度空间时，会用0x20 （也就是空格）来进行填充。</p><p>接着再来分析下Record Header的最后两个字节，这两个字节代表next_recorder，0x2c代表下一个记录的偏移量，即当前记录的位置加上偏移量0x2c就是下条记录的起始位置。</p><p>第二行将不做整理，除了RowID不同外，它和第一行大同小异，现在来分析有NULL值的第三行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------------------</span><br><span class="line">03 01                               /*变长字段长度列表，逆序*/</span><br><span class="line">06                                   /*NULL标志位，第三行有NULL值*/</span><br><span class="line">00 00 20 ff 98                  /*Record Header*/</span><br><span class="line">00 00 00 2b 68 02           /*RowID*/</span><br><span class="line">00 00 00 00 06 07           /*TransactionID*/</span><br><span class="line">80 00 00 00 32 01 10       /*Roll Pointer*/</span><br><span class="line">64                                   /*列1数据&#x27;d&#x27;*/</span><br><span class="line">66 66 66                         /*列4数据&#x27;fff&#x27;*/</span><br><span class="line">---------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>第三行有NULL值，因此NULL标志位不再是00而是06，转换成二进制为00000110，为1的值代表第2列和第3列的数据为NULL。在其后存储列数据的部分，用户会发现没有存储NULL列，而只存储了第1列和第4列非NULL的值。</p><p>因此这个例子很好地说明了：&#x3D;&#x3D;不管是CHAR类型还是VARCHAR类型，在compact格式下NULL值都不占用任何存储空间&#x3D;&#x3D;</p><h2 id="3-3-Dynamic和Compressed行格式"><a href="#3-3-Dynamic和Compressed行格式" class="headerlink" title="3.3 Dynamic和Compressed行格式"></a>3.3 Dynamic和Compressed行格式</h2><h3 id="3-3-1-行溢出"><a href="#3-3-1-行溢出" class="headerlink" title="3.3.1 行溢出"></a>3.3.1 行溢出</h3><p><strong><font color=red>InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。</font></strong></p><p>很多DBA喜欢MySQL数据库提供的VARCHAR(M)类型，认为可以存放65535字节。这是真的吗？如果我们使用 ascii字符集的话，一个字符就代表一个字节，我们看看VARCHAR(65535)是否可用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE  TABLE  varchar_size_demo(</span><br><span class="line"> c  VARCHAR(65535)</span><br><span class="line"> )  CHARSET=ascii  ROW_FORMAT=Compact;</span><br><span class="line"># 结果如下：</span><br><span class="line">ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have  to  change  some  columns  to  TEXT or  BLOBs</span><br></pre></td></tr></table></figure><p>报错信息表达的意思是：MySQL对一条记录占用的最大存储空间是有限制的，&#x3D;&#x3D;除BLOB或者TEXT类型的列之外， 其他所有的列&#x3D;&#x3D;（不包括隐藏列和记录头信息）&#x3D;&#x3D;占用的字节长度加起来不能超过65535个字节&#x3D;&#x3D;</p><p>这个65535个字节除了列本身的数据之外，还包括一些其他的数据，以Compact行格式为例，比如说我们为了存储一个VARCHAR(M)类型的列，除了真实数据占有空间以外，还需要记录的额外信息。</p><p>如果该VARCHAR类型的列没有NOT NULL属性，那&#x3D;&#x3D;最多只能存储65532个字节的数据&#x3D;&#x3D;，因为变长字段的长度占用 2个字节，NULL值标识需要占用1个字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE  TABLE  varchar_size_demo(</span><br><span class="line">    c  VARCHAR(65532)</span><br><span class="line">)  CHARSET=ascii  ROW_FORMAT=Compact; # 可以创建成功</span><br></pre></td></tr></table></figure><p>如果有not null属性，那么就不需要NULL值标识，也就可以多存储一个字节，即65533个字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE  TABLE  varchar_size_demo( </span><br><span class="line">  c  VARCHAR(65533)  not  null</span><br><span class="line">)  CHARSET=ascii  ROW_FORMAT=Compact; # 可以创建成功</span><br></pre></td></tr></table></figure><p>通过上面的案例，我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能出现一个页存放不了一条记录，这种现象称为&#x3D;&#x3D;行溢出&#x3D;&#x3D;</p><p>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行&#x3D;&#x3D;分页存储&#x3D;&#x3D;，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。</p><p>这称为页的扩展，举例如下：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418556.png" alt="image-20220725091306108"></p><h3 id="3-3-2-Dynamic和Compressed行格式"><a href="#3-3-2-Dynamic和Compressed行格式" class="headerlink" title="3.3.2 Dynamic和Compressed行格式"></a>3.3.2 Dynamic和Compressed行格式</h3><p>在MySQL 8.0中，&#x3D;&#x3D;默认行格式就是Dynamic&#x3D;&#x3D;，Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧：</p><ul><li>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。</li><li>Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。</li></ul><p>Compressed行记录格式的另一个功能就是，存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418052.png" alt="image-20220725091327355"></p><h2 id="3-4-Redundant行格式"><a href="#3-4-Redundant行格式" class="headerlink" title="3.4 Redundant行格式"></a>3.4 Redundant行格式</h2><p>Redundant是MySQL 5.0版本之前InnoDB的行记录存储方式，MySQL 5.0支持Redundant是为了兼容之前版本的页格式。</p><p>现在我们把表record_test_table的行格式修改为Redundant：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE record_test_table ROW_FORMAT=Redundant;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418548.png" alt="image-20220725091402259"></p><p>从上图可以看到，不同于Compact行记录格式，Redundant行格式的首部是一个字段长度偏移列表，同样是按照列的顺序&#x3D;&#x3D;逆序放置&#x3D;&#x3D;的。</p><p>下边我们从各个方面看一下Redundant行格式有什么不同的地方。</p><h3 id="3-4-1-字段长度偏移列表"><a href="#3-4-1-字段长度偏移列表" class="headerlink" title="3.4.1 字段长度偏移列表"></a>3.4.1 字段长度偏移列表</h3><p>注意Compact行格式的开头是变长字段长度列表，而Redundant行格式的开头是字段长度偏移列表，与变长字段长度列表有两处不同：</p><ul><li>少了“变长”两个字：Redundant行格式会把该条记录中所有列（包括隐藏列）的长度信息都按照逆序存储到&#x3D;&#x3D;字段长度偏移列表&#x3D;&#x3D;</li><li>多了“偏移”两个字：这意味着计算列值长度的方式不像Compact行格式那么直观，它是采用两个相邻数值的差值来计算&#x3D;&#x3D;各个列值&#x3D;&#x3D;的长度</li></ul><p>举例：比如第一条记录的字段长度偏移列表就是：<br>2B 25 1F 1B 13 0C 06</p><p>因为它是逆序排放的，所以按照列的顺序排列就是：<br>06 0C 13 17 1A 24 25</p><p>按照两个相邻数值的差值来计算各个列值的长度的意思就是：</p><ul><li>第一列(row_id)的长度就是 0x06个字节，也就是6个字节。</li><li>第二列(transaction_id)的长度就是 (0x0C - 0x06)个字节，也就是6个字节。</li><li>第三列(roll_pointer)的长度就是 (0x13 - 0x0C)个字节，也就是7个字节。</li><li>第四列(col1)的长度就是 (0x1B - 0x13)个字节，也就是8个字节。</li><li>第五列(col2)的长度就是 (0x1F - 0x1B)个字节，也就是4个字节。</li><li>第六列(col3)的长度就是 (0x25 - 0x1F)个字节，也就是6个字节。</li><li>第七列(col4)的长度就是 (0x2B - 0x25)个字节，也就是6个字节。</li></ul><h3 id="3-4-2-记录头信息（record-header）"><a href="#3-4-2-记录头信息（record-header）" class="headerlink" title="3.4.2 记录头信息（record header）"></a>3.4.2 记录头信息（record header）</h3><p>不同于Compact行格式，Redundant行格式中的记录头信息固定占用6个字节（48位），每位的含义见下表</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418853.jpeg"></p><p>与Compact行格式的记录头信息对比来看，有两处不同：（下面的解释，了解即可）</p><ul><li>Redundant行格式多了<code>n_field</code>和<code>1byte_offs_flag</code>这两个属性。</li><li>Redundant行格式没有record_type这个属性。</li></ul><p>其中，n_fields：代表一行中列的数量，占用10位，这也很好地解释了为什么MySQL一个行支持最多的列为1023。另一个值为1byte_offs_flags，该值定义了偏移列表占用1个字节还是2个字节。当它的值为1时，表明使用1个字节存储。当它的值为0时，表明使用2个字节存储。</p><p><strong><font color=blue>1byte_offs_flag的值是怎么选择的 ?</font></strong></p><p>我们前边说过每个列对应的偏移量可以占用1个字节或者2个字节来存储，那到底什么时候用1个字节，什么时候用2个字节呢？其实是根据该条Redundant行格式记录的真实数据占用的总大小来判断的：</p><ul><li><p>当记录的真实数据占用的字节数值不大于127（十六进制0x7F，二进制01111111）时，每个列对应的偏移量占用1个字节。</p></li><li><p>当记录的真实数据占用的字节数大于127，但不大于32767（十六进制0x7FFF，二进制0111111111111111）时，每个列对应的偏移量占用2个字节。</p></li><li><p>有没有记录的真实数据大于32767的情况呢？有，不过此时的记录已经存放到了溢出页中，在本页中只保留前768个字节和20个字节的溢出页面地址。因为字段长度偏移列表处只需要记录每个列在本页面中的偏移就好了，所以每个列使用2个字节来存储偏移量就够了。</p><p>大家可以看出来，Redundant行格式还是比较简单粗暴的，直接使用整个记录的真实数据长度来决定使用1个字节还是2个字节存储列对应的偏移量。只要整条记录的真实数据占用的存储空间大小大于127，即使第一个列的值占用存储空间小于127，那对不起，也需要使用2个字节来表示该列对应的偏移量。简单粗暴，就是这么简单粗暴（所以这种行格式有些过时了）。</p><p>为了在解析记录时知道每个列的偏移量是使用1个字节还是2个字节表示的，Redundant行格式特意在<code>记录头信息</code>里放置了一个称之为1byte_offs_flag的属性：</p></li></ul><p><strong>Redundant行格式中NULL值的处理</strong></p><p>因为Redundant行格式并没有NULL值列表，所以Redundant行格式在字段长度偏移列表中的各个列对应的偏移量处做了一些特殊处理 —— 将列对应的偏移量值的第一个比特位作为是否为NULL的依据，该比特位也可以被称之为NULL比特位。也就是说在解析一条记录的某个列时，首先看一下该列对应的偏移量的NULL比特位是不是为1。如果为1，那么该列的值就是NULL，否则不是NULL。</p><p>这也就解释了上边介绍为什么只要记录的真实数据大于127（十六进制0x7F，二进制01111111）时，就采用2个字节来表示一个列对应的偏移量，主要是第一个比特位是所谓的NULL比特位，用来标记该列的值是否为NULL。</p><p>但是还有一点要注意，对于值为NULL的列来说，该列的类型是否为定长类型决定了NULL值的实际存储方式，我们接下来分析一下record_test_table表的第二条记录，它对应的字段长度偏移列表如下：<br> A4 A4 1A 17 13 0C 06<br>按照列的顺序排放就是：<br>06 0C 13 17 1A A4 A4<br>我们分情况看一下：</p><ul><li>如果存储NULL值的字段是定长类型的，比方说<code>CHAR(M)</code>数据类型的，则NULL值也将占用记录的真实数据部分，并把该字段对应的数据使用0x00字节填充。<br>如图第二条记录的c3列的值是NULL，而c3列的类型是<code>CHAR(10)</code>，占用记录的真实数据部分10字节，所以我们看到在Redundant行格式中使用0x00000000000000000000来表示NULL值。<br>另外，c3列对应的偏移量为0xA4，它对应的二进制实际是：10100100，可以看到最高位为1，意味着该列的值是NULL。将最高位去掉后的值变成了0100100，对应的十进制值为36，而c2列对应的偏移量为0x1A，也就是十进制的26。36 - 26 &#x3D; 10，也就是说最终c3列占用的存储空间为10个字节。</li><li>如果该存储NULL值的字段是变长数据类型的，则不在记录的真实数据处占用任何存储空间。<br>比如record_test_table表的c4列是VARCHAR(10)类型的，VARCHAR(10)是一个变长数据类型，c4列对应的偏移量为0xA4，与c3列对应的偏移量相同，这也就意味着它的值也为NULL，将0xA4的最高位去掉后对应的十进制值也是36，36 - 36 &#x3D; 0，也就意味着c4列本身不占用任何记录的实际数据处的空间。</li></ul><p>除了以上的几点之外，Redundant行格式和Compact行格式还是大致相同的</p><p>&#x3D;&#x3D;总结：Redundant行格式和Compact行格式的差异&#x3D;&#x3D;</p><ol><li><p>Redundant 没有了NULL值列表</p></li><li><p>Redundant 行格式的记录头信息</p><ul><li><p>多了<code>n_field</code>和<code>1byte_offs_flag</code>这两个属性</p></li><li><p>没有record_type这个属性。</p></li></ul></li></ol><h1 id="4-区、段与碎片区"><a href="#4-区、段与碎片区" class="headerlink" title="4. 区、段与碎片区"></a>4. 区、段与碎片区</h1><h2 id="4-1-为什么要有区？"><a href="#4-1-为什么要有区？" class="headerlink" title="4.1 为什么要有区？"></a>4.1 为什么要有区？</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418020.png"></p><h2 id="4-2-为什么要有段？"><a href="#4-2-为什么要有段？" class="headerlink" title="4.2 为什么要有段？"></a>4.2 为什么要有段？</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251420405.png" alt="image-20220725123630473"></p><h2 id="4-3-为什么要有碎片区？"><a href="#4-3-为什么要有碎片区？" class="headerlink" title="4.3 为什么要有碎片区？"></a>4.3 为什么要有碎片区？</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418563.png"></p><h2 id="4-4-区的分类"><a href="#4-4-区的分类" class="headerlink" title="4.4 区的分类"></a>4.4 区的分类</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418173.png"></p><h1 id="5-表空间"><a href="#5-表空间" class="headerlink" title="5. 表空间"></a>5. 表空间</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418019.png" alt="image-20220725125810159"></p><h2 id="5-1-独立表空间"><a href="#5-1-独立表空间" class="headerlink" title="5.1 独立表空间"></a>5.1 独立表空间</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418236.png"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251420539.png" alt="image-20220725130517704"></p><p>你能看到inndb_file_per_table&#x3D;ON，这意味着每张表都会单独保存一个<code>.ibd</code>文件</p><h2 id="5-2-系统表空间"><a href="#5-2-系统表空间" class="headerlink" title="5.2 系统表空间"></a>5.2 系统表空间</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418619.png"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418963.png"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418702.png" alt="image-20220725132440712"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418483.png" alt="image-20220725132656365"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418548.png" alt="image-20220725132301490"></p><h1 id="附录：数据页加载的三种方式"><a href="#附录：数据页加载的三种方式" class="headerlink" title="附录：数据页加载的三种方式"></a>附录：数据页加载的三种方式</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251419043.png" alt="image-20220725122714509"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251419972.png" alt="image-20220725122846616"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251421187.png" alt="image-20220725122942422"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251419621.png" alt="image-20220725123250579"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、索引的数据结构</title>
      <link href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC04%E7%AB%A0_%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC04%E7%AB%A0_%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-为什么使用索引"><a href="#1-为什么使用索引" class="headerlink" title="1. 为什么使用索引"></a>1. 为什么使用索引</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207191612413.png" alt="image-20220714094507900"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171922032.png" alt="image-20220714094315112"></p><p>假如给数据使用 <code>二叉树</code> 这样的数据结构进行存储，如下图所示</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171922692.png" alt="image-20220714095339210"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207191612830.png" alt="image-20220714095625048"></p><h1 id="2、索引及其优缺点"><a href="#2、索引及其优缺点" class="headerlink" title="2、索引及其优缺点"></a>2、索引及其优缺点</h1><h2 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171922811.png" alt="image-20220714100123298"></p><h2 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h2><ol><li>类似大学图书馆建书目索引，提高数据检索的效率，&#x3D;&#x3D;降低 数据库的 IO 成本&#x3D;&#x3D; 这也是创建索引的主要的原因。</li><li>通过创建唯一索引，可以保证数据库表中每一行 <code>数据的唯一性</code> (唯一约束)</li><li>在实现数据的参考完整性方面，可以 <code>加速表和表之间的连接</code>。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。</li><li>在使用分组和排序子句进行数据查询时，可以显著<code>减少查询中分组和排序的时间</code>，降低了 CPU 的消耗。</li></ol><h2 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h2><p>增加索引也有许多不利的方面，主要表现在如下几个方面:</p><ol><li>创建索引和维护索引要 <code>耗费时间</code> （因为索引是排好序的），并且随着数据量的增加，所耗费的时间也会增加。</li><li>索引需要占 磁盘空间，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间，<code>存储在磁盘上</code> ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</li><li>虽然索引大大提高了查询速度，同时却会<code>降低更新表的速度</code>。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li></ol><p><strong>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171922637.png" alt="image-20220714101826957"></p><h1 id="3-InnoDB-中索引的推演"><a href="#3-InnoDB-中索引的推演" class="headerlink" title="3. InnoDB 中索引的推演"></a>3. InnoDB 中索引的推演</h1><h2 id="3-1-索引之前的查找"><a href="#3-1-索引之前的查找" class="headerlink" title="3.1 索引之前的查找"></a>3.1 索引之前的查找</h2><p>先来看一个精确匹配的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;</span><br></pre></td></tr></table></figure><h3 id="3-1-1-在一个页中的查找"><a href="#3-1-1-在一个页中的查找" class="headerlink" title="3.1.1 在一个页中的查找"></a>3.1.1 在一个页中的查找</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171923988.png" alt="image-20220714102440500"></p><p><strong>注意：</strong></p><ul><li><p>数据表中记录之间物理上是不连续的，但是逻辑上是连续的，之间通过单链表进行连接；数据页之间通过双向链表进行连接</p></li><li><p>以主键为搜索条件：$O(log2^n)$，以其他列为搜索条件：$O(n)$</p></li></ul><h3 id="3-1-2-在很多页中查找"><a href="#3-1-2-在很多页中查找" class="headerlink" title="3.1.2 在很多页中查找"></a>3.1.2 在很多页中查找</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171923474.png" alt="image-20220714103545824"></p><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 <code>从第一个页</code> 沿着 <code>双向链表</code>一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 <code>超级耗时</code> 的。此时 <code>索引</code> 应运而生。</p><p>我们可以联想下学校的图书馆：所有书架上有着对应的编号，每个书架中有着分区从A-Z。借书时，先根据书的类型找到对应的书架，再从书架中对应的分区找到目标书籍。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171923442.png" alt="image-20220714103858008"></p><h2 id="3-2-设计索引"><a href="#3-2-设计索引" class="headerlink" title="3.2 设计索引"></a>3.2 设计索引</h2><p>建一个表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE index_demo(</span><br><span class="line">        -&gt; c1 INT,</span><br><span class="line">        -&gt; c2 INT,</span><br><span class="line">    -&gt;     c3 CHAR(1),</span><br><span class="line">    -&gt;     PRIMARY KEY(c1)</span><br><span class="line">    -&gt; ) ROW_FORMAT = Compact;</span><br></pre></td></tr></table></figure><p>这个新建的 <code>index_demo</code> 表中有 2 个 INT 类型的列，1 个 CHAR(1) 类型的列，而且我们规定了 c1 列为主键， 这个表使用 <code>Compact</code> 行格式来实际存储记录的。这里我们简化了 index_demo 表的行格式示意图：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171923843.png" alt="image-20220714104547667"></p><p>我们只在示意图里展示记录的这几个部分：</p><ul><li><code>record_type</code>：记录头信息的一项属性，<strong>表示记录的类型</strong>， <code>0</code> 表示普通记录、 <code>2</code> 表示最小记 录、 <code>3</code> 表示最大记录、 <code>1</code>  表示目录项的记录，暂时还没用过，下面讲。</li><li><code>next_record</code>：记录头信息的一项属性，<strong>表示下一条地址相对于本条记录的地址偏移量</strong>，我们用<br>箭头来表明下一条记录是谁。（用来保证数据逻辑上的连续）</li><li><code>各个列的值</code>：这里只记录在 <code>index_demo</code> 表中的三个列，分别是 <code>c1 、 c2 和 c3</code>。</li><li><code>其他信息</code>：除了上述 3 种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171923379.png" alt="image-20220714104641376"></p><p>把一些记录放到页里的示意图就是：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171923794.png" alt="image-20220714104659573"></p><h3 id="3-2-1一个简单的索引设计方案"><a href="#3-2-1一个简单的索引设计方案" class="headerlink" title="3.2.1一个简单的索引设计方案"></a>3.2.1一个简单的索引设计方案</h3><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 <code>想快速的定位到需要查找的记录在哪些数据页</code> 中该咋办？我们可以为快速定位记录所在的数据页而 <code>建立一个目录</code> 。 建这个目录必须完成下边这些事：</p><ul><li><strong><font color=red>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</font></strong></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171923427.png" alt="image-20220714112538569"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171923153.png" alt="image-20220714112856589"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171923762.png" alt="image-20220714113025543"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207191613261.png" alt="image-20220714113113065"></p><ul><li><strong><font color=red>给所有的页建立一个目录项。</font></strong></li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171923242.png" alt="image-20220714113248419"></p><p><strong>注意：</strong>不建立目录项前，每次进行查询（插入）数据时，都要从前往后一个个数据页、一条条记录查找。需要先加载数据页，再二分查找对应的数据。甚至有时候，加载数据页的速度比查找速度还耗时，这样就非常得不偿失了。才有了 为所有的页建立目录项的操作。</p><p><strong><font color=blue>所以我们为上边几个页做好的目录就像这样子：</font></strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171923741.png" alt="image-20220714113526840"></p><p>以 <code>页 28</code> 为例，它对应 <code>目录项 2</code> ，这个目录项中包含着该页的页号 <code>28</code> 以及该页中用户记录的最小主键值 <code>5</code> 。我们只需要把几个目录项在物理存储器上连续存储（比如：<strong>数组</strong>），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为 <code>20</code> 的记录，具体查找过程分两步：</p><ol><li>先从目录项中根据 <code>二分法</code> 快速确定出主键值为 <code>20</code> 的记录在 <code>目录项 3</code> 中（因为 12 &lt; 20 &lt; 209 ），它对应的页是 <code>页 9</code>。</li><li>再根据前边说的在页中查找记录的方式（二分法）去 <code>页 9</code> 中定位具体的记录。</li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为&#x3D;&#x3D;索引&#x3D;&#x3D; 。</p><h3 id="3-2-2-InnoDB-中的索引方案"><a href="#3-2-2-InnoDB-中的索引方案" class="headerlink" title="3.2.2 InnoDB 中的索引方案"></a>3.2.2 InnoDB 中的索引方案</h3><p>&#x3D;&#x3D;思考一下，我们之前的设计方案有什么问题？&#x3D;&#x3D; </p><p>如下图：比如我们要插入三条数据且恰好在页28和页29之间的，那么需要重新创建个数据页，同时创建对应的目录项，但是目录项是保存在数组中的。目录项3、4都需要向后移动，然后才能插入新的目录项。这样的话效率是非常低的。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171923849.png" alt="image-20220714113526840"></p><p>解决办法：为多个目录项建立目录页，目录项之间通过指针方式进行连接（链表），目录页上建立当前页的目录信息，便于后续的二分查找。同时目录项之间指针连接也方便进行插入和删除操作。</p><p>具体细节看下面的第一次迭代！</p><h4 id="①-迭代-1-次：目录项纪录的页"><a href="#①-迭代-1-次：目录项纪录的页" class="headerlink" title="① 迭代 1 次：目录项纪录的页"></a>① 迭代 1 次：目录项纪录的页</h4><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171923731.png" alt="image-20220715184655930"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171923346.png" alt="image-20220715184437264"></p><p>我们把前边使用到的目录项放到数据页中的样子就是这样：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171923523.png" alt="image-20220715182931843"></p><p>从图中可以看出来，我们新分配了一个编号为 30 的页来专门存储目录项记录。这里再次强调 <code>目录项记录</code> 和普通的 <code>用户记录</code> 的<strong>不同点</strong>：</p><ul><li><code>目录项记录</code> 的 <code>record_type</code> 值是 1，而 <code>普通用户记录</code> 的 <code>record_type</code> 值是 0。</li><li>目录项记录只有 <code>主键值和页的编号</code> 两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列 ，另外还有 InnoDB 自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫 <code>min_rec_mask</code> 的属性，只有在存储 <code>目录项记录</code> 的页中的主键值最小的<code>目录项记录</code> 的 <code>min_rec_mask</code> 值为 1 ，其他别的记录的 <code>min_rec_mask</code> 值都是 0 。</li></ul><p><strong>相同点：</strong>两者用的是一样的数据页，都会为主键值生成 <code>Page Directory</code> （页目录），从而在按照主键值进行查找时可以使用 <code>二分法</code> 来加快查询速度 (如果没有页目录，链表是无法进行 二分查找)</p><p>现在以查找主键为 <code>20</code> 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ol><li>先到存储 <code>目录项记录</code>的页，也就是页 30 中通过 <code>二分法</code> 快速定位到对应目录项，因为 12 &lt; 20 &lt; 209，所以定位到对应的记录所在的页就是页 9。</li><li>再到存储用户记录的页9中根据 <code>二分法</code> 快速定位到主键值为 20 的用户记录。</li></ol><p><strong>注意：</strong>建立目录页后，IO次数也会降低。比如上面的查找只有两次IO</p><h4 id="②-迭代-2-次：多个目录项纪录的页"><a href="#②-迭代-2-次：多个目录项纪录的页" class="headerlink" title="② 迭代 2 次：多个目录项纪录的页"></a>② 迭代 2 次：多个目录项纪录的页</h4><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171924274.png" alt="image-20220715194903736"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171924587.png"></p><p>从图中可以看出，我们插入了一条主键值为 320 的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了 <code>页 31</code> 。</li><li>因为原先存储目录项记录的 <code>页 30 的容量已满</code>（我们前边假设只能存储 4 条目录项记录），所以不得不需要一个新的 <code>页 32</code> 来存放 <code>页 31</code> 对应的目录项。(目录页之间用双向链表连接)</li></ul><p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要 3 个步骤，以查找主键值为 <code>20</code> 的记录为例：</p><ol><li><p>确定 <code>目录项记录页</code></p><p>我们现在的存储目录项记录的页有两个，即 <code>页 30</code> 和 <code>页 32</code> ，又因为页 30 表示的目录项的主键值的范围是 <code>[1, 320)</code>，<code>页 32</code> 表示的目录项的主键值不小于 <code>320</code> ，所以主键值为 <code>20</code> 的记录对应的目录项记录在 <code>页 30</code> 中。</p></li><li><p>通过目录项记录页 <code>确定用户记录真实所在的页</code> 。在一个存储 <code>目录项记录</code> 的页中通过主键值定位一条目录项记录的方式说过了。</p></li><li><p>在真实存储用户记录的页中定位到具体的记录。</p></li></ol><p><strong>存在的问题：</strong>查找数据第一步，判断数据是在哪个目录项记录页中时，由于目录项记录页之间是双链表连接的，所以只能从前往后进行遍历查找（<code>过程中IO次数较多</code>），之后找到了再二分查找到对应的数据页… </p><p><strong>改进办法：</strong>&#x3D;&#x3D;为数据项记录页 建立目录页&#x3D;&#x3D;</p><h4 id="③-迭代-3-次：目录项记录页的目录页"><a href="#③-迭代-3-次：目录项记录页的目录页" class="headerlink" title="③ 迭代 3 次：目录项记录页的目录页"></a>③ 迭代 3 次：目录项记录页的目录页</h4><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207191613637.png" alt="image-20220715195038044"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171924115.png"></p><p>如图，我们生成了一个存储更高级目录项的 <code>页 33</code> ，这个页中的两条记录分别代表页 30 和页 32，如果用户记录的主键值在 <code>[1, 320)</code> 之间，则到页 30 中查找更详细的目录项记录，如果主键值 <code>不小于 320</code> 的话，就到页 32 中查找更详细的目录项记录。</p><p>我们可以用下边这个图来描述它：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171924978.png" alt="image-20220715191318626"></p><p>这个数据结构，它的名称是 <code>B+ 树</code> 。</p><h4 id="④-B-Tree"><a href="#④-B-Tree" class="headerlink" title="④ B+Tree"></a>④ B+Tree</h4><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171924249.png" alt="image-20220715195450204"></p><p>一个 B+ 树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 <code>0</code> 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 <code>最多存放 3 条记录</code> ，存放目录项 记录的页 <code>最多存放 4 条记录</code> 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 <code>100 条用户记录</code> ，所有存放目录项记录的内节点代表的数据页可以存 放 <code>1000 条目录项记录</code> ，那么：</p><ul><li>如果 B+ 树只有 1 层，也就是只有 1 个用于存放用户记录的节点，最多能存放 <code>100</code> 条记录。</li><li>如果 B+ 树有 2 层，最多能存放 <code>1000×100=10,0000</code>条记录。</li><li>如果 B+ 树有 3 层，最多能存放 <code>1000×1000×100=1,0000,0000</code>条记录。 1亿</li><li>如果 B+ 树有 4 层，最多能存放 <code>1000×1000×1000×100=1000,0000,0000</code>条记录。相当多的记录！！！ 1000亿</li></ul><p>你的表里能存放 <code>100000000000</code> 条记录吗？所以一般情况下，我们 <code>用到的 B+ 树都不会超过 4 层</code> ，那我们通过主键值去查找某条记录最多只需要做 4 个页面内的查找（查找 3 个目录项页和一个用户记录页），又因为在每个页面内有所谓的 <code>Page Directory</code> （页目录），所以在页面内也可以通过二分法实现快速定位记录。</p><p>&#x3D;&#x3D;为啥B+ 树都不会超过 4 层呢？&#x3D;&#x3D;</p><p><strong><font color=red>树的层次达到4的时候，可以存储的数据量足够多了（1000亿）。树的层次越低，IO次数就越少，从而效率越高</font></strong></p><h2 id="3-3-常见索引概念"><a href="#3-3-常见索引概念" class="headerlink" title="3.3 常见索引概念"></a>3.3 常见索引概念</h2><p>索引按照物理实现方式，索引可以分为 2 种：&#x3D;&#x3D;聚簇（聚集）和非聚簇（非聚集）索引&#x3D;&#x3D;。我们也把非聚集索引称为二级索引或者辅助索引。</p><h3 id="3-3-1-聚簇索引"><a href="#3-3-1-聚簇索引" class="headerlink" title="3.3.1 聚簇索引"></a>3.3.1 聚簇索引</h3><p><strong>特点：</strong></p><ol><li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义:<ul><li><code>页内</code> 的记录是按照主键的大小顺序排成一个 <code>单向链表</code> 。</li><li>各个存放存放 <code>用户记录的页</code>，也是根据页中用户记录的主键大小顺序排成一个 <code>双向链表</code>.</li><li>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个<code>双向链表</code></li></ul></li><li><strong>B+ 树的叶子节点存储的是完整的用户记录。</strong><ul><li>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</li></ul></li></ol><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207191614852.png" alt="image-20220715232925683"></p><p><strong>优点：</strong></p><ul><li><code>数据访问更快</code> ，因为聚簇索引将索引和数据保存在同一个 B+ 树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的 <code>排序查找</code> 和 <code>范围查找</code> 速度非常快 (因为数据本身就是有序的)</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 <code>节省了大量的 io 操作</code> 。</li></ul><p><strong>缺点:</strong></p><ul><li><code>插入速度严重依赖于插入顺序</code> ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个 <strong>自增的 ID 列为主键</strong> <ul><li>前半句分析。比如我们在<code>上上幅图</code>中页9和页20中间插入个 主键为200的数据，这就会导致页20及其后面的需要进行逻辑上的移动，然后插入新数据。同时上层目录页中的数据以及指针也可能变动，依次往上推，从而会降低性能！</li><li>后半句思考：删除的时候通常不真正删除，而是弄一个删除标记是不是和这个有关？</li></ul></li><li>更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义<strong>主键为不可更新</strong><ul><li>比如我们将 <code>上上幅图</code> 中的 209 改为 409，也会导致数据的移动。同时对上层目录页中的数据以及指针也可能变动，依次往上推，从而影响性能！</li></ul></li><li><code>二级索引访问需要两次索引查找</code> ，第一次找到主键值，第二次根据主键值找到行数据 （下文细讲）</li></ul><p><strong>限制：</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171924851.png" alt="image-20220715233902014"></p><h3 id="3-3-2-二级索引（辅助索引、非聚簇索引）"><a href="#3-3-2-二级索引（辅助索引、非聚簇索引）" class="headerlink" title="3.3.2 二级索引（辅助索引、非聚簇索引）"></a>3.3.2 二级索引（辅助索引、非聚簇索引）</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171933867.png" alt="image-20220715234340429"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171926371.png" alt="image-20220715231734736"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171927771.png" alt="image-20220715234935943"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171927908.png" alt="image-20220715235447064"></p><p><strong>概念：&#x3D;&#x3D;回表&#x3D;&#x3D;</strong> 我们根据这个以 c2 列大小排序的 B+ 树只能确定我们要查找记录的主键值，所以如果我们想根据 c2 列的值查找到完整的用户记录的话，仍然需要到 <code>聚簇索引</code> 中再查一遍，这个过程称为 <code>回表</code> 。也就是根据 &#x3D;&#x3D;c2 列的值查询一条完整的用户记录需要使用到 <code>2</code> 棵 B+ 树&#x3D;&#x3D;！</p><p><strong><font color=red>问题：为什么我们还需要一次回表操作呢？直接把完整的用户记录放到叶子节点不 OK 吗？</font></strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171927961.png" alt="image-20220715235754879"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171927850.png" alt="image-20220715231752138"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171927931.png" alt="image-20220716000732454"></p><p>第三点的解释：聚簇索引中存放的是记录的所有字段，一旦进行修改，聚簇索引上的数据是一定需要修改的。而非聚簇索引存放的是主键+单个字段，相对来说修改的少，效率也就高。</p><h3 id="3-3-3-联合索引"><a href="#3-3-3-联合索引" class="headerlink" title="3.3.3 联合索引"></a>3.3.3 联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+ 树按照 <code>c2 和c3 列</code> 的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照 c2 列进行排序。</li><li>在记录的 c2 列相同的情况下，采用 c3 列进行排序</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171927898.png"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171927913.png" alt="image-20220716002008182"></p><p>注意一点，以 c2 和 c3 列的大小为排序规则建立的 B+ 树称为 &#x3D;&#x3D;联合索引 ，本质上也是一个二级索引&#x3D;&#x3D;。它的意思与分别为 c2 和 c3 列分别建立索引的表述是不同的，不同点如下:</p><ul><li>建立 <code>联合索引</code> 只会建立如上图一样的 1 棵 B+ 树。</li><li>为 c2 和 c3 列分别建立索引会分别以 c2 和 c3 列的大小为排序规则建立 2 棵 B+ 树。</li></ul><h2 id="3-4-InnoDB-的-B-树索引的注意事项"><a href="#3-4-InnoDB-的-B-树索引的注意事项" class="headerlink" title="3.4 InnoDB 的 B+ 树索引的注意事项"></a>3.4 InnoDB 的 B+ 树索引的注意事项</h2><p><strong><font color=blue>1. 根页面位置万年不动</font></strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171927355.png" alt="image-20220717153401761"></p><p><strong>注意：</strong>B+树的构建是自上往下构建的</p><p><strong><font color=blue>2. 内节点中目录项记录的唯一性</font></strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171927754.png" alt="image-20220717154200568"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171927402.png" alt="image-20220717154111061"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207191618131.png" alt="image-20220717155054555"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171927042.png" alt="image-20220717154649228"></p><p><strong>注意：</strong>页号虽然也可以保证列的唯一性，但是没有实际意义。而其他的列比如c3、c 4我们也不能保证唯一性。所以我们增添的是主键值，再进行判断时也是根据 <code>列号+主键 </code>来选择向哪一页插入数据</p><p><strong><font color=blue>3. 一个页面最少存储 2 条记录</font></strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207191614926.png" alt="image-20220717155342368"></p><h1 id="4-MyISAM-中的索引方案"><a href="#4-MyISAM-中的索引方案" class="headerlink" title="4. MyISAM 中的索引方案"></a>4. MyISAM 中的索引方案</h1><p><strong>B 树索引适用存储引擎如表所示：</strong></p><table><thead><tr><th align="left"><strong>索引</strong> &#x2F; <strong>存储引擎</strong></th><th align="left">MyISAM</th><th align="left">InnoDB</th><th align="left">Memory</th></tr></thead><tbody><tr><td align="left">B-Tree 索引</td><td align="left">支持</td><td align="left">支持</td><td align="left">支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb 和 MyISAM 默认的索引是 B-tree 索引；而 Memory 默认的索引是 Hash 索引。</p><p>&#x3D;&#x3D;MyISAM 引擎使用 <code>B+Tree</code> 作为索引结构&#x3D;&#x3D;，叶子节点的 data 域存放的是 <code>数据记录的地址</code>  （所以MyISAM把索引和数据分开存储了）</p><p><strong>注意：</strong> 在MySQL中，B 树实际上还是B+树。但是在选择谈到选择MySQL的数据结构时，这两者就区别大了</p><h2 id="4-1-MyISAM-索引的原理"><a href="#4-1-MyISAM-索引的原理" class="headerlink" title="4.1 MyISAM 索引的原理"></a>4.1 MyISAM 索引的原理</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171927588.png" alt="image-20220717161900703"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171927035.png" alt="image-20220715231824610"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207191615572.png" alt="image-20220717162146794"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171927564.png" alt="image-20220715231837968"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207191616598.png" alt="image-20220717162348210"></p><p><strong>注意：</strong>对于MYISAM来说，无论是主键索引还是非主键索引都属于非聚簇索引，因为数据和索引是分离的</p><h2 id="4-2-MyISAM-与-InnoDB-对比"><a href="#4-2-MyISAM-与-InnoDB-对比" class="headerlink" title="4.2 MyISAM 与 InnoDB 对比"></a>4.2 MyISAM 与 InnoDB 对比</h2><p><strong><font color=red>MyISAM 的索引方式都是“非聚簇”的，与 InnoDB 包含 1 个聚簇索引是不同的</font></strong></p><p><strong>两种引擎中索引的区别：</strong></p><ol><li>在 InnoDB 存储引擎中，我们只需要根据主键值对 <code>聚簇索引</code> 进行一次查找就能找到对应的记录，而在 <code>MyISAM</code> 中却需要进行一次 <code>回表</code> 操作，意味着 MyISAM 中建立的索引相当于全部都是 <code>二级索引</code> 。（<code>MyISAM</code>的回表就是根据地址到data表中查找数据）</li><li>InnoDB 的数据文件本身就是索引文件，而 MyISAM 索引文件和数据文件是 <code>分离的</code> ，索引文件仅保存数据记录的地址。</li><li>InnoDB 的非聚簇索引 data 域存储相应记录 <code>主键的值</code> ，而 MyISAM 索引记录的是 <code>地址</code> 。换句话说， InnoDB 的所有非聚簇索引都引用主键作为 data 域。</li><li>MyISAM 的回表操作是十分 <code>快速</code> 的，因为是拿着地址偏移量直接到文件中取数据的，反观 InnoDB 是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</li><li>InnoDB 要求表 <code>必须有主键 ( MyISAM 可以没有 )</code>。如果没有显式指定，则 MySQL 系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整型。<ul><li>InnoDB的主键是为了生成聚簇索引，所以必须有；MyISAM 中的索引都是非聚簇的，数据和索引分离，所以对MyISAM没有要求。但是为了查询方便，还是建议指定某一字段为主键，从而方便存储引擎为其构建索引，提升查询效率。</li></ul></li></ol><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171928739.png" alt="image-20220717163934737"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171928059.png" alt="image-20220715231909478"></p><h1 id="5-索引的代价"><a href="#5-索引的代价" class="headerlink" title="5. 索引的代价"></a>5. 索引的代价</h1><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p><ul><li><p><strong>空间上的代价</strong></p><p>每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树由许多数据页组成，那就是很大的一片存储空间。</p></li><li><p><strong>时间上的代价</strong></p><p>每次对表中的数据进行 <code>增</code>、<code>删</code>、<code>改</code>操作时，都需要去修改各个 B+ 树索引。而且我们讲过，B+ 树每层节点都是按照索引列的值 <code>从小到大的顺序排序</code> 而组成了 <code>双向链表</code> 。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些 <code>记录移位</code> ， <code>页面分裂</code> 、 <code>页面回收</code> 等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的 B+ 树都要进行相关的维护操作，会给性能拖后腿。</p></li></ul><blockquote><p>一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。</p></blockquote><h1 id="6-MySQL-数据结构选择的合理性"><a href="#6-MySQL-数据结构选择的合理性" class="headerlink" title="6. MySQL 数据结构选择的合理性"></a>6. MySQL 数据结构选择的合理性</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207191616637.png" alt="image-20220717165213800"></p><h2 id="6-1-全表遍历"><a href="#6-1-全表遍历" class="headerlink" title="6.1 全表遍历"></a>6.1 全表遍历</h2><p>这里都懒得说了（加载所有页到内存，进行遍历查找，非常耗时，性能极差）</p><h2 id="6-2-Hash-结构"><a href="#6-2-Hash-结构" class="headerlink" title="6.2 Hash 结构"></a>6.2 Hash 结构</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171928395.png" alt="image-20220717170503380"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171928978.png" alt="image-20220715231924996"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171928498.png" alt="image-20220717171015638"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171928194.png" alt="image-20220715231940599"></p><p>上图中哈希函数 h 有可能将两个不同的关键字映射到相同的位置，这叫做 <code>碰撞</code> ，在数据库中一般采用<code>链接法</code> 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171928762.png" alt="image-20220715231955539"></p><p><strong><font color=red>Hash 结构效率高，那为什么索引结构要设计成树型呢？</font></strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171928921.png" alt="image-20220717171419076"></p><p><strong>Hash 索引适用存储引擎如表所示：</strong></p><table><thead><tr><th align="left"><strong>索引</strong> &#x2F; <strong>存储引擎</strong></th><th align="left">MyISAM</th><th align="left">InnoDB</th><th align="left">Memory</th></tr></thead><tbody><tr><td align="left">HASH 索引</td><td align="left">不支持</td><td align="left">不支持</td><td align="left"><code>支持</code></td></tr></tbody></table><p>&#x3D;&#x3D;<strong>Hash索引的适用性</strong>&#x3D;&#x3D;</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171928321.png" alt="image-20220717172136557"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171928874.png" alt="image-20220715232011897"></p><p>采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。</p><p>我们可以通过 <code>innodb_adaptive_hash_index</code> 变量来查看是否开启了自适应 Hash，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%adaptive_hash_index&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171928818.png" alt="image-20220715232023427"></p><h2 id="6-3-二叉搜索树"><a href="#6-3-二叉搜索树" class="headerlink" title="6.3 二叉搜索树"></a>6.3 二叉搜索树</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171928584.png" alt="image-20220717181604411"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171928608.png" alt="image-20220715232037198"></p><p>创造出来的二分搜索树如下图所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171928202.png" alt="image-20220715232048465"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171928642.png" alt="image-20220717182128622"></p><h2 id="6-4-AVL-树"><a href="#6-4-AVL-树" class="headerlink" title="6.4 AVL 树"></a>6.4 AVL 树</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929504.png" alt="image-20220717182241429"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171928128.png" alt="image-20220715232059135"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929849.png" alt="image-20220717182343402"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929985.png" alt="image-20220715232108965"></p><p>你能看到此时树的高度降低了，当数据量N大的时候，以及树的分叉数M大的时候，M叉树的高度会远小于二叉树的高度(M&gt;2)。所以，我们需要把树<code>从“瘦高&quot;变&quot;矮胖”</code>。</p><h2 id="6-5-B-Tree"><a href="#6-5-B-Tree" class="headerlink" title="6.5 B-Tree"></a>6.5 B-Tree</h2><p>B树的英文是Balance Tree,也就是&#x3D;&#x3D;多路平衡查找树&#x3D;&#x3D;。简写为B-Tree (注意横杠表示这两个单词连起来的意思，不是减号)。它的高度远小于平衡二叉树的高度。</p><p>B 树的结构如下图所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929257.png" alt="image-20220715232120451"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929433.png" alt="image-20220717182836451"></p><p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p><ol><li>根节点的儿子数的范围是 [2,M]。</li><li>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为 [ceil（M &#x2F; 2）, M]。</li><li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil（M &#x2F; 2）, M]。</li><li>假设中间节点节点的关键字为：Key[1]，Key[2]，…，Key[k-1]，且关键字按照升序排序，即 Key[i] &lt; Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1]，P[2]，…，P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]）的子树，P[k] 指向关键字大于 Key[k-1] 的子树。</li><li>所有叶子节点位于同一层。</li></ol><p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它 有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15) 大于 12，刚好符合刚才我们给出的特征。</p><p>然后我们来看下如何用 B 树进行查找。假设我们想要 <code>查找的关键字是 9</code>，那么步骤可以分为以下几步：</p><ol><li>我们与根节点的关键字 (17，35)进行比较，9 小于 17 那么得到指针 P1;</li><li>按照指针 P1 找到磁盘块 2，关键字为（8，12)，因为 9 在 8 和 12 之间，所以我们得到指针 P2;</li><li>按照指针 P2 找到磁盘块 6，关键字为（9，10)，然后我们找到了关键字 9。</li></ol><p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I&#x2F;O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。<code>B 树相比平衡二叉树来说磁盘 I/O 操作更少</code>， 在数据查询中比平衡二叉树效率要高。所以<code>只要树的高度足够低，IO 次数足够少，就可以提高查询性能</code> 。</p><p><strong>小结</strong></p><ol><li><p>B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</p></li><li><p>&#x3D;&#x3D;关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据&#x3D;&#x3D;。搜索有可能在非叶子节点结束</p></li><li><p>其搜索性能等价于在关键字全集内做一次二分查找。</p></li></ol><p><strong>再举例 1：</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929907.png" alt="image-20220715232133122"></p><p><strong>注意：</strong>叶子节点和非叶子节点都存放数据。我们要查找C1:8，通过比较在磁盘块2中有对应的，那么数据就存在磁盘块2中</p><h2 id="6-6-B-Tree"><a href="#6-6-B-Tree" class="headerlink" title="6.6 B+Tree"></a>6.6 B+Tree</h2><p>B+树也是一种多路搜索树，<code>基于B树做出了改进</code>，主流的DBMS都支持B+树的索引方式,比如MySQL。相比于B-Tree，&#x3D;&#x3D;B+Tree适合文件索引 系统&#x3D;&#x3D;。</p><ul><li>MySQL 官网说明：</li></ul><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929089.png" alt="image-20220715232146550"></p><p><strong>B+ 树和 B 树的差异：</strong></p><ol><li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数 +1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小)。</li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中，<code>非叶子节点既保存索引，也保存数据记录</code> 。</li><li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。而B树中，叶子节点组成的链表是不完整的，还包含目录页中的数据</li></ol><p>下图就是一棵B+树，阶数为3，根节点中的关键字1、18、 35分别是子节点(1, 8，14) ，(18, 24, 31)和(35， 41， 53) 中的最小值。每一层父节点的关键字都会出现在下一层的子节点的关键字中，因此在叶子节点中包括了所有的关键字信息，并且每一个叶子节点都有一个指向下一个节点的指针，这样就形成了一个链表。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929073.png" alt="image-20220717184500555"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207191617500.png" alt="image-20220717184652033"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929217.png" alt="image-20220717184830228"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929914.png" alt="image-20220717184924406"></p><blockquote><p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。</p><p>但 B 树和 B+ 树各有自己的应用场景，不能说 B+ 树完全比 B 树好，反之亦然。</p></blockquote><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929537.png" alt="image-20220717185506036"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929115.png" alt="image-20220717185610352"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929801.png" alt="image-20220717185938636"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929401.png" alt="image-20220717190325041"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929857.png" alt="image-20220717190638630"></p><h2 id="6-7-R-树"><a href="#6-7-R-树" class="headerlink" title="6.7 R 树"></a>6.7 R 树</h2><p>R-Tree 在 MySQL 很少使用，仅支持 <code>geometry 数据类型</code> ，支持该类型的存储引擎只有 myisam、bdb、 innodb、ndb、archive 几种。举个 R 树在现实领域中能够解决的例子：查找 20 英里以内所有的餐厅。如果没有 R 树你会怎么解决？一般情况下我们会把餐厅的坐标（x,y）分为两个字段存放在数据库中，一个字段记录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满足要求。如果一个地区有 100 家餐厅的话，我们就要进行 100 次位置计算操作了，如果应用到谷歌、百度地图这种超大数据库中，这种方法便必定不可行了。R 树就很好的 <code>解决了这种高维空间搜索问题</code>。它把 B 树的思想很好的扩展到了多维空间，采用了 B 树分割空间的思想，并在添加、删除操作时采用合并、分解结点的方法，保证树的平衡性。因此，R 树就是一棵用来 <code>存储高维数据的平衡树</code> 。相对于 B-Tree，R-Tree 的优势在于范围查找。</p><table><thead><tr><th align="left"><strong>索引</strong> &#x2F; <strong>存储引擎</strong></th><th align="left">MyISAM</th><th align="left">InnoDB</th><th align="left">Memory</th></tr></thead><tbody><tr><td align="left">R-Tree 索引</td><td align="left">支持</td><td align="left">支持</td><td align="left"><code>不支持</code></td></tr></tbody></table><h2 id="6-8-小结"><a href="#6-8-小结" class="headerlink" title="6.8 小结"></a>6.8 小结</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929306.png" alt="image-20220717190902117"></p><p>&#x3D;&#x3D;面试中常考点：B+树和B-树的区别、B+树和Hash的区别&#x3D;&#x3D;</p><h2 id="6-9-附录：算法的时间复杂度"><a href="#6-9-附录：算法的时间复杂度" class="headerlink" title="6.9 附录：算法的时间复杂度"></a>6.9 附录：算法的时间复杂度</h2><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207171929602.png" alt="image-20220715232212165"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、存储引擎</title>
      <link href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC03%E7%AB%A0_%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC03%E7%AB%A0_%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207132335455.png" alt="image-20220713231227788"></p><h1 id="1-查看存储引擎"><a href="#1-查看存储引擎" class="headerlink" title="1. 查看存储引擎"></a>1. 查看存储引擎</h1><p>查看mysql提供什么存储引擎:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207132335257.png" alt="image-20220713223052510"></p><h1 id="2-设置系统默认的存储引擎"><a href="#2-设置系统默认的存储引擎" class="headerlink" title="2. 设置系统默认的存储引擎"></a>2. 设置系统默认的存储引擎</h1><ul><li><p>查看默认的存储引擎:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%storage_engine%&#x27;; </span><br><span class="line">#或</span><br><span class="line">SELECT @@default_storage_engine;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207132335167.png" alt="image-20220713223312035"></p></li><li><p>修改默认的存储引擎</p><p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用 <code>InnoDB</code> 作为表的存储引擎。 如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET DEFAULT_STORAGE_ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>或者修改 <code>my.cnf</code> 文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default-storage-engine=MyISAM</span><br><span class="line"># 重启服务</span><br><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure></li></ul><h1 id="3-设置表的存储引擎"><a href="#3-设置表的存储引擎" class="headerlink" title="3. 设置表的存储引擎"></a>3. 设置表的存储引擎</h1><p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为 <code>不同的表设置不同的存储引擎</code> ，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p><h2 id="3-1-创建表时指定存储引擎"><a href="#3-1-创建表时指定存储引擎" class="headerlink" title="3.1 创建表时指定存储引擎"></a>3.1 创建表时指定存储引擎</h2><p>我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎 <code>InnoDB</code> 。如果我们想显式的指定一下表的存储引擎，那可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名( </span><br><span class="line">  建表语句;</span><br><span class="line">) ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure><h2 id="3-2-修改表的存储引擎"><a href="#3-2-修改表的存储引擎" class="headerlink" title="3.2 修改表的存储引擎"></a>3.2 修改表的存储引擎</h2><p>如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 存储引擎名称; </span><br></pre></td></tr></table></figure><p>比如我们修改一下 <code>engine_demo_table</code> 表的存储引擎:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE engine_demo_table ENGINE = InnoDB;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>这时我们再查看一下 <code>engine_demo_table</code> 的表结构:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> engine_demo_table\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="keyword">Table</span>: engine_demo_table</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `engine_demo_table` (</span><br><span class="line">  `i` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>可以看到该表的存储引擎已经改为<code>InnoDB</code>了。</p><h1 id="4-引擎介绍"><a href="#4-引擎介绍" class="headerlink" title="4. 引擎介绍"></a>4. 引擎介绍</h1><h2 id="4-1-InnoDB-引擎：具备-外键-支持功能的事务存储引擎"><a href="#4-1-InnoDB-引擎：具备-外键-支持功能的事务存储引擎" class="headerlink" title="4.1 InnoDB 引擎：具备&#x3D;&#x3D;外键&#x3D;&#x3D;支持功能的事务存储引擎"></a>4.1 InnoDB 引擎：具备&#x3D;&#x3D;外键&#x3D;&#x3D;支持功能的事务存储引擎</h2><ul><li>MySQL 从 3.23.34a 开始就包含 InnoDB 存储引擎。<code>大于等于 5.5 之后，默认采用 InnoDB 引擎</code> </li><li>InnoDB 是 MySQL 的 &#x3D;&#x3D;默认事务型引擎&#x3D;&#x3D; ，它被设计用来处理大量的短期（short-lived）事务。可以确保事务的完整提交（Commit）和回滚（Rollback）。</li><li>&#x3D;&#x3D;除了增加和查询外，还需要更新、删除操作&#x3D;&#x3D;，那么，应优先选择 InnoDB 存储引擎。</li><li><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎</strong>。 数据文件结构：</li><li><code>表名.frm</code> 存储表结构（MySQL8.0时，合并在表名.ibd中）</li><li><code>表名.ibd</code> 存储数据和索引</li><li>&#x3D;&#x3D;InnoDB是 为处理巨大数据量的最大性能设计&#x3D;&#x3D;。<ul><li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如：<code>.frm</code> ， <code>.par</code> ， <code>.trn</code> ， <code>.isl</code> ， 等都在 MySQL 8.0 中不存在了。</li></ul></li><li>对比 MyISAM 的存储引擎，<code>InnoDB写的处理效率差一些</code> ，并且会占用更多的磁盘空间以保存数据和索引。</li><li>MyISAM 只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据(加载数据时，也要加载索引)，<code>对内存要求较高</code> ，而且内存大小对性能有决定性的影响。</li></ul><h2 id="4-2-MyISAM-引擎：主要的非事务处理存储引擎"><a href="#4-2-MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="4.2 MyISAM 引擎：主要的非事务处理存储引擎"></a>4.2 MyISAM 引擎：主要的非事务处理存储引擎</h2><ul><li>MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数（GIS）等，但 MyISAM <code>不支持事务、行级锁、外键</code>，有一个毫无疑问的缺陷就是 <code>崩溃后无法安全恢复</code>。</li><li><code>5.5 之前默认的存储引擎</code></li><li>优势是访问的 <code>速度快</code> ，对事务完整性没有要求或者以 SELECT、INSERT 为主的应用</li><li>针对数据统计有额外的常数存储。故而<code>count(*)</code> 的查询效率很高</li><li>数据文件结构<ul><li><code>表名.frm</code> 存储表结构</li><li><code>表名.MYD</code> 存储数据（MYData）</li><li><code>表名.MYI</code> 存储索引（MYIndex）</li></ul></li><li>应用场景:只读应用或者以读为主的业务</li></ul><h2 id="4-3-Archive-引擎：用于数据存档"><a href="#4-3-Archive-引擎：用于数据存档" class="headerlink" title="4.3 Archive 引擎：用于数据存档"></a>4.3 Archive 引擎：用于数据存档</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207132335661.png" alt="image-20220713231445827"></p><p>下表展示了 ARCHIVE 存储引擎功能：</p><table><thead><tr><th align="left">特征</th><th align="left">支持</th></tr></thead><tbody><tr><td align="left">B树索引</td><td align="left">不支持</td></tr><tr><td align="left"><code>备份/时间点恢复</code>(在服务器中实现，而不是在存储引擎中)</td><td align="left">支持</td></tr><tr><td align="left">集群数据库支持</td><td align="left">不支持</td></tr><tr><td align="left">聚集索引</td><td align="left">不支持</td></tr><tr><td align="left">压缩数据</td><td align="left">支持</td></tr><tr><td align="left">数据缓存</td><td align="left">不支持</td></tr><tr><td align="left">加密数据(加密功能在服务器中实现)</td><td align="left">支持</td></tr><tr><td align="left">外键支持</td><td align="left">不支持</td></tr><tr><td align="left">全文检索索引</td><td align="left">不支持</td></tr><tr><td align="left">地理空间数据类型支持</td><td align="left">支持</td></tr><tr><td align="left">地理空间索引支持</td><td align="left">不支持</td></tr><tr><td align="left">哈希索引</td><td align="left">不支持</td></tr><tr><td align="left">索引缓存</td><td align="left">不支持</td></tr><tr><td align="left"><code>锁粒度</code></td><td align="left">行锁</td></tr><tr><td align="left">MVCC</td><td align="left">不支持</td></tr><tr><td align="left">存储限制</td><td align="left">没有任何限制</td></tr><tr><td align="left">交易</td><td align="left">不支持</td></tr><tr><td align="left">更新数据字典的统计信息</td><td align="left">支持</td></tr></tbody></table><h2 id="4-4-Blackhole-引擎：丢弃写操作，读操作会返回空内容"><a href="#4-4-Blackhole-引擎：丢弃写操作，读操作会返回空内容" class="headerlink" title="4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容"></a>4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207132335029.png" alt="image-20220713231926786"></p><h2 id="4-5-CSV-引擎：存储数据时，以逗号分隔各个数据项"><a href="#4-5-CSV-引擎：存储数据时，以逗号分隔各个数据项" class="headerlink" title="4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项"></a>4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207132335774.png" alt="image-20220713232053842"></p><p>使用案例如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test (i <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>, c <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>) ENGINE <span class="operator">=</span> CSV;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.06</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;record one&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;record two&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.05</span> sec)</span><br><span class="line">Records: <span class="number">2</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test; </span><br><span class="line"><span class="operator">+</span><span class="comment">---+------------+</span></span><br><span class="line"><span class="operator">|</span>i  <span class="operator">|</span>c           <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">---+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> record <span class="keyword">one</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span> record two <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>创建 CSV 表还会创建相应的 <code>元文件</code> ，用于 <code>存储表的状态</code> 和 <code>表中存在的行数</code> 。此文件的名称与表的名称相 同，后缀为 <code>CSM</code>。如图所示</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207132335054.png" alt="image-20220713232615402"></p><p>如果检查 <code>test.CSV</code> 通过执行上述语句创建的数据库目录中的文件，其内容使用Notepad++打开如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;1&quot;,&quot;record one&quot;</span><br><span class="line">&quot;2&quot;,&quot;record two&quot;</span><br></pre></td></tr></table></figure><p>这种格式可以被 Microsoft Excel 等电子表格应用程序读取，甚至写入。使用 Microsoft Excel 打开如图所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207132335502.png" alt="image-20220713232637071"></p><h2 id="4-6-Memory-引擎：置于内存的表"><a href="#4-6-Memory-引擎：置于内存的表" class="headerlink" title="4.6 Memory 引擎：置于内存的表"></a>4.6 Memory 引擎：置于内存的表</h2><p><strong>概述:</strong></p><p>Memory 采用的逻辑介质是 <code>内存 ， 响应速度很快</code> ，但是当mysqld守护进程崩溃的时候 <code>数据会丢失</code> 。另 外，要求存储的数据是数据长度不变的格式，比如，Blob 和 Text 类型的数据不可用。</p><p><strong>主要特征:</strong></p><ul><li>Memory 同时 <code>支持哈希（HASH）索引</code>和 <code>B+树索引</code> 。</li><li>Memory 表至少比 MyISAM表 要 <code>快一个数量级</code>。</li><li>MEMORY <code>表的大小是受限制</code>的。表的大小主要取决于两个参数，分别是 <code>max_rows</code> 和<code>max_heap_table_size</code>。其中，max_rows可以在创建表时指定；max_heap_table_size 的大小默认为 16 MB，可以按需要进行扩大。</li><li>数据文件与索引文件分开存储。</li><li>缺点：其数据易丢失，生命周期短。基于这个缺陷，选择 MEMORY 存储引擎时需要特别小心。</li></ul><p><strong>使用Memory存储引擎的场景:</strong></p><ol><li><code>目标数据比较小</code>，而且非常 <code>频繁的进行访问</code>，在内存中存放数据，如果太大的数据会造成 <code>内存溢出</code> 。可以通过参数 <code>max_heap_table_size</code> 控制 Memory 表的大小，限制 Memory 表的最大的大小。</li><li>如果 <code>数据是临时的</code> ，而且 <code>必须立即可用</code> 得到，那么就可以放在内存中。</li><li>存储在 Memory 表中的数据如果突然间 <code>丢失的话也没有太大的关系</code>。</li></ol><h2 id="4-7-Federated-引擎：访问远程表"><a href="#4-7-Federated-引擎：访问远程表" class="headerlink" title="4.7 Federated 引擎：访问远程表"></a>4.7 Federated 引擎：访问远程表</h2><p>Federated 引擎是访问其他MySQL服务器的一个 代理 ，尽管该引擎看起来提供了一种很好的跨服务器的灵活性 ，但也经常带来问题，因此默认是禁用的 。</p><h2 id="4-8-Merge-引擎：管理多个MyISAM表构成的表集合"><a href="#4-8-Merge-引擎：管理多个MyISAM表构成的表集合" class="headerlink" title="4.8 Merge 引擎：管理多个MyISAM表构成的表集合"></a>4.8 Merge 引擎：管理多个MyISAM表构成的表集合</h2><h2 id="4-9-NDB引擎：MySQL集群专用存储引擎"><a href="#4-9-NDB引擎：MySQL集群专用存储引擎" class="headerlink" title="4.9 NDB引擎：MySQL集群专用存储引擎"></a>4.9 NDB引擎：MySQL集群专用存储引擎</h2><p>也叫做 NDB Cluster 存储引擎，主要用于 <code>MySQL Cluster 分布式集群</code> 环境。</p><h2 id="4-10-引擎对比"><a href="#4-10-引擎对比" class="headerlink" title="4.10 引擎对比"></a>4.10 引擎对比</h2><p>MySQL中同一个数据库，不同的表可以选择不同的存储引擎。如下表对常用存储引擎做出了对比。</p><table><thead><tr><th align="left">特点</th><th align="left">MyISAM</th><th align="left">InnoDB</th><th align="left">MEMORY</th><th align="left">MERGE</th><th align="left">NDB</th></tr></thead><tbody><tr><td align="left">存储限制</td><td align="left">有</td><td align="left">64TB</td><td align="left">有</td><td align="left">没有</td><td align="left">有</td></tr><tr><td align="left"><code>事务安全性</code></td><td align="left"></td><td align="left">支持</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>锁机制</code></td><td align="left">表锁，即使操作一条 记录也会锁住整个表，不适合高并发的操作</td><td align="left">行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td><td align="left">表锁</td><td align="left">表锁</td><td align="left">行锁</td></tr><tr><td align="left">B树索引</td><td align="left">支持</td><td align="left">支持</td><td align="left">支持</td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left">哈希索引</td><td align="left"></td><td align="left"></td><td align="left">支持</td><td align="left"></td><td align="left">支持</td></tr><tr><td align="left">全文索引</td><td align="left">支持</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">集群索引</td><td align="left"></td><td align="left">支持</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">数据缓存</td><td align="left"></td><td align="left">支持</td><td align="left">支持</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>索引缓存</code></td><td align="left">只缓存索引，不缓存真实数据</td><td align="left">不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td><td align="left">支持</td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left">数据可压缩</td><td align="left">支持</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">空间使用</td><td align="left">低</td><td align="left">高</td><td align="left">N&#x2F;A</td><td align="left">低</td><td align="left">低</td></tr><tr><td align="left">内存使用</td><td align="left">低</td><td align="left">高</td><td align="left">中等</td><td align="left">低</td><td align="left">高</td></tr><tr><td align="left">批量插入的速度</td><td align="left">高</td><td align="left">低</td><td align="left">高</td><td align="left">高</td><td align="left">高</td></tr><tr><td align="left"><code>支持外键</code></td><td align="left"></td><td align="left">支持</td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h1 id="5-MyISAM-和-InnoDB"><a href="#5-MyISAM-和-InnoDB" class="headerlink" title="5. MyISAM 和 InnoDB"></a>5. MyISAM 和 InnoDB</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207132336896.png" alt="image-20220713230507218"></p><table><thead><tr><th align="center">对比项</th><th align="center">MyISAM</th><th align="center">InnoDB</th></tr></thead><tbody><tr><td align="center">外键</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">事务</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">行表锁</td><td align="center">表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td align="center">行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td align="center">缓存</td><td align="center">只缓存索引，不缓存真实数据</td><td align="center">不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td align="center">自带系统表使用</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">关注点</td><td align="center">性能：节省资源、消耗少、简单业务</td><td align="center">事务：并发写、事务、更大资源</td></tr><tr><td align="center">默认安装</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center">默认使用</td><td align="center">N</td><td align="center">Y</td></tr></tbody></table><h1 id="6-阿里巴巴、淘宝用哪个"><a href="#6-阿里巴巴、淘宝用哪个" class="headerlink" title="6. 阿里巴巴、淘宝用哪个"></a>6. 阿里巴巴、淘宝用哪个</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207132336908.png" alt="image-20220713230922017"></p><ul><li><strong>Percona</strong> 为 MySQL 数据库服务器进行了改进，在功能和性能上较 MySQL 有很显著的提升。</li><li>该版本提升了在高负载情况下的 InnoDB 的性能、为 DBA 提供一些非常有用的性能诊断工具；另外有更多的参数和命令来控制服务器行为。</li><li>该公司新建了一款存储引擎叫 <code>Xtradb</code> 完全可以替代<code>Innodb</code> ，并且在性能和并发上做得更好</li><li>阿里巴巴大部分 MySQL 数据库其实使用的 percona 的原型加以修改。</li></ul><h1 id="7-补充"><a href="#7-补充" class="headerlink" title="7. 补充:"></a>7. 补充:</h1><h2 id="7-1-InnoDB-表的优势"><a href="#7-1-InnoDB-表的优势" class="headerlink" title="7.1 InnoDB 表的优势"></a>7.1 InnoDB 表的优势</h2><p>InnoDB 存储引擎在实际应用中拥有诸多优势，比如操作便利、提高了数据库的性能、维护成本低等。如果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。InnoDB 崩溃恢复功能自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。</p><p>InnoDB 存储引擎在主内存中维护缓冲池，高频率使用的数据将在内存中直接被处理。这种缓存方式应用于多种信息，加速了处理进程。</p><p>在专用服务器上，物理内存中高达 80% 的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以设置外键加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或内存中的数据出现崩溃， 在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优化。<code>InnoDB 不支持当前读写，也会缓冲改变的数据到数据流磁盘</code>.</p><p>InnoDB 的性能优势不只存在于长时运行查询的大型表。在同一列多次被查询时，自适应哈希索引会提高查询的速度。使用 InnoDB 可以压缩表和相关的索引，可以 <code>在不影响性能和可用性的情况下创建或删除索引</code>。对于大型文本和 BLOB 数据，使用动态行形式，这种存储布局更高效。通过查询 INFORMATION_SCHEMA 库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB 表可以与其他存储引擎表混用。即使有些操作系统限制文件大小为 2GB，InnoDB 仍然可以处理。<code>当处理大数据量时，InnoDB 兼顾 CPU，以达到最大性能</code></p><h2 id="7-2-InnoDB-和-ACID-模型"><a href="#7-2-InnoDB-和-ACID-模型" class="headerlink" title="7.2 InnoDB 和 ACID 模型"></a>7.2 InnoDB 和 ACID 模型</h2><p>ACID 模型是一系列数据库设计规则，这些规则着重强调可靠性，而可靠性对于商业数据和任务关键型应用非常重要。MySQL 包含类似 InnoDB 存储引擎的组件，与 ACID 模型紧密相连，这样出现意外时，数据不会崩溃，结果不会失真。如果依赖 ACID 模型，可以不使用一致性检查和崩溃恢复机制。如果拥有额外的软件保护，极可靠的硬件或者应用可以容忍一小部分的数据丢失和不一致，可以将 MySQL 设置调整为只依赖部分 ACID 特性，以达到更高的性能。下面讲解 InnoDB 存储引擎与 ACID 模型相同作用的四个方面。</p><ol><li><strong>原子方面</strong> ACID 的原子方面主要涉及 InnoDB 事务，与 MySQL 相关的特性主要包括:<ul><li>自动提交设置。</li><li>COMMIT 语句。</li><li>ROLLBACK 语句。</li><li>操作 INFORMATION_SCHEMA 库中的表数据。</li></ul></li><li><strong>一致性方面</strong> ACID 模型的一致性主要涉及保护数据不崩溃的内部 InnoDB 处理过程，与 MySQL 相关的特性主要包括:<ul><li>InnoDB 双写缓存。</li><li>InnoDB 崩溃恢复。</li></ul></li><li><strong>隔离方面</strong> 隔离是应用于事务的级别，与 MySQL 相关的特性主要包括:<ul><li>自动提交设置。</li><li>SET ISOLATION LEVEL 语句。</li><li>InnoDB 锁的低级别信息。</li></ul></li><li><strong>耐久性方面</strong> ACID 模型的耐久性主要涉及与硬件配置相互影响的 MySQL 软件特性。由于硬件复杂多样化，耐久性方面没有具体的规则可循。与 MySQL 相关的特性有:<ul><li>InnoDB 双写缓存，通过 innodb_doublewrite 配置项配置。</li><li>配置项 innodb_flush_log_at_trx_commit。</li><li>配置项 sync_binlog。</li><li>配置项 innodb_file_per_table。</li><li>存储设备的写入缓存。</li><li>存储设备的备用电池缓存。</li><li>运行 MySQL 的操作系统。</li><li>持续的电力供应。</li><li>备份策略。</li><li>对分布式或托管的应用，最主要的在于硬件设备的地点以及网络情况。</li></ul></li></ol><h2 id="7-3-InnoDB架构"><a href="#7-3-InnoDB架构" class="headerlink" title="7.3 InnoDB架构"></a>7.3 InnoDB架构</h2><ol><li><strong>缓冲池</strong> 缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的数据能够直接在内存中获得，从而提高速度。</li><li><strong>更改缓存</strong> 更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁 盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分 InnoDB 缓冲池。 在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由 innodb_change_buffering 配置项管理。</li><li><strong>自适应哈希索引</strong> 自适应哈希索引将负载和足够的内存结合起来，使得 InnoDB 像内存数据库一样运行， 不需要降低事务上的性能或可靠性。这个特性通过 innodb_adaptive_hash_index 选项配置，或者通过 <code>-- skip-innodb_adaptive_hash_index</code> 命令行在服务启动时关闭。</li><li><strong>重做日志缓存</strong> 重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过 innodb_log_buffer_size 配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存使得大型事务能够正常运行而不需要写入磁盘。</li><li><strong>系统表空间</strong> 系统表空间包括 InnoDB 数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引数据。多表共享，系统表空间被视为共享表空间。</li><li><strong>双写缓存</strong> 双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存后，InnoDB 才会将数据页写入合适的位置。</li><li><strong>撤销日志</strong> 撤销日志是一系列与事务相关的撤销记录的集合，包含如何撤销事务最近的更改。如果其他事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。撤销日志存在于撤销日志片段中，这些片段包含于回滚片段中。</li><li><strong>每个表一个文件的表空间</strong> 每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中， 而不是系统表空间中。这个功能通过 innodb_file_per_table 配置项开启。每个表空间由一个单独的 <code>.ibd</code> 数据文件代表，该文件默认被创建在数据库目录中。</li><li><strong>通用表空间</strong> 使用 CREATE TABLESPACE 语法创建共享的 InnoDB 表空间。通用表空间可以创建在 MySQL 数据目录之外能够管理多个表并支持所有行格式的表。</li><li><strong>撤销表空间</strong> 撤销表空间由一个或多个包含撤销日志的文件组成。撤销表空间的数量由 innodb_undo_tablespaces 配置项配置。</li><li><strong>临时表空间</strong> 用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。 innodb_temp_data_file_path 配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在 innodb_data_home_dir 变量指定的目录下创建一个自动扩展的数据文件。</li><li><strong>重做日志</strong> 重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间， 重做日志会将请求数据进行编码，这些请求会改变 InnoDB 表数据。遇到意外崩溃后，未完成的更改会自动在初始化期间重新进行。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、逻辑架构剖析</title>
      <link href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC02%E7%AB%A0_%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90/"/>
      <url>/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC02%E7%AB%A0_%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="1-逻辑架构剖析"><a href="#1-逻辑架构剖析" class="headerlink" title="1. &#x3D;&#x3D;逻辑架构剖析&#x3D;&#x3D;"></a>1. &#x3D;&#x3D;逻辑架构剖析&#x3D;&#x3D;</h1><h2 id="1-1-服务器处理客户端请求"><a href="#1-1-服务器处理客户端请求" class="headerlink" title="1.1 服务器处理客户端请求"></a>1.1 服务器处理客户端请求</h2><p>首先MySQL是典型的C&#x2F;S架构，即<code>Client/Server</code> 架构‘ ， 服务器端程序使用的mysqld。</p><p>不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是:<strong>客户端进程向服务器进程发送一段文本(SQL语句) ,服务器进程处理后再向客户端进程发送一段文本(处理结果)</strong></p><p>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢?这里以查询请求为例展示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130116081.png" alt="image-20220709175522383"></p><p>下面具体展开看一下:(针对MySQL5.7)</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130116304.png" alt="image-20220115171412362"></p><p><strong>分析</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130116078.png"></p><h2 id="1-2-Connectors"><a href="#1-2-Connectors" class="headerlink" title="1.2 Connectors"></a>1.2 Connectors</h2><p>Connectors指的是不同语言中与SQL的交互。MySQL首先是一 个网络程序，在TCP之上定义了自己的应用层协议。所以要使用MySQL,我们可以编写代码，跟MySQL Server<code>建立TCP连接</code>，之后按照其定义好的协议进行交互。或者比较方便的办法是调用SDK，比如Native C API、JDBC、 PHP等各语 言MySQL Connector,或者通过ODBC。 但&#x3D;&#x3D;通过SDK来访问MySQL，本质上还是在TCP连接上通过MySQL协议跟MySQL进行交互&#x3D;&#x3D;。</p><p>接下来的MySQL Server结构可以分为如下的三层：</p><h2 id="1-3-第-1-层：连接层"><a href="#1-3-第-1-层：连接层" class="headerlink" title="1.3 第 1 层：连接层"></a>1.3 第 1 层：连接层</h2><p>系统(客户端)访问 MySQL 服务器前，做的第一件事就是建立 <code>TCP</code> 连接。 经过三次握手建立连接成功后，MySQL 服务器对 <code>TCP</code> 传输过来的账号密码做身份认证、权限获取。</p><ul><li>用户名或密码不对，会收到一个 Access denied for user 错误，客户端程序结束执行</li><li>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</li></ul><p><code>TCP</code> 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><p><strong>接着我们来思考一个问题</strong></p><p>&#x3D;&#x3D;一个系统只会和MySQL服务器建立一个连接吗？只能有一个系统和MySQL服务 器建立连接吗？&#x3D;&#x3D;<br>当然不是，多个系统都可以和MySQL服务器建立连接，每个系统建立的连接肯定不止一个。所以，为了解决TCP无限创建与TCP频繁创建销毁带来的资源耗尽、性能下降问题。MySQL服务器里有专门的<code>TCP连接池</code>限制连接数，采用<code>长连接模式</code>复用TCP连接,来解决上述问题。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130116686.png" alt="image-20220709192708094"></p><p><code>TCP</code>连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><p>这些内容我们都归纳到<code>MySQL</code>的连接管理组件中。</p><p>所以&#x3D;&#x3D;连接管理的职责是负责认证、管理连接、获取权限信息&#x3D;&#x3D;。</p><h2 id="1-4-第-2-层：服务层"><a href="#1-4-第-2-层：服务层" class="headerlink" title="1.4 第 2 层：服务层"></a>1.4 第 2 层：服务层</h2><p>第二层架构主要完成大多数的核心服务功能，如SQL接口， 并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p><p>在该层，服务器会<strong>解析查询</strong>并创建相应的内部<strong>解析树</strong>，并对其完成相应的<strong>优化</strong>：如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。</p><p>&#x3D;&#x3D;如果是SELECT语句，服务器还会查询内部的缓存&#x3D;&#x3D;。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><ul><li><p><strong>SQL Interface：SQL接口</strong></p><ul><li>接收用户的 SQL 命令，并且返回用户需要查询的结果。比如 <code>SELECT ... FROM</code> 就是调用 SQL Interface</li><li>MySQL 支持 DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种 SQL 语言接口</li></ul></li><li><p><strong>Parser：解析器</strong></p><ul><li>在解析器中对 SQL 语句进行语法分析、语义分析。将 SQL 语句分解成数据结构，并将这个结构传递到后续步骤，以后 SQL 语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个 SQL 语句是不合理的。</li><li>在 SQL 命令传递到解析器的时候会被解析器验证和解析，并为其创建 <code>语法树</code>，并根据数据字典丰富查询语法树，会 <code>验证该客户端是否具有执行该查询的权限</code> 。创建好语法树后，MySQL 还会对 SQL 查询进行语法上的优化，进行查询重写。</li></ul></li><li><p><strong>Optimizer：查询优化器</strong></p><ul><li><p>SQL 语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个 <code>执行计划</code> 。</p></li><li><p>这个执行计划表明应该 <code>使用哪些索引</code> 进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p></li><li><p>它使用“ <code>选取-投影-连接</code> ”策略进行查询。例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这个 SELECT 查询先根据 WHERE 语句进行选取 ，而不是将表全部查询出来以后再进行 gender 过滤。 这个 SELECT 查询先根据 id 和 name 进行属性投影 ，而不是将属性全部取出以后再进行过滤，将这两个查询条件 连接起来生成最终查询结果。</p></li></ul></li><li><p><strong>Caches &amp; Buffers: 查询缓存组件</strong></p><ul><li>MySQL内部维持着一些 Cache 和 Buffer，比如 Query Cache 用来缓存一条 SELECT 语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li><li>这个查询缓存可以在 <code>不同客户端之间共享</code> 。</li><li>从 MySQL 5.7.20 开始，不推荐使用查询缓存，并在 <code>MySQL 8.0中删除</code> 。</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小故事：</span><br><span class="line">如果我问你9+8×16-3×2×17的值是多少，你可能会用计算器去算一下，最终结果35。如果再问你一遍9+8×16-</span><br><span class="line">3×2×17的值是多少，你还用再傻呵呵的再算一遍吗？我们刚刚已经算过了，直接说答案就好了。</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-5-第-3-层：引擎层"><a href="#1-5-第-3-层：引擎层" class="headerlink" title="1.5 第 3 层：引擎层"></a>1.5 第 3 层：引擎层</h2><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用，主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。同时开源的 MySQL还<strong>允许开发人员设置自己的存储引擎</strong>。</p><p>这种高效的模块化架构为那些希望专门针对特定应用程序需求(例如数据仓库、事务处理或高可用性情况)的人提供了巨大的好处，同时享受使用一组独立于任何接口和服务的优势存储引擎。</p><p>插件式存储引擎层（Storage Engines），&#x3D;&#x3D;真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作&#x3D;&#x3D; ，服务器通过 API 与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p><p>MySQL 8.0.25 默认支持的存储引擎如下:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130116558.png" alt="image-20220115171937681"></p><h2 id="1-6-存储层"><a href="#1-6-存储层" class="headerlink" title="1.6 存储层"></a>1.6 存储层</h2><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 <code>文件系统</code> 上，以 <code>文件</code> 的方式存 在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用 DAS、NAS、SAN等各种存储系统。</p><h2 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a>1.7 小结</h2><p>MySQL 架构图本节开篇所示。下面为了熟悉 SQL 执行流程方便，我们可以简化如下:</p><p><img src="https://blog-images-1309598269.cos.ap-beijing.myqcloud.com/blogImgs/202206300055402.png" alt="image-20220115172118991"></p><p>简化为三层结构：</p><ol><li>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端;</li><li>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关;</li><li>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</li></ol><h1 id="2-SQL-执行流程"><a href="#2-SQL-执行流程" class="headerlink" title="2. SQL 执行流程"></a>2. SQL 执行流程</h1><h2 id="2-1-MySQL-中的-SQL执行流程"><a href="#2-1-MySQL-中的-SQL执行流程" class="headerlink" title="2.1 MySQL 中的 SQL执行流程"></a>2.1 MySQL 中的 SQL执行流程</h2><p>&#x3D;&#x3D;MySQL的查询流程:&#x3D;&#x3D;</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130116406.png" alt="image-20220115172223043"></p><h3 id="2-1-1-查询缓存"><a href="#2-1-1-查询缓存" class="headerlink" title="2.1.1 查询缓存"></a>2.1.1 <strong>查询缓存</strong></h3><p>Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端;如果没 有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL 8.0 之后就抛弃 了这个功能。</p><p><strong>大多数情况查询缓存就是个鸡肋，为什么呢?</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">101</span>;</span><br></pre></td></tr></table></figure><p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的 <code>鲁棒性大大降低</code>，只有 <code>相同的查询操作才会命中查询缓存</code>。两个查询请求在任何字符上的不同（例如：空格、注释、 大小写），都会导致缓存不会命中。因此 MySQL 的 <code>查询缓存命中率不高</code> 。</p><p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数 <code>NOW</code> ，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的!</p><p>此外，既然是缓存，那就有它 <code>缓存失效的时候</code>。MySQL 的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或 <code>DROP DATABASE</code> 语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于 <code>更新压力大的数据库</code>来说，查询缓存的命中率会非常低。</p><p><strong><font color=red>总之，因为查询缓存往往弊大于利，查询缓存的失效非常频繁。</font></strong></p><p>一般建议大家在静态表里使用查询缓存，什么叫<code>静态表</code>呢?就是一般我们极少更新的表。比如，一个系统配置表、字典表，这张表上的查询才适合使用查询缓存。好在MySQL也提供了这种“<code>按需使用</code>”的方式。你可以将my.cnf参数 query_ <em>cache</em> type  设置成DEMAND，代表当sql语句中有SQL_ CACHE关键词时才缓存。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">query_ cache_ <span class="built_in">type</span>有3个值0代表关闭查询缓存0FF，1代表开启ON，2 (DEMAND)</span></span><br><span class="line">query_cache_ type=2</span><br></pre></td></tr></table></figure><p>这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL. CACHE <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">5</span> ;<span class="operator">|</span></span><br></pre></td></tr></table></figure><p>查看当前mysq|实例是否开启缓存机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># MySQL5.7 中：</span><br><span class="line">mysql&gt; show global variables like &quot;%query_cache_type%&quot;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| query_cache_type | OFF   |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># MySQL8.0 中：</span><br><span class="line">mysql&gt; show global variables like &quot;%query_cache_type%&quot;;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p>监控查询缓存的命中率</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;%Qcache%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130116898.png" alt="image-20220712222507959"></p><ul><li><code>Qcache_free_blocks</code> ：表示查询缓存中还有多少剩余的blocks,如果该值显示较大,则说明查询缓存中的<code>内存碎片</code>过多了，可能在一定的时间进行整理。</li><li><code>Qcache_free_memory</code> ：查询缓存的内存大小，通过这个参数可以很清晰的知道当前系统的查询内存是否够用，是多了，还是不够用，DBA可以根据实际情况做出调整。</li><li><code>Qcache_hits</code> ：表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越理想。</li><li><code>Qcache_inserts</code> ：表示多少次未命中然后插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理,执行查询处理后把结果insert到查询缓存中。这样的情况的次数越多，表示查询缓存应用到的比较少，效果也就不理想。当然系统刚启动后，查询缓存是空的，这很正常。</li><li><code>Qcache_lowmem_prunes</code> ：该参数记录有多少条查询因为内存不足而被移除出查询缓存。通过这个值，用户可以适当的调整缓存大小。</li><li><code>Qcache_not_cached</code> ：表示因为query_cache_type的设置而没有被缓存的查询数量。</li><li><code>Qcache_queries_in_cache</code>：当前缓存中<code>缓存的查询数量</code>。</li><li><code>Qcache_total_blocks</code> ：当前缓存的block数量。</li></ul><h3 id="2-1-2-解析器"><a href="#2-1-2-解析器" class="headerlink" title="2.1.2 解析器"></a>2.1.2 <strong>解析器</strong></h3><p>在解析器中对 SQL 语句进行语法分析、语义分析。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130116982.png" alt="image-20220115172951498"></p><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对SQL语句做解析。SQL语句的分析分为词法分析与语法分析。</p><p>分析器先做“<code>词法分析</code> ”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面 的字符串分别是什么，代表什么。</p><p> MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>接着，要做“<code>词法分析</code> ”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输 入的这个 SQL 语句是否 <code>满足 MySQL 语法</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> department_id,job_id,<span class="built_in">avg</span>(salary) <span class="keyword">from</span> employees <span class="keyword">group</span> <span class="keyword">by</span> department_id; </span><br></pre></td></tr></table></figure><p>如果你的语句不对，就会收到“”的错误提醒，比如这个语句from写成了rom。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * fro user;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;fro user&#x27; at line 1</span><br></pre></td></tr></table></figure><p>如果SQL语句正确，则会生成一个这样的语法树:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130117140.png" alt="image-20220115173057415"></p><p>下图是SQL词法分析的过程步骤：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130117605.png" alt="image-20220712223741324"></p><p>至此我们解析器的工作任务也基本圆满了。接下来进入到优化器。</p><h3 id="2-1-3-优化器"><a href="#2-1-3-优化器" class="headerlink" title="2.1.3 优化器"></a>2.1.3 优化器</h3><p>在优化器中会确定 SQL 语句的执行路径，比如是根据 <code>全表检索</code> ，还是根据 <code>索引检索</code> 等。</p><p>经过了解析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。<strong>一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划</strong>。</p><p>举例：如下语句是执行两个表的 join:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test1 <span class="keyword">join</span> test2 <span class="keyword">using</span>(ID)</span><br><span class="line"><span class="keyword">where</span> test1.name<span class="operator">=</span><span class="string">&#x27;zhangwei&#x27;</span> <span class="keyword">and</span> test2.name<span class="operator">=</span><span class="string">&#x27;mysql高级课程&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方案1:可以先从表 test1 里面取出 name=&#x27;zhangwei&#x27;的记录的 ID 值，再根据 ID 值关联到表 test2，再判断 test2 里面 name 的值是否等于 &#x27;mysql高级课程&#x27;。</span><br><span class="line"></span><br><span class="line">方案2:可以先从表 test2 里面取出 name=&#x27;mysql高级课程&#x27; 的记录的 ID 值，再根据 ID 值关联到 test1， 再判断 test1 里面 name的值是否等于 zhangwei。</span><br><span class="line"></span><br><span class="line">这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化</span><br><span class="line">器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</span><br><span class="line"></span><br><span class="line">如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。</span><br></pre></td></tr></table></figure><p>在查询优化器中，可以分为 <code>逻辑查询</code> 优化阶段和 <code>物理查询</code> 优化阶段。</p><p>逻辑查询优化就是通过改变SQL语句的内容来使得SQL查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对SQL语句进行<code>等价变换</code>，对查询进行重写，而查询重写的数学基础就是关系代数。对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等。</p><p>物理查询优化是基于关系代数进行的查询重写,而关系代数的每一步都对应着物理计算, 这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地<code>使用索引</code>，提升查询效率。</p><h3 id="2-1-4-执行器"><a href="#2-1-4-执行器" class="headerlink" title="2.1.4 执行器"></a>2.1.4 执行器</h3><p>截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了 <code>执行器阶段</code> 。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130117552.png" alt="image-20220115173252824"></p><p>在执行之前需要判断该用户是否具备权限 。如果没有，就会返回权限错误。如果具备权限，就执行 SQL 查询并返回结果。在 MySQL 8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，调用存储引擎API对表进行的读写。存储引擎API只是抽象接口，下面还有个<strong>存储引擎层</strong>，具体实现还是要看表选择的存储引擎。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130117221.png"></p><p>比如：表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p><ul><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中; 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ul><p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。</p><p>&#x3D;&#x3D;SQL 语句在 MySQL 中的流程是&#x3D;&#x3D;：<code>SQL 语句 → 查询缓存 → 解析器 → 优化器 → 执行器</code>。</p><p><img src="https://blog-images-1309598269.cos.ap-beijing.myqcloud.com/blogImgs/202206231430741.png" alt="image-20220115173423050"></p><h2 id="2-2-MySQL8中SQL执行原理"><a href="#2-2-MySQL8中SQL执行原理" class="headerlink" title="2.2 MySQL8中SQL执行原理"></a>2.2 MySQL8中SQL执行原理</h2><p>前面的结构图很复杂，我们需要抓取最核心的部分: SQL的执行原理。不同的DBMS的SQL的执行原理是相通的，只是在不同的软件中，各有各的实现路径。</p><p>既然一条SQL语句会经历不同的模块,那我们就来看下，在不同的模块中，SQL 执行所使用的资源(时间)是怎样的。如何在MySQL中对一条SQL语句的执行时间进行分析。</p><h3 id="2-2-1-确认profiling是否开启"><a href="#2-2-1-确认profiling是否开启" class="headerlink" title="2.2.1. 确认profiling是否开启"></a>2.2.1. 确认profiling是否开启</h3><p>了解查询语句底层执行的过程：<code>select @@profiling;</code> 或者<code>show variables like &#39;%profiling%&#39; </code>查看是否开启计划。开启它可以让MySQL收集在SQL执行时所使用的资源情况，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@profiling;</span><br><span class="line">mysq1&gt; show variables like &#x27;profiling&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130117783.png" alt="image-20220712230716818"></p><p>profiling &#x3D; 0代表关闭，我们需要把profiling打开，即设置为1；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling = 1;</span><br></pre></td></tr></table></figure><p>Profiling功能由MySQL会话变量：profiling控制。默认是OFF（关闭状态）。</p><h3 id="2-2-2-多次执行相同SQL查询"><a href="#2-2-2-多次执行相同SQL查询" class="headerlink" title="2.2.2.多次执行相同SQL查询"></a>2.2.2.多次执行相同SQL查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-查看profiles"><a href="#2-2-3-查看profiles" class="headerlink" title="2.2.3.查看profiles"></a>2.2.3.查看profiles</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profiles #查询所有sql语句的分析概览</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130117582.png" alt="image-20220713001646187"></p><h3 id="2-2-4-查看profile"><a href="#2-2-4-查看profile" class="headerlink" title="2.2.4.查看profile"></a>2.2.4.查看profile</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profie;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130117949.png" alt="image-20220713001733244"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profie for query Query_ID;# 查看某一次sql执行的分析过程</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130117654.png" alt="image-20220713001825251"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130117926.png" alt="image-20220713001556760"></p><h2 id="2-3-MySQL5-7中SQL执行原理"><a href="#2-3-MySQL5-7中SQL执行原理" class="headerlink" title="2.3 MySQL5.7中SQL执行原理"></a>2.3 MySQL5.7中SQL执行原理</h2><p>这里我们需要<code>显示开启查询缓存模式</code>。在MySQL5.7中如下设置：</p><h3 id="2-3-1-配置文件中开启查询缓存"><a href="#2-3-1-配置文件中开启查询缓存" class="headerlink" title="2.3.1.配置文件中开启查询缓存"></a>2.3.1.配置文件中开启查询缓存</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type=1</span><br></pre></td></tr></table></figure><h3 id="2-3-2-重启Mysql服务"><a href="#2-3-2-重启Mysql服务" class="headerlink" title="2.3.2.重启Mysql服务"></a>2.3.2.重启Mysql服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><h3 id="2-3-3-开启查询计划"><a href="#2-3-3-开启查询计划" class="headerlink" title="2.3.3.开启查询计划"></a>2.3.3.开启查询计划</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling = 1;</span><br></pre></td></tr></table></figure><h3 id="2-3-4-执行语句两次"><a href="#2-3-4-执行语句两次" class="headerlink" title="2.3.4.执行语句两次"></a>2.3.4.执行语句两次</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from departments;</span><br><span class="line"></span><br><span class="line">select * from departments;</span><br></pre></td></tr></table></figure><h3 id="2-3-5-查看profiles"><a href="#2-3-5-查看profiles" class="headerlink" title="2.3.5.查看profiles"></a>2.3.5.查看profiles</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130117455.png" alt="image-20220713000901627"></p><h3 id="2-3-6-查看profile"><a href="#2-3-6-查看profile" class="headerlink" title="2.3.6.查看profile"></a>2.3.6.查看profile</h3><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130117965.png" alt="image-20220713000946556"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130117166.png" alt="image-20220713001014156"></p><p>结论不言而喻.执行编号10时,比执行编号9时少了很多信息,从截图中可以看出查询语句直接从缓存中获取数据 .</p><ul><li><strong>注意1：</strong>&#x3D;&#x3D;SQL必须时一致的,否则,不能命中缓存.&#x3D;&#x3D;</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#虽然查询结果一致， 但并没有命中缓存。</span><br><span class="line">select * from mydb . mytbl where id=2</span><br><span class="line">select * from mydb . mytbl where id&gt;1 and id&lt;3</span><br></pre></td></tr></table></figure><ul><li><strong>注意2：</strong>同样的开启缓存的配置信息如果在MySQL8中添加。重启服务时会报错:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ root@atguigu01 ~]# vim /etc/my.cnf</span><br><span class="line">[root@atguigu01 ~]# systemctl restart mysqld;</span><br><span class="line">Job for mysqld.service failed because the control process exited with error code. See</span><br><span class="line">&quot;systemctl status mysqld. service&quot; and &quot;journalctl -xe&quot; for details.</span><br></pre></td></tr></table></figure><p>分别在MySQL5.7和MySQL8中执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%query_ cache%&#x27;;</span><br></pre></td></tr></table></figure><p>MySQL5.7中显示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130117439.png" alt="image-20220713002324616"></p><p>MySQL8.0中显示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130117438.png" alt="image-20220713002427047"></p><h2 id="2-4-SQL语法顺序"><a href="#2-4-SQL语法顺序" class="headerlink" title="2.4 SQL语法顺序"></a>2.4 SQL语法顺序</h2><p>随着 MySQL 版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而动态调整执行顺序。</p><p>需求：查询每个部门年龄高于 20 岁的人数且高于 20 岁人数不能少于 2 人，显示人数最多的第一名部门信息。</p><p>下面是经常出现的查询顺序:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130118286.png" alt="image-20220115174625139">]</p><h2 id="2-5-Oracle中的SQL执行流程-了解"><a href="#2-5-Oracle中的SQL执行流程-了解" class="headerlink" title="2.5 Oracle中的SQL执行流程(了解)"></a>2.5 Oracle中的SQL执行流程(了解)</h2><p>Oracle中采用了&#x3D;&#x3D;共享池&#x3D;&#x3D;来判断SQL语句是否存在缓存和执行计划，通过这一步骤我们可以知道应该采用硬解析还是软解析。</p><p>我们先来看下SQL在Oracle中的执行过程:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130118798.png" alt="image-20220713003902294">从上面这张图中可以看出, SQL语句在Oracle中经历了以下的几个步骤。</p><ol><li><strong>语法检查</strong>：检查SQL拼写是否正确，如果不正确，Oracle 会报语法错误。</li><li><strong>语义检查</strong>：检查SQL中的访问对象是否存在。比如我们在写SELECT语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证SQL语句没有错误。</li><li><strong>权限检查</strong>：看用户是否具备访问该数据的权限。</li></ol><p>Oracle通过检查共享池是否存在SQL语句的执行计划，来判断进行软解析,还是硬解析。那软解析和硬解析又该怎么理解呢?</p><p>在共享池中，Oracle 首先对SQL语句进行<code>Hash运算</code>，然后根据Hash值在库缓存(Library Cache)中查找，如果<code>存在SQL语句的执行计划</code>，就直接拿来执行，直接进入“执行器”的环节,这就是<code>软解析</code>。</p><p>如果没有找到SQL语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤,这就是<code>硬解析</code>。</p><ol start="5"><li><strong>优化器</strong>:优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。</li><li><strong>执行器</strong>:当有了解析树和执行计划之后,就知道了SQL该怎么被执行，这样就可以在执行器中执行语句了。</li></ol><p>共享池是Oracle中的术语，包括了库缓存,数据字典缓冲区等。我们_上面已经讲到了库缓存区，它主要缓存SQL语句和执行计划。而<code>数据字典缓冲区</code>存储的是Oracle中的对象定义,比如表、视图、索引等对象。当对SQL语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。</p><p><code>库缓存</code>这一个步骤，决定了SQL语句是否需要进行硬解析。为了提升SQL的执行效率,我们应该尽量避免硬解析，因为在SQL的执行过程中，创建解析树，生成执行计划是很消耗资源的。</p><p>你可能会问，如何避免硬解析，尽量使用软解析呢?在Oracle中，<code>绑定变量</code>是它的一大特色。绑定变量就是在SQL语句中使用变量，通过不同的变量取值来改变SQL的执行结果。这样做的好处是能<code>提升软解析的可能性</code>，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量还需要视情况而定。</p><p>举个例子，我们可以使用下面的查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from player where player_id = 10001;</span><br></pre></td></tr></table></figure><p>你也可以使用绑定变量，如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOL&gt; select * from plaver where plaver id = :plaver_id:</span><br></pre></td></tr></table></figure><p>这两个查询语句的效率在Oracle中是完全不同的。如果你在查询player. _id&#x3D; 10001之后,还会查询10002、10003之类的数据,那么每- -次查询都会创建一 个新的查询解析。 而第二种方式使用了绑定变量，那么在第一-次查询之后，在共享池中就会存在这类查询的执行计划，也就是软解析。</p><p>因此，我<strong>们可以通过使用绑定变量来减少硬解析，减少Oracle的解析工作量</strong>。但是这种方式也有缺点，使用动态SQL的方式，因为参数不同，会导致SQL的执行效率不同，同时SQL优化也会比较困难。</p><p>&#x3D;&#x3D;Oracle的架构图：&#x3D;&#x3D;</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130118351.png" alt="image-20220713004228345"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130118783.png"></p><h1 id="3-数据库缓冲池（buffer-pool）"><a href="#3-数据库缓冲池（buffer-pool）" class="headerlink" title="3. 数据库缓冲池（buffer pool）"></a>3. 数据库缓冲池（buffer pool）</h1><p><code>InnoDB</code>存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页 面(包括读页面、写页面、创建新页面等操作)。而磁盘 I&#x2F;O 需要消耗的时间很多，而在内存中进行操 作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请<code>占用内存来作为数据缓冲池</code>，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<code>Buffer Pool</code>之后才可以访 问。</p><p>这样做的好处是可以让磁盘活动最小化，从而<code>减少与磁盘直接进行 I/O 的时间</code> 。要知道，这种策略对提 升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p><h2 id="3-1-缓冲池-vs-查询缓存"><a href="#3-1-缓冲池-vs-查询缓存" class="headerlink" title="3.1 缓冲池 vs 查询缓存"></a>3.1 缓冲池 vs 查询缓存</h2><p><strong>缓冲池和查询缓存是一个东西吗？不是。</strong></p><h3 id="3-1-1-缓冲池（Buffer-Pool）"><a href="#3-1-1-缓冲池（Buffer-Pool）" class="headerlink" title="3.1.1 缓冲池（Buffer Pool）"></a>3.1.1 缓冲池（Buffer Pool）</h3><p>首先我们需要了解在 InnoDB 存储引擎中，缓冲池都包括了哪些。</p><p>在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，如下图所示:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130118698.png" alt="image-20220115175644920"></p><p>从图中，你能看到InnoDB缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应Hash和数据字典信息等。</p><p><strong>缓存池的重要性:</strong></p><p>对于使用<code>InnoDB</code>作为存储引擎的表来说,不管是用于存储用户数据的索引(包括聚簇索引和二级索引)，还是各种系统数据，都是以<code>页</code>的形式存放在<code>表空间</code>中的,而所谓的表空间只不过是InnoDB对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是各位也都知道，磁盘的速度慢的跟乌龟一样,怎么能配得上“<code>快如风，疾如电”的CPU</code>呢?这里，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟。所以InnoDB存储弓|擎在处理客户端的请求时，当需要访问某个页的数据时，就会把<code>完整的页的数据全部加载到内存</code>中，也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉,而是将其<code>缓存</code>起来,这样将来有请求再次访问该页面时，就可以<code>省去磁盘I0</code>的开销了。</p><p><strong>缓存原则：</strong></p><p>“<code>位置 * 频次</code> ”这个原则，可以帮我们对 I&#x2F;O 访问效率进行优化。 首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。</p><p>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会 <code>优先对使用频次高的热数据进行加载</code>。</p><p><strong>缓冲池的预读特性:</strong></p><p>一个缓存了解了缓冲池的作用之后，我们还需要了解缓冲池的另一个特性: <code>预读</code>。</p><p>缓冲池的作用就是提升I&#x2F;0效率，而我们进行读取数据的时候存在一个“局部性原理”， 也就是说我使用了一些数据，<code>大概率还会使用它周围的一些数据</code>，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘1&#x2F;O操作。</p><h3 id="3-1-2-查询缓存"><a href="#3-1-2-查询缓存" class="headerlink" title="3.1.2 查询缓存"></a>3.1.2 查询缓存</h3><p>那么什么是查询缓存呢?</p><p>查询缓存是提前把 <code>查询结果缓存</code> 起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p><h2 id="3-2-缓冲池如何读取数据"><a href="#3-2-缓冲池如何读取数据" class="headerlink" title="3.2 缓冲池如何读取数据"></a>3.2 缓冲池如何读取数据</h2><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。<br>缓存在数据库中的结构和作用如下图所示：</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130118451.png" alt="image-20220115175859026"></p><p><strong>&#x3D;&#x3D;如果我们执行SQL语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗?&#x3D;&#x3D;</strong> </p><p>实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息,然后数据库会<code>以一定的频率刷新</code>到磁盘上。注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做<code>checkpoint的机制</code>将数据回写到磁盘上,这样做的好处就是提升了数据库的整体性能。</p><p>比如，当<code>缓冲池不够用</code>时，需要释放掉一些不常用的页，此时就可以强行采用checkpoint的方式，将不常用的脏页回写到磁盘上,然后再从缓冲池中将这些页释放掉。这里脏页(dirty page)指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</p><h2 id="3-3-查看-设置缓冲池的大小"><a href="#3-3-查看-设置缓冲池的大小" class="headerlink" title="3.3 查看&#x2F;设置缓冲池的大小"></a>3.3 查看&#x2F;设置缓冲池的大小</h2><p>如果你使用的是MySQL MyISAM存储引擎,它只缓存索引， 不缓存数据，对应的键缓存参数<br><code>key_buffer_size</code>，你可以用它进行查看。</p><p>如果你使用的是InnoDB存储引擎，可以通过查看 <code>innodb_buffer_pool_size</code> 变量来查看缓冲池的大 小。命令如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_size&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130118317.png" alt="image-20220115175953098"></p><p>你能看到此时 InnoDB 的缓冲池大小只有 134217728&#x2F;1024&#x2F;1024&#x3D;128MB。我们可以修改缓冲池大小，比如 改为256MB，方法如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_buffer_pool_size <span class="operator">=</span> <span class="number">268435456</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130118511.png" alt="image-20220115180020887"></p><p>或者:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size <span class="operator">=</span> <span class="number">268435456</span></span><br></pre></td></tr></table></figure><p>然后再来看下修改后的缓冲池大小，此时已成功修改成了 256 MB:</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130118502.png" alt="image-20220115180055102"></p><h2 id="3-4-多个Buffer-Pool实例"><a href="#3-4-多个Buffer-Pool实例" class="headerlink" title="3.4 多个Buffer Pool实例"></a>3.4 多个Buffer Pool实例</h2><p>Buffer Pool本质是InnoDB向操作系统申请的一块<code>连续的内存空间</code>，在多线程环境下，访问Buffer Pool中的数据都需要<code>加锁</code>处理。在Buffer Pool特别大而且多线程并发访问特别高的情况下，单一的Buffer Pool可能会影响请求的处理速度。所以在Buffer Pool特别大的时候，我们可以把它们<code>拆分成若干个小的Buffer Pool</code> ，每个Buffer Pool都称为一个<code>实例</code>，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。</p><p>我们可以在服务器启动的时候通过设置<code>innodb_buffer_pool_instances</code> 的值来修改Buffer Pool实例的个数,</p><p>比方说这样:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这样就表明我们要创建2个 <code>Buffer Pool</code> 实例。</p><p>我们看下如何查看缓冲池的个数，使用命令:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_instances&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130118918.png" alt="image-20220115180223458"></p><p>那每个 <code>Buffer Pool</code> 实例实际占多少内存空间呢?其实使用这个公式算出来的：<code>innodb_buffer_pool_size/innodb_buffer_pool_instances</code></p><p>也就是总共的大小除以实例的个数，结果就是每个<code>Buffer Pool</code> 实例占用的大小。</p><p>不过也不是说Buffer Pool实例创建的越多越好，分别<code>管理各个Buffer Pool也是需要性能开销</code>的，InnoDB规定:当innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的，InnoDB会默认把innodb_ buffe _pool_instances 的值修改为1。而我们鼓励在Buffer Ppol大于或等于1G的时候设置多个Buffer Pool实例。</p><h2 id="3-5-引申问题"><a href="#3-5-引申问题" class="headerlink" title="3.5 引申问题"></a>3.5 引申问题</h2><p>Buffer Pool 是 MySQL 内存结构中十分核心的一个组成，你可以先把它想象成一个黑盒子。</p><p><strong>黑盒下的更新数据流程</strong></p><p>当我们查询数据的时候，会先去Buffer Pool中查询。如果Buffer Pool中不存在,存储弓|擎会先将数据从磁盘加载到Buffer Pool中，然后将数据返回给客户端;同理，当我们更新某个数据的时候，如果这个数据不存在于Buffer Pool,同样会先数据加载进来，然后修改修改内存的数据。被修改过的数据会在之后统一刷入磁盘。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207130118256.png" alt="image-20220115180314323"></p><p>这个过程看似没啥问题，实则是有问题的。假设我们修改Buffer Pool中的数据成功，但是还没来得及将数据刷入磁盘MySQL就挂了怎么办?按照上图的逻辑，此时更新之后的数据只存在于Buffer Pool中,如果此时MySQL宕机了，这部分数据将会永久地丢失;</p><p>我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复?</p><p>答案：<strong>Redo Log &amp; Undo Log</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、MySQL的数据目录</title>
      <link href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC01%E7%AB%A0_MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/"/>
      <url>/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC01%E7%AB%A0_MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-MySQL8的主要目录结构"><a href="#1-MySQL8的主要目录结构" class="headerlink" title="1. MySQL8的主要目录结构"></a>1. MySQL8的主要目录结构</h2><p>以 Linux 系统为例进行讲解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xue ~]# find / -name mysql</span><br></pre></td></tr></table></figure><p>安装好MySQL 8之后，我们查看如下的目录结构:</p><h3 id="1-1-数据库文件的存放路径"><a href="#1-1-数据库文件的存放路径" class="headerlink" title="1.1 数据库文件的存放路径"></a>1.1 数据库文件的存放路径</h3><p>&#x3D;&#x3D;MySQL数据库文件的存放路径：&#x3D;&#x3D;<code>/var/lib/mysql/</code></p><p>MySQL服务器程序在启动时会到文件系统的某个目录下加载一些文件，之后在运行过程中产生的数据也都会存储到这个目录下的某些文件中，这个目录就称为 <code>数据目录</code>。</p><p>MySQL把数据都存到哪个路径下呢？其实 <code>数据目录</code> 对应这一个系统变量 <code>datadir</code>，我们在使用客户端与服务器建立连接之后查看这个系统变量的值就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;datadir&#x27;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | /var/lib/mysql/ |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.04 sec)</span><br></pre></td></tr></table></figure><p>从结果中可以看出，在我的计算机上MySQL的数据目录就是 <code>/var/lib/mysql</code>&#x2F; 。</p><h3 id="1-2-相关命令目录"><a href="#1-2-相关命令目录" class="headerlink" title="1.2 相关命令目录"></a>1.2 相关命令目录</h3><p>&#x3D;&#x3D;相关命令目录：&#x2F;usr&#x2F;bin（mysqladmin、mysqlbinlog、mysqldump等命令）和&#x2F;usr&#x2F;sbin&#x3D;&#x3D;。</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207091733159.png" alt="image-20220709112725420"></p><h3 id="1-3-配置文件目录"><a href="#1-3-配置文件目录" class="headerlink" title="1.3 配置文件目录"></a>1.3 <strong>配置文件目录</strong></h3><p>&#x3D;&#x3D;配置文件目录：&#x2F;usr&#x2F;share&#x2F;mysql-8.0（命令及配置文件），&#x2F;etc&#x2F;mysql（如 my.cnf）&#x3D;&#x3D;</p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207091733524.png" alt="image-20220709112825432"></p><h2 id="2-数据库和文件系统的关系"><a href="#2-数据库和文件系统的关系" class="headerlink" title="2. 数据库和文件系统的关系"></a>2. 数据库和文件系统的关系</h2><p>像<code>InnoDB</code>、<code>MyISAM </code>这样的存储引擎都是把表存储在磁盘上的，操作系统用来管理磁盘的结构被称为&#x3D;&#x3D;文件系统&#x3D;&#x3D;，所以用专业一点的话来表述就是:像<strong>InnoDB、MyISAM</strong> 这样的存储引擎都是把&#x3D;&#x3D;表存储在文件系统上&#x3D;&#x3D;的。当我们想读取数据的时候，这些存储引擎会从文件系统中把数据读出来返回给我们，当我们想写入数据的时候,这些存储弓擎会把这些数据又写回文件系统。本章学习一下<code>InnoDB</code>和<code>MyISAM</code>这两个存储弓|擎的数据如何在文件系统中存储。</p><h3 id="2-1-查看默认数据库"><a href="#2-1-查看默认数据库" class="headerlink" title="2.1 查看默认数据库"></a>2.1 查看默认数据库</h3><p>查看一下在我的计算机上当前有哪些数据库:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> DATABASES; </span><br></pre></td></tr></table></figure><p>可以看到有 4 个数据库是属于 MySQL 自带的系统数据库。</p><ul><li><p><code>mysql</code></p><p>MySQL 系统自带的核心数据库，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定 义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</p></li><li><p><code>information_schema</code></p><p>MySQL 系统自带的数据库，这个数据库保存着 MySQL 服务器 <code>维护的所有其他数据库的信息</code> ，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为 <code>元数据</code> 。在系统数据库 <code>information_schema</code> 中提供了一些以 <code>innodb_sys</code> 开头的表，用于表示内部系统表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> USE information_schema;</span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_sys%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_information_schema (innodb_sys<span class="operator">%</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> INNODB_SYS_DATAFILES                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> INNODB_SYS_VIRTUAL                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> INNODB_SYS_INDEXES                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> INNODB_SYS_TABLES                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> INNODB_SYS_FIELDS                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> INNODB_SYS_TABLESPACES                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> INNODB_SYS_FOREIGN_COLS                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> INNODB_SYS_COLUMNS                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> INNODB_SYS_FOREIGN                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> INNODB_SYS_TABLESTATS                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------------+</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p><code>performance_schema</code></p><p>MySQL 系统自带的数据库，这个数据库里主要保存 MySQL 服务器运行过程中的一些状态信息，可以用来 <code>监控 MySQL 服务的各类性能指标</code> 。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等信息。</p></li><li><p><code>sys</code></p><p>MySQL 系统自带的数据库，这个数据库主要是通过 <code>视图</code> 的形式把 <code>information_schema</code> 和 <code>performance_schema</code> 结合起来，帮助系统管理员和开发人员监控 MySQL 的技术性能。</p></li></ul><h3 id="2-2-数据库在文件系统中的表示"><a href="#2-2-数据库在文件系统中的表示" class="headerlink" title="2.2 数据库在文件系统中的表示"></a>2.2 数据库在文件系统中的表示</h3><p>使用<code>CREATE DATABASE 数据库名</code>语句创建一个数据库的时候， 在文件系统上实际发生了什么呢?其实很简单,每个数据库都对应数据目录下的一个子目录，或者说对应一个文件夹，每当新建一 个数据库时, MySQL会帮我们做这两件事儿:</p><ol><li>在<code>数据目录</code>下创建一个和数据库名同名的子目录。</li><li>在与该数据库名同名的子目录下创建一个名为<code> db.opt</code>的文件(仅限MySQL5.7及之前版本)，这个文件中包含了<code>该数据库的各种属性</code>，比如该数据库的字符集和比较规则。</li></ol><p>我们再看一下我的计算机上的数据目录下的内容:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@hadoop102</span> <span class="operator">~</span>]# cd <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql</span><br><span class="line">[root<span class="variable">@hadoop102</span> mysql]# ll</span><br><span class="line">总用量 <span class="number">188880</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql       56 5月   9 21:36 auto.cnf</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql      156 6月  13 18:50 binlog.000005</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql      156 7月   9 13:05 binlog.000006</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql      156 7月   9 13:05 binlog.000007</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql       48 7月   9 13:05 binlog.index</span></span><br><span class="line"><span class="operator">-</span>rw<span class="comment">-------. 1 mysql mysql     1676 5月   9 21:36 ca-key.pem</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">--r--. 1 mysql mysql     1112 5月   9 21:36 ca.pem</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">--r--. 1 mysql mysql     1112 5月   9 21:36 client-cert.pem</span></span><br><span class="line"><span class="operator">-</span>rw<span class="comment">-------. 1 mysql mysql     1680 5月   9 21:36 client-key.pem</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql   196608 7月   9 13:05 #ib_16384_0.dblwr</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql  8585216 5月   9 21:36 #ib_16384_1.dblwr</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql     3357 5月  10 22:47 ib_buffer_pool</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql 12582912 7月   9 13:05 ibdata1</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql 50331648 7月   9 13:05 ib_logfile0</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql 50331648 5月   9 21:36 ib_logfile1</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql 12582912 7月   9 13:05 ibtmp1</span></span><br><span class="line">drwxr<span class="operator">-</span>x<span class="comment">---. 2 mysql mysql     4096 7月   9 13:05 #innodb_temp</span></span><br><span class="line">drwxr<span class="operator">-</span>x<span class="comment">---. 2 mysql mysql     4096 5月   9 21:36 mysql</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql 25165824 7月   9 13:05 mysql.ibd</span></span><br><span class="line">srwxrwxrwx. <span class="number">1</span> mysql mysql        <span class="number">0</span> <span class="number">7</span>月   <span class="number">9</span> <span class="number">13</span>:<span class="number">05</span> mysql.sock</span><br><span class="line"><span class="operator">-</span>rw<span class="comment">-------. 1 mysql mysql        5 7月   9 13:05 mysql.sock.lock</span></span><br><span class="line">drwxr<span class="operator">-</span>x<span class="comment">---. 2 mysql mysql     4096 5月   9 21:36 performance_schema</span></span><br><span class="line"><span class="operator">-</span>rw<span class="comment">-------. 1 mysql mysql     1680 5月   9 21:36 private_key.pem</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">--r--. 1 mysql mysql      452 5月   9 21:36 public_key.pem</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">--r--. 1 mysql mysql     1112 5月   9 21:36 server-cert.pem</span></span><br><span class="line"><span class="operator">-</span>rw<span class="comment">-------. 1 mysql mysql     1680 5月   9 21:36 server-key.pem</span></span><br><span class="line">drwxr<span class="operator">-</span>x<span class="comment">---. 2 mysql mysql     4096 5月   9 21:36 sys</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql 16777216 7月   9 13:05 undo_001</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql 16777216 7月   9 13:05 undo_002</span></span><br></pre></td></tr></table></figure><p>这个数据目录下的文件和子目录比较多，除了 <code>information_schema</code> 这个系统数据库外，其他的数据库在 <code>数据目录</code> 下都有对应的子目录。</p><h3 id="2-3-表在文件系统中的表示"><a href="#2-3-表在文件系统中的表示" class="headerlink" title="2.3 表在文件系统中的表示"></a>2.3 表在文件系统中的表示</h3><h4 id="2-3-1-InnoDB存储引擎模式"><a href="#2-3-1-InnoDB存储引擎模式" class="headerlink" title="2.3.1 InnoDB存储引擎模式"></a>2.3.1 InnoDB存储引擎模式</h4><p><strong>1、表结构</strong></p><p>为了保存表结构， <code>InnoDB</code>在 <code>数据目录</code> 下对应的数据库子目录下创建了一个专门用于 <code>描述表结构的文件</code>，文件名是这样：<code>表名.frm</code></p><p>比方说我们在 <code>test</code>数据库下创建一个名为<code>test</code>的表</p><p>那在数据库 <code>test</code> 对应的子目录下就会创建一个名为 <code>test.frm</code> 的用于描述表结构的文件。<code>.frm</code> 文件的格式在不同的平台上都是相同的。这个后缀名为 <code>.frm</code> 是以 <code>二进制格式</code> 存储的，我们直接打开是乱码的。</p><p><strong>2、表中数据和索引</strong></p><p><font color=#880000><strong>①系统表空间（system tablespace）</strong></font></p><p>默认情况下，InnoDB 会在数据目录下创建一个名为 <code>ibdata1</code>、大小为 <code>12M</code> 的文件，这个文件就是对应的 <code>系统表空间</code> 在文件系统上的表示。怎么才12M？</p><p>注意这个文件是 <code>自扩展文件</code> ，当不够用的时候它会自己增加文件大小。</p><p>当然，如果你想让系统表空间对应文件系统上多个实际文件，或者仅仅觉得原来的 <code>ibdata1</code> 这个文件名难听，那可以在MySQL启动时配置对应的文件路径以及它们的大小，比如我们这样修改一下my.cnf 配置文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_data_file_path=data1:512M;data2:512M:autoextend</span><br></pre></td></tr></table></figure><p>这样在MySQL启动之后就会创建这两个512M大小的文件作为<code>系统表空间</code>，其中的<code>autoextend</code>表明这两个文件如果不够用会自动扩展data2文件的大小。</p><p>需要注意的一点是,&#x3D;&#x3D;在一个MySQL服务器中，系统表空间只有一份&#x3D;&#x3D;。从MySQL5.5.7到MySQL5.6.6之间的各个版本中，我们<strong>表中的数据都会被默认存储到这个系统表空间</strong>。</p><p><strong><font color=#880000>②独立表空间（file-per-table tablespace）</font></strong></p><p>在 MySQL 5.6.6 以及之后的版本中，InnoDB 并不会默认的把各个表的数据存储到系统表空间中，而是为 <code>每一个表建立一个独立表空间</code>，也就是说我们创建了多少个表，就有多少个独立表空间。使用 <code>独立表空间</code> 来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个 <code>.ibd</code> 的扩展名而已，所以完整的文件名称长这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.ibd</span><br></pre></td></tr></table></figure><p>比如：我们使用了 <code>独立表空间</code> 去存储<code>test</code>数据库下的 <code>test</code> 表的话，那么在该表所在数据库<code>atguigu</code>对应的 test 目录下会为 test 表创建这两个文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.frm</span><br><span class="line">test.ibd</span><br></pre></td></tr></table></figure><p>其中 <code>test.ibd</code> 文件就用来存储 <code>test</code> 表中的数据和索引；而<code>text.frm</code> 描述表的结构。</p><p><strong><font color=#880000>③系统表空间与独立表空间的设置</font></strong></p><p>我们可以自己指定使用 <code>系统表空间</code> 还是 <code>独立表空间</code> 来存储数据，这个功能由启动参数 <code>innodb_file_per_table</code> 控制，比如说我们想刻意将表数据都存储到 <code>系统表空间</code> 时，可以在启动MySQL服务器的时候这样配置:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_file_per_table<span class="operator">=</span><span class="number">0</span> # <span class="number">0</span>:代表使用系统表空间; <span class="number">1</span>:代表使用独立表空间</span><br></pre></td></tr></table></figure><p>默认情况:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_file_per_table <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec) # <span class="keyword">on</span>：代表独立表空间</span><br></pre></td></tr></table></figure><p><strong><font color=#880000>④其他类型的表空间</font></strong></p><p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。</p><p><strong>3、图解</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207091733845.png"></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207091733587.png"></p><p><strong>4、疑问</strong></p><p><code>.frm</code> 在MySQL8中不存在了，去哪里了？</p><p>这就需要解析 <code>ibd 文件</code>。Oracle官方将 <code>frm文件</code> 的信息及更多信息移动到叫做序列化字典信息（Serialized Dictionary Information,SDI），SDI 被写在 ibd 文件内部，MySQL 8.0 属于 Oracle 旗下，同理。</p><p>为了从 IBD 文件中提取 SDI 信息，Oracle 提供了一个应用程序 ibd2sdi</p><p>这个工具不需要下载，MySQL8自带的有，只需要你配好环境变量就能到处用。</p><p>查看表结构：到存储ibd文件的目录下，执行下面的命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibd2sdi <span class="comment">--dump-file=student.txt student.ibd</span></span><br></pre></td></tr></table></figure><p>这样 ibd2sdi 就会把 <code>xxx.ibd</code> 里存储的表结构以 json 的格式保存在 student.txt 中</p><h4 id="2-3-2-MyISAM-存储引擎模式"><a href="#2-3-2-MyISAM-存储引擎模式" class="headerlink" title="2.3.2 MyISAM 存储引擎模式"></a>2.3.2 MyISAM 存储引擎模式</h4><p><strong>1、表结构</strong></p><p>在存储表结构方面， <code>MyISAM</code> 和 <code>InnoDB</code> 一样，也是在 <code>数据目录</code> 下对应的数据库子目录下创建了一个专 门用于描述表结构的文件：<code>表名.frm</code></p><p><strong>2、表中数据和索引</strong></p><p>在 MyISAM 中的索引全部都是 <code>二级索引</code> ，该存储引擎的 <code>数据和索引是分开存放</code> 的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。假如 <code>test</code> 表使用 MyISAM 存储引擎的话，那么在它所在数据库对应的 <code>test</code> 目录下会为 test 表创建这三个文件：</p><ul><li><code>test.frm</code> 存储表结构</li><li><code>test.MYD</code> 存储数据 (MYData)</li><li><code>test.MYI</code> 存储索引 (MYIndex)</li></ul><p><strong>3、图解</strong></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207091734468.png"></p><h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h3><p>举例：<code>数据库 a</code> ， <code>表b</code> 。</p><ol><li><p>如果表 b 采用 <code>InnoDB</code> ，data&#x2F;a 中会产生 1 个或者 2 个文件:</p><ul><li><code>b.frm</code>：描述表结构文件，字段长度等</li><li>如果采用 <code>系统表空间</code> 模式的，数据信息和索引信息都存储在 <code>ibdata1</code> 中</li><li>如果采用 <code>独立表空间</code> 存储模式，data&#x2F;a中还会产生 <code>b.ibd</code> 文件（存储数据信息和索引信息）</li></ul><blockquote><p>MySQL 5.7 中会在 data&#x2F;a 的目录下生成 <code>db.opt</code> 文件用于保存数据库的相关配置。比如：字符集、比较规则。而 MySQL 8.0 不再提供 db.opt 文件。</p><p>MySQL 8.0 中 不再单独提供 <code>b.frm</code>，而是合并在 <code>b.ibd</code> 文件中。</p></blockquote></li><li><p>如果表 b 采用 <code>MyISAM</code> ，data&#x2F;a中会产生 3 个文件:</p><ul><li>MySQL5.7 中 <code>b.frm</code> ：描述表结构文件，字段长度等。</li><li>MySQL8.0 中 <code>b.xxx.sdi</code> ：描述表结构文件，字段长度等</li><li><code>b.MYD</code> (MYData)：数据信息文件，存储数据信息(如果采用独立表存储模式)</li><li><code>b.MYI</code> (MYIndex)：存放索引信息文件</li></ul></li></ol><h3 id="2-5-视图在文件系统中的表示"><a href="#2-5-视图在文件系统中的表示" class="headerlink" title="2.5 视图在文件系统中的表示"></a>2.5 视图在文件系统中的表示</h3><p>我们知道MySQL中的<code>视图</code>其实是<code>虚拟的表</code>，也就是某个查询语句的一一个别名而已，所以在存储视图的时候是不要存储真实的数据的，只需要把它的结构存储起来就行了。和表一样，描述视图结构的文件也会被存储到所属数据库对应的子目录下边，只会存储一个<code>视图名. frm</code>的文件。如下图中的: <code>emp_details_view.frm</code></p><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207091735198.png" alt="image-20220709125100055"></p><h3 id="2-6-其他的文件"><a href="#2-6-其他的文件" class="headerlink" title="2.6 其他的文件"></a>2.6 其他的文件</h3><p>除了我们上边说的这些用户自己存储的数据以外，<code>数据目录</code>下还包括为了更好运行程序的一些额外文件,主要包括这几种类型的文件:</p><ul><li><p><strong>服务器进程文件</strong></p><p>我们知道每运行一个MySQL服务器程序,都意味着启动一个进程。MySQL服务器会把自己的进程ID写入到一个文件中。</p></li><li><p><strong>服务器日志文件</strong></p><p>在服务器运行过程中，会产生各种各样的日志，比如常规的查询日志、错误日志、二进制日志、redo日志等。这些日志各有各的用途。后面讲解。</p></li><li><p><strong>默认&#x2F;自动生成的SSL和RSA证书和密钥文件</strong></p><p>主要是为了客户端和服务器安全通信而创建的一些文件。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
