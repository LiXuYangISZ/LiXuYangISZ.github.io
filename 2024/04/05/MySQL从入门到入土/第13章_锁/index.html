<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>十三、锁 | Leo的博客</title><meta name="author" content="Leo"><meta name="copyright" content="Leo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC]  事务的隔离性由这章讲述的锁来实现 1. 概述锁是计算机协调多个进程或线程并发访问某一资源的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等)，就需要保证这个数据在任何时刻最多只有一个线程在访问，保证数据的完整性和一致性。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。 在数据库中，除传统的">
<meta property="og:type" content="article">
<meta property="og:title" content="十三、锁">
<meta property="og:url" content="https://blog.dalicoding.fun/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC13%E7%AB%A0_%E9%94%81/index.html">
<meta property="og:site_name" content="Leo的博客">
<meta property="og:description" content="[TOC]  事务的隔离性由这章讲述的锁来实现 1. 概述锁是计算机协调多个进程或线程并发访问某一资源的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等)，就需要保证这个数据在任何时刻最多只有一个线程在访问，保证数据的完整性和一致性。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。 在数据库中，除传统的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg">
<meta property="article:published_time" content="2024-04-05T06:24:13.000Z">
<meta property="article:modified_time" content="2024-04-05T07:08:50.712Z">
<meta property="article:author" content="Leo">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.dalicoding.fun/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC13%E7%AB%A0_%E9%94%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"00PKU8B7R6","apiKey":"058cbcb1db57036717778c874da0ef87","indexName":"blog-leo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Leo","link":"链接: ","source":"来源: Leo的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '十三、锁',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-05 15:08:50'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/center-atom.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403221853832.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Leo的博客"><img class="site-icon" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202404041655130.png"/><span class="site-name">Leo的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">十三、锁</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-05T06:24:13.000Z" title="发表于 2024-04-05 14:24:13">2024-04-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-05T07:08:50.712Z" title="更新于 2024-04-05 15:08:50">2024-04-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="十三、锁"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<hr>
<p>事务的<code>隔离性</code>由这章讲述的<code>锁</code>来实现</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>锁</code>是计算机协调多个进程或线程<code>并发访问某一资源</code>的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等)，就需要保证这个数据在任何时刻<code>最多只有一个线程</code>在访问，保证数据的<code>完整性</code>和<code>一致性</code>。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。</p>
<p>在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对<code>并发操作进行控制</code>，因此产生了<code>锁</code>。同时<code>锁机制</code>也为实现MySQL的各个隔离级别提供了保证。<code>锁冲突</code>也是影响数据库<code>并发访问性能</code>的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p>
<h2 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2. MySQL并发事务访问相同记录"></a>2. MySQL并发事务访问相同记录</h2><p>并发事务访问相同记录的情况大致可以划分为3种：</p>
<h3 id="2-1-读-读情况"><a href="#2-1-读-读情况" class="headerlink" title="2.1 读-读情况"></a>2.1 读-读情况</h3><p><code>读-读</code> 情况，即并发事务相继 <code>读取相同的记录</code> 。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p>
<h3 id="2-2-写-写情况"><a href="#2-2-写-写情况" class="headerlink" title="2.2 写-写情况"></a>2.2 写-写情况</h3><p><code>写-写</code> 情况，即并发事务相继对相同的记录做出改动。</p>
<p>在这种情况下会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们 <code>排队执行</code> ，这个排队的过程其实是通过 <code>锁</code> 来实现的。这个所谓的锁其实是一个 <code>内存中的结构</code> ，在事务执行前本来是没有锁的，也就是说一开始是没有 <code>锁结构</code> 和记录进行关联的,如图所示：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335827.png" alt="image-20230123203920264"></p>
<p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 锁结构 ，当没有的时候就会在内存中生成一个 <code>锁结构</code> 与之关联。比如，事务 <code>T1</code>要对这条记录做改动，就需要生成一个 <code>锁结构</code> 与之关联：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335836.png" alt="image-20230123203950048"></p>
<p>在 <code>锁结构</code> 里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来:</p>
<ul>
<li><code>trx信息</code>:代表这个锁结构是哪个事务生成的。</li>
<li><code>is_waiting </code>:代表当前事务是否在等待。</li>
</ul>
<p>当事务<code>T1</code>改动了这条记录后，就生成了一个<code>锁结构</code>与该记录关联，因为之前没有别的事务为这条记录加锁，所以<code>is_waiting</code>属性就是<code>false</code>，把这个场景就称之为<code>获取锁成功</code>，或者<code>加锁成功</code>，然后就可以继续执行操作了</p>
<p>在事务T1提交之前，另一个事务<code>T2</code>也想对该记录做改动，那么先看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个<code>锁结构</code>与这条记录关联，不过锁结构的<code>is_waiting</code>属性值为<code>true</code>，表示当前事务需要等待，把这个场景就称之为<code>获取锁失败</code>，或者<code>加锁失败</code>，图示:</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335830.png" alt="image-20230123204057637"></p>
<p>在事务T1提交之后，就会把该事务生成的<code>锁结构释放</code>掉，然后看看还有没有别的事务在等待获取锁，发现了事务<code>T2</code>还在等待获取锁，所以把事务T2对应的锁结构的<code>is_waiting</code>属性设置为<code>false</code>，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。效果图就是这样:</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335839.png" alt="image-20230123204129603"></p>
<p><strong>小结几种说法:</strong></p>
<ul>
<li><p>不加锁<br>意思就是不需要在内存中生成对应的<code>锁结构</code>，可以直接执行操作。</p>
</li>
<li><p>获取锁成功，或者加锁成功<br>意思就是在内存中生成了对应的<code>锁结构</code>，而且锁结构的<code>is_waiting</code>属性为<code>false</code>，也就是事务可以继续执行操作。</p>
</li>
<li><p>获取锁失败，或者加锁失败，或者没有获取到锁</p>
<p>意思就是在内存中生成了对应的<code>锁结构</code>，不过锁结构的<code>is_waiting</code>属性为<code>true</code>，也就是事务需要等待，不可以继续执行操作。</p>
</li>
</ul>
<h3 id="2-3-读-写或写-读情况"><a href="#2-3-读-写或写-读情况" class="headerlink" title="2.3 读-写或写-读情况"></a>2.3 读-写或写-读情况</h3><p><code>读-写</code> 或 <code>写-读</code> ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 <code>脏读</code>、 <code>不可重复读</code> 、 <code>幻读</code> 的问题。</p>
<p>各个数据库厂商对 <code>SQL标准</code> 的支持都可能不一样。比如<font color=red>MySQL在 <code>REPEATABLE READ</code> 隔离级别上就已经解决了 <code>幻读</code> 问题</font>。</p>
<h3 id="2-4-并发问题的解决方案"><a href="#2-4-并发问题的解决方案" class="headerlink" title="2.4 并发问题的解决方案"></a>2.4 并发问题的解决方案</h3><p>**<font color=orange>怎么解决 <code>脏读</code> 、 <code>不可重复读</code> 、 <code>幻读</code> 这些问题呢？</font>**其实有两种可选的解决方案：</p>
<ul>
<li><font color=red>方案一：读操作利用多版本并发控制（<code>MVCC </code>，下章讲解），写操作进行<code>加锁</code> 。</font></li>
</ul>
<p>所谓的<code>MVCC</code>，就是生成一个<code>ReadView</code>，通过ReadView找到符合条件的记录版本（(历史版本由<code>undo</code>日志构建)。查询语句只能读到在生成ReadView之前<code>已提交事务所做的更改</code>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<code>写操作</code>肯定针对的是<code>最新版本的记录</code>，&#x3D;&#x3D;读记录的历史版本和改动记录的最新版本本身并不冲突&#x3D;&#x3D;，也就是采用MVCC时，<code>读-写</code>操作并不冲突</p>
<blockquote>
<p>普通的SELECT语句在<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别下会使用到MVCC读取记录。</p>
<ul>
<li>在<code>READ COMMITTED</code> 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了<code>事务不可以读取到未提交的事务所做的更改</code> ，也就是避免了脏读现象；</li>
<li>在<code>REPEATABLE READ</code> 隔离级别下，一个事务在执行过程中只有<code>第一次执行SELECT操作</code> 才会生成一个ReadView，之后的SELECT操作都 <code>复用</code> 这个ReadView，这样也就避免了不可重复读 和幻读的问题</li>
</ul>
</blockquote>
<ul>
<li><font color=red>方案二：读、写操作都采用加锁的方式</font></li>
</ul>
<p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去<code>读取记录的最新版本</code>。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行<code>加锁</code>操作，这样也就意味着<code>读</code>操作和<code>写</code>操作也像<code>写-写</code>操作那样排队执行。</p>
<p><code>脏读</code>的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p>
<p><code>不可重复读</code>的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就<code>无法修改</code>该记录，自然也不会发生不可重复读了</p>
<p><code>幻读</code>问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬（因为你并不知道给谁加锁~)</p>
<p><strong>小结对比发现：</strong></p>
<ul>
<li>采用 <code>MVCC </code>方式的话，<code>读-写</code> 操作彼此并不冲突，<code>性能更高</code> 。</li>
<li>采用 <code>加锁</code> 方式的话， 读-写 操作彼此需要 <code>排队执行</code> ，影响性能。</li>
</ul>
<p>一般情况下当然愿意采用<code>MVCC</code>来解决 读-写 操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用 <code>加锁</code> 的方式执行。下面就讲解下MySQL中不同类别的锁。</p>
<h2 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3. 锁的不同角度分类"></a>3. 锁的不同角度分类</h2><p>锁的分类图，如下：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335845.png" alt="image-20230123212838138"></p>
<h3 id="3-1从数据操作的类型划分-读锁、写锁"><a href="#3-1从数据操作的类型划分-读锁、写锁" class="headerlink" title="3.1从数据操作的类型划分:读锁、写锁"></a>3.1从数据操作的类型划分:读锁、写锁</h3><p>对于数据库中并发事务的<code>读-读</code>情况并不会引起什么问题。对于<code>写-写</code>、<code>读-写</code>或<code>写-读</code>这些情况可能会引起一些问题，需要使用<code>MVCC</code>或者<code>加锁</code>的方式来解决它们。在使用<code>加锁</code>的方式解决问题时，由于既要允许<code>读-读</code>情况不受影响，又要使<code>写-写</code>、<code>读-写</code>或<code>写-读</code>情况中的操作相互阻塞，所以MySQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为&#x3D;&#x3D;共享锁(Shared Lock，S Lock)&#x3D;&#x3D;和&#x3D;&#x3D;排他锁(Exclusive Lock，X Lock)&#x3D;&#x3D;，也叫&#x3D;&#x3D;读锁(readlock)&#x3D;&#x3D;和&#x3D;&#x3D;写锁(write lock)&#x3D;&#x3D;</p>
<ul>
<li><code>读锁</code>:也称为<code>共享锁</code>、英文用<code>S</code>表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</li>
<li><code>写锁</code>:也称为<code>排他锁</code>、英文用<code>X</code>表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源</li>
</ul>
<blockquote>
<p>需要注意的是对于InnoDB引擎来说，读锁和写锁可以加在表上，也可以加在行上。</p>
</blockquote>
<p><strong>举例（行级读写锁)︰</strong>如果一个事务T1已经获得了某个行r的读锁，那么此时另外的一个事务T2是可以去获得这个行r的读锁的，因为读取操作并没有改变行r的数据;但是，如果某个事务T3想获得行r的写锁，则它必须等待事务T1、T2释放掉行r上的读锁才行。</p>
<blockquote>
<p>总结:这里的兼容是指对同一张表或记录的锁的兼容性情况</p>
</blockquote>
<table>
<thead>
<tr>
<th>兼容情况</th>
<th>X锁</th>
<th>S锁</th>
</tr>
</thead>
<tbody><tr>
<td>X锁</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S锁</td>
<td>不兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<h4 id="1-锁定读"><a href="#1-锁定读" class="headerlink" title="1. 锁定读"></a>1. 锁定读</h4><p>在采用<code>加锁</code>方式解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题时，读取一条记录时需要获取该记录的<code>S锁</code>，其实是不严谨的，有时候需要在读取记录时就获取记录的<code>X锁</code> ，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的<code>SELECT</code>语句格式:</p>
<ul>
<li>对读取的记录加S锁∶</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE; </span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> SHARE;#(<span class="number">8.0</span>新增语法)</span><br></pre></td></tr></table></figure>

<p>在普通的SELECT语句后边加<code>LOCK IN SHARE MODE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加<code>S锁</code>，这样允许别的事务继续获取这些记录的<code>S锁</code>（比方说别的事务也使用<code>SELECT …LOCK IN SHARE MODE</code>语句来读取这些记录)，但是不能获取这些记录的<code>X锁</code>(比如使用<code>SELECT … FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的<code>X锁</code>，那么它们会阻塞，直到当前事务提交之后将这些记录上的<code>S锁</code>释放掉</p>
<ul>
<li>对读取的记录加<code>X锁</code>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>在普通的SELECT语句后边加<code>FOR UPDATE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加<code>X锁</code>，这样既不允许别的事务获取这些记录的<code>S锁</code>(比方说别的事务使用<code>SELECT … LOCK IN SHARE MODE</code>语句来读取这些记录)，也不允许获取这些记录的<code>X锁</code>(比如使用<code>SELECT … FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的<code>S锁</code>或者<code>X锁</code>，那么它们会阻塞，直到当前事务提交之后将这些记录上的<code>X锁</code>释放掉</p>
<p><strong><font color=blue>案例演示</font></strong></p>
<ul>
<li>S-&gt;S</li>
</ul>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335867.png"></p>
<ul>
<li>S-&gt;X</li>
</ul>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335594.png"></p>
<ul>
<li>X-&gt;S</li>
</ul>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335638.png"></p>
<ul>
<li>X-&gt;X</li>
</ul>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335738.png"></p>
<p><strong>MySQL8.0新特性:</strong></p>
<p>在5.7及之前的版本，<code>SELECT … FOR UPDATE</code>，如果获取不到锁，会一直等待，直到<br><code>innodb_lock_wait_timeout</code>超时。在8.0版本中，在SELECT …FOR UPDATE，SELECT …FOR SHARE后添加<code>NOWAIT</code>、<code>SKIP LOCKED</code>语法，跳过锁等待，或者跳过锁定。</p>
<p>如果查询的行已经加锁：</p>
<ul>
<li>那么NOWAIT会立即报错返回</li>
<li>而SKIP LOCKED也会立即返回，只是返回的结果中不包含被锁定的行。</li>
</ul>
<p><strong><font color=blue>演示</font></strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#事务A</span><br><span class="line"><span class="keyword">begin</span> ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+-- --+--------+- ------ +</span></span><br><span class="line"><span class="comment">| id  |    NAME|  balance|</span></span><br><span class="line"><span class="comment">|   1 │     张三|    40.00|</span></span><br><span class="line"><span class="comment">|   2 |     李四|    0.00 |</span></span><br><span class="line"><span class="comment">|   3 |     王五|   100.00|</span></span><br><span class="line"><span class="comment">+--- -+--------+- ------ +</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#事务B</span><br><span class="line"><span class="keyword">begin</span> ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">for</span> <span class="keyword">update</span> nowait;</span><br><span class="line">#报错返回</span><br><span class="line">#ERROR <span class="number">3572</span> (HYO00): Statement aborted because lock(s) could <span class="keyword">not</span> be acquired immediately <span class="keyword">and</span> NOMAIT <span class="keyword">is</span> set.</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">skip</span> locked;</span><br><span class="line"># 因为事务A获得X锁，所以查到的记录是空的<span class="operator">~</span></span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (o<span class="number">.00</span> sec)</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line">#Query Ok,o <span class="keyword">rows</span> affected ( sec)</span><br></pre></td></tr></table></figure>

<h4 id="2-写操作"><a href="#2-写操作" class="headerlink" title="2. 写操作"></a>2. 写操作</h4><p>平常所用到的写操作无非是 <code>DELETE</code>、<code>UPDATE</code>、<code>INSERT </code>这三种:</p>
<ul>
<li><code>DELETE</code>：对一条记录做DELETE操作的过程其实是先在<code>B+</code>树中定位到这条记录的位置，然后获取这条记录的<code>X锁</code>，再执行<code>delete mark</code>操作。也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</li>
<li><code>UPDATE</code>︰在对一条记录做UPDATE操作时分为三种情况:<ul>
<li>情况1: 未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。<br>则先在<code>B+</code>树中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原记录的位置进行修改操作。也可以把这个定位待修改记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</li>
<li>情况2∶未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。<br>则先在<code>B+</code>树中定位到这条记录的位置，然后获取一下记录的<code>X锁</code>，将该记录<code>彻底删除掉</code>（就是把记录彻底移入垃圾链表)，最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个<code>获取X锁的锁定读</code>，新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</li>
<li>情况3∶ 修改了该记录的键值，则相当于在原记录上做<code>DELETE</code>操作之后再来一次<code>INSERT</code>操作，加锁操作就需要按照<code>DELETE</code>和<code>INSERT</code>的规则进行了。（同情况2）</li>
</ul>
</li>
<li><code>INSERT </code>：&#x3D;&#x3D;一般情况下，新插入一条记录的操作并不加锁&#x3D;&#x3D;，通过一种称之为<code>隐式锁</code>的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</li>
</ul>
<blockquote>
<p>分析：因为插入之前就没有要锁的记录，所以也就不需要加X锁了</p>
</blockquote>
<h3 id="3-2-从数据操作的粒度划分-表级锁、页级锁、行锁"><a href="#3-2-从数据操作的粒度划分-表级锁、页级锁、行锁" class="headerlink" title="3.2 从数据操作的粒度划分:表级锁、页级锁、行锁"></a>3.2 从数据操作的粒度划分:表级锁、页级锁、行锁</h3><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很<code>耗资源</code>的事情（涉及获取、检查、释放锁等动作)。因此数据库系统需要在<code>高并发响应</code>和<code>系统性能</code>两方面进行平衡，这样就产生了“<code>锁粒度</code>(Lock granularity)”的概念。</p>
<p>对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细；其实一个事务也可以在<code>表级别</code>进行加锁，自然就被称之为<code>表级锁</code>或者<code>表锁</code>，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。锁的粒度主要分为<code>表级锁</code>、<code>页级锁</code>和<code>行锁</code>。</p>
<h4 id="1-表锁-Table-Lock"><a href="#1-表锁-Table-Lock" class="headerlink" title="1. 表锁(Table Lock)"></a>1. 表锁(Table Lock)</h4><p>该锁会锁定整张表，它是MySQL中最基本的锁策略，并<code>不依赖于存储引擎</code>（不管你是MySQL的什么存储引擎，对于表锁的策略都是一样的)，并且表锁是<code>开销最小</code>的策略(因为粒度比较大)。由于表级锁一次会将整个表锁定，所以可以很好的<code>避免死锁</code>问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致<code>并发率大打折扣</code>。</p>
<h5 id="①-表级别的S锁、X锁"><a href="#①-表级别的S锁、X锁" class="headerlink" title="① 表级别的S锁、X锁"></a><font color=orange>① 表级别的S锁、X锁</font></h5><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的<code>S锁</code>或者<code>X锁</code>的。在对某个表执行一些诸如<code>ALTER TABLE</code>、<code>DROP TABLE</code>这类的<code>DDL</code>语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行DDL语句也会发生阻塞。这个过程其实是通过在<code>server层</code>使用一种称之为<code>元数据锁</code>(英文名: <code>Metadata Locks</code>，简称<code>MDL</code>）结构来实现的。</p>
<p>&#x3D;&#x3D;一般情况下，不会使用InnoDB存储引擎提供的表级别的 <code>S锁</code> 和 <code>X锁</code>&#x3D;&#x3D;  (因为InnoDB支持更小粒度的行锁~)。只会在一些特殊情况下，比方说 <code>崩溃恢复</code> 过程中用到。比如，在系统变量 <code>autocommit=0</code>，<code>innodb_table_locks = 1</code> 时， <code>手动</code> 获取InnoDB存储引擎提供的表t 的 <code>S锁</code> 或者 <code>X锁</code> 可以这么写：</p>
<ul>
<li><code>LOCK TABLES t READ</code> ：InnoDB存储引擎会对表 t 加表级别的<code>S锁</code> 。</li>
<li><code>LOCK TABLES t WRITE</code> ：InnoDB存储引擎会对表 t 加表级别的<code>X锁</code> 。</li>
</ul>
<p>不过尽量避免在使用InnoDB存储引擎的表上使用 <code>LOCK TABLES</code> 这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的 <code>行锁</code> ，关于InnoDB表级别的 S锁 和 X锁 大家了解一下就可以了</p>
<p><strong>举例：</strong> 下面我们讲解MylSAM引擎下的表锁。</p>
<ul>
<li>步骤1：创建表并添加数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mylock(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY auto_increment,NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">)ENGINE myisam;#存储引擎使用InnoDB也可以，只是不建议</span><br><span class="line"></span><br><span class="line">#插入一条数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mylock(NAME) <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#查询表中所有的数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mylock;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+----+------+</span></span><br><span class="line"><span class="comment">| id | NAME |</span></span><br><span class="line"><span class="comment">+----+------+</span></span><br><span class="line"><span class="comment">|  1 | a    |</span></span><br><span class="line"><span class="comment">+----+------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>步骤2：查看表上加过的锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> TABLES <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> TABLES;#主要关注In_use字段的值 <span class="operator">&gt;</span><span class="number">0</span></span><br><span class="line"><span class="comment">/*部分输出</span></span><br><span class="line"><span class="comment">SHOW OPEN TABLES;</span></span><br><span class="line"><span class="comment">+--------------------+---------------------------+--------+-------------+</span></span><br><span class="line"><span class="comment">| Database           | Table                     | In_use | Name_locked |</span></span><br><span class="line"><span class="comment">+--------------------+---------------------------+--------+-------------+</span></span><br><span class="line"><span class="comment">| atguigudb3         | user1                     |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | tablespace_files          |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | column_statistics         |      0 |           0 |</span></span><br><span class="line"><span class="comment">| atguigudb3         | account                   |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | table_stats               |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | check_constraints         |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | view_table_usage          |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | tables_priv               |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | column_type_elements      |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | foreign_key_column_usage  |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | time_zone_name            |      0 |           0 |</span></span><br><span class="line"><span class="comment">.........................................................................</span></span><br><span class="line"><span class="comment">| information_schema | TABLES                    |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | time_zone_transition_type |      0 |           0 |</span></span><br><span class="line"><span class="comment">| mysql              | tablespaces               |      0 |           0 |</span></span><br><span class="line"><span class="comment">+--------------------+---------------------------+--------+-------------+</span></span><br><span class="line"><span class="comment">61 rows in set (0.01 sec)                </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的结果表明，当前数据库中没有被锁定的表。</p>
</blockquote>
<ul>
<li>步骤3：手动增加表锁命令</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES t READ:#存储引擎会对表t加表级别的共享锁。共享锁也叫读锁或S锁(Share的缩写)</span><br><span class="line">LOCK TABLES t WRITE:#存储引擎会对表t加表级别的排他锁。排它锁也叫独占锁、写锁或X锁(是eXclusive的缩写)</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> lock tables mylock write;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">OPEN</span> TABLES <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> Database   <span class="operator">|</span> <span class="keyword">Table</span>  <span class="operator">|</span> In_use <span class="operator">|</span> Name_locked <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> atguigudb3 <span class="operator">|</span> mylock <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------+--------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤4：释放锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#释放锁</span><br><span class="line">unlock tables;#释放当前加锁的表</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤5：加读锁</li>
</ul>
<p>为mylock表加read锁(读阻塞写)，观察阻塞的情况，流程如下:</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335780.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#######################SessonA中########################################</span></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">begin;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">lock tables mylock <span class="built_in">read</span>;<span class="comment">#为表加上读锁</span></span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from mylock;<span class="comment">#自己可读</span></span></span><br><span class="line">+----+------+</span><br><span class="line">| id | NAME |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | a    |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">update mylock <span class="built_in">set</span> name = <span class="string">&#x27;a1&#x27;</span> <span class="built_in">where</span> <span class="built_in">id</span> = 1; <span class="comment">#自己不可写</span></span></span><br><span class="line">ERROR 1099 (HY000): Table &#x27;mylock&#x27; was locked with a READ lock and can&#x27;t be updated</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from account; <span class="comment"># 不可操作其他表</span></span></span><br><span class="line">ERROR 1100 (HY000): Table &#x27;account&#x27; was not locked with LOCK TABLES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################################sessionB###############################</span></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from mylock;<span class="comment">#其他人可以读</span></span></span><br><span class="line">+----+------+</span><br><span class="line">| id | NAME |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | a    |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">update mylock <span class="built_in">set</span> name = <span class="string">&#x27;a2&#x27;</span> <span class="built_in">where</span> <span class="built_in">id</span> = 1; <span class="comment">#其他人不可写，需要等待</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">阻塞....</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#######################SessionA##########################</span></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">unlock tables; <span class="comment">#释放锁</span></span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#######################SessionB#########################</span></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">update mylock <span class="built_in">set</span> name = <span class="string">&#x27;a2&#x27;</span> <span class="built_in">where</span> <span class="built_in">id</span> = 1;<span class="comment">#获取到锁，进行写操作</span></span></span><br><span class="line">Query OK, 1 row affected (13.41 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from mylock;<span class="comment"># 数据已经变更</span></span></span><br><span class="line">+----+------+</span><br><span class="line">| id | NAME |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | a2   |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<ul>
<li>步骤6∶加写锁</li>
</ul>
<p>为mylock表加write锁，观察阻塞的情况，流程如下:</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335828.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#######################SessionA########################################</span></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">lock tables mylock write; <span class="comment">#为表上加写锁</span></span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from mylock; <span class="comment">#自己可用读</span></span></span><br><span class="line">+----+------+</span><br><span class="line">| id | NAME |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | a1   |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">update mylock <span class="built_in">set</span> name = <span class="string">&#x27;a2&#x27;</span> <span class="built_in">where</span> <span class="built_in">id</span> = 1; <span class="comment">#自己可以写</span></span></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from account; <span class="comment">#自己无法操作其他表</span></span></span><br><span class="line">ERROR 1100 (HY000): Table &#x27;account&#x27; was not locked with LOCK TABLES</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###########################SessionB##################################</span></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from mylock; <span class="comment">#其他人不可以读</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">阻塞...</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">update mylock <span class="built_in">set</span> name = <span class="string">&#x27;a3&#x27;</span> <span class="built_in">where</span> <span class="built_in">id</span> = 1; <span class="comment">#其他人不可以写</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">阻塞...</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from account; <span class="comment">#可以操作其他表</span></span></span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | abc    |      40 |</span><br><span class="line">|  2 | 李四   |       0 |</span><br><span class="line">|  3 | 王五   |     100 |</span><br><span class="line">|  4 | 马六   |    1000 |</span><br><span class="line">|  5 | 张三   |    6666 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong><br><font color=red>MylSAM在执行查询语句(SELECT)前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁</font>。InnoDB存储引擎是不会为这个表添加表级别的读锁或者写锁的。</p>
<p>MySQL的表级锁有两种模式：(以MyISAM表进行操作的演示)</p>
<ul>
<li>表共享读锁(Table Read Lock)</li>
<li>表独占写锁(Table Write Lock)</li>
</ul>
<table>
<thead>
<tr>
<th align="center">锁类型</th>
<th align="center">自己可读</th>
<th align="center">自己可写</th>
<th align="center">自己可操作其他表</th>
<th align="center">他人可读</th>
<th align="center">他人可写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读锁</td>
<td align="center">是</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">否，需等待</td>
</tr>
<tr>
<td align="center">写锁</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">否</td>
<td align="center">否，需等待</td>
<td align="center">否，需等待</td>
</tr>
</tbody></table>
<h5 id="②-意向锁-（intention-lock）"><a href="#②-意向锁-（intention-lock）" class="headerlink" title="② 意向锁 （intention lock）"></a><font color=orange>② 意向锁 （intention lock）</font></h5><p>InnoDB 支持 <code>多粒度锁</code>（multiple granularity locking） ，它允许 <code>行级锁</code> 与 <code>表级锁</code> 共存，而<code>意向锁</code>就是其中的一种 <code>表锁</code> 。</p>
<ul>
<li>意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。</li>
<li>意向锁是一种&#x3D;&#x3D;不与行级锁冲突的表级锁&#x3D;&#x3D;，这一点非常重要。</li>
<li>表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</li>
</ul>
<p>意向锁分为两种：</p>
<ul>
<li><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<code>共享锁</code>（S锁）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<code>排他锁</code>（X锁）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>即：&#x3D;&#x3D;意向锁是由存储引擎 <code>自己维护的</code> ，用户无法手动操作意向锁&#x3D;&#x3D;，在为数据行加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据行 <code>所在数据表的对应意向锁</code> 。</p>
<p><strong><font color=blue>1、意向锁要解决的问题</font></strong></p>
<p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁；如果存在意向锁，那么此时就会受到由T1控制的<code>表级别意向锁的阻塞</code>。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说就是<code>给更大一级别的空间示意里面是否已经上过锁</code>。</p>
<p>在数据表的场景中，<font color=red>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</font>，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p>
<ul>
<li>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁。</li>
<li>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排他锁</li>
</ul>
<p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录</p>
<p>举例：事务的隔离级别默认为Repeatable-Read，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 创建表teacher，插入<span class="number">6</span>条数据</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `teacher`(</span><br><span class="line">  id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `teacher` <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;zhangsan&#x27;</span>),</span><br><span class="line">(<span class="number">2</span> , <span class="string">&#x27;lisi&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;wangwu&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;zhaoliu&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;songhongkang&#x27;</span>),</span><br><span class="line">(<span class="number">6</span> , <span class="string">&#x27;leifengyang&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 查看数据</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> zhangsan     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> lisi         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> wangwu       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> zhaoliu      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> songhongkang <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> leifengyang  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># 假设事务A获取了某一行的排他锁，并未提交</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"># 事务B想要获取teacher表的表读锁，语句如下。</span><br><span class="line"><span class="keyword">begin</span> ;</span><br><span class="line">LOCK TABLES teacher READ;</span><br><span class="line">#阻塞...</span><br></pre></td></tr></table></figure>

<p>因为共享锁与排他锁互斥，所以事务B在试图对teacher表加共享锁的时候，必须保证两个条件</p>
<p>（1）当前没有其他事务持有teacher表的排他锁</p>
<p>（2）当前没有其他事务持有teacher 表中任意一行的排他锁。</p>
<p>为了检测是否满足第二个条件，事务B必须在确保teacher表不存在任何排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了意向锁之后，情况就不一样了。</p>
<p>意向锁是怎么解决这个问题的呢？首先需要知道意向锁之间的兼容互斥性，如下所示：</p>
<table>
<thead>
<tr>
<th>兼容性</th>
<th>意向共享锁(lS)</th>
<th>意向排他锁(IX)</th>
</tr>
</thead>
<tbody><tr>
<td>意向共享锁(IS)</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>意向排他锁(IX)</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>即意向锁之间是互相兼容的，虽然意向锁和自家兄弟互相兼容，但是它会与普通的排他&#x2F;共享锁互斥。</p>
<table>
<thead>
<tr>
<th>兼容性</th>
<th>意向共享锁(lS)</th>
<th>意向排他锁(IX)</th>
</tr>
</thead>
<tbody><tr>
<td>共享锁(S)</td>
<td>兼容</td>
<td>互斥</td>
</tr>
<tr>
<td>排他锁(X)</td>
<td>互斥</td>
<td>互斥</td>
</tr>
</tbody></table>
<blockquote>
<p>注意这里的排他&#x2F;共享锁指的都是表锁，&#x3D;&#x3D;意向锁不会与行级的共享&#x2F;排他锁互斥&#x3D;&#x3D;。 可以把意向锁看做是一种行级锁的标记</p>
</blockquote>
<p>回到刚才teacher表的例子。事务A获取了某一行的排他锁，并未提交:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>此时 teacher表存在两把锁： teacher表上的意向排他锁与id为6的数据行上的排他锁。事务B想要获取teacher表的共享锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">LOCK TABLES teacher READ;</span><br></pre></td></tr></table></figure>

<p>此时事务B检测事务A持有teacher 表的意向排他锁，就可以得知事务A必然持有该表中某些数据行的排他锁，那么事务B对teacher表的加锁请求就会被<code>排斥</code>(<code>阻塞</code>)，而<code>无需去检测</code>表中的每一行数据是否存在排他锁。  </p>
<p><strong><font color=blue>2、意向锁的并发性</font></strong><br><font color=red>意向锁不会与行级的共享&#x2F;排他锁互斥！</font>正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。(如果互斥，那么行级锁直接就退化成表锁了，就没有什么优势了~)</p>
<p>我们扩展一下上面teacher表的例子来概括一下意向锁的作用（一条数据从被锁定到被释放的过程中，可能存在多种不同锁，但是这里只着重表现意向锁)</p>
<p>**<font color=green>① </font>**事务A先获取了某一行的排他锁，并未提交:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>**<font color=green>② </font>**事务A获取了teacher表上的意向排他锁，事务A获取了id为6的数据行上的排他锁。之后事务B想要获取teacher表的共享锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">LOCK TABLES teacher READ ;</span><br></pre></td></tr></table></figure>

<p>③ 事务B<code>检测到</code>事务A持有teacher表的<code>意向排他锁</code>。事务B对teacher表的加锁请求被<code>阻塞</code>(排斥)。最后事务C也想获取teacher表中某一行的排他锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>事务C申请teacher表的意向排他锁。事务C检测到事务A持有teacher表的意向排他锁。<code>因为意向锁之间并不互斥</code>，所以事务C获取到了teacher表的意向排他锁。因为id为5的数据行上不存在任何排他锁，最终事务C成功获取到了该数据行上的<code>排他锁</code>。</p>
<p><strong>从上面的案例可以得到如下结论：</strong></p>
<ol>
<li>InnoDB支持<code>多粒度锁</code>，特定场景下，&#x3D;&#x3D;行级锁可以与表级锁共存&#x3D;&#x3D;。</li>
<li>意向锁之间互不排斥，但除了IS与S兼容外，<code>意向锁会与共享锁 / 排他锁互斥</code>。</li>
<li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li>
<li>意向锁在保证并发性的前提下，实现了<code>行锁和表锁共存</code>且<code>满足事务隔离性</code>的要求。</li>
</ol>
<h5 id="③-自增锁（AUTO-INC锁）"><a href="#③-自增锁（AUTO-INC锁）" class="headerlink" title="③ 自增锁（AUTO-INC锁）"></a><font color=orange>③ 自增锁（AUTO-INC锁）</font></h5><p>在使用MySQL过程中，我们可以为表的某个列添加 <code>AUTO_INCREMENT </code>属性。举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `teacher` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure>

<p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改如下所示</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `teacher` (name) <span class="keyword">VALUES</span> (<span class="string">&#x27;zhangsan&#x27;</span>), (<span class="string">&#x27;lisi&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值，结果如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+----+----------+</span></span><br><span class="line"><span class="comment">| id | name |</span></span><br><span class="line"><span class="comment">+----+----------+</span></span><br><span class="line"><span class="comment">| 1 | zhangsan |</span></span><br><span class="line"><span class="comment">| 2 | lisi |</span></span><br><span class="line"><span class="comment">+----+----------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>现在看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是“ <code>Simple inserts</code> ”，“ <code>Bulk inserts</code> ”和“ <code>Mixed-mode inserts</code> ”。</p>
<p><strong>1. “Simple inserts” （简单插入）</strong><br>可以 <code>预先确定要插入的行数</code> （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<code>INSERT…VALUES()</code> 和 <code>REPLACE</code> 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行数。</p>
<p><strong>2. “Bulk inserts” （批量插入）</strong><br><code>事先不知道要插入的行数</code> （和所需自动递增值的数量）的语句。比如 <code>INSERT … SELECT</code> ， <code>REPLACE … SELECT</code> 和<code>LOAD DATA</code>语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。</p>
<p><strong>3. “Mixed-mode inserts” （混合模式插入）</strong><br>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 <code>INSERT INTO teacher (id,name) VALUES (1,‘a’), (NULL,‘b’), (5,‘c’), (NULL,‘d’); </code>只是指定了部分id的值。另一种类型的“混合模式插入”是 <code>INSERT … ON DUPLICATE KEY UPDATE</code> 。</p>
<p>对于上面数据插入的案例，MySQL中采用了<code>自增锁</code>的方式来实现，&#x3D;&#x3D;AUTO-INC锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁&#x3D;&#x3D;，在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC锁释放掉。&#x3D;&#x3D;一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞&#x3D;&#x3D;，可以保证一个语句中分配的递增值是连续的。也正因为此，其<code>并发性显然并不高</code>，&#x3D;&#x3D;当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争&#x3D;&#x3D;，这样的并发潜力其实是很低下的，所以InnoDB通过<code>innodb_autoinc_lock_mode</code>的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。</p>
<p><strong><font color=blue>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：（了解）</font></strong></p>
<p><code>(1) innodb_autoinc_lock_mode = 0(“传统&quot;锁定模式)</code> 在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会 <code>限制并发</code> 能力。</p>
<p><code>（2) innodb_autoinc_lock_mode = 1(“连续”锁定模式)</code> 在 MySQL 8.0 之前，连续锁定模式是 默认 的。</p>
<p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT …SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p>
<p>对于“Simple inserts”（要插入的行数事先已知），则通过在<code> mutex（轻量锁）</code> 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。</p>
<p><code>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式)</code></p>
<p>从 MySQL 8.0 开始，交错锁定模式是 <code>默认</code> 的。</p>
<p>在这种锁定模式下，所有类INSERT语句都不会使用表级AUTO-INC锁，并且可以同时执行多个语句。这是最快和最可扩展的锁定模式，但是当使用基于语句的复制或恢复方案时，<code>从二进制日志重播SQL语句时，这是不安全的</code>。</p>
<p>在此锁定模式下，自动递增值保证在所有并发执行的所有类型的insert语句中是<code>唯一</code>且<code>单调递增</code>的。但是，由于多个语句可以同时生成数字(即，跨语句交叉编号），<code>为任何给定语句插入的行生成的值可能不是连续的</code>。</p>
<p>如果执行的语句是”simple inserts”，其中要插入的行数已提前知道，除了“Mixed-mode inserts”之外，为单个语句生成的数字不会有间隙。然而，当执行“bulk inserts”时，在由任何给定语句分配的自动递增值中可能存在间隙。</p>
<h5 id="④-元数据锁（MDL锁）"><a href="#④-元数据锁（MDL锁）" class="headerlink" title="④ 元数据锁（MDL锁）"></a><font color=orange>④ 元数据锁（MDL锁）</font></h5><p>MySQL5.5引入了<code>meta data lock</code>，简称<code>MDL</code>锁，属于表锁范畴。MDL的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个<code>表结构做变更</code>，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的</p>
<p>因此，&#x3D;&#x3D;当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁&#x3D;&#x3D;。</p>
<p>读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。&#x3D;&#x3D;不需要显式使用&#x3D;&#x3D;，在访问一个表的时候会被自动加上。</p>
<p><strong>举例：元数据锁的使用场景模拟</strong></p>
<ul>
<li>会话A：从表中查询数据</li>
</ul>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335043.png" alt="image-20230125165020157"></p>
<ul>
<li>会话B：修改表结构，增加新列</li>
</ul>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335170.png" alt="image-20230125165055077"></p>
<ul>
<li>会话C：查看当前MySQL的进程，可以得出B中的阻塞就是因为A为teacher加了MDL锁</li>
</ul>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335683.png" alt="image-20230125163142559"></p>
<ul>
<li>在会话B中结束修改，进行读操作</li>
</ul>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335772.png" alt="image-20230125163856580"></p>
<ul>
<li>B中之前的所有进行提交，重新开启事务尽心修改，同时C中也开启一个事务进行查询~</li>
</ul>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335815.png"></p>
<p>可以看出会话B被阻塞，这是由于会话A拿到了teacher表的<code>元数据读锁</code>，会话B想申请teacher表的<code>元数据写锁</code>，由于&#x3D;&#x3D;读写锁互斥&#x3D;&#x3D;，会话B需要等待会话A释放元数据锁才能执行。而会话C要在表teacher上新申请MDL读锁的请求也会被<code>会话B</code> 阻塞。</p>
<p>前面说了，所有对表的增删改查操作都需要先申请MDL读锁，现在就都被阻塞了，等于这个表现在完全不可读写了，&#x3D;&#x3D;并发性大大降低&#x3D;&#x3D;！！！这也就是元数据锁可能带来的问题~</p>
<h4 id="2-InnoDB中的行锁"><a href="#2-InnoDB中的行锁" class="headerlink" title="2. InnoDB中的行锁"></a>2. InnoDB中的行锁</h4><p>行锁(Row Lock)也称为记录锁，顾名思义，就是锁住某一行（某条记录row)。需要的注意的是，MySQL服务器层并没有实现行锁机制，&#x3D;&#x3D;行级锁只在存储引擎层实现&#x3D;&#x3D;。</p>
<p><strong>优点：</strong> 锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code>。<br><strong>缺点：</strong> 对于<code>锁的开销比较大</code>，加锁会比较慢，容易出现<code>死锁</code>情况。</p>
<p><font color=red>InnoDB与MylSAM的最大不同有两点：一是支持事务(TRANSACTION)；二是采用了行级锁。</font></p>
<p><font color=blue>演示环境搭建</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">  id <span class="type">INT</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  class <span class="type">varchar</span> (<span class="number">10</span>) ,<span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">)Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"># 插入几条记录</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span> ,<span class="string">&#x27;一班&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;李四&#x27;</span> ,<span class="string">&#x27;一班&#x27;</span>),</span><br><span class="line">( <span class="number">8</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;二班&#x27;</span>),</span><br><span class="line">( <span class="number">15</span>,<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;二班&#x27;</span>),</span><br><span class="line">(<span class="number">20</span>, <span class="string">&#x27;钱七&#x27;</span>,<span class="string">&#x27;三班&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> student;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+----+--------+--------+</span></span><br><span class="line"><span class="comment">| id | name   | class  |</span></span><br><span class="line"><span class="comment">+----+--------+--------+</span></span><br><span class="line"><span class="comment">|  1 | 张三   | 一班   |</span></span><br><span class="line"><span class="comment">|  3 | 李四   | 一班   |</span></span><br><span class="line"><span class="comment">|  8 | 王五   | 二班   |</span></span><br><span class="line"><span class="comment">| 15 | 赵六   | 二班   |</span></span><br><span class="line"><span class="comment">| 20 | 钱七   | 三班   |</span></span><br><span class="line"><span class="comment">+----+--------+--------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>student表中的聚簇索引的简图如下所示</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335858.png" alt="image-20230125202318828"></p>
<p>这里把B+树的索引结构做了一个超级简化，只把索引中的记录给拿了出来，下面看看都有哪些常用的行锁类型。</p>
<h5 id="①-记录锁（Record-Locks）"><a href="#①-记录锁（Record-Locks）" class="headerlink" title="① 记录锁（Record Locks）"></a><font color=orange>① 记录锁（Record Locks）</font></h5><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为： <code>LOCK_REC_NOT_GAP</code>。比如把id值为8的那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335945.png" alt="image-20230125202950342"></p>
<p>举例如下：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335991.png" alt="image-20230125203029242"></p>
<p>代码演示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">###############################SessionA###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> student <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;张三1&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; #为id<span class="operator">=</span><span class="number">1</span>的记录加X型的行锁</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">###############################SessionB###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> class  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 李四   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> lock <span class="keyword">in</span> share mode; </span><br><span class="line">#阻塞...因为sessonA中的事务对该记录了X锁</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; #执行超时</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> student <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;李四1&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>; #为id<span class="operator">=</span><span class="number">3</span>的记录加X型的锁</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> student <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;张三2&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">#阻塞...</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; #执行超时</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###############################SessionA###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>; #提交</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">###############################SessionB###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> student <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;张三2&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; #再次尝试获取X锁，执行成功</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">5.74</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name    <span class="operator">|</span> class  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 张三<span class="number">2</span>   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 李四<span class="number">1</span>   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> 王五    <span class="operator">|</span> 二班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> 赵六    <span class="operator">|</span> 二班   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> 钱七    <span class="operator">|</span> 三班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+--------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>记录锁是有S锁和X锁之分的，称之为 <code>S型记录锁</code> 和 <code>X型记录锁</code> 。</p>
<ul>
<li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li>
<li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li>
</ul>
<h5 id="②-间隙锁（Gap-Locks）"><a href="#②-间隙锁（Gap-Locks）" class="headerlink" title="② 间隙锁（Gap Locks）"></a><font color=orange>② 间隙锁（Gap Locks）</font></h5><blockquote>
<p>对于repeatable read，sql标准没解决幻读，MySQL中解决了幻读</p>
</blockquote>
<p>MySQL在 <code>REPEATABLE READ</code> 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 <code>MVCC</code>方案解决，也可以采用 <code>加锁</code> 方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些 <code>幻影记录</code> 加上 <code>记录锁</code> 。InnoDB提出了一种称之为<code>Gap Locks</code> 的锁，官方的类型名称为： <code>LOCK_GAP</code>，我们可以简称为 <code>gap锁</code> 。</p>
<p>比如，把id值为5的那条记录加一个gap锁的示意图如下。</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335196.png"></p>
<p>图中id值为5的记录加了gap锁，意味着 <code>不允许别的事务在id值为5的记录所在的间隙插入新记录</code> ，其实就是id列的值<code>(3, 8)</code>这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新记录，它定位到该条新记录在id为5的间隙锁的范围内，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。</p>
<p><font color=red>gap锁的提出仅仅是为了防止插入幻影记录而提出的</font>。虽然有共享gap锁和独占gap锁这样的说法，但是它们起到的作用是相同的。而且&#x3D;&#x3D;如果对一条记录加了gap锁&#x3D;&#x3D;〈不论是共享gap锁还是独占gap锁)，&#x3D;&#x3D;并不会限制其他事务对这条记录加记录锁或者继续加gap锁&#x3D;&#x3D;。</p>
<p><strong>举例：</strong></p>
<table>
<thead>
<tr>
<th>Session1</th>
<th>Session2</th>
</tr>
</thead>
<tbody><tr>
<td>select * from student where id &#x3D; 5 lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from student where id &#x3D; 5 for update;</td>
</tr>
</tbody></table>
<p>这里session 2并不会被堵住。因为表里并没有id&#x3D;5这个记录，因此 session 1加的是间隙锁（3,8)。而session 2也是在这个间隙加的间隙锁。它们有共同的目标，即:保护这个间隙，不允许插入值。但，它们之间是不冲突的。</p>
<p><strong>注意，</strong>给一条记录加了<code>gap锁</code>只是<code>不允许</code>其他事务往这条记录前边的间隙<code>插入新记录</code>，那对于最后一条记录之后的间隙，也就是student 表中id值为<code>20</code>的记录之后的间隙该咋办呢？也就是说给哪条记录加<code>gap锁</code>才能阻止其他事务插入<code>id值</code>在<code>(20，正无穷)</code>这个区间的新记录呢？这时候我们在讲数据页时介绍的两条伪记录派上用场了：</p>
<ul>
<li><code>Infimum</code>记录，表示该页面中最小的记录。</li>
<li><code>Supremum</code>记录，表示该页面中最大的记录。</li>
</ul>
<p>为了实现阻止其他事务插入id值在(20, 正无穷)这个区间的新记录，可以给索引中的最后一条记录，也就是id值为20的那条记录所在页面的<code>Supremum</code>记录加上一个gap锁，如图所示</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335240.png" alt="image-20230125210502347"></p>
<p><strong><font color=bule>代码演示：</font></strong></p>
<ul>
<li>关于X和S锁互斥的知识回顾</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">###############################SessionA###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">8</span> lock <span class="keyword">in</span> share mode; #为id<span class="operator">=</span><span class="number">8</span>的记录加S锁</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> class  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> 王五   <span class="operator">|</span> 二班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">###############################SessionB####################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>; # A已经为id<span class="operator">=</span><span class="number">8</span>的加了S锁，B就不能加X锁了</span><br><span class="line"><span class="operator">^</span>C<span class="operator">^</span>C <span class="comment">-- query aborted</span></span><br><span class="line">ERROR <span class="number">1317</span> (<span class="number">70100</span>): Query execution was interrupted</span><br><span class="line"></span><br><span class="line">#################SessionA<span class="operator">&amp;</span>SessionB########################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>间隙锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#############################SessionA#####################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># id<span class="operator">=</span><span class="number">5</span>的记录不存在，所以无法加上记录锁<span class="operator">~</span> 对于不存在的记录，加的是间隙锁。（<span class="number">3</span><span class="number">-8</span>）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span> lock <span class="keyword">in</span> share mode; </span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">############################SessionB####################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># 依旧加的是间隙锁。可以看出共享gap锁和独占gap锁作用相同，而且可以重复加<span class="operator">~</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">##########################SessionC######################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;三班&#x27;</span>); #在间隙锁范围内，无法插入</span><br><span class="line">#阻塞...</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>

<ul>
<li>可以这样实现加 id &gt; 20的间隙锁：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">25</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果记录存在，则使用<code>for update</code> 或 <code>lock in share mode</code> 加的就是记录锁，如果记录不存在加的就是间隙锁~</p>
</blockquote>
<p>&#x3D;&#x3D;间隙锁的引入，可能会导致&#x3D;&#x3D;同样的语句锁住更大的范围，这其实是影响了并发度的。下面的例子会产生&#x3D;&#x3D;死锁&#x3D;&#x3D;。</p>
<table>
<thead>
<tr>
<th>Session1</th>
<th>Session2</th>
</tr>
</thead>
<tbody><tr>
<td>begin; select *from student where id &#x3D; 5 for update;</td>
<td>begin;select * from student where id &#x3D; 5 for update;</td>
</tr>
<tr>
<td></td>
<td>INSERT INTO student VALUES(5,’宋红康,‘二班’);阻塞</td>
</tr>
<tr>
<td>INSERT INTO student VALUES(5,‘宋红康’,‘二班’);(ERROR 1213(40001):Deadlock found when trying to get lock; try restarting transaction)</td>
<td></td>
</tr>
</tbody></table>
<p>① session 1执行select …for update语句，由于id &#x3D; 5这一行并不存在，因此会<code>加上间隙锁(3，8)</code>;<br>② session2执行select … for update语句，同样会<code>加上间隙锁（3，8)</code>，间隙锁之间不会冲突，因此这个语句可以执行成功;<br>③ session 2试图插入一行(5, ‘宋红康’, ‘二班’)，被session 1的间隙锁挡住了，只好<code>进入等待</code>；</p>
<p>④ session 1试图插入一行(5. 宋红康’二班)，被session2的间隙锁挡住了。至此，两个session陷入<code>死锁</code>。</p>
<p><strong><font color=bule>代码演示：</font></strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#############################SessionA####################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span> lock <span class="keyword">in</span> share mode; #为id<span class="operator">=</span><span class="number">5</span>加间隙锁</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#############################SessionB####################################</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; #为id<span class="operator">=</span><span class="number">5</span>加间隙锁</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>); #id<span class="operator">=</span><span class="number">7</span>在间隙区间</span><br><span class="line">#阻塞...</span><br><span class="line"></span><br><span class="line">###########################SessionA######################################</span><br><span class="line">#出现了死锁，也可能在B中出现</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;Jane&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>); </span><br><span class="line">ERROR <span class="number">1213</span> (<span class="number">40001</span>): Deadlock found <span class="keyword">when</span> trying <span class="keyword">to</span> <span class="keyword">get</span> lock; try restarting transaction</span><br><span class="line"></span><br><span class="line">##########################SessionB##################################</span><br><span class="line">#出现死锁后，按照策略，让A回滚，从而B中的<span class="keyword">Insert</span>执行成功<span class="operator">~</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>); </span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p><font color=red>分析：为什么会出现 死锁呢？</font></p>
<p>当SessionA中执行Insert，就会造成：B中Insert在等A中的间隙锁的释放~ A中的Insert在等B中间隙锁的释放~ （因为只有释放后，这俩各自的Insert才会继续执行）。从而A和B相互等待，就产生了<code>死锁</code></p>
<p>那为啥发生死锁后，A执行失败，B又成功执行了呢？(参见 3.6其它锁之:死锁)</p>
<p>这涉及MySQL的处理死锁机制。当MySQL发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务（将持有最少行级排他锁的事务进行回滚），让其他事务得以继续执行！</p>
<h5 id="③-临键锁（Next-Key-Locks）"><a href="#③-临键锁（Next-Key-Locks）" class="headerlink" title="③ 临键锁（Next-Key Locks）"></a><font color=orange>③ 临键锁（Next-Key Locks）</font></h5><p>有时候既想 <code>锁住某条记录</code> ，又想 <code>阻止 </code>其他事务在该记录前边的 <code>间隙插入新记录</code> ，所以InnoDB就提出了一种称之为 <code>Next-Key Locks</code> 的锁，官方的类型名称为： <code>LOCK_ORDINARY</code> ，我们也可以简称为<code>next-key锁</code> 。Next-Key Locks是在存储引擎 <code>innodb</code>、事务级别在 <code>可重复读</code> 的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。</p>
<p>比如，把id值为8的那条记录加一个next-key锁的示意图如下:</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335320.png"></p>
<p><code>next-key</code>锁的本质就是一个<code>记录锁</code>和一个<code>gap锁</code>的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的<code>间隙</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">8</span> <span class="keyword">and</span> id <span class="operator">&gt;</span> <span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p><font color=blue>代码演示</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#############################SessionA####################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># 为(<span class="number">8</span>，,<span class="number">15</span>]加邻键锁（<span class="number">8</span><span class="number">-15</span>是间隙 <span class="operator">+</span> <span class="number">15</span>记录锁）</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">15</span> <span class="keyword">and</span> id <span class="operator">&gt;</span> <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> class  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> 赵六   <span class="operator">|</span> 二班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#############################SessionB####################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">15</span> lock <span class="keyword">in</span> share mode; #无法获取S锁</span><br><span class="line"><span class="operator">^</span>C<span class="operator">^</span>C <span class="comment">-- query aborted</span></span><br><span class="line">ERROR <span class="number">1317</span> (<span class="number">70100</span>): Query execution was interrupted</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">15</span> <span class="keyword">for</span> <span class="keyword">update</span>; #无法获取X锁</span><br><span class="line"><span class="operator">^</span>C<span class="operator">^</span>C <span class="comment">-- query aborted</span></span><br><span class="line">ERROR <span class="number">1317</span> (<span class="number">70100</span>): Query execution was interrupted</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">12</span>,<span class="string">&#x27;Tim&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>); #无法在间隙内插入数据</span><br><span class="line"><span class="operator">^</span>C<span class="operator">^</span>C <span class="comment">-- query aborted</span></span><br><span class="line">ERROR <span class="number">1317</span> (<span class="number">70100</span>): Query execution was interrupted</span><br><span class="line">    </span><br><span class="line">###############################SessionA<span class="operator">&amp;</span>SessionB#######################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h5 id="④-插入意向锁（Insert-Intention-Locks）"><a href="#④-插入意向锁（Insert-Intention-Locks）" class="headerlink" title="④ 插入意向锁（Insert Intention Locks）"></a><font color=orange>④ 插入意向锁（Insert Intention Locks）</font></h5><p>我们说一个事务在 <code>插入</code> 一条记录时需要判断一下插入位置是不是被别的事务加了 <code>gap锁</code> （ <code>next-key</code>锁也包含 <code>gap锁</code> ），如果有的话，插入操作需要等待，直到拥有 <code>gap锁</code> 的那个事务提交。但是InnoDB &#x3D;&#x3D;规定事务在等待的时候也需要在内存中生成一个锁结构&#x3D;&#x3D;，表明有事务想在某个 <code>间隙</code> 中 插入 <code>新记录</code>，但是现在在等待。InnoDB就把这种类型的锁命名为 <code>Insert Intention Locks</code> ，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们称为 <code>插入意向锁</code> 。&#x3D;&#x3D;插入意向锁是一种 <code>Gap锁</code> ，不是意向锁&#x3D;&#x3D;，在insert操作时产生。</p>
<blockquote>
<p>插入意向锁是在插入一条记录行前，由 INSERT 操作产生的一种间隙锁<br>事实上插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</p>
</blockquote>
<p>插入意向锁是在插入一条记录行前，由&#x3D;&#x3D;INSERT 操作产生的一种间隙锁&#x3D;&#x3D;。该锁用以表示<code>插入意向</code>，当多个事务在同一区间(gap）插入<code>位置不同</code>的多条数据时，事务之间<code>不需要互相等待</code>。假设存在两条值分别为8和15的记录，两个不同的事务分别试图插入值为11和12的两条记录，每个事务在获取插入行上独占的(排他）锁前，都会获取(8，15）之间的间隙锁，但是因为数据行之间并<code>不冲突</code>，所以两个事务之间并不会产生冲突（<code>阻塞等待</code>)。总结来说，插入意向锁的特性可以分成两部分：</p>
<p>(1）&#x3D;&#x3D;插入意向锁是一种特殊的间隙锁&#x3D;&#x3D;―—间隙锁可以锁定开区间内的部分记录。<br>(2）&#x3D;&#x3D;插入意向锁之间互不排斥&#x3D;&#x3D;，所以即使多个事务在同一区间插入多条记录，只要记录本身(主键、唯一索引)<code>不冲突</code>，那么事务之间就不会出现冲突等待</p>
<p>注意，虽然插入意向锁中含有意向锁三个字，但是它并不属于意向锁而属于间隙锁，因为意向锁是表锁而插入意向锁是行锁</p>
<p>比如，把id值为8的那条记录加一个插入意向锁的示意图如下:</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335409.png" alt="image-20230126151811673"></p>
<p>比如，现在T1为id值为8的记录加了一个gap锁，然后T2和T3分别想向student表中插入id值分别为4、5的两条记录，所以现在为id值为8的记录加的锁的示意图就如下所示:</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335546.png" alt="image-20230126151840355"></p>
<p>从图中可以看到，由于<code>T1持有gap锁</code>，所以<code>T2和T3</code>需要<code>生成一个插入意向锁</code>的锁结构并且处于<code>等待</code>状态。当T1提交后会把它获取到的锁都释放掉，这样T2和T3就能<code>获取</code>到对应的插入意向锁了(本质上就是把插入意向锁对应锁结构的is_waiting属性改为false)，T2和T3之间也并不会相互阻塞，它们可以<code>同时</code>获取到id值为8的插入意向锁，然后执行插入操作。事实上&#x3D;&#x3D;插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。&#x3D;&#x3D;</p>
<p><strong><font color=blue>演示-插入意向锁</font></strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">###############################SessionA####################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">12</span> <span class="keyword">for</span> <span class="keyword">update</span>; #加间隙锁</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">###############################SessionB####################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">12</span>,<span class="string">&#x27;Tim&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>); </span><br><span class="line">#阻塞..同时会加插入意向锁</span><br><span class="line"></span><br><span class="line">##############################SessionC###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">11</span>,<span class="string">&#x27;Tim&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>);</span><br><span class="line">#阻塞..同时会加插入意向锁。 可以看出插入意向锁是相互兼容的，毕竟id都不同嘛</span><br><span class="line"></span><br><span class="line">##############################SessionA#################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>; #提交</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">#############################SessionB###############################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">12</span>,<span class="string">&#x27;Tim&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>); #插入成功</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">45.43</span> sec)</span><br><span class="line">##############################SessionC#################################</span><br><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,class) <span class="keyword">values</span>(<span class="number">11</span>,<span class="string">&#x27;Tim&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>); #插入成功</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h4 id="3-页锁"><a href="#3-页锁" class="headerlink" title="3. 页锁"></a>3. 页锁</h4><p>页锁就是在 <code>页的粒度</code> 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。&#x3D;&#x3D;页锁的开销介于表锁和行锁之间，会出现<code>死锁</code>。锁定粒度介于表锁和行锁之间，并发度一般&#x3D;&#x3D;。</p>
<p>每个层级的锁数量是有限制的，因为锁会占用内存空间， <code>锁空间的大小是有限的</code> 。当某个层级的锁数量超过了这个层级的阈值时，就会进行 <code>锁升级</code> 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中<code>行锁升级为表锁</code>，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p>
<p><font color=blue>死锁演示：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">事务A目前锁定了页A，想要锁定页B才可以执行完。</span><br><span class="line">事务B目前锁定了页B，想要锁定页A才可以执行完。</span><br><span class="line">### 死锁</span><br></pre></td></tr></table></figure>



<h3 id="3-3-从对待锁的态度划分-乐观锁、悲观锁"><a href="#3-3-从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="3.3 从对待锁的态度划分:乐观锁、悲观锁"></a>3.3 从对待锁的态度划分:乐观锁、悲观锁</h3><p>从对待锁的态度来看锁的话，可以将锁分成<code>乐观锁</code>和<code>悲观锁</code>，从名字中也可以看出这两种锁是两种看待<code>数据并发的思维方式</code> 。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的 <code>设计思想</code> 。</p>
<h4 id="1-悲观锁（Pessimistic-Locking）"><a href="#1-悲观锁（Pessimistic-Locking）" class="headerlink" title="1. 悲观锁（Pessimistic Locking）"></a>1. 悲观锁（Pessimistic Locking）</h4><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的<code>锁机制</code>来实现，从而保证数据操作的排它性。</p>
<p>悲观锁总是假设<code>最坏</code>的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 <code>阻塞</code> 直到它拿到锁（&#x3D;&#x3D;共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程&#x3D;&#x3D;）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中 <code>synchronized</code>和 <code>ReentrantLock </code>等独占锁就是悲观锁思想的实现。</p>
<p><strong><font color=blue>秒杀案例1：</font></strong><br>商品秒杀过程中，库存数量的减少，避免出现<code>超卖</code>的情况。比如，商品表中有一个字段为quantity表示当前该商品的库存量。假设商品为华为mate40，id为1001，quantity&#x3D;100个。如果不使用锁的情况下，操作方法如下所示:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#第<span class="number">1</span>步:查出商品库存</span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1001</span> ;</span><br><span class="line">#第<span class="number">2</span>步:如果库存大于<span class="number">0</span>，则根据商品信息生产订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders (item_id）<span class="keyword">values</span> ( <span class="number">1001</span> ) ;</span><br><span class="line">#第<span class="number">3</span>步:修改商品的库存，num表示购买数量</span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity <span class="operator">=</span> quantity<span class="operator">-</span>num <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1001</span> ;</span><br></pre></td></tr></table></figure>

<p>这样写的话，在并发量小的公司没有大的问题，但是如果在 <code>高并发环境</code> 下可能出现以下问题</p>
<table>
<thead>
<tr>
<th></th>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>step1(查询还有100部手机)</td>
<td>step1(查询还有100部手机)</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>step2(生成订单)</td>
</tr>
<tr>
<td>3</td>
<td>step2(生成订单)</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>step3(减库存1)</td>
</tr>
<tr>
<td>5</td>
<td>step3(减库存2)</td>
<td></td>
</tr>
</tbody></table>
<p>其中线程B此时已经下单并且减完库存，这个时候线程A依然去执行step3，就可能会造成<code>超卖</code>。</p>
<p>我们使用悲观锁可以解决这个问题，商品信息从查询出来到修改，中间有一个生成订单的过程，使用悲观锁的原理就是，&#x3D;&#x3D;在查询items信息后就把当前的数据锁定，直到修改完毕后再解锁&#x3D;&#x3D;。那么整个过程中，因为数据被锁定了，就不会出现有第三者来对其进行修改了。而这样做的前提是<code>需要将要执行的SQL语句放在同一个事务中</code>，否则达不到锁定数据行的目的。</p>
<p><strong>修改如下:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#第<span class="number">1</span>步:查出商品库存</span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1001</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">#第<span class="number">2</span>步:如果库存大于<span class="number">0</span>，则根据商品信息生产订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders (item_id)<span class="keyword">values</span>(<span class="number">1001</span>);</span><br><span class="line">#第<span class="number">3</span>步:修改商品的库存，num表示购买数量</span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity <span class="operator">=</span> quantity<span class="operator">-</span>num <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1001</span> ;</span><br></pre></td></tr></table></figure>

<p><code>select … for update</code> 是MySQL中悲观锁。 此时在items表中，id为1001的那条数据就被锁定了，其他的要执行<code>select quantity from items where id = 1001 for update;</code>语句的事务必须等本次事务提交之后才能执行。这样可以保证当前的数据不会被其它事务修改。</p>
<blockquote>
<p>注意，当执行select quantity from items where id &#x3D; 1001 for update;语句之后，如果在其他事务中执行select quantity from items where id &#x3D; 1001;语句，并不会受第一个事务的影响，仍然可以正常查询出数据。</p>
</blockquote>
<p>另外，<font color=red>select … for update语句执行过程中所有扫描的行都会被锁上，因此在MySQL中用悲观锁必须确定使用了索引，而不是全表扫描，否则将会把整个表锁住（表锁）</font>。</p>
<blockquote>
<p>InnoDB 行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据 InnoDB 才使用行级锁，否则 InnoDB 将使用表锁~</p>
</blockquote>
<p>悲观锁不适用的场景较多，它存在一些不足，因为悲观锁大多数情况下依靠数据库的锁机制来实现，以保证程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是 <code>长事务</code> 而言，这样的 <code>开销往往无法承受</code>，这时就需要乐观锁。</p>
<h4 id="2-乐观锁（Optimistic-Locking）"><a href="#2-乐观锁（Optimistic-Locking）" class="headerlink" title="2. 乐观锁（Optimistic Locking）"></a>2. 乐观锁（Optimistic Locking）</h4><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是&#x3D;&#x3D;不采用数据库自身的锁机制，而是通过程序来实现&#x3D;&#x3D;。在程序上，可以采用 <code>版本号机制</code> 或者 <code>CAS机制</code> 实现。&#x3D;&#x3D;乐观锁适用于<code>多读</code>的应用类型，这样可以提高吞吐量&#x3D;&#x3D;。在Java中<code>java.util.concurrent.atomic</code> 包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p>
<p><strong><font color=orange>1. 乐观锁的版本号机制</font></strong></p>
<p>在表中设计一个 <code>版本字段 version</code> ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行 <code>UPDATE ... SET version = version + 1 WHERE version=version</code> 。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p>
<p>这种方式类似我们熟悉的SVN、CVS版本管理系统，当修改了代码进行提交时，首先会检查当前版本号与服务器上的版本号是否一致，如果一致就可以直接提交，如果不一致就需要更新服务器上的最新代码，然后再进行提交。</p>
<p><strong><font color=orange>2. 乐观锁的时间戳机制</font></strong></p>
<p>时间戳和版本号机制一样，也是在更新提交的时候，将<code>当前数据的时间戳和更新之前取得的时间戳</code>进行比较，如果两者一致则更新成功，否则就是版本冲突。</p>
<p>能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳(版本号或者时间戳)，从而证明当前拿到的数据是否最新。</p>
<p><font color=blue>秒杀案例2</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#第<span class="number">1</span>步:查出商品库存</span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line">#第<span class="number">2</span>步:如果库存大于<span class="number">0</span>，则根据商品信息生产订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders (item_id）<span class="keyword">values</span> (<span class="number">1001</span>);</span><br><span class="line"></span><br><span class="line">#第<span class="number">3</span>步:修改商品的库存,num表示购买数量</span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity <span class="operator">=</span> quantity<span class="operator">-</span>num , version <span class="operator">=</span> version<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1001</span> <span class="keyword">and</span> version <span class="operator">=</span> #&#123;version&#125; ;</span><br></pre></td></tr></table></figure>

<p>注意，如果数据表是 <code>读写分离</code> (主写从读)的表，当matser表中写入的数据没有及时同步到slave表中时，会造成更新一直失败的问题。此时需要<code>强制读取master表</code>中的数据（即将select语句放到事务中即可，这时候查询的就是master主库了)</p>
<p>如果对同一条数据进行 <code>频繁的修改</code> 的话，那么就会出现这么一种场景，每次修改都只有一个事务能更新成功，在业务感知上面就有大量的失败操作。我们把代码修改如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#第<span class="number">1</span>步:查出商品库存</span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line">#第<span class="number">2</span>步:如果库存大于<span class="number">0</span>，则根据商品信息生产订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders (item_id)<span class="keyword">values</span>(<span class="number">1001</span>);</span><br><span class="line"></span><br><span class="line">#第<span class="number">3</span>步:修改商品的库存，num表示购买数量</span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity <span class="operator">=</span> quantity<span class="operator">-</span>num <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1001</span> <span class="keyword">and</span> quantity<span class="operator">-</span>num <span class="operator">&gt;</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>这样就会使每次修改都能成功，而且不会出现超卖的现象。</p>
<p><strong><font color=orange>3. 两种锁的适用场景</font></strong></p>
<p>从这两种锁的设计思想中，总结一下乐观锁和悲观锁的适用场景：</p>
<ol>
<li><p><code>乐观锁</code> 适合 <code>读操作多</code> 的场景，相对来说写的操作比较少。它的优点在于<code>程序实现</code> ，<code>不存在死锁</code> 问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</p>
</li>
<li><p><code>悲观锁</code> 适合 <code>写操作多</code> 的场景，因为写的操作具有 <code>排它性</code> 。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止 <code>读 - 写</code> 和 <code>写 - 写</code> 的冲突。</p>
</li>
</ol>
<p>把乐观锁和悲观锁总结如下图所示</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335691.png" alt="image-20230127145003149"></p>
<h3 id="3-4-按加锁的方式划分-显式锁、隐式锁"><a href="#3-4-按加锁的方式划分-显式锁、隐式锁" class="headerlink" title="3.4 按加锁的方式划分:显式锁、隐式锁"></a>3.4 按加锁的方式划分:显式锁、隐式锁</h3><h4 id="1-隐式锁"><a href="#1-隐式锁" class="headerlink" title="1. 隐式锁"></a>1. 隐式锁</h4><blockquote>
<p><strong>回顾</strong></p>
<p>一个事务在执行<code>INSERT</code>操作时，如果即将插入的<code>间隙</code>已经被其他事务加了<code>gap锁</code>，那么本次<code>INSERT</code>操作会阻塞，并且当前事务会在该间隙上加一个<code>插入意向锁</code>。【被动加锁】</p>
<p>否则，一般情况下，新插入一条记录的操作并不加锁（后面会推翻这个结论，<font color=red>严格来说是加锁的，隐式锁</font>）【主动加锁】</p>
</blockquote>
<p>那如果一个事务首先插入了一条记录（此时并没有在内存生产与该记录关联的锁结构)，然后另一个事务:</p>
<ul>
<li>立即使用<code>SELECT … LOCK IN SHARE MODE</code>语句读取这条记录，也就是要获取这条记录的<code>S锁</code>，或者使用<code>SELECT… FOR UPDATE</code>语句读取这条记录，也就是要获取这条记录的<code>X锁</code>，怎么办?<br>如果允许这种情况的发生，那么可能产生<code>脏读</code>问题。</li>
<li>立即修改这条记录，也就是要获取这条记录的<code>X锁</code>，怎么办?<br>如果允许这种情况的发生，那么可能产生<code>脏写</code>问题。</li>
</ul>
<p>这时候前边提过的<code>事务id</code>又要起作用了。把聚簇索引和二级索引中的记录分开看一下：（原理了解即可）</p>
<p><strong>情景一：</strong>对于聚簇索引记录来说，有一个<code>trx_id </code>隐藏列，该隐藏列记录着最后改动该记录的 <code>事务id</code> 。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 <code>trx_id</code> 隐藏列代表的的就是当前事务的 <code>事务id</code> ，如果其他事务此时想对该记录添加 <code>S锁</code> 或者 <code>X锁</code> 时，首先会看一下该记录的<code>trx_id</code> 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就<code>帮助</code>当前事务创建一个 <code>X锁</code> （也就是为当前事务创建一个锁结构， <code>is_waiting</code> 属性是 <code>false</code>），然后自己进入阻塞状态（也就是为自己也创建一个锁结构， <code>is_waiting</code>属性是 <code>true </code>）。<br><strong>情景二：</strong>对于二级索引记录来说，本身并没有<code>trx_id</code> 隐藏列，但是在二级索引页面的 Page Header 部分有一个 <code>PAGE_MAX_TRX_ID</code> 属性，该属性代表对该页面做改动的最大的 <code>事务id</code> ，如果 <code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活跃 <code>事务id</code> ，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复 <code>情景一</code> 的做法。<br>即：&#x3D;&#x3D;一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于<code>事务id</code>的存在，相当于加了一个隐式锁&#x3D;&#x3D;。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种<code>延迟加锁</code>的机制，从而来减少加锁的数量。</p>
<p>隐式锁在实际内存对象中并不含有这个锁信息。&#x3D;&#x3D;只有当产生锁等待时，隐式锁转化为显式锁&#x3D;&#x3D;。</p>
<p>InnoDB的insert操作，对插入的记录不加锁，但是此时如果另一个线程进行当前读，类似以下的用例，整个过程会发生什么呢 ?</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">############################SessionA#########################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">12</span>,<span class="string">&#x27;关羽&#x27;</span>,<span class="string">&#x27;三班&#x27;</span>); #此时相当于会加个隐式锁</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">###########################SessionC###############################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> performance_schema.data_lock_waits\G; #隐式锁是查不到的</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">##########################SessionB################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student lock <span class="keyword">in</span> share mode;  #可以侧面得出结论，隐式锁是存在的<span class="operator">~</span></span><br><span class="line">#阻塞... #阻塞也会导致A中的隐式锁转为显示锁</span><br><span class="line"></span><br><span class="line">##########################SessionC###################################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> performance_schema.data_lock_waits\G; #查到由隐式锁转的显示锁</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">                          ENGINE: INNODB</span><br><span class="line">       REQUESTING_ENGINE_LOCK_ID: <span class="number">140078105288944</span>:<span class="number">47</span>:<span class="number">4</span>:<span class="number">10</span>:<span class="number">140078009627240</span></span><br><span class="line">REQUESTING_ENGINE_TRANSACTION_ID: <span class="number">421553081999600</span></span><br><span class="line">            REQUESTING_THREAD_ID: <span class="number">49</span></span><br><span class="line">             REQUESTING_EVENT_ID: <span class="number">25</span></span><br><span class="line">REQUESTING_OBJECT_INSTANCE_BEGIN: <span class="number">140078009627240</span></span><br><span class="line">         BLOCKING_ENGINE_LOCK_ID: <span class="number">140078105288088</span>:<span class="number">47</span>:<span class="number">4</span>:<span class="number">10</span>:<span class="number">140078009620736</span></span><br><span class="line">  BLOCKING_ENGINE_TRANSACTION_ID: <span class="number">17430</span></span><br><span class="line">              BLOCKING_THREAD_ID: <span class="number">49</span></span><br><span class="line">               BLOCKING_EVENT_ID: <span class="number">25</span></span><br><span class="line">  BLOCKING_OBJECT_INSTANCE_BEGIN: <span class="number">140078009620736</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p><strong>隐式锁的逻辑过程如下：</strong></p>
<p>A. InnoDB的每条记录中都一个隐含的<code>trx_id</code>字段，这个字段存在于聚簇索引的B+Tree中。<br>B. 在操作一条记录前，首先根据记录中的<code>trx_id</code>检查该事务是否是活动的事务(未提交或回滚)。如果是活动的事务，首先将 &#x3D;&#x3D;隐式锁 转换为 显式锁&#x3D;&#x3D; (就是为该事务添加一个锁)。<br>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为<code>waiting</code>状态。如果没有冲突不加锁，跳到E。<br>D. 等待加锁成功，被唤醒，或者超时。<br>E. 写数据，并将自己的 <code>事务id</code> 写入trx_id字段。</p>
<h4 id="2-显式锁"><a href="#2-显式锁" class="headerlink" title="2. 显式锁"></a>2. 显式锁</h4><p>通过特定的语句进行加锁，一般称之为显示加锁，例如:</p>
<ul>
<li>显示加共享锁：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ....lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>

<ul>
<li>显示加排它锁：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ....<span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-其它锁之：全局锁"><a href="#3-5-其它锁之：全局锁" class="headerlink" title="3.5 其它锁之：全局锁"></a>3.5 其它锁之：全局锁</h3><p>全局锁就是对<code>整个数据库实例</code>加锁。当你需要让整个库处于<code>只读状态</code>的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句(数据的增删改)、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用<code>场景</code>是：做<code>全库逻辑备份</code>。</p>
<p>全局锁的命令:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></table></figure>

<h3 id="3-6-其它锁之：死锁"><a href="#3-6-其它锁之：死锁" class="headerlink" title="3.6 其它锁之：死锁"></a>3.6 其它锁之：死锁</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性<code>循环</code>。死锁举例如下：</p>
<p><strong>举例一：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>start transaction;<br/>update account set money&#x3D;10 where id&#x3D;1;</td>
<td>start transaction;</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>update account set money&#x3D;10 where id&#x3D;2:</td>
</tr>
<tr>
<td>3</td>
<td>update account set money&#x3D;20 where id&#x3D;2:</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>update account set money&#x3D;20 where id&#x3D;1;</td>
</tr>
</tbody></table>
<p>这时候，事务1在等待事务2释放id&#x3D;2的行锁，而事务2在等待事务1释放id&#x3D;1的行锁。 事务1和事务2在<code>互相等待</code>对方的资源释放，就是进入了<code>死锁</code>状态。当出现死锁以后，有两种策略 ：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数<code>innodb_lock_wait_timeout </code>来设置。</li>
<li>另一种策略是，发起<code>死锁检测</code>，发现死锁后，主动回滚死锁链条中的某一个事务（<code>将持有最少行级排他锁的事务进行回滚</code>），让其他事务得以继续执行。将参数<code>innodb_deadlock_detect </code>设置为<code>on </code>，表示开启这个逻辑。</li>
</ul>
<p>在InnoDB中，innodb_lock_wait_timeout的默认值是<code>50s</code>，意味着如果采用第一个策略，当出现死锁以后,第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p>
<p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p><strong>举例二：</strong></p>
<p>用户A给用户B转账100，在此同时，用户B也给用户A转账100。这个过程，可能导致死锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#事务<span class="number">1</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">108</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;#操作<span class="number">1</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>);#操作<span class="number">3</span></span><br><span class="line"></span><br><span class="line">#事务<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;#操作<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;#操作<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335741.png" alt="image-20230127162458138"></p>
<h4 id="2-产生死锁的必要条件"><a href="#2-产生死锁的必要条件" class="headerlink" title="2. 产生死锁的必要条件"></a>2. 产生死锁的必要条件</h4><ol>
<li>两个或者两个以上事务</li>
<li>每个事务都已经持有锁并且申请新的锁</li>
<li>锁资源同时只能被同一个事务持有或者不兼容</li>
<li>事务之间因为持有锁和申请锁导致彼此循环等待</li>
</ol>
<blockquote>
<p>死锁的关键在于:两个(或以上)的Session加锁的顺序不一致。</p>
</blockquote>
<p><strong><font color=blue>演示—死锁</font></strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#####################################SessionA########################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; #为<span class="number">1</span>d<span class="operator">=</span><span class="number">1</span>的加X锁</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">###################################SessionB########################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>; #为id<span class="operator">=</span><span class="number">3</span>的加X锁</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">######################################SessionA###########################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>; #想要获取id为<span class="number">3</span>的X锁</span><br><span class="line">#阻塞...</span><br><span class="line"></span><br><span class="line">#####################################SessionB####################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; #想要获取id为<span class="number">1</span>的X锁</span><br><span class="line">ERROR <span class="number">1213</span> (<span class="number">40001</span>): Deadlock found <span class="keyword">when</span> trying <span class="keyword">to</span> <span class="keyword">get</span> lock; #出现死锁</span><br><span class="line"></span><br><span class="line">#################################SessionA############################</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>; #阻塞解开，继续执行</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">18.39</span> sec) # 具体死锁为啥会被解开，下面会讲哦<span class="operator">~</span></span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="3-如何处理死锁"><a href="#3-如何处理死锁" class="headerlink" title="3. 如何处理死锁"></a>3. 如何处理死锁</h4><p><font color=orange><strong>方式1：</strong>等待，直到超时( innodb_lock_wait_timeout&#x3D;50s)</font></p>
<p>即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其<code>回滚</code>，另外事务继续进行。这种方法简单有效，在innodb中，参数<code>innodb_lock_wait_timeout</code>用来设置超时时间。</p>
<p>缺点：对于在线服务来说，这个等待时间往往是无法接受的。</p>
<p>那将此值修改短一些，比如1s，0.1s是否合适？不合适，容易误伤到普通的锁等待。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_lock_wait_timeout&#x27;</span>;;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name            <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_lock_wait_timeout <span class="operator">|</span> <span class="number">50</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p><font color=orange><strong>方式2：</strong>使用死锁检测进行死锁处理</font></p>
<p>方式1检测死锁太过被动，innodb还提供了<code>wait-for graph</code>算法来主动进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。</p>
<p>这是一种较为<code>主动的死锁检测机制</code>，要求数据库<code>保存锁的信息链表</code>和<code>事务等待链表</code>两部分信息。</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335843.png" alt="image-20230127163322402"></p>
<p>基于这两个信息，可以绘制wait-for graph 等待图</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335890.png" alt="image-20230127163339663"></p>
<blockquote>
<p>死锁检测的原理是构建一个以<code>事务为顶点、锁为边的有向图</code>，判断有向图是否存在<code>环</code>，存在即有死锁</p>
</blockquote>
<p>一旦检测到<code>回路</code>、有死锁，这时候InnoDB存储引擎会选择<code>回滚undo量最小的事务</code>，让其他事务继续执行( <code>innodb_deadlock_detect=on</code>表示开启这个逻辑)。</p>
<p>缺点：每个新的被阻塞的线程，都要判断是不是由于自己的加入导致了死锁，这个操作时间复杂度是O(n)。如果100个并发线程同时更新同一行，意味着要检测100*100&#x3D; 1万次，1万个线程就会有1千万次检测。</p>
<p><strong>如何解决？</strong></p>
<ul>
<li>方式1：关闭死锁检测，但意味着可能会出现大量的超时，会导致业务有损。</li>
<li>方式2：控制并发访问的数量。比如在中间件中实现对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作</li>
</ul>
<blockquote>
<p>进一步的思路：可以考虑通过<code>将一行改成逻辑上的多行</code>来减少锁冲突。比如，连锁超市账户总额的记录，可以考虑放到多条记录上。账户总额等于这多个记录的值的总和。</p>
</blockquote>
<h4 id="4-如何避免死锁"><a href="#4-如何避免死锁" class="headerlink" title="4. 如何避免死锁"></a>4. 如何避免死锁</h4><ul>
<li><code>合理设计索引</code>，使业务SQL尽可能通过索引定位更少的行，减少锁竞争。</li>
<li><code>调整业务逻辑SQL执行顺序</code>，避免update&#x2F;delete长时间持有锁的SQL在事务前面。</li>
<li>避免大事务，<code>尽量将大事务拆成多个小事务来处理</code>，小事务缩短锁定资源的时间，发生锁冲突的几率也更小</li>
<li><code>在并发比较高的系统中，不要显式加锁</code>，特别是是在事务里显式加锁。如select … for<br>update语句，如果是在事务里运行了start transaction或设置了autocommit等于0，那么就会锁定所查找到的记录</li>
<li><code>降低隔离级别</code>。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。</li>
</ul>
<h2 id="4-锁的内存结构"><a href="#4-锁的内存结构" class="headerlink" title="4. 锁的内存结构"></a>4. 锁的内存结构</h2><p>前边说对一条记录加锁的本质就是在内存中创建一个<code>锁结构</code>与之关联，那么是不是一个事务对多条记录加锁，就要创建多个<code>锁结构</code>呢?比如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#事务T1</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>

<p>理论上创建多个<code>锁结构</code>没问题，但是如果一个事务要获取10000条记录的锁，生成10000个锁结构也太崩溃了! 所以决定在对不同记录加锁时，如果符合下边这些条件的记录会放到一个<code>锁结构</code>中。</p>
<ul>
<li>在同一个事务中进行加锁操作</li>
<li>被加锁的记录在同一个页面中</li>
<li>加锁的类型是一样的</li>
<li>等待状态是一样的</li>
</ul>
<p><code>InnoDB</code>存储引擎中的<code>锁结构</code>如下:</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335999.png" alt="image-20230127222432726"></p>
<p>结构解析：</p>
<ol>
<li><code>锁所在的事务信息 ：</code></li>
</ol>
<p>不论是 <code>表锁</code> 还是 <code>行锁</code> ，都是在事务执行过程中生成的，哪个事务生成了这个 <code>锁结构</code> ，这里就记录这个事务的信息。</p>
<p>此锁所在的事务信息 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p>
<ol start="2">
<li><code>索引信息 ：</code></li>
</ol>
<p>对于 <code>行锁</code> 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p>
<ol start="3">
<li><code>表锁／行锁信息 ：</code></li>
</ol>
<p><code>表锁结构</code> 和 <code>行锁结构</code> 在这个位置的内容是不同的：</p>
<ul>
<li>表锁：记载着是对哪个表加的锁，还有其他的一些信息。</li>
<li>行锁：记载了三个重要的信息：<ul>
<li><code>Space ID</code> ：记录所在表空间。</li>
<li><code>Page Number</code> ：记录所在页号。</li>
<li><code>n_bits</code> ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，<code>这个n_bits 属性代表使用了多少比特位</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后也不至于重新分配锁结构</p>
</blockquote>
<ol start="4">
<li><code>type_mode ：</code></li>
</ol>
<p>这是一个32位的数，被分成了 <code>lock_mode </code>、 <code>lock_type </code>和 <code>rec_lock_type </code>三个部分，如图所示：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202301272335161.png" alt="image-20230127222846678"></p>
<ul>
<li>锁的模式（<code>lock_mode </code>），占用低4位，可选的值如下：<ul>
<li><code>LOCK_IS </code>（十进制的<code>0</code> ）：表示共享意向锁，也就是<code>IS锁</code></li>
<li><code>LOCK_IX </code>（十进制的<code>1</code> ）：表示独占意向锁，也就是<code>IX锁</code> 。</li>
<li><code>LOCK_S </code>（十进制的<code>2</code> ）：表示共享锁，也就是<code>S锁</code> 。</li>
<li><code>LOCK_X </code>（十进制的<code>3</code> ）：表示独占锁，也就是<code>X锁</code> 。</li>
<li><code>LOCK_AUTO_INC </code>（十进制的<code>4</code> ）：表示AUTO-INC锁 。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在InnoDB存储引擎中，LOCK_IS,LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式</p>
</blockquote>
<ul>
<li>锁的类型（<code>lock_type </code>），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul>
<li><code>LOCK_TABLE </code>（十进制的16 ），也就是当第5个比特位置为1时，表示表级锁。</li>
<li><code>LOCK_REC </code>（十进制的32 ），也就是当第6个比特位置为1时，表示行级锁。</li>
</ul>
</li>
<li>行锁的具体类型（<code>rec_lock_type </code>），使用其余的位来表示。只有在<code>lock_type </code>的值为<code>LOCK_REC </code>时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul>
<li><code>LOCK_ORDINARY </code>（十进制的<code>0 </code>）：表示<code>next-key</code>锁 。</li>
<li><code>LOCK_GAP </code>（十进制的<code>512 </code>）：也就是当第10个比特位置为1时，表示<code>gap锁</code> </li>
<li><code>LOCK_REC_NOT_GAP </code>（十进制的<code>1024 </code>）：也就是当第11个比特位置为<code>1</code>时，表示<code>正经记录锁</code> </li>
<li><code>LOCK_INSERT_INTENTION </code>（十进制的<code>2048</code>）：也就是当第12个比特位置为1时，表示<code>插入意向锁</code>。其他的类型：还有一些不常用的类型我们就不多说了。</li>
</ul>
</li>
<li><code>is_waiting </code>属性呢？基于内存空间的节省，所以把<code>is_waiting </code>属性放到了<code>type_mode </code>这个32位的数字中：<ul>
<li><code>LOCK_WAIT </code>（十进制的<code>256 </code>） ：当第9个比特位置为 1 时，表示<code>is_waiting </code>为<code>true </code>，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示<code>is_waiting </code>为<code>false </code>，也就是当前事务获取锁成功。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><p><code>其他信息</code> ：为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p>
</li>
<li><p><code>一堆比特位</code> ：</p>
</li>
</ol>
<p>如果是 <code>行锁结构</code> 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 <code>n_bits </code>属性表示的。InnoDB数据页中的每条记录在 <code>记录头信息</code> 中都包含一个 <code>heap_no </code>属性，伪记录 <code>Infimum </code>的<code>heap_no </code>值为<code>0 </code>， <code>Supremum </code>的 <code>heap_no </code>值为 <code>1 </code>，之后每插入一条记录， <code>heap_no </code>值就增1。 <code>锁结构</code> 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 <code>heap_no </code>，即一个比特位映射到页内的一条记录。</p>
<h2 id="5-锁监控"><a href="#5-锁监控" class="headerlink" title="5. 锁监控"></a>5. 锁监控</h2><p>关于MySQL锁的监控，我们一般可以通过检查 InnoDB_row_lock 等状态变量来分析系统上的行锁的争夺情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                 <span class="operator">|</span> <span class="keyword">Value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_current_waits <span class="operator">|</span> <span class="number">0</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time          <span class="operator">|</span> <span class="number">129831</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time_avg      <span class="operator">|</span> <span class="number">18547</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time_max      <span class="operator">|</span> <span class="number">51095</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_waits         <span class="operator">|</span> <span class="number">7</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+--------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>对各个状态量的说明如下：</p>
<ul>
<li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li>
<li><code>Innodb_row_lock_time </code>：从系统启动到现在锁定总时间长度；（等待总时长）</li>
<li><code>Innodb_row_lock_time_avg </code>：每次等待所花平均时间；（等待平均时长）</li>
<li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li>
<li><code>Innodb_row_lock_waits </code>：系统启动后到现在总共等待的次数；（等待总次数）</li>
</ul>
<p>对于这5个状态变量，比较重要的3个见上面（橙色）</p>
<p><strong>其他监控方法：</strong></p>
<p>MySQL把事务和锁的信息记录在了 <code>information_schema </code>库中，涉及到的三张表分别是<code>INNODB_TRX </code>、 <code>INNODB_LOCKS </code>和 <code>INNODB_LOCK_WAITS </code>。</p>
<p><code>MySQL5.7及之前</code> ，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况</p>
<p>MySQL8.0删除了<code>information_schema.INNODB_LOCKS</code>，添加了 performance_schema.data_locks ，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p>
<p>同时,information_schema.INNODB_LOCK_WAITS也被 <code>performance_schema.data_lock_waits</code> 所代替。</p>
<h2 id="6-附录"><a href="#6-附录" class="headerlink" title="6. 附录"></a>6. 附录</h2><blockquote>
<p>主要补充间隙锁加锁规则，共11个案例~ 感兴趣的小伙伴可以参考老师讲课的课件，这部分很全</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.dalicoding.fun">Leo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.dalicoding.fun/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC13%E7%AB%A0_%E9%94%81/">https://blog.dalicoding.fun/2024/04/05/MySQL从入门到入土/第13章_锁/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.dalicoding.fun" target="_blank">Leo的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202404041655138.jpg" target="_blank"><img class="post-qr-code-img" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202404041655138.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202404041655057.jpg" target="_blank"><img class="post-qr-code-img" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202404041655057.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC12%E7%AB%A0_MySQL%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/" title="十二、MySQL事务日志"><img class="cover" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">十二、MySQL事务日志</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC14%E7%AB%A0_%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" title="十四、多版本并发控制"><img class="cover" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">十四、多版本并发控制</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC01%E7%AB%A0_MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/" title="一、MySQL的数据目录"><img class="cover" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">一、MySQL的数据目录</div></div></a></div><div><a href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC02%E7%AB%A0_%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90/" title="二、逻辑架构剖析"><img class="cover" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909521.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">二、逻辑架构剖析</div></div></a></div><div><a href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC03%E7%AB%A0_%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" title="三、存储引擎"><img class="cover" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">三、存储引擎</div></div></a></div><div><a href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC04%E7%AB%A0_%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="四、索引的数据结构"><img class="cover" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909521.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">四、索引的数据结构</div></div></a></div><div><a href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC05%E7%AB%A0_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/" title="五、InnoDB数据存储结构"><img class="cover" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909521.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">五、InnoDB数据存储结构</div></div></a></div><div><a href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC06%E7%AB%A0_%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="六、索引的创建与设计原则"><img class="cover" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909053.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">六、索引的创建与设计原则</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403221853832.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Leo</div><div class="author-info__description">Leo的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LiXuYangISZ"><i class="fab fa-github"></i><span>🛴前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LiXuYangISZ" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/img/WeChatQRCode.jpg" target="_blank" title="icon-weixin"><i class="微信" style="color: faa-tada;"></i></a><a class="social-icon" href="https://res.abeim.cn/api/qq/?qq=2422737092" target="_blank" title="icon-QQ"><i class="QQ" style="color: faa-tada;"></i></a><a class="social-icon" href="https://space.bilibili.com/434261812" target="_blank" title="icon-bilibili"><i class="B站" style="color: faa-tada;"></i></a><a class="social-icon" href="mailto:2422737092@qq.com" target="_blank" title="icon-youxiang"><i class="QQ邮箱" style="color: faa-tada;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center>主域名：<br><a href="https://blog.dalicoding.fun"><b><font color="#5ea6e5">欢迎来到Leo的博客~</font></b></a></center></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-MySQL%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%9B%B8%E5%90%8C%E8%AE%B0%E5%BD%95"><span class="toc-text">2. MySQL并发事务访问相同记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%AF%BB-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="toc-text">2.1 读-读情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%86%99-%E5%86%99%E6%83%85%E5%86%B5"><span class="toc-text">2.2 写-写情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%AF%BB-%E5%86%99%E6%88%96%E5%86%99-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="toc-text">2.3 读-写或写-读情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">2.4 并发问题的解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%94%81%E7%9A%84%E4%B8%8D%E5%90%8C%E8%A7%92%E5%BA%A6%E5%88%86%E7%B1%BB"><span class="toc-text">3. 锁的不同角度分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86-%E8%AF%BB%E9%94%81%E3%80%81%E5%86%99%E9%94%81"><span class="toc-text">3.1从数据操作的类型划分:读锁、写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-text">1. 锁定读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text">2. 写操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%92%E5%88%86-%E8%A1%A8%E7%BA%A7%E9%94%81%E3%80%81%E9%A1%B5%E7%BA%A7%E9%94%81%E3%80%81%E8%A1%8C%E9%94%81"><span class="toc-text">3.2 从数据操作的粒度划分:表级锁、页级锁、行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%A1%A8%E9%94%81-Table-Lock"><span class="toc-text">1. 表锁(Table Lock)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E8%A1%A8%E7%BA%A7%E5%88%AB%E7%9A%84S%E9%94%81%E3%80%81X%E9%94%81"><span class="toc-text">① 表级别的S锁、X锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E6%84%8F%E5%90%91%E9%94%81-%EF%BC%88intention-lock%EF%BC%89"><span class="toc-text">② 意向锁 （intention lock）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E8%87%AA%E5%A2%9E%E9%94%81%EF%BC%88AUTO-INC%E9%94%81%EF%BC%89"><span class="toc-text">③ 自增锁（AUTO-INC锁）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%EF%BC%88MDL%E9%94%81%EF%BC%89"><span class="toc-text">④ 元数据锁（MDL锁）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-InnoDB%E4%B8%AD%E7%9A%84%E8%A1%8C%E9%94%81"><span class="toc-text">2. InnoDB中的行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E8%AE%B0%E5%BD%95%E9%94%81%EF%BC%88Record-Locks%EF%BC%89"><span class="toc-text">① 记录锁（Record Locks）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Locks%EF%BC%89"><span class="toc-text">② 间隙锁（Gap Locks）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E4%B8%B4%E9%94%AE%E9%94%81%EF%BC%88Next-Key-Locks%EF%BC%89"><span class="toc-text">③ 临键锁（Next-Key Locks）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88Insert-Intention-Locks%EF%BC%89"><span class="toc-text">④ 插入意向锁（Insert Intention Locks）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%A1%B5%E9%94%81"><span class="toc-text">3. 页锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%BB%8E%E5%AF%B9%E5%BE%85%E9%94%81%E7%9A%84%E6%80%81%E5%BA%A6%E5%88%92%E5%88%86-%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">3.3 从对待锁的态度划分:乐观锁、悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%88Pessimistic-Locking%EF%BC%89"><span class="toc-text">1. 悲观锁（Pessimistic Locking）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%88Optimistic-Locking%EF%BC%89"><span class="toc-text">2. 乐观锁（Optimistic Locking）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%8C%89%E5%8A%A0%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%92%E5%88%86-%E6%98%BE%E5%BC%8F%E9%94%81%E3%80%81%E9%9A%90%E5%BC%8F%E9%94%81"><span class="toc-text">3.4 按加锁的方式划分:显式锁、隐式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9A%90%E5%BC%8F%E9%94%81"><span class="toc-text">1. 隐式锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%98%BE%E5%BC%8F%E9%94%81"><span class="toc-text">2. 显式锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%85%B6%E5%AE%83%E9%94%81%E4%B9%8B%EF%BC%9A%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-text">3.5 其它锁之：全局锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%85%B6%E5%AE%83%E9%94%81%E4%B9%8B%EF%BC%9A%E6%AD%BB%E9%94%81"><span class="toc-text">3.6 其它锁之：死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">2. 产生死锁的必要条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81"><span class="toc-text">3. 如何处理死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-text">4. 如何避免死锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%94%81%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-text">4. 锁的内存结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%94%81%E7%9B%91%E6%8E%A7"><span class="toc-text">5. 锁监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%99%84%E5%BD%95"><span class="toc-text">6. 附录</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/04/05/test/" title="测试文章"><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909053.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试文章"/></a><div class="content"><a class="title" href="/2024/04/05/test/" title="测试文章">测试文章</a><time datetime="2024-04-05T08:07:00.000Z" title="发表于 2024-04-05 16:07:00">2024-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC13%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="十三、垃圾回收器"><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十三、垃圾回收器"/></a><div class="content"><a class="title" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC13%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="十三、垃圾回收器">十三、垃圾回收器</a><time datetime="2024-04-05T07:45:13.000Z" title="发表于 2024-04-05 15:45:13">2024-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC12%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" title="十二、垃圾回收相关概念"><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十二、垃圾回收相关概念"/></a><div class="content"><a class="title" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC12%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" title="十二、垃圾回收相关概念">十二、垃圾回收相关概念</a><time datetime="2024-04-05T07:45:12.000Z" title="发表于 2024-04-05 15:45:12">2024-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC11%E7%AB%A0_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/" title="十一、垃圾回收相关算法"><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十一、垃圾回收相关算法"/></a><div class="content"><a class="title" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC11%E7%AB%A0_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/" title="十一、垃圾回收相关算法">十一、垃圾回收相关算法</a><time datetime="2024-04-05T07:45:11.000Z" title="发表于 2024-04-05 15:45:11">2024-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC10%E7%AB%A0_StringTable/" title="十、StringTable"><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十、StringTable"/></a><div class="content"><a class="title" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC10%E7%AB%A0_StringTable/" title="十、StringTable">十、StringTable</a><time datetime="2024-04-05T07:45:10.000Z" title="发表于 2024-04-05 15:45:10">2024-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Leo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><img  src="https://img.shields.io/badge/%E8%B1%ABICP%E5%A4%87-2023001225-%23c41b6c" title="本站已加入ICP豪华套餐，豫ICP备2023001225号"></a>&nbsp;   <a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://my-twikoo-orpin.vercel.app/',
      region: 'ap-hangzhou',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://my-twikoo-orpin.vercel.app/',
      region: 'ap-hangzhou',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://my-twikoo-orpin.vercel.app/',
        region: 'ap-hangzhou',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script defer src="/live2d-widget/autoload.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>