<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>五、InnoDB数据存储结构 | Leo的博客</title><meta name="author" content="Leo"><meta name="copyright" content="Leo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 数据的存储结构：页 1.1 磁盘与内存交互基本单位：页  1.2 页结构概述 1.3 页的大小 1.4 页的上层结构  2. 页的内部结构  2.1 File Header（文件头部）和File Trailer（文件尾部）2.1.1 File Header（文件头部）作用：描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等） 大小：38字节 构成：   FIL_PAGE_OFFSE">
<meta property="og:type" content="article">
<meta property="og:title" content="五、InnoDB数据存储结构">
<meta property="og:url" content="https://blog.dalicoding.fun/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC05%E7%AB%A0_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Leo的博客">
<meta property="og:description" content="1. 数据的存储结构：页 1.1 磁盘与内存交互基本单位：页  1.2 页结构概述 1.3 页的大小 1.4 页的上层结构  2. 页的内部结构  2.1 File Header（文件头部）和File Trailer（文件尾部）2.1.1 File Header（文件头部）作用：描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等） 大小：38字节 构成：   FIL_PAGE_OFFSE">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909521.jpg">
<meta property="article:published_time" content="2024-04-05T06:24:04.000Z">
<meta property="article:modified_time" content="2024-04-05T07:10:16.846Z">
<meta property="article:author" content="Leo">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909521.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.dalicoding.fun/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC05%E7%AB%A0_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"00PKU8B7R6","apiKey":"058cbcb1db57036717778c874da0ef87","indexName":"blog-leo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Leo","link":"链接: ","source":"来源: Leo的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '五、InnoDB数据存储结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-05 15:10:16'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/center-atom.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403221853832.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909521.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Leo的博客"><img class="site-icon" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202404041655130.png"/><span class="site-name">Leo的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">五、InnoDB数据存储结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-05T06:24:04.000Z" title="发表于 2024-04-05 14:24:04">2024-04-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-05T07:10:16.846Z" title="更新于 2024-04-05 15:10:16">2024-04-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="五、InnoDB数据存储结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-数据的存储结构：页"><a href="#1-数据的存储结构：页" class="headerlink" title="1. 数据的存储结构：页"></a>1. 数据的存储结构：页</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251415034.png" alt="image-20220724103054165"></p>
<h2 id="1-1-磁盘与内存交互基本单位：页"><a href="#1-1-磁盘与内存交互基本单位：页" class="headerlink" title="1.1 磁盘与内存交互基本单位：页"></a>1.1 磁盘与内存交互基本单位：页</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251415335.png" alt="image-20220724103337984"></p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251415197.png" alt="image-20220724103747719"></p>
<h2 id="1-2-页结构概述"><a href="#1-2-页结构概述" class="headerlink" title="1.2 页结构概述"></a>1.2 页结构概述</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251415916.png" alt="image-20220724104418653"></p>
<h2 id="1-3-页的大小"><a href="#1-3-页的大小" class="headerlink" title="1.3 页的大小"></a>1.3 页的大小</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251415071.png" alt="image-20220724104412027"></p>
<h2 id="1-4-页的上层结构"><a href="#1-4-页的上层结构" class="headerlink" title="1.4 页的上层结构"></a>1.4 页的上层结构</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416875.png" alt="image-20220724104918055"></p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416509.png" alt="image-20220724104825429"></p>
<h1 id="2-页的内部结构"><a href="#2-页的内部结构" class="headerlink" title="2. 页的内部结构"></a>2. 页的内部结构</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416468.png" alt="image-20220724111001675"></p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416267.png" alt="image-20220724110313834"></p>
<h2 id="2-1-File-Header（文件头部）和File-Trailer（文件尾部）"><a href="#2-1-File-Header（文件头部）和File-Trailer（文件尾部）" class="headerlink" title="2.1 File Header（文件头部）和File Trailer（文件尾部）"></a>2.1 File Header（文件头部）和File Trailer（文件尾部）</h2><h3 id="2-1-1-File-Header（文件头部）"><a href="#2-1-1-File-Header（文件头部）" class="headerlink" title="2.1.1 File Header（文件头部）"></a>2.1.1 File Header（文件头部）</h3><p><strong>作用：</strong>描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）</p>
<p><strong>大小：</strong>38字节</p>
<p><strong>构成：</strong></p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416558.bmp"></p>
<ul>
<li><p><strong><font color=green>FIL_PAGE_OFFSET（4字节）</font></strong></p>
<p>每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。</p>
</li>
<li><p><strong><font color=green>FIL_PAGE_TYPE（2字节）</font></strong></p>
<p>这个代表当前页的类型</p>
</li>
</ul>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416462.png" alt="image-20220724125956493"></p>
<ul>
<li><p><strong><font color=green>FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）</font></strong></p>
<p>InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。</p>
</li>
</ul>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416475.png" alt="image-20220724130103373"></p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416013.png" alt="image-20220724130110950"></p>
<ul>
<li><p><strong><font color=green>FIL_PAGE_SPACE_OR_CHKSUM（4字节）</font></strong></p>
<p>文件头部和文件尾部都有属性：<code>FIL_PAGE_SPACE_OR_CHKSUM</code></p>
<p><strong>作用：</strong><br>InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整。</p>
<p>&#x3D;&#x3D;为了检测一个页是否完整&#x3D;&#x3D;（也就是在同步的时候有没有发生只同步一半的尴尬情况），这时&#x3D;&#x3D;可以通过文件尾的校验和&#x3D;&#x3D;（checksum 值）&#x3D;&#x3D;与文件头的校验和做比对&#x3D;&#x3D;，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。</p>
<p><strong>具体的：</strong></p>
<p>每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，&#x3D;&#x3D;如果完全同步成功，则页的首部和尾部的校验和应该是一致的&#x3D;&#x3D;。如果写了一半儿断电了，那么在File Header中的校验和就代表着已经修改过的页，而在File Trailer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。这里，校验方式就是采用 &#x3D;&#x3D;Hash 算法&#x3D;&#x3D;进行校验。</p>
</li>
<li><p><strong><font color=green>FIL_PAGE_LSN（8字节）</font></strong></p>
<p>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</p>
</li>
</ul>
<h3 id="2-1-2-File-Trailer（文件尾部）"><a href="#2-1-2-File-Trailer（文件尾部）" class="headerlink" title="2.1.2 File Trailer（文件尾部）"></a>2.1.2 File Trailer（文件尾部）</h3><ul>
<li><p><strong><font color=green>前4个字节代表页的校验和：</font></strong><br>这个部分是和File Header中的校验和相对应的。</p>
</li>
<li><p><strong><font color=green>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：</font></strong></p>
<p>这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。</p>
</li>
</ul>
<h2 id="2-2-User-Records-用户记录-、最大最小记录、Free-Space-空闲空间"><a href="#2-2-User-Records-用户记录-、最大最小记录、Free-Space-空闲空间" class="headerlink" title="2.2 User Records(用户记录)、最大最小记录、Free Space(空闲空间)"></a>2.2 User Records(用户记录)、最大最小记录、Free Space(空闲空间)</h2><h3 id="2-2-1-Free-Space-空闲空间"><a href="#2-2-1-Free-Space-空闲空间" class="headerlink" title="2.2.1 Free Space (空闲空间)"></a>2.2.1 Free Space (空闲空间)</h3><p>我们自己存储的记录会按照指定的&#x3D;&#x3D;行格式&#x3D;&#x3D;存储到&#x3D;&#x3D;User Records&#x3D;&#x3D;部分。但是在一开始生成页的时候，其实并没有User Records这个部分，&#x3D;&#x3D;每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分&#x3D;&#x3D;，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去&#x3D;&#x3D;申请新的页&#x3D;&#x3D;了。</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416340.png" alt="image-20220724130814897"></p>
<h3 id="2-2-2-User-Records-用户记录"><a href="#2-2-2-User-Records-用户记录" class="headerlink" title="2.2.2 User Records (用户记录)"></a>2.2.2 User Records (用户记录)</h3><p>User Records中的这些记录按照&#x3D;&#x3D;指定的行格式&#x3D;&#x3D;一条一条摆在User Records部分，相互之间形成&#x3D;&#x3D;单链表&#x3D;&#x3D;。</p>
<p><strong>用户记录里的一条条数据如何记录？</strong></p>
<p>这里需要讲讲记录行格式的记录头信息。</p>
<h3 id="2-2-3-Infimum-Supremum（最小最大记录）"><a href="#2-2-3-Infimum-Supremum（最小最大记录）" class="headerlink" title="2.2.3 Infimum + Supremum（最小最大记录）"></a>2.2.3 Infimum + Supremum（最小最大记录）</h3><p><strong>记录可以比较大小吗？</strong></p>
<p>是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是&#x3D;&#x3D;比较主键&#x3D;&#x3D;的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。</p>
<p>InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的，如图所示：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416484.png" alt="image-20220724131119987"></p>
<p>这两条记录&#x3D;&#x3D;不是我们自己定义的记录&#x3D;&#x3D;，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分，如图所示：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416501.png" alt="image-20220724131133664"></p>
<h2 id="2-3-Page-Directory-页目录-、Page-Header-页面头部"><a href="#2-3-Page-Directory-页目录-、Page-Header-页面头部" class="headerlink" title="2.3 Page Directory(页目录)、Page Header(页面头部)"></a>2.3 Page Directory(页目录)、Page Header(页面头部)</h2><h3 id="2-3-1-Page-Directory（页目录）"><a href="#2-3-1-Page-Directory（页目录）" class="headerlink" title="2.3.1 Page Directory（页目录）"></a>2.3.1 Page Directory（页目录）</h3><p><font color=green><strong>1.为什么需要页目录？</strong></font></p>
<p>在页中，记录是以&#x3D;&#x3D;单向链表&#x3D;&#x3D;的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是&#x3D;&#x3D;检索效率不高&#x3D;&#x3D;，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，&#x3D;&#x3D;专门给记录做一个目录&#x3D;&#x3D;，通过&#x3D;&#x3D;二分查找&#x3D;&#x3D;法的方式进行检索，提升效率。</p>
<p>需求：根据主键值查找页中的某条记录，如何实现快速查找呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM page_demo WHERE c1 = 3;</span><br></pre></td></tr></table></figure>

<p><font color=red>方式1：顺序查找</font></p>
<p>从Infimum记录（最小记录）开始，沿着链表一直往后找，总有一天会找到（或者找不到），在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。</p>
<p>如果一个页中存储了非常多的记录，这么查找性能很差。</p>
<p><font color=red>方式2：使用页目录，二分法查找</font></p>
<ol>
<li><p>将所有的记录分成几个组，<strong>这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记</strong>录。</p>
<ul>
<li><p>第 1 组，也就是最小记录所在的分组只有 1 个记录；</p>
</li>
<li><p>最后一组，就是最大记录所在的分组，会有 1-8 条记录；</p>
</li>
<li><p>其余的组记录数量在 4-8 条之间。</p>
</li>
</ul>
<p>这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会&#x3D;&#x3D;尽量平分&#x3D;&#x3D;。</p>
</li>
<li><p>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 <code>n_owned</code> 字段。</p>
</li>
<li><p><font color=blue>页目录用来存储每组最后一条记录的地址偏移量</font>，这些地址偏移量会按照<font color=blue>先后顺序存储</font>起来，每组的地址偏移量也被称之为<font color=blue>槽（slot）</font>，每个槽相当于指针指向了不同组的最后一个记录。</p>
</li>
</ol>
<p>举例1：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416213.png" alt="image-20220724131400355"></p>
<p>举例2：</p>
<p>现在的page_demo表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录。如下图：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251416778.png" alt="image-20220724131423102"></p>
<p>从这个图中我们需要注意这么几点：</p>
<ul>
<li>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。</li>
<li>注意最小和最大记录的头信息中的n_owned属性<ul>
<li>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。</li>
<li>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</li>
</ul>
</li>
</ul>
<p>用箭头指向的方式替代数字，这样更易于我们理解，修改后如下：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417332.png" alt="image-20220724131446750"></p>
<p>再换个角度看一下：（单纯从逻辑上看一下这些记录和页目录的关系）</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417844.png" alt="image-20220724131513633"></p>
<p><font color=green><strong>2. 页目录分组的个数如何确定？</strong></font></p>
<p>为什么 上面例中 最小记录的n_owned值为1，而最大记录的n_owned值为5呢？</p>
<p>InnoDB规定：<strong>对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在1<del>8条之间，剩下的分组中记录的条数范围只能在是 4</del>8 条之间</strong>。</p>
<p>分组是按照下边的步骤进行的：</p>
<ul>
<li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li>
<li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li>
<li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li>
</ul>
<p><font color=green><strong>3. 页目录结构下如何快速查找记录？</strong></font></p>
<p>现在向page_demo表中添加更多的数据。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO page_demo </span><br><span class="line">VALUES</span><br><span class="line">(5, 500, &#x27;zhou&#x27;), </span><br><span class="line">(6, 600, &#x27;chen&#x27;), </span><br><span class="line">(7, 700, &#x27;deng&#x27;), </span><br><span class="line">(8, 800, &#x27;yang&#x27;), </span><br><span class="line">(9, 900, &#x27;wang&#x27;), </span><br><span class="line">(10, 1000, &#x27;zhao&#x27;), </span><br><span class="line">(11, 1100, &#x27;qian&#x27;), </span><br><span class="line">(12, 1200, &#x27;feng&#x27;), </span><br><span class="line">(13, 1300, &#x27;tang&#x27;), </span><br><span class="line">(14, 1400, &#x27;ding&#x27;), </span><br><span class="line">(15, 1500, &#x27;jing&#x27;), </span><br><span class="line">(16, 1600, &#x27;quan&#x27;);</span><br></pre></td></tr></table></figure>

<p>添加了12条记录，现在页里一共有18条记录了（包括最小和最大记录），这些记录被分成了5个组，如图所示：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417557.png" alt="image-20220724152747713"></p>
<p>这里只保留了16条记录的记录头信息中的n_owned和next_record属性，省略了各个记录之间的箭头。</p>
<p>现在看怎么从这个页目录中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用二分法来进行快速查找。5个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low&#x3D;0，最高的槽就是high&#x3D;4。比方说我们想<font color=blue>找主键值为6的记录</font>，过程是这样的：</p>
<ol>
<li>计算中间槽的位置：(0+4)&#x2F;2&#x3D;2，所以查看槽2对应记录的主键值为8，又因为8 &gt; 6，所以设置high&#x3D;2，low保持不变。</li>
<li>重新计算中间槽的位置：(0+2)&#x2F;2&#x3D;1，所以查看槽1对应的主键值为4，又因为4 &lt; 6，所以设置low&#x3D;1，high保持不变。</li>
<li>因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中。此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。</li>
</ol>
<p>但是我们前边又说过，&#x3D;&#x3D;每个槽对应的记录都是该组中主键值最大的记录&#x3D;&#x3D;，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。</p>
<p>由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</p>
<p><strong>小结：</strong></p>
<p>在一个数据页中查找指定主键值的记录的过程分为两步：</p>
<ol>
<li>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。</li>
<li>通过记录的<code>next_record</code>属性遍历该槽所在的组中的各个记录。</li>
</ol>
<h3 id="2-3-2-Page-Header（页面头部）"><a href="#2-3-2-Page-Header（页面头部）" class="headerlink" title="2.3.2 Page Header（页面头部）"></a>2.3.2 Page Header（页面头部）</h3><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417062.png" alt="image-20220724153112168"></p>
<ul>
<li><p>PAGE_DIRECTION</p>
<p>假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是PAGE_DIRECTION。</p>
</li>
<li><p>PAGE_N_DIRECTION</p>
<p>假设连续几次插入新记录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。</p>
</li>
</ul>
<h2 id="2-4-从数据页的角度看B-树如何查询"><a href="#2-4-从数据页的角度看B-树如何查询" class="headerlink" title="2.4 从数据页的角度看B+树如何查询"></a>2.4 从数据页的角度看B+树如何查询</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417757.png" alt="image-20220724123214937"></p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417428.png" alt="image-20220724123449401"></p>
<h1 id="3-InnoDB行格式（或记录格式）"><a href="#3-InnoDB行格式（或记录格式）" class="headerlink" title="3. InnoDB行格式（或记录格式）"></a>3. InnoDB行格式（或记录格式）</h1><h2 id="3-1-指定行格式的语法"><a href="#3-1-指定行格式的语法" class="headerlink" title="3.1 指定行格式的语法"></a>3.1 指定行格式的语法</h2><p>在创建或修改表的语句中指定行格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称 # 创建</span><br><span class="line">ALTER TABLE 表名 ROW_FORMAT=行格式名称 # 修改</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE record_test_table (</span><br><span class="line">    -&gt;     col1 VARCHAR(8),</span><br><span class="line">    -&gt;     col2 VARCHAR(8) NOT NULL,</span><br><span class="line">    -&gt;     col3 CHAR(8),</span><br><span class="line">    -&gt;     col4 VARCHAR(8)</span><br><span class="line">    -&gt; ) CHARSET=ascii ROW_FORMAT=COMPACT;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>向表中插入两条记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO record_test_table(col1, col2, col3, col4) </span><br><span class="line">VALUES</span><br><span class="line">(&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;wangwu&#x27;, &#x27;songhk&#x27;), </span><br><span class="line">(&#x27;tong&#x27;, &#x27;chen&#x27;, NULL, NULL);</span><br></pre></td></tr></table></figure>

<h2 id="3-2-COMPACT行格式"><a href="#3-2-COMPACT行格式" class="headerlink" title="3.2 COMPACT行格式"></a>3.2 COMPACT行格式</h2><p>在MySQL 5.1版本中，&#x3D;&#x3D;默认设置为Compact行格式&#x3D;&#x3D;。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417467.png" alt="image-20220725090341137"></p>
<h3 id="3-2-1-变长字段长度列表"><a href="#3-2-1-变长字段长度列表" class="headerlink" title="3.2.1 变长字段长度列表"></a>3.2.1 变长字段长度列表</h3><p>MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为&#x3D;&#x3D;变长字段&#x3D;&#x3D;，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。&#x3D;&#x3D;在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表&#x3D;&#x3D;。</p>
<p>注意：这里面存储的变长长度和字段&#x3D;&#x3D;顺序是反过来的&#x3D;&#x3D;。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。</p>
<p>以record_test_table表中的第一条记录举例：因为record_test_table表的col1、col2、col4列都是VARCHAR(8)类型的，所以这三个列的值的长度都需要保存在记录开头处，注意record_test_table表中的各个列都使用的是ascii字符集（每个字符只需要1个字节来进行编码，如果是UTF-8，则需要3个字节哦~ ~~）</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417716.png" alt="image-20220725085822376"></p>
<p>又因为这些长度值需要按照列的逆序存放，所以最后变长字段长度列表的字节串用十六进制表示的效果就是（各个字节之间实际上没有空格，用空格隔开只是方便理解）：<br>06 04 08 </p>
<p>把这个字节串组成的变长字段长度列表填入上边的示意图中的效果就是：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417011.png" alt="image-20220725085836023"></p>
<h3 id="3-2-2-NULL值列表"><a href="#3-2-2-NULL值列表" class="headerlink" title="3.2.2 NULL值列表"></a>3.2.2 NULL值列表</h3><p>Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了。</p>
<p><strong>为什么定义NULL值列表？</strong></p>
<p>之所以要存储NULL是因为数据都是需要对齐的，如果&#x3D;&#x3D;没有标注出来NULL值&#x3D;&#x3D;的位置，就有可能在查询数据的时候&#x3D;&#x3D;出现混乱&#x3D;&#x3D;。如果使&#x3D;&#x3D;用一个特定的符号&#x3D;&#x3D;放到相应的数据位表示空置的话，虽然能达到效果，但是这样很&#x3D;&#x3D;浪费空间&#x3D;&#x3D;，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，格式如下：</p>
<ul>
<li><p>二进制位的值为1时，代表该列的值为NULL。</p>
</li>
<li><p>二进制位的值为0时，代表该列的值不为NULL。</p>
</li>
</ul>
<p>例如：字段 a、b、c，其中a是主键，在某一行中存储的数依次是 a&#x3D;1、b&#x3D;null、c&#x3D;2。那么Compact行格式中的NULL值列表中存储：01。第一个0表示c不为null，第二个1表示b是null。这里之所以没有a是因为数据库会自动跳过主键，因为主键肯定是非NULL且唯一的，在NULL值列表的数据中就会自动跳过主键。</p>
<p>record_test_table的两条记录的NULL值列表就如下：</p>
<p>第一条记录：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417444.png" alt="image-20220725090200671"></p>
<p>第二条记录：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417659.png" alt="image-20220725090210661"></p>
<h3 id="3-2-3-记录头信息（5字节）"><a href="#3-2-3-记录头信息（5字节）" class="headerlink" title="3.2.3 记录头信息（5字节）"></a>3.2.3 记录头信息（5字节）</h3><p><strong><font color=blue>1. 记录头信息概述</font></strong></p>
<p>创建表page_demo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE page_demo(</span><br><span class="line">    -&gt;     c1 INT,</span><br><span class="line">    -&gt;     c2 INT,</span><br><span class="line">    -&gt;     c3 VARCHAR(10000),</span><br><span class="line">    -&gt;     PRIMARY KEY (c1)</span><br><span class="line">    -&gt; ) CHARSET=ascii ROW_FORMAT=Compact;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>这个表中记录的行格式示意图：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417972.png" alt="image-20220724170923339"></p>
<p>这些记录头信息中各个属性如下：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417949.png" alt="image-20220724170944226"></p>
<p>简化后的行格式示意图：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251421140.png" alt="image-20220724171000430"></p>
<p>插入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO page_demo </span><br><span class="line">VALUES</span><br><span class="line">(1, 100, &#x27;song&#x27;), </span><br><span class="line">(2, 200, &#x27;tong&#x27;), </span><br><span class="line">(3, 300, &#x27;zhan&#x27;), </span><br><span class="line">(4, 400, &#x27;lisi&#x27;);</span><br></pre></td></tr></table></figure>

<p>图示如下：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417875.png" alt="image-20220724171028579"></p>
<p>注：为啥编号是从2开始的，因为默认会有一个最小记录和最大记录</p>
<p><strong><font color=blue>2. 头信息中各个属性详细分析</font></strong></p>
<ul>
<li><p><strong><font color=green>delete_mask</font></strong></p>
<p>这个属性标记着当前记录是否被删除，占用1个二进制位。</p>
<ul>
<li><p>值为0：代表记录并没有被删除</p>
</li>
<li><p>值为1：代表记录被删除掉了</p>
</li>
</ul>
<p><font color=red><strong>被删除的记录为什么还在页中存储呢？</strong></font></p>
<p>你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其他的记录在磁盘上需要&#x3D;&#x3D;重新排列，导致性能消耗&#x3D;&#x3D;。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的&#x3D;&#x3D;垃圾链表&#x3D;&#x3D;，在这个链表中的记录占用的空间称之为&#x3D;&#x3D;可重用空间&#x3D;&#x3D;，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉</p>
</li>
<li><p><strong><font color=green>min_rec_mask</font></strong></p>
<p>B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。</p>
<p>我们自己插入的四条记录的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录。</p>
</li>
<li><p><strong><font color=green>record_type</font></strong></p>
<p>这个属性表示当前记录的类型，一共有4种类型的记录：</p>
<ul>
<li><p>0：表示普通记录</p>
</li>
<li><p>1：表示B+树非叶节点记录</p>
</li>
<li><p>2：表示最小记录</p>
</li>
<li><p>3：表示最大记录</p>
</li>
</ul>
<p>从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的record_type值都是0，而最小记录和最大记录的record_type值分别为2和3。至于record_type为1的情况，我们在索引的数据结构章节讲过。</p>
</li>
<li><p><strong><font color=green>heap_no</font></strong></p>
<p>这个属性表示当前记录在本页中的位置。</p>
<p>从图中可以看出来，我们插入的4条记录在本页中的位置分别是：2、3、4、5。</p>
<p><font color=red>怎么不见heap_no值为0和1的记录呢？</font></p>
<p>MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为&#x3D;&#x3D;伪记录&#x3D;&#x3D;或者&#x3D;&#x3D;虚拟记录&#x3D;&#x3D;。这两个伪记录一个代表&#x3D;&#x3D;最小记录&#x3D;&#x3D;，一个代表&#x3D;&#x3D;最大记录&#x3D;&#x3D;。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前。</p>
</li>
<li><p><strong><font color=green>n_owned</font></strong></p>
<p>页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。 详情见page directory。</p>
</li>
<li><p><strong><font color=green>next_record</font></strong></p>
<p>记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的&#x3D;&#x3D;地址偏移量&#x3D;&#x3D;。</p>
<p>比如：第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。</p>
<p>注意，<strong>下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录</strong>。而且规定Infimum记录（也就是最小记录）的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum记录（也就是最大记录）。下图用箭头代替偏移量表示next_record。</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251417284.png" alt="image-20220724173342146"></p>
</li>
</ul>
<p><strong><font color=blue>3. 演示删除和添加操作</font></strong></p>
<p>&#x3D;&#x3D;删除操作：&#x3D;&#x3D;</p>
<p>从表中删除掉一条记录，这个链表也是会跟着变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM page_demo WHERE c1 = 2;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br></pre></td></tr></table></figure>

<p>删掉第2条记录后的示意图就是：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418963.png" alt="image-20220724173857326"></p>
<p>从图中可以看出来，删除第2条记录前后主要发生了这些变化：</p>
<ul>
<li>第2条记录并没有从存储空间中移除，而是把该条记录的<code>delete_mask</code>值设置为1。</li>
<li>第2条记录的<code>next_record</code>值变为了0，意味着该记录没有下一条记录了。</li>
<li>第1条记录的<code>next_record</code>指向了第3条记录。</li>
<li>最大记录的<code>n_owned</code>值从 5 变成了 4 。</li>
</ul>
<p><font color=red>所以，不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的</font>。</p>
<p>&#x3D;&#x3D;添加操作：&#x3D;&#x3D;</p>
<p>主键值为2的记录被我们删掉了，但是存储空间却没有回收，如果我们再次把这条记录插入到表中，会发生什么事呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO page_demo VALUES(2, 200, &#x27;tong&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>我们看一下记录的存储情况：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418651.png" alt="image-20220724173938500"></p>
<p><strong><font color=blue>直接复用了原来被删除记录的存储空间</font>。</strong></p>
<p><strong>说明：</strong>当数据页中存在多条被删除掉的记录时，这些记录的<code>next_record</code>属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。</p>
<h3 id="3-2-4-记录真实的数据"><a href="#3-2-4-记录真实的数据" class="headerlink" title="3.2.4 记录真实的数据"></a>3.2.4 记录真实的数据</h3><p>记录的真实数据除了我们自己定义的列的数据以外，还会有三个隐藏列：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418835.png" alt="image-20220725090426277"></p>
<p>实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR。</p>
<ul>
<li>&#x3D;&#x3D;一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键&#x3D;&#x3D;。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。</li>
<li>事务ID和回滚指针在后面的《第14章_MySQL事务日志》章节中讲解。</li>
</ul>
<p>举例：分析Compact行记录的内部结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytest(</span><br><span class="line">    col1 VARCHAR(10),</span><br><span class="line">    col2 VARCHAR(10),</span><br><span class="line">    col3 CHAR(10),</span><br><span class="line">    col4 VARCHAR(10)</span><br><span class="line">)ENGINE=INNODB CHARSET=LATIN1 ROW_FORMAT=COMPACT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO mytest</span><br><span class="line">VALUES(&#x27;a&#x27;,&#x27;bb&#x27;,&#x27;bb&#x27;,&#x27;ccc&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO mytest</span><br><span class="line">VALUES(&#x27;d&#x27;,&#x27;ee&#x27;,&#x27;ee&#x27;,&#x27;fff&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO mytest</span><br><span class="line">VALUES(&#x27;d&#x27;,NULL,NULL,&#x27;fff&#x27;);</span><br></pre></td></tr></table></figure>

<p>在Windows操作系统下，可以选择通过程序UltraEdit打开表空间文件mytest.ibd这个二进制文件。内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">0000c070 73 75 70 72 65 6d 75 6d 03 02 01 00 00 00 10 00|supremum........|</span><br><span class="line">0000c080 2c 00 00 00 2b 68 00 00 00 00 00 06 05 80 00 00|,...+h..........|</span><br><span class="line">0000c090 00 32 01 10 61 62 62 62 62 20 20 20 20 20 20 20|.2..abbbb|</span><br><span class="line">0000c0a0 20 63 63 63 03 02 01 00 00 00 18 00 2b 00 00 00|ccc........+...|</span><br><span class="line">0000c0b0 2b 68 01 00 00 00 00 06 06 80 00 00 00 32 01 10|+h...........2..|</span><br><span class="line">0000c0c0 64 65 65 65 65 20 20 20 20 20 20 20 20 66 66 66|deeeefff|</span><br><span class="line">0000c0d0 03 01 06 00 00 20 ff 98 00 00 00 2b 68 02 00 00|..........+h...|</span><br><span class="line">0000c0e0 00 00 06 07 80 00 00 00 32 01 10 64 66 66 66 00|........2..dfff.|</span><br><span class="line">------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418739.png"></p>
<p>该行记录从0000c078开始，参考下面的，相信大家会有更好的理解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------------------</span><br><span class="line">03 02 01                     /*变长字段长度列表，逆序*/</span><br><span class="line">00                              /*NULL标志位，第一行没有NULL值*/</span><br><span class="line">00 00 10 00 2c            /*Record Header，固定5字节长度*/</span><br><span class="line">00 00 00 2b 68 00       /*RowID InnoDB自动创建，6字节*/</span><br><span class="line">00 00 00 00 06 05       /*TransactionID*/</span><br><span class="line">80 00 00 00 32 01 10   /*Roll Pointer*/</span><br><span class="line">61                               /*列1数据&#x27;a&#x27;*/</span><br><span class="line">62 62                          /*列2数据&#x27;bb&#x27;*/</span><br><span class="line">62 62 20 20 20 20 20 20 20 20/*列3数据&#x27;bb&#x27;*/</span><br><span class="line">63 63 63                     /*列4数据&#x27;ccc&#x27;*/</span><br><span class="line">---------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>注意1：InnoDB每行有隐藏列TransactionID和Roll Pointer。:<br>注意2：固定长度CHAR字段在未能完全占用其长度空间时，会用0x20 （也就是空格）来进行填充。</p>
<p>接着再来分析下Record Header的最后两个字节，这两个字节代表next_recorder，0x2c代表下一个记录的偏移量，即当前记录的位置加上偏移量0x2c就是下条记录的起始位置。</p>
<p>第二行将不做整理，除了RowID不同外，它和第一行大同小异，现在来分析有NULL值的第三行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------------------</span><br><span class="line">03 01                               /*变长字段长度列表，逆序*/</span><br><span class="line">06                                   /*NULL标志位，第三行有NULL值*/</span><br><span class="line">00 00 20 ff 98                  /*Record Header*/</span><br><span class="line">00 00 00 2b 68 02           /*RowID*/</span><br><span class="line">00 00 00 00 06 07           /*TransactionID*/</span><br><span class="line">80 00 00 00 32 01 10       /*Roll Pointer*/</span><br><span class="line">64                                   /*列1数据&#x27;d&#x27;*/</span><br><span class="line">66 66 66                         /*列4数据&#x27;fff&#x27;*/</span><br><span class="line">---------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>第三行有NULL值，因此NULL标志位不再是00而是06，转换成二进制为00000110，为1的值代表第2列和第3列的数据为NULL。在其后存储列数据的部分，用户会发现没有存储NULL列，而只存储了第1列和第4列非NULL的值。</p>
<p>因此这个例子很好地说明了：&#x3D;&#x3D;不管是CHAR类型还是VARCHAR类型，在compact格式下NULL值都不占用任何存储空间&#x3D;&#x3D;</p>
<h2 id="3-3-Dynamic和Compressed行格式"><a href="#3-3-Dynamic和Compressed行格式" class="headerlink" title="3.3 Dynamic和Compressed行格式"></a>3.3 Dynamic和Compressed行格式</h2><h3 id="3-3-1-行溢出"><a href="#3-3-1-行溢出" class="headerlink" title="3.3.1 行溢出"></a>3.3.1 行溢出</h3><p><strong><font color=red>InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。</font></strong></p>
<p>很多DBA喜欢MySQL数据库提供的VARCHAR(M)类型，认为可以存放65535字节。这是真的吗？如果我们使用 ascii字符集的话，一个字符就代表一个字节，我们看看VARCHAR(65535)是否可用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE  TABLE  varchar_size_demo(</span><br><span class="line"> c  VARCHAR(65535)</span><br><span class="line"> )  CHARSET=ascii  ROW_FORMAT=Compact;</span><br><span class="line"># 结果如下：</span><br><span class="line">ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have  to  change  some  columns  to  TEXT or  BLOBs</span><br></pre></td></tr></table></figure>

<p>报错信息表达的意思是：MySQL对一条记录占用的最大存储空间是有限制的，&#x3D;&#x3D;除BLOB或者TEXT类型的列之外， 其他所有的列&#x3D;&#x3D;（不包括隐藏列和记录头信息）&#x3D;&#x3D;占用的字节长度加起来不能超过65535个字节&#x3D;&#x3D;</p>
<p>这个65535个字节除了列本身的数据之外，还包括一些其他的数据，以Compact行格式为例，比如说我们为了存储一个VARCHAR(M)类型的列，除了真实数据占有空间以外，还需要记录的额外信息。</p>
<p>如果该VARCHAR类型的列没有NOT NULL属性，那&#x3D;&#x3D;最多只能存储65532个字节的数据&#x3D;&#x3D;，因为变长字段的长度占用 2个字节，NULL值标识需要占用1个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE  TABLE  varchar_size_demo(</span><br><span class="line">    c  VARCHAR(65532)</span><br><span class="line">)  CHARSET=ascii  ROW_FORMAT=Compact; # 可以创建成功</span><br></pre></td></tr></table></figure>

<p>如果有not null属性，那么就不需要NULL值标识，也就可以多存储一个字节，即65533个字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE  TABLE  varchar_size_demo( </span><br><span class="line">  c  VARCHAR(65533)  not  null</span><br><span class="line">)  CHARSET=ascii  ROW_FORMAT=Compact; # 可以创建成功</span><br></pre></td></tr></table></figure>

<p>通过上面的案例，我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能出现一个页存放不了一条记录，这种现象称为&#x3D;&#x3D;行溢出&#x3D;&#x3D;</p>
<p>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行&#x3D;&#x3D;分页存储&#x3D;&#x3D;，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。</p>
<p>这称为页的扩展，举例如下：</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418556.png" alt="image-20220725091306108"></p>
<h3 id="3-3-2-Dynamic和Compressed行格式"><a href="#3-3-2-Dynamic和Compressed行格式" class="headerlink" title="3.3.2 Dynamic和Compressed行格式"></a>3.3.2 Dynamic和Compressed行格式</h3><p>在MySQL 8.0中，&#x3D;&#x3D;默认行格式就是Dynamic&#x3D;&#x3D;，Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧：</p>
<ul>
<li>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。</li>
<li>Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。</li>
</ul>
<p>Compressed行记录格式的另一个功能就是，存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储。</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418052.png" alt="image-20220725091327355"></p>
<h2 id="3-4-Redundant行格式"><a href="#3-4-Redundant行格式" class="headerlink" title="3.4 Redundant行格式"></a>3.4 Redundant行格式</h2><p>Redundant是MySQL 5.0版本之前InnoDB的行记录存储方式，MySQL 5.0支持Redundant是为了兼容之前版本的页格式。</p>
<p>现在我们把表record_test_table的行格式修改为Redundant：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE record_test_table ROW_FORMAT=Redundant;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418548.png" alt="image-20220725091402259"></p>
<p>从上图可以看到，不同于Compact行记录格式，Redundant行格式的首部是一个字段长度偏移列表，同样是按照列的顺序&#x3D;&#x3D;逆序放置&#x3D;&#x3D;的。</p>
<p>下边我们从各个方面看一下Redundant行格式有什么不同的地方。</p>
<h3 id="3-4-1-字段长度偏移列表"><a href="#3-4-1-字段长度偏移列表" class="headerlink" title="3.4.1 字段长度偏移列表"></a>3.4.1 字段长度偏移列表</h3><p>注意Compact行格式的开头是变长字段长度列表，而Redundant行格式的开头是字段长度偏移列表，与变长字段长度列表有两处不同：</p>
<ul>
<li>少了“变长”两个字：Redundant行格式会把该条记录中所有列（包括隐藏列）的长度信息都按照逆序存储到&#x3D;&#x3D;字段长度偏移列表&#x3D;&#x3D;</li>
<li>多了“偏移”两个字：这意味着计算列值长度的方式不像Compact行格式那么直观，它是采用两个相邻数值的差值来计算&#x3D;&#x3D;各个列值&#x3D;&#x3D;的长度</li>
</ul>
<p>举例：比如第一条记录的字段长度偏移列表就是：<br>2B 25 1F 1B 13 0C 06</p>
<p>因为它是逆序排放的，所以按照列的顺序排列就是：<br>06 0C 13 17 1A 24 25</p>
<p>按照两个相邻数值的差值来计算各个列值的长度的意思就是：</p>
<ul>
<li>第一列(row_id)的长度就是 0x06个字节，也就是6个字节。</li>
<li>第二列(transaction_id)的长度就是 (0x0C - 0x06)个字节，也就是6个字节。</li>
<li>第三列(roll_pointer)的长度就是 (0x13 - 0x0C)个字节，也就是7个字节。</li>
<li>第四列(col1)的长度就是 (0x1B - 0x13)个字节，也就是8个字节。</li>
<li>第五列(col2)的长度就是 (0x1F - 0x1B)个字节，也就是4个字节。</li>
<li>第六列(col3)的长度就是 (0x25 - 0x1F)个字节，也就是6个字节。</li>
<li>第七列(col4)的长度就是 (0x2B - 0x25)个字节，也就是6个字节。</li>
</ul>
<h3 id="3-4-2-记录头信息（record-header）"><a href="#3-4-2-记录头信息（record-header）" class="headerlink" title="3.4.2 记录头信息（record header）"></a>3.4.2 记录头信息（record header）</h3><p>不同于Compact行格式，Redundant行格式中的记录头信息固定占用6个字节（48位），每位的含义见下表</p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418853.jpeg"></p>
<p>与Compact行格式的记录头信息对比来看，有两处不同：（下面的解释，了解即可）</p>
<ul>
<li>Redundant行格式多了<code>n_field</code>和<code>1byte_offs_flag</code>这两个属性。</li>
<li>Redundant行格式没有record_type这个属性。</li>
</ul>
<p>其中，n_fields：代表一行中列的数量，占用10位，这也很好地解释了为什么MySQL一个行支持最多的列为1023。另一个值为1byte_offs_flags，该值定义了偏移列表占用1个字节还是2个字节。当它的值为1时，表明使用1个字节存储。当它的值为0时，表明使用2个字节存储。</p>
<p><strong><font color=blue>1byte_offs_flag的值是怎么选择的 ?</font></strong></p>
<p>我们前边说过每个列对应的偏移量可以占用1个字节或者2个字节来存储，那到底什么时候用1个字节，什么时候用2个字节呢？其实是根据该条Redundant行格式记录的真实数据占用的总大小来判断的：</p>
<ul>
<li><p>当记录的真实数据占用的字节数值不大于127（十六进制0x7F，二进制01111111）时，每个列对应的偏移量占用1个字节。</p>
</li>
<li><p>当记录的真实数据占用的字节数大于127，但不大于32767（十六进制0x7FFF，二进制0111111111111111）时，每个列对应的偏移量占用2个字节。</p>
</li>
<li><p>有没有记录的真实数据大于32767的情况呢？有，不过此时的记录已经存放到了溢出页中，在本页中只保留前768个字节和20个字节的溢出页面地址。因为字段长度偏移列表处只需要记录每个列在本页面中的偏移就好了，所以每个列使用2个字节来存储偏移量就够了。</p>
<p>大家可以看出来，Redundant行格式还是比较简单粗暴的，直接使用整个记录的真实数据长度来决定使用1个字节还是2个字节存储列对应的偏移量。只要整条记录的真实数据占用的存储空间大小大于127，即使第一个列的值占用存储空间小于127，那对不起，也需要使用2个字节来表示该列对应的偏移量。简单粗暴，就是这么简单粗暴（所以这种行格式有些过时了）。</p>
<p>为了在解析记录时知道每个列的偏移量是使用1个字节还是2个字节表示的，Redundant行格式特意在<code>记录头信息</code>里放置了一个称之为1byte_offs_flag的属性：</p>
</li>
</ul>
<p><strong>Redundant行格式中NULL值的处理</strong></p>
<p>因为Redundant行格式并没有NULL值列表，所以Redundant行格式在字段长度偏移列表中的各个列对应的偏移量处做了一些特殊处理 —— 将列对应的偏移量值的第一个比特位作为是否为NULL的依据，该比特位也可以被称之为NULL比特位。也就是说在解析一条记录的某个列时，首先看一下该列对应的偏移量的NULL比特位是不是为1。如果为1，那么该列的值就是NULL，否则不是NULL。</p>
<p>这也就解释了上边介绍为什么只要记录的真实数据大于127（十六进制0x7F，二进制01111111）时，就采用2个字节来表示一个列对应的偏移量，主要是第一个比特位是所谓的NULL比特位，用来标记该列的值是否为NULL。</p>
<p>但是还有一点要注意，对于值为NULL的列来说，该列的类型是否为定长类型决定了NULL值的实际存储方式，我们接下来分析一下record_test_table表的第二条记录，它对应的字段长度偏移列表如下：<br> A4 A4 1A 17 13 0C 06<br>按照列的顺序排放就是：<br>06 0C 13 17 1A A4 A4<br>我们分情况看一下：</p>
<ul>
<li>如果存储NULL值的字段是定长类型的，比方说<code>CHAR(M)</code>数据类型的，则NULL值也将占用记录的真实数据部分，并把该字段对应的数据使用0x00字节填充。<br>如图第二条记录的c3列的值是NULL，而c3列的类型是<code>CHAR(10)</code>，占用记录的真实数据部分10字节，所以我们看到在Redundant行格式中使用0x00000000000000000000来表示NULL值。<br>另外，c3列对应的偏移量为0xA4，它对应的二进制实际是：10100100，可以看到最高位为1，意味着该列的值是NULL。将最高位去掉后的值变成了0100100，对应的十进制值为36，而c2列对应的偏移量为0x1A，也就是十进制的26。36 - 26 &#x3D; 10，也就是说最终c3列占用的存储空间为10个字节。</li>
<li>如果该存储NULL值的字段是变长数据类型的，则不在记录的真实数据处占用任何存储空间。<br>比如record_test_table表的c4列是VARCHAR(10)类型的，VARCHAR(10)是一个变长数据类型，c4列对应的偏移量为0xA4，与c3列对应的偏移量相同，这也就意味着它的值也为NULL，将0xA4的最高位去掉后对应的十进制值也是36，36 - 36 &#x3D; 0，也就意味着c4列本身不占用任何记录的实际数据处的空间。</li>
</ul>
<p>除了以上的几点之外，Redundant行格式和Compact行格式还是大致相同的</p>
<p>&#x3D;&#x3D;总结：Redundant行格式和Compact行格式的差异&#x3D;&#x3D;</p>
<ol>
<li><p>Redundant 没有了NULL值列表</p>
</li>
<li><p>Redundant 行格式的记录头信息</p>
<ul>
<li><p>多了<code>n_field</code>和<code>1byte_offs_flag</code>这两个属性</p>
</li>
<li><p>没有record_type这个属性。</p>
</li>
</ul>
</li>
</ol>
<h1 id="4-区、段与碎片区"><a href="#4-区、段与碎片区" class="headerlink" title="4. 区、段与碎片区"></a>4. 区、段与碎片区</h1><h2 id="4-1-为什么要有区？"><a href="#4-1-为什么要有区？" class="headerlink" title="4.1 为什么要有区？"></a>4.1 为什么要有区？</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418020.png"></p>
<h2 id="4-2-为什么要有段？"><a href="#4-2-为什么要有段？" class="headerlink" title="4.2 为什么要有段？"></a>4.2 为什么要有段？</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251420405.png" alt="image-20220725123630473"></p>
<h2 id="4-3-为什么要有碎片区？"><a href="#4-3-为什么要有碎片区？" class="headerlink" title="4.3 为什么要有碎片区？"></a>4.3 为什么要有碎片区？</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418563.png"></p>
<h2 id="4-4-区的分类"><a href="#4-4-区的分类" class="headerlink" title="4.4 区的分类"></a>4.4 区的分类</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418173.png"></p>
<h1 id="5-表空间"><a href="#5-表空间" class="headerlink" title="5. 表空间"></a>5. 表空间</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418019.png" alt="image-20220725125810159"></p>
<h2 id="5-1-独立表空间"><a href="#5-1-独立表空间" class="headerlink" title="5.1 独立表空间"></a>5.1 独立表空间</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418236.png"></p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251420539.png" alt="image-20220725130517704"></p>
<p>你能看到inndb_file_per_table&#x3D;ON，这意味着每张表都会单独保存一个<code>.ibd</code>文件</p>
<h2 id="5-2-系统表空间"><a href="#5-2-系统表空间" class="headerlink" title="5.2 系统表空间"></a>5.2 系统表空间</h2><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418619.png"></p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418963.png"></p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418702.png" alt="image-20220725132440712"></p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418483.png" alt="image-20220725132656365"></p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251418548.png" alt="image-20220725132301490"></p>
<h1 id="附录：数据页加载的三种方式"><a href="#附录：数据页加载的三种方式" class="headerlink" title="附录：数据页加载的三种方式"></a>附录：数据页加载的三种方式</h1><p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251419043.png" alt="image-20220725122714509"></p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251419972.png" alt="image-20220725122846616"></p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251421187.png" alt="image-20220725122942422"></p>
<p><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/img/202207251419621.png" alt="image-20220725123250579"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.dalicoding.fun">Leo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.dalicoding.fun/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC05%E7%AB%A0_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">https://blog.dalicoding.fun/2024/04/05/MySQL从入门到入土/第05章_InnoDB数据存储结构/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.dalicoding.fun" target="_blank">Leo的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909521.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202404041655138.jpg" target="_blank"><img class="post-qr-code-img" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202404041655138.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202404041655057.jpg" target="_blank"><img class="post-qr-code-img" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202404041655057.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC04%E7%AB%A0_%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="四、索引的数据结构"><img class="cover" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">四、索引的数据结构</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC06%E7%AB%A0_%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="六、索引的创建与设计原则"><img class="cover" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">六、索引的创建与设计原则</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC01%E7%AB%A0_MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/" title="一、MySQL的数据目录"><img class="cover" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909053.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">一、MySQL的数据目录</div></div></a></div><div><a href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC03%E7%AB%A0_%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" title="三、存储引擎"><img class="cover" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909053.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">三、存储引擎</div></div></a></div><div><a href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC02%E7%AB%A0_%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90/" title="二、逻辑架构剖析"><img class="cover" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909521.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">二、逻辑架构剖析</div></div></a></div><div><a href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC06%E7%AB%A0_%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="六、索引的创建与设计原则"><img class="cover" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">六、索引的创建与设计原则</div></div></a></div><div><a href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC04%E7%AB%A0_%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="四、索引的数据结构"><img class="cover" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">四、索引的数据结构</div></div></a></div><div><a href="/2024/04/05/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/%E7%AC%AC09%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" title="九、数据库的设计规范"><img class="cover" src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311910777.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">九、数据库的设计规范</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403221853832.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Leo</div><div class="author-info__description">Leo的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LiXuYangISZ"><i class="fab fa-github"></i><span>🛴前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LiXuYangISZ" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/img/WeChatQRCode.jpg" target="_blank" title="icon-weixin"><i class="微信" style="color: faa-tada;"></i></a><a class="social-icon" href="https://res.abeim.cn/api/qq/?qq=2422737092" target="_blank" title="icon-QQ"><i class="QQ" style="color: faa-tada;"></i></a><a class="social-icon" href="https://space.bilibili.com/434261812" target="_blank" title="icon-bilibili"><i class="B站" style="color: faa-tada;"></i></a><a class="social-icon" href="mailto:2422737092@qq.com" target="_blank" title="icon-youxiang"><i class="QQ邮箱" style="color: faa-tada;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center>主域名：<br><a href="https://blog.dalicoding.fun"><b><font color="#5ea6e5">欢迎来到Leo的博客~</font></b></a></center></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A%E9%A1%B5"><span class="toc-number">1.</span> <span class="toc-text">1. 数据的存储结构：页</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%A3%81%E7%9B%98%E4%B8%8E%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D%EF%BC%9A%E9%A1%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 磁盘与内存交互基本单位：页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%A1%B5%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 页结构概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E9%A1%B5%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 页的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E9%A1%B5%E7%9A%84%E4%B8%8A%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 页的上层结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E9%A1%B5%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">2. 页的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-File-Header%EF%BC%88%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8%EF%BC%89%E5%92%8CFile-Trailer%EF%BC%88%E6%96%87%E4%BB%B6%E5%B0%BE%E9%83%A8%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 File Header（文件头部）和File Trailer（文件尾部）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-File-Header%EF%BC%88%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8%EF%BC%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 File Header（文件头部）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-File-Trailer%EF%BC%88%E6%96%87%E4%BB%B6%E5%B0%BE%E9%83%A8%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2 File Trailer（文件尾部）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-User-Records-%E7%94%A8%E6%88%B7%E8%AE%B0%E5%BD%95-%E3%80%81%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%AE%B0%E5%BD%95%E3%80%81Free-Space-%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 User Records(用户记录)、最大最小记录、Free Space(空闲空间)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-Free-Space-%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 Free Space (空闲空间)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-User-Records-%E7%94%A8%E6%88%B7%E8%AE%B0%E5%BD%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 User Records (用户记录)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-Infimum-Supremum%EF%BC%88%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E8%AE%B0%E5%BD%95%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3 Infimum + Supremum（最小最大记录）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Page-Directory-%E9%A1%B5%E7%9B%AE%E5%BD%95-%E3%80%81Page-Header-%E9%A1%B5%E9%9D%A2%E5%A4%B4%E9%83%A8"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 Page Directory(页目录)、Page Header(页面头部)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-Page-Directory%EF%BC%88%E9%A1%B5%E7%9B%AE%E5%BD%95%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 Page Directory（页目录）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-Page-Header%EF%BC%88%E9%A1%B5%E9%9D%A2%E5%A4%B4%E9%83%A8%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 Page Header（页面头部）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E4%BB%8E%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8BB-%E6%A0%91%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 从数据页的角度看B+树如何查询</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-InnoDB%E8%A1%8C%E6%A0%BC%E5%BC%8F%EF%BC%88%E6%88%96%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">3. InnoDB行格式（或记录格式）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%8C%87%E5%AE%9A%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 指定行格式的语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-COMPACT%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 COMPACT行格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 变长字段长度列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-NULL%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 NULL值列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF%EF%BC%885%E5%AD%97%E8%8A%82%EF%BC%89"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 记录头信息（5字节）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E8%AE%B0%E5%BD%95%E7%9C%9F%E5%AE%9E%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4 记录真实的数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Dynamic%E5%92%8CCompressed%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 Dynamic和Compressed行格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E8%A1%8C%E6%BA%A2%E5%87%BA"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1 行溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-Dynamic%E5%92%8CCompressed%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2 Dynamic和Compressed行格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Redundant%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 Redundant行格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%81%8F%E7%A7%BB%E5%88%97%E8%A1%A8"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1 字段长度偏移列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF%EF%BC%88record-header%EF%BC%89"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2 记录头信息（record header）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%8C%BA%E3%80%81%E6%AE%B5%E4%B8%8E%E7%A2%8E%E7%89%87%E5%8C%BA"><span class="toc-number">4.</span> <span class="toc-text">4. 区、段与碎片区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8C%BA%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 为什么要有区？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%AE%B5%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 为什么要有段？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%A2%8E%E7%89%87%E5%8C%BA%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 为什么要有碎片区？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%8C%BA%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 区的分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">5.</span> <span class="toc-text">5. 表空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%8B%AC%E7%AB%8B%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 独立表空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 系统表空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">附录：数据页加载的三种方式</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC13%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="十三、垃圾回收器"><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909053.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十三、垃圾回收器"/></a><div class="content"><a class="title" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC13%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="十三、垃圾回收器">十三、垃圾回收器</a><time datetime="2024-04-05T07:45:13.000Z" title="发表于 2024-04-05 15:45:13">2024-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC12%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" title="十二、垃圾回收相关概念"><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909053.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十二、垃圾回收相关概念"/></a><div class="content"><a class="title" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC12%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" title="十二、垃圾回收相关概念">十二、垃圾回收相关概念</a><time datetime="2024-04-05T07:45:12.000Z" title="发表于 2024-04-05 15:45:12">2024-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC11%E7%AB%A0_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/" title="十一、垃圾回收相关算法"><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909053.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十一、垃圾回收相关算法"/></a><div class="content"><a class="title" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC11%E7%AB%A0_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/" title="十一、垃圾回收相关算法">十一、垃圾回收相关算法</a><time datetime="2024-04-05T07:45:11.000Z" title="发表于 2024-04-05 15:45:11">2024-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC10%E7%AB%A0_StringTable/" title="十、StringTable"><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909053.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十、StringTable"/></a><div class="content"><a class="title" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC10%E7%AB%A0_StringTable/" title="十、StringTable">十、StringTable</a><time datetime="2024-04-05T07:45:10.000Z" title="发表于 2024-04-05 15:45:10">2024-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC09%E7%AB%A0_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" title="九、执行引擎"><img src="https://blog-photos-lxy.oss-cn-hangzhou.aliyuncs.com/images/2023/7/202403311909521.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="九、执行引擎"/></a><div class="content"><a class="title" href="/2024/04/05/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC09%E7%AB%A0_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" title="九、执行引擎">九、执行引擎</a><time datetime="2024-04-05T07:45:09.000Z" title="发表于 2024-04-05 15:45:09">2024-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Leo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><img  src="https://img.shields.io/badge/%E8%B1%ABICP%E5%A4%87-2023001225-%23c41b6c" title="本站已加入ICP豪华套餐，豫ICP备2023001225号"></a>&nbsp;   <a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://my-twikoo-orpin.vercel.app/',
      region: 'ap-hangzhou',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://my-twikoo-orpin.vercel.app/',
      region: 'ap-hangzhou',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://my-twikoo-orpin.vercel.app/',
        region: 'ap-hangzhou',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script defer src="/live2d-widget/autoload.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>